{
Ultibo FileSystem interface unit.

Copyright (C) 2022 - SoftOz Pty Ltd.

Arch
====

 <All>

Boards
======

 <All>

Licence
=======

 LGPLv2.1 with static linking exception (See COPYING.modifiedLGPL.txt)
 
Credits
=======

 Information for this unit was obtained from:

 
References
==========


Filesystems
===========

 Notes: Numbering of Devices, Partitions, Volumes, Drives etc

        Example:

        Machine with 2 Floppy drives, 2 Fixed drives

        Fixed Drive 1 has 2 Partitions (1 Primary and 1 Extended)
        Fixed Drive 2 has 1 Partition (1 Primary)

        \Floppy0  = Device 00h / Partition 0
        \Floppy1  = Device 01h / Partition 0

        \Harddisk0\Partition1 = Device 80h / Partition 1
        \Harddisk0\Extended1  = Device 80h / Extended 1
        \Harddisk0\Partition2 = Device 80h / Partition 2

        \Harddisk1\Partition1 = Device 81h / Partition 1

        \Volume1 = \Floppy0
        \Volume2 = \Floppy1
        \Volume3 = \Harddisk0\Partition1
        \Volume4 = \Harddisk1\Partition1
        \Volume5 = \Harddisk0\Partition2

        A: = \Volume1
        B: = \Volume2
        C: = \Volume3   (Alternate Name = \HarddiskVolume1)
        D: = \Volume4   (Alternate Name = \HarddiskVolume2)
        E: = \Volume5   (Alternate Name = \HarddiskVolume3)

       
}

{$mode delphi} {Default to Delphi compatible syntax}
{$H+}          {Default to AnsiString}
{$inline on}   {Allow use of Inline procedures}

unit FileSystem;

interface

uses GlobalConfig,GlobalConst,GlobalTypes,Platform,Threads,HeapManager,Devices,Logging,Storage,Dos,SysUtils,Classes,Unicode,Ultibo,UltiboUtils,UltiboClasses;

//To Do //The handling of UpdateEnumHandles/UpdateFindHandles may still be not sufficient, handles are updated and then entry is removed etc
        //This could leave open the possibility of another thread moving to that entry in between time (need a WriterLock somewhere ?)
        //UpdateEnumHandles can be handled by moving into WriterLock block
        //UpdateFindHandles, wrapper usage with FEntries WriterLock to protect ?
                        
        //Really applies to CheckFileHandles as well, another thread could open in between
        //Wrapper usage with FEntries WriterLock to protect ?
                        
        //ReleaseFindHandles/ReleaseFileHandles/ReleaseRawHandles/ReleaseEnumHandles are ok as they are after the remove
        //DismountFileHandles/DismountFindHandles are ok as they invalid or close the handle before remove
                      
//To Do //Complete Ansi/Unicode implementation (Both versions for each function)

//To Do //Universal 64bit sectors etc

//To Do //Change Handle values from Integer to THandle to match FPC
        //Change Integer to LongInt where applicable to match FPC

//To Do //Look for:

//Handle Verbose

//Continuing

//Critical

//Move

//Int64

//Lock
//Unlock

//Writer ?
 
//Reader

//) = Uppercase(  //Use WorkBuffer

//API

{==============================================================================}
{Global definitions}
{$INCLUDE GlobalDefines.inc}
  
{==============================================================================}
const
 {FileSystem specific constants}
 FILESYS_LOGGING_DESCRIPTION = 'Filesystem Logging';
 
 FILESYS_STORAGE_TIMER_INTERVAL = 100; {Timer interval for device additions or insertions}

 {FileSystem Lock States}
 FILESYS_LOCK_NONE  = 0;
 FILESYS_LOCK_READ  = 1;
 FILESYS_LOCK_WRITE = 2;
 FILESYS_LOCK_AUTO  = 3; {Not intended for use in all situations, use with extreme caution}
 
 {FileSystem Cache}
 FILESYS_CACHE_THREAD_NAME    = 'Filesystem Cache';      {Thread name for Filesystem cache threads}
 FILESYS_CACHE_THREAD_PRIORITY = THREAD_PRIORITY_HIGHER; {Thread priority for Filesystem cache threads}
 
 FILESYS_CACHE_TIMER_INTERVAL = 50;                      {50ms timer interval for Filesystem cache}
 FILESYS_CACHE_FLUSH_TIMEOUT = 3000;                     {Filesystem cache flush timeout 3 seconds}
 FILESYS_CACHE_DISCARD_TIMEOUT = 180000;                 {Filesystem cache discard timeout 3 minutes}
 
 {Entry Timer}
 FILESYS_ENTRY_TIMER_INTERVAL = 1000;                    {1000ms timer interval for Filesystem entries}
 FILESYS_ENTRY_DELETE_TIMEOUT = 30000;                   {Filesystem entry delete timeout 30 seconds}
 
 {Cache Timer}
 CACHE_TIMER_KEY_NONE = TIMER_KEY_NONE;
 CACHE_TIMER_KEY_MAX = TIMER_KEY_MAX;
 CACHE_TIMER_KEY_MIN = TIMER_KEY_MIN;

 {Entry Timer}
 ENTRY_TIMER_KEY_NONE = TIMER_KEY_NONE;
 ENTRY_TIMER_KEY_MAX = TIMER_KEY_MAX;
 ENTRY_TIMER_KEY_MIN = TIMER_KEY_MIN;
 
const
 {Partition, Device, Volume constants}
 MIN_FLOPPY_DEVICE = $00;
 MAX_FLOPPY_DEVICE = $7F;

 MIN_FIXED_DEVICE = $80;
 MAX_FIXED_DEVICE = $FF; {Extends over CDROM/Other}

 MIN_CDROM_DEVICE = $E0;
 MAX_CDROM_DEVICE = $EF;

 MIN_OTHER_DEVICE = $F0;
 MAX_OTHER_DEVICE = $FF;

 INVALID_PARTITION = -1;
 INVALID_DEVICE = -1;
 INVALID_VOLUME = 0;

 MIN_PARTITION = 0;
 MAX_PARTITION = 3;
 MAX_EXTENDED = 1;   {Only 2 partitions in second level}
 
 MIN_FLOPPY_DRIVE = MIN_DRIVE;
 MAX_FLOPPY_DRIVE = MIN_DRIVE + 1;

 MIN_FIXED_DRIVE = MIN_DRIVE + 2;
 MAX_FIXED_DRIVE = MAX_DRIVE;

 MIN_SECTOR_SIZE = 512;
 MAX_SECTOR_SIZE = 4096;
 ISO_SECTOR_SIZE = 2048;
 
 VOLUME_PREFIX = '\Volume';         {eg \Volume1}
 EXTENDED_PREFIX = '\Extended';     {eg \Extended1}
 PARTITION_PREFIX = '\Partition';   {eg \Partition1}
 CONTROLLER_PREFIX = '\Controller'; {eg \Controller0}
 CDROM_DEVICE_PREFIX = '\Cdrom';     {eg \Cdrom0}
 OTHER_DEVICE_PREFIX = '\Other';     {eg \Other0}
 FIXED_DEVICE_PREFIX = '\Harddisk';  {eg \Harddisk0}
 FLOPPY_DEVICE_PREFIX = '\Floppy';   {eg \Floppy0}
 UNKNOWN_DEVICE_PREFIX = '\Unknown'; {eg \Unknown0}

 VOLUME_PATH_PREFIX = '\\?';         {eg \\?\Volume1\Home}
 DEVICE_PATH_PREFIX = '\\.';         {eg \\.\Harddisk0\Partition1\Home}
 REPARSE_PATH_PREFIX = '\??\';
 
 BOOT_RECORD_SIGNATURE = $AA55;
 PARTITION_RECORD_SIGNATURE = $AA55;
 BOOT_SECTOR_SIGNATURE = $AA55;
 
const
 {Find Flags}
 FIND_FLAG_NONE       = $00000000;
 FIND_FLAG_FILE_NAMES = $00000001;

 {Find Wildcards}
 FIND_WILDCARD_NAME = '*.*';
 FIND_WILDCARD_STREAM = '*';

const
 {File Mode constants}
 fmOpenMask = $000F;
 fmShareMask = $00F0;
 
const
 {File Attribute constants}
 faDot          = $01000000;
 faDotDot       = $02000000;
 faFile         = $04000000;
 faStream       = $08000000;
 faFlagName     = $00100000;   {Used for FAT case flags}
 faFlagExt      = $00200000;   {Used for FAT case flags}
 faFlagBoth     = (faFlagName or faFlagExt);
 faFlagLong     = $00400000;   {Not currently used}
 faFlagMetafile = $00800000;   {Used for NTFS Metafiles}

 faFlagMask     = $0FFF0000;   {Used to preserve internal attributes}
 faFindMask     = $0000FFFF;   {Used to mask internal attributes}
 faMatchMask    = (faFile or faStream or faVolumeID or faDirectory);

 {Additional File Attribute Flags for NTFS/EXTFS/NSS}
 faDevice       = $00000040;
 faNormal       = $00000080;
 faTemporary    = $00000100;
 faSparse       = $00000200;
 faReparse      = $00000400; {See also faSymLink in filutilh.inc (SysUtils)}
 faCompressed   = $00000800;
 faOffline      = $00001000;
 faNotIndexed   = $00002000;
 faEncrypted    = $00004000;

 faMftDirectory = $10000000; {Used only by FileName Attribute}
 faMftIndexView = $20000000; {Used by both the StandardInformation and FileName attributes}

 {Note: NTFS does not store the faVolumeID or faDirectory attributes}
 
 {Additional File Attribute constants}
 faNone         = $00000000;
 faStandard     = (faReadOnly or faHidden or faSysFile or faArchive);
 faLongName     = (faReadOnly or faHidden or faSysFile or faVolumeID);
 faLongMask     = (faReadOnly or faHidden or faSysFile or faVolumeID or faDirectory or faArchive);
 
const
 {Volume Attribute constants}
 vaNone              = $00000000;
 vaCaseSensitive     = $00000001;
 vaCasePreserved     = $00000002;
 vaUnicode           = $00000004;
 vaPersistentAcls    = $00000008;
 vaFileCompression   = $00000010;
 vaVolumeQuotas      = $00000020;
 vaSparseFiles       = $00000040;
 vaReparsePoints     = $00000080;
 vaRemoteStorage     = $00000100;
 vaLongNamesApi      = $00004000;
 vaVolumeCompressed  = $00008000;
 vaObjectIds         = $00010000;
 vaEncryption        = $00020000;
 vaNamedStreams      = $00040000;
 vaReadOnly          = $00080000;

 {Additional Volume Attribute constants}
 vaBootCatalog       = $01000000; {Used to indicate support for ISO Boot Catalogs}
 vaVirtualVolume     = $02000000; {Used to indicate Volume is Virtual or on a Virtual Device}
 vaFolderEncryption  = $04000000; {Used to indicate support for Folder Encryption (New files in folder are automatically encrypted)}
 vaFolderCompression = $08000000; {Used to indicate support for Folder Compression (New files in folder are automatically compressed)}
 
const
 {Device Attribute constants}
 daNone       = $00000000;
 daWriteable  = $00000001;
 daVirtual    = $00000002;
 
const
 {Image Attribute constants}
 iaNone       = $00000000;
 iaDisk       = $00000001; {Memory/File/Device} {All others always Disk}
 iaPartition  = $00000002; {Memory/File/Device}
 iaVolume     = $00000004; {Memory/File/Device}
 iaDrive      = $00000008; {Memory/File/Device}
 iaCDROM      = $00000010; {Memory/File/Device/Iso}
 iaDVD        = $00000020; {Memory/File/Device/Iso}
 iaFlat       = $00000040; {Bochs}
 iaSparse     = $00000080; {Bochs}
 iaGrowing    = $00000100; {Bochs}
 iaFixed      = $00000200; {Vpc/Vbox/Vmware}
 iaDynamic    = $00000400; {Vpc/Vbox/Vmware}
 iaSplit      = $00000800; {Vpc/Vmware/WIM/Ghost/Portlock/Powerquest}
 iaUndoable   = $00001000; {Vpc/Vbox/Vmware}

 iaReadable   = $00010000; {All}
 iaWriteable  = $00020000; {All}
 iaEraseable  = $00040000; {All}
 
const
 {Catalog Attribute constants}
 caNone        = $00000000;
 caDefault     = $00000001; {Initial/Default Entry}
 caBootable    = $00000002; {Boot Indicator}
 caNoEmulation = $00000004; {No Emulation}
 caFloppy12M   = $00000008; {1.2M}
 caFloppy144M  = $00000010; {1.44M}
 caFloppy288M  = $00000020; {2.88M}
 caHardDisk    = $00000040; {Hard Disk}
 
const
 {Misc constants}
 NAME_HASH_SIZE = 8;  {Used for Internal Name Hash Generation only}
 
const
 {Partition Ids} {See http://www.win.tue.nl/~aeb/partitions/partition_types-1.html}
 MAX_PARTITION_ID = 255;
 pidUnused           = 0;  {Empty}
 pidFAT12            = 1;
 pidXENIXROOT        = 2;
 pidXENIXUSR         = 3;
 pidFAT16            = 4;  {under 32M}
 pidExtended         = 5;
 pidFAT16HUGE        = 6;  {over 32M}
 pidHPFSNTFS         = 7;
 pidAIXOS2           = 8;
 pidAIX              = 9;
 pidOS2BOOT          = 10;
 pidFAT32            = 11;
 pidFAT32LBA         = 12;
 pidUnknown013       = 13;
 pidFAT16LBA         = 14;
 pidExtLBA           = 15;
 pidOPUS             = 16;
 pidHIDDEN12         = 17;
 pidCompaqDiag       = 18;
 pidUnknown019       = 19;
 pidHIDDEN16         = 20;
 pidUnknown021       = 21;
 pidHIDDEN16HUGE     = 22;  {??????}
 pidHIDDENHPFS       = 23;
 pidASTSWAP          = 24;
 pidWillowtech       = 25;
 pidUnknown026       = 26;
 pidHIDDEN32         = 27;
 pidHIDDEN32LBA      = 28;
 pidUnknown029       = 29;
 pidHIDDEN16LBA      = 30;
 pidUnknown031       = 31;
 pidWillowsoft       = 32;
 pidOxygen           = 33;
 pidOxygenExtended   = 34;
 pidReserved035      = 35;
 pidNECMSDOS         = 36;
 pidUnknown037       = 37;
 pidUnknown038       = 38;
 pidUnknown039       = 39;
 pidUnknown040       = 40;
 pidUnknown041       = 41;
 pidUnknown042       = 42;
 pidUnknown043       = 43;
 pidUnknown044       = 44;
 pidUnknown045       = 45;
 pidUnknown046       = 46;
 pidUnknown047       = 47;
 pidUnknown048       = 48;
 pidReserved049      = 49;
 pidAlienNOS         = 50;
 pidReserved051      = 51;
 pidReserved052      = 52;
 pidOS2JFS           = 53;
 pidReserved054      = 54;
 pidUnknown055       = 55;
 pidTheos057         = 56;
 pidPlan9            = 57;
 pidTheos058         = 58;
 pidTheos059         = 59;
 pidPowerQuest       = 60;
 pidHiddenNetware    = 61;
 pidUnknown062       = 62;
 pidUnknown063       = 63;
 pidVENIX286         = 64;
 pidPersonalRISC     = 65;
 pidSFS              = 66;
 pidPTSDOS           = 67;
 pidGoBack           = 68;
 pidEUMEL069         = 69;
 pidEUMEL070         = 70;
 pidEUMEL071         = 71;
 pidEUMEL072         = 72;
 pidUnknown073       = 73;
 pidAdaOS            = 74;
 pidUnknown075       = 75;
 pidOberon           = 76;
 pidQNX4077          = 77;
 pidQNX4078          = 78;
 pidQNX4079          = 79;
 pidOnTrack080       = 80;
 pidNOVELL081        = 81;
 pidCPM              = 82;
 pidOnTrack083       = 83;
 pidOnTrack084       = 84;
 pidEZDrive          = 85;
 pidGoldenBow        = 86;
 pidUnknown087       = 87;
 pidUnknown088       = 88;
 pidUnknown089       = 89;
 pidUnknown090       = 90;
 pidUnknown091       = 91;
 pidPriamEdisk       = 92;
 pidUnknown093       = 93;
 pidUnknown094       = 94;
 pidUnknown095       = 95;
 pidUnknown096       = 96;
 pidSpeedStor097     = 97;
 pidUnknown098       = 98;
 pidSysV             = 99;
 pidNetware286       = 100;
 pidNWFS             = 101;  {Traditional / Netware 6 Master}
 pidUnknown102       = 102;
 pidNovell103        = 103;
 pidNovell104        = 104;
 pidNSS              = 105;  {NSS / Netware 6}
 pidUnknown106       = 106;
 pidUnknown107       = 107;
 pidUnknown108       = 108;
 pidUnknown109       = 109;
 pidUnknown110       = 110;
 pidUnknown111       = 111;
 pidDiskSecure       = 112;
 pidUnknown113       = 113;
 pidUnknown114       = 114;
 pidReserved115      = 115;
 pidReserved116      = 116;
 pidPCIX             = 117;
 pidReserved118      = 118;
 pidUnknown119       = 119;
 pidUnknown120       = 120;
 pidUnknown121       = 121;
 pidUnknown122       = 122;
 pidUnknown123       = 123;
 pidUnknown124       = 124;
 pidUnknown125       = 125;
 pidUnknown126       = 126;
 pidUnknown127       = 127;
 pidMinix            = 128;
 pidLinuxMinix       = 129;
 pidLinuxSwap        = 130;
 pidLinuxNative      = 131;
 pidHIDDENC          = 132;
 pidLinuxExtended    = 133;
 pidFAT16Stripe      = 134;
 pidNTFSStripe       = 135;
 pidUnknown136       = 136;
 pidUnknown137       = 137;
 pidUnknown138       = 138;
 pidUnknown139       = 139;
 pidUnknown140       = 140;
 pidUnknown141       = 141;
 pidUnknown142       = 142;
 pidUnknown143       = 143;
 pidUnknown144       = 144;
 pidUnknown145       = 145;
 pidUnknown146       = 146;
 pidAmoeba           = 147;
 pidAmoebaBBT        = 148;
 pidUnknown149       = 149;
 pidUnknown150       = 150;
 pidUnknown151       = 151;
 pidUnknown152       = 152;
 pidUnknown153       = 153;
 pidUnknown154       = 154;
 pidUnknown155       = 155;
 pidUnknown156       = 156;
 pidUnknown157       = 157;
 pidUnknown158       = 158;
 pidUnknown159       = 159;
 pidPhoenixPM        = 160;
 pidReserved161      = 161;
 pidUnknown162       = 162;
 pidReserved163      = 163;
 pidReserved164      = 164;
 pidFreeBSD          = 165;
 pidOpenBSD          = 166;
 pidNeXTStep         = 167;
 pidUnknown168       = 168;
 pidUnknown169       = 169;
 pidUnknown170       = 170;
 pidDarwinBoot       = 171;
 pidUnknown172       = 172;
 pidUnknown173       = 173;
 pidUnknown174       = 174;
 pidUnknown175       = 175;
 pidUnknown176       = 176;
 pidUnknown177       = 177;
 pidUnknown178       = 178;
 pidUnknown179       = 179;
 pidReserved180      = 180;
 pidUnknown181       = 181;
 pidFAT16MirrorA     = 182;
 pidNTFSMirrorA      = 183;
 pidBSDIswap         = 184;
 pidUnknown185       = 185;
 pidUnknown186       = 186;
 pidUnknown187       = 187;
 pidUnknown188       = 188;
 pidUnknown189       = 189;
 pidUnknown190       = 190;
 pidUnknown191       = 191;
 pidUnknown192       = 192;
 pidDRDOSFAT12       = 193;
 pidUnknown194       = 194;
 pidUnknown195       = 195;
 pidDRDOSFAT16       = 196;
 pidUnknown197       = 197;
 pidFAT16MirrorB     = 198;
 pidNTFSMirrorB      = 199;
 pidUnknown200       = 200;
 pidUnknown201       = 201;
 pidUnknown202       = 202;
 pidUnknown203       = 203;
 pidUnknown204       = 204;
 pidUnknown205       = 205;
 pidUnknown206       = 206;
 pidUnknown207       = 207;
 pidUnknown208       = 208;
 pidUnknown209       = 209;
 pidTinyEFAT         = 210;
 pidEFAT             = 211;
 pidSecuredEFAT      = 212;
 pidOpticalEFAT      = 213;
 pidUnknown214       = 214;
 pidUnknown215       = 215;
 pidCPM86            = 216;
 pidUnknown217       = 217;
 pidUnknown218       = 218;
 pidConcurrentCPM    = 219;
 pidUnknown220       = 220;
 pidUnknown221       = 221;
 pidUnknown222       = 222;
 pidUnknown223       = 223;
 pidUnknown224       = 224;
 pidSpeedStorFAT12   = 225;
 pidUnknown226       = 226;
 pidUnknown227       = 227;
 pidSpeedStorFAT16   = 228;
 pidReserved229      = 229;
 pidReserved230      = 230;
 pidUnknown231       = 231;
 pidUnknown232       = 232;
 pidUnknown233       = 233;
 pidUnknown234       = 234;
 pidBeOSBFS1         = 235;
 pidUnknown236       = 236;
 pidUnknown237       = 237;
 pidUnknown238       = 238;
 pidUnknown239       = 239;
 pidLinuxRISC        = 240;
 pidStorageDimension = 241;
 pidDOS33Secondary   = 242;
 pidSpeedStor243     = 243;
 pidSpeedStor244     = 244;
 pidPrologue         = 245;
 pidSpeedStor246     = 246;
 pidOSGEFAT          = 247;
 pidUnknown248       = 248;
 pidUnknown249       = 249;
 pidBochsX86         = 250;
 pidVMware           = 251;
 pidVMwareSwap       = 252;
 pidLinuxRAID        = 253;
 pidLANstep          = 254;
 pidXenixBBT         = 255;

 PARTITION_NAMES:array[0..MAX_PARTITION_ID] of String = (
  'Unused',
  'FAT12',
  'XENIX ROOT',
  'XENIX USR',
  'FAT16 (up to 32M)',
  'Extended',
  'FAT16 (over 32M)',
  'HPFS or NTFS',
  'AIX or OS/2',
  'AIX',
  'OS/2 Boot Manager',
  'FAT32',
  'FAT32 (LBA)',
  'Unknown',
  'FAT16 (LBA)',
  'Extended (LBA)',
  'OPUS',
  'Hidden FAT12',
  'Compaq Diagnostic',
  'Unknown',
  'Hidden FAT16 (<32M)',
  'Unknown',
  'Hidden FAT16 (>32M)',
  'Hidden HPFS',
  'AST SWAP',
  'Willowtech',
  'Unknown',
  'Hidden FAT32',
  'Hidden FAT32 (LBA)',
  'Unknown',
  'Hidden FAT16 (LBA)',
  'Unknown',
  'Willowsoft',
  'Oxygen',
  'Oxygen Extended',
  'Reserved',
  'NEC MS-DOS 3.X',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Reserved',
  'Alien NOS',
  'Reserved',
  'Reserved',
  'OS/2 JFS',
  'Reserved',
  'Unknown',
  'Theos',
  'Plan 9',
  'Theos',
  'Theos',
  'PowerQuest Recovery',
  'Hidden Netware',
  'Unknown',
  'Unknown',
  'VENIX 80286',
  'Personal RISC',
  'SFS',
  'PTS-DOS',
  'GoBack',
  'EUMEL/Elan',
  'EUMEL/Elan',
  'EUMEL/Elan',
  'EUMEL/Elan',
  'Unknown',
  'AdaOS Aquila',
  'Unknown',
  'Oberon',
  'First QNX 4.0',
  'Second QNX 4.0',
  'Third QNX 4.0',
  'OnTrack DM',
  'NOVELL',
  'CP/M',
  'OnTrack DM',
  'OnTrack DM',
  'EZ Drive',
  'GoldenBow',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Priam Edisk',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'SpeedStor',
  'Unknown',
  'Sys V / Mach / HURD',
  'Netware 286',
  'Netware 386',
  'Unknown',
  'Novell',
  'Novell',
  'Netware NSS',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'DiskSecure',
  'Unknown',
  'Unknown',
  'Reserved',
  'Reserved',
  'PC/IX',
  'Reserved',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Minix v1.1-1.4a',
  'Linux / Minix',
  'Linux Swap',
  'Linux Native',
  'Hidden C:',
  'Linux Extended',
  'FAT16 Stripe Set',
  'NTFS Stripe Set',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Amoeba',
  'Amoeba BBT',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Phoenix Power Management',
  'Reserved',
  'Unknown',
  'Reserved',
  'Reserved',
  'FreeBSD',
  'OpenBSD',
  'NeXTStep',
  'Unknown',
  'Unknown',
  'Unknown',
  'Apple Darwin Boot',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Reserved',
  'Unknown',
  'FAT16 Mirror (Master)',
  'NTFS Mirror (Master)',
  'BSDI Swap',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'DR-DOS FAT12',
  'Unknown',
  'Unknown',
  'DR-DOS FAT16',
  'Unknown',
  'FAT16 Mirror (Slave)',
  'NTFS Mirror (Slave)',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Tiny EFAT',
  'EFAT',
  'Secured EFAT',
  'Optical EFAT',
  'Unknown',
  'Unknown',
  'CP/M-86',
  'Unknown',
  'Unknown',
  'Concurrent CP/M',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'SpeedStor FAT12',
  'Unknown',
  'Unknown',
  'SpeedStor FAT16',
  'Reserved',
  'Reserved',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'BeOS BFS-1',
  'Unknown',
  'Unknown',
  'Unknown',
  'Unknown',
  'Linux/PA-RISC',
  'Storage Dimension',
  'DOS 3.3+ Secondary',
  'SpeedStor',
  'SpeedStor',
  'Prologue',
  'SpeedStor',
  'OSG EFAT',
  'Unknown',
  'Unknown',
  'BochsX86',
  'VMware',
  'VMware Swap',
  'Linux RAID',
  'LANstep',
  'Xenix BBT');
 
 {Device descriptions}
 FILESYS_ATA_DEVICE_DESCRIPTION = 'ATA Storage Device';
 FILESYS_ATAPI_DEVICE_DESCRIPTION = 'ATAPI Storage Device';
 FILESYS_SCSI_DEVICE_DESCRIPTION = 'SCSI Storage Device';
 FILESYS_USB_DEVICE_DESCRIPTION = 'USB Storage Device';
 FILESYS_MMC_DEVICE_DESCRIPTION = 'MMC/SD Storage Device';
 
 {Controller descriptions}
 FILESYS_ATA_CONTROLLER_DESCRIPTION = 'ATA Storage Controller';
 FILESYS_ATAPI_CONTROLLER_DESCRIPTION = 'ATAPI Storage Controller';
 FILESYS_SCSI_CONTROLLER_DESCRIPTION = 'SCSI Storage Controller';
 FILESYS_USB_CONTROLLER_DESCRIPTION = 'USB Storage Controller';
 FILESYS_MMC_CONTROLLER_DESCRIPTION = 'MMC/SD Storage Controller';
 
 {FileSystem logging}
 FILESYS_LOG_LEVEL_DEBUG     = LOG_LEVEL_DEBUG;  {FileSystem debugging messages}
 FILESYS_LOG_LEVEL_INFO      = LOG_LEVEL_INFO;   {FileSystem informational messages, such as a filesystem being mounted or dismounted}
 FILESYS_LOG_LEVEL_WARN      = LOG_LEVEL_WARN;   {FileSystem warning messages}
 FILESYS_LOG_LEVEL_ERROR     = LOG_LEVEL_ERROR;  {FileSystem error messages}
 FILESYS_LOG_LEVEL_NONE      = LOG_LEVEL_NONE;   {No FileSystem messages}

var 
 FILESYS_DEFAULT_LOG_LEVEL:LongWord = FILESYS_LOG_LEVEL_DEBUG; {Minimum level for FileSystem messages.  Only messages with level greater than or equal to this will be printed}
 
var 
 {FileSystem logging}
 FILESYS_LOG_ENABLED:Boolean; 
 
{==============================================================================}
type
 {FileSystem specific types}
 PStorageDeviceEvent = ^TStorageDeviceEvent;
 TStorageDeviceEvent = record
  Timer:TTimerHandle;
  Device:PStorageDevice;
 end;
 
type 
 {Cache Timer}
 PCacheTimerItem = ^TCacheTimerItem;
 TCacheTimerItem = record
  Key:Integer;               {Ordering key for timer list}
  Page:TObject;              {The cache page referenced by this timer list item}
  Prev:PCacheTimerItem;      {Previous item in timer list}
  Next:PCacheTimerItem;      {Next item in timer list}
 end;
 
type
 {Entry Timer}
 PEntryTimerItem = ^TEntryTimerItem;
 TEntryTimerItem = record
  Key:Integer;               {Ordering key for timer list}
  Entry:TObject;             {The disk entry referenced by this timer list item}
  Prev:PEntryTimerItem;      {Previous item in timer list}
  Next:PEntryTimerItem;      {Next item in timer list}
 end;
 
type //To do //These should be constants to allow for future expansion
 TMediaType = (mtUNKNOWN,mtINVALID,mtFLOPPY,mtFIXED,mtREMOVABLE,mtCDROM,mtDVD,mtOTHER);

 TFloppyType = (ftUNKNOWN,ftINVALID,ft360K,ft12M,ft720K,ft144M,ft288M,ftATAPI);

 TImageType = (itUNKNOWN,itINVALID,itMEMORY,itFILE,itDEVICE,itISO,itBOCHS,itVMWARE,itVPC,itVBOX);
 
type //To do //These should be constants to allow for future expansion
 {Cache types}
 TCacheState = (csCLEAN,csDIRTY);

 TCacheMode = (cmNONE,cmREADONLY,cmREADWRITE);

 TCachePageType = (ptNONE,ptDEVICE);

 TCachePageState = (psUNKNOWN,psEMPTY,psCLEAN,psDIRTY);

 TCachePageContent = (pcUNKNOWN,pcDATA,pcDIRECTORY,pcENTRY,pcSYSTEM);
 
type
 {Cache Statistics}
 PCacheStatistics = ^TCacheStatistics;
 TCacheStatistics = record
  {Information}
  PageSize:LongWord;
  PageCount:LongWord;
  CacheSize:LongWord;
  CacheMode:TCacheMode;
  CacheState:TCacheState;
  FlushTimeout:LongWord;
  DiscardTimeout:LongWord;
  {Read / Write}
  ReadCached:Int64;
  ReadDirect:Int64;
  WriteBack:Int64;
  WriteThrough:Int64;
  WriteDirect:Int64;
  {Hit / Miss}
  HitCount:Int64;
  MissCount:Int64;
  {Allocate Success / Failure}
  FailCount:Int64;
  SuccessCount:Int64;
  {Page Flush / Discard}
  FlushCount:Int64;
  DiscardCount:Int64;
  UnknownCount:Int64;
  {Page Times}
  OldestClean:Int64;
  NewestClean:Int64;
  OldestDirty:Int64;
  NewestDirty:Int64;
 end;

type
 {Compatibility types}
 TSearchRec = SysUtils.TRawbyteSearchRec;
 {TSearchRec = record
  Time: Integer;
  Size: Integer;
  Attr: Integer;
  Name: TFileName;
  ExcludeAttr: Integer;
  FindHandle: THandle;
  FindData: TWin32FindData;
 end;} {TSearchRec is always defined in SysUtils}
 
 {$IFNDEF FPC_LEGACY}
 TSymLinkRec = SysUtils.TRawbyteSymLinkRec;
 {TSymLinkRec is always defined in SysUtils}
 {$ENDIF}
 
type
 {Search types}
 TFileSearchRec = record
  FindHandle:THandle;
  FindData:TWin32FindData;
 end;

 TDiskSearchRec = record
  Name:String;
  MediaType:TMediaType;
  FloppyType:TFloppyType;
  FindHandle:THandle;
  Context:LongWord;
  Verbose:Boolean;
 end;

 TPartitionSearchRec = record
  Name:String;
  Index:LongWord;
  FindHandle:THandle;
  Context:LongWord;
  Verbose:Boolean;
 end;
 
 TVolumeSearchRec = record
  Name:String;
  Attributes:LongWord;
  VolumeLabel:String;
  VolumeGUID:String;
  VolumeSerial:LongWord;
  DriveType:TDriveType;
  FileSysType:TFileSysType;
  FindHandle:THandle;
  Context:LongWord;
  Verbose:Boolean;
 end;
 
 TDriveSearchRec = record
  Name:String;
  Attributes:LongWord;
  VolumeLabel:String;
  VolumeGUID:String;
  VolumeSerial:LongWord;
  DriveType:TDriveType;
  FileSysType:TFileSysType;
  FindHandle:THandle;
  Context:LongWord;
  Verbose:Boolean;
 end;
 
 TImageSearchRec = record
  Name:String;
  ImageNo:Integer;
  ImageType:TImageType;
  MediaType:TMediaType;
  FloppyType:TFloppyType;
  Attributes:LongWord;
  SectorSize:Word;
  SectorCount:Int64;
  Cylinders:LongWord;
  Heads:LongWord;
  Sectors:LongWord;
  PartitionId:Byte;
  FindHandle:THandle;
  Context:LongWord;
  Verbose:Boolean;
 end;
 
 TCatalogSearchRec = record
  Name:String;
  Path:String;
  CatalogNo:LongWord;
  MediaType:TMediaType;
  FloppyType:TFloppyType;
  Attributes:LongWord;
  SectorSize:Word;
  SectorCount:Int64;
  FindHandle:THandle;
  Context:LongWord;
 end;
 
 TMountSearchRec = record
  Name:String;
  FindHandle:THandle;
  Context:LongWord;
 end;

 TJunctionSearchRec = record
  Name:String;
  FindHandle:THandle;
  Context:LongWord;
 end;

 TStreamSearchRec = record
  FindHandle:THandle;
  Context:Pointer;
  FindData:TWin32FindStreamData;
 end;
 
 TLinkSearchRec = record
  Name:String;
  FindHandle:THandle;
  Context:Pointer;
 end;
 
type
 {FAT12/FAT16 BIOS Parameter Block}
 TBiosPB = packed record   
  BytesPerSector:Word;     {512,1024,2048,4096 - Usually 512}
  SectorsPerCluster:Byte;  {1,2,4,8,16,32,64,128}
  ReservedSectors:Word;    {FAT12/16 - Usually 1, FAT32 - Usually 32}
  NumberOfFats:Byte;       {Usually 2}
  RootEntryCount:Word;     {FAT32 always 0, FAT16 usually 512}
                           {RootEntryCount * 32 must be even multiple of BytesPerSector}
  TotalSectors16:Word;     {Total Sectors on the drive or 0 if TotalSectors32 used}
  MediaId:Byte;            {F8 for Fixed media, F0 usually for Removable media}
  SectorsPerFat16:Word;    {FAT32 always 0, Number of Sectors per FAT}
  SectorsPerTrack:Word;    {Sectors Per Track for Int13}
  NumberOfHeads:Word;      {Number of Header for Int13 eg 1.44MB = 2}
  HiddenSectors:LongWord;  {Number of Hidden Sectors preceeding Partition}
                           {Only valid on Partitioned media}
  TotalSectors32:LongWord; {Total Sectors on the drive or 0 if TotalSectors16 used}
 end;
 
type
 {FAT32 BIOS Parameter Block}
 TExtBiosPB = packed record      
  BytesPerSector:Word;           {512,1024,2048,4096 - Usually 512}
  SectorsPerCluster:Byte;        {1,2,4,8,16,32,64,128}
  ReservedSectors:Word;          {FAT12/16 - Usually 1, FAT32 - Usually 32}
  NumberOfFats:Byte;             {Usually 2}
  RootEntryCount:Word;           {FAT32 always 0, FAT16 usually 512}
                                 {RootEntryCount * 32 must be even multiple of BytesPerSector}
  TotalSectors16:Word;           {Total Sectors on the drive or 0 if TotalSectors32 used}
  MediaId:Byte;                  {F8 for Fixed media, F0 usually for Removable media}
  SectorsPerFat16:Word;          {FAT32 always 0, Number of Sectors per FAT}
  SectorsPerTrack:Word;          {Sectors Per Track for Int13}
  NumberOfHeads:Word;            {Number of Header for Int13 eg 1.44MB = 2}
  HiddenSectors:LongWord;        {Number of Hidden Sectors preceeding Partition}
                                 {Only valid on Partitioned media}
  TotalSectors32:LongWord;       {Total Sectors on the drive or 0 if TotalSectors16 used}
  SectorsPerFat32:LongWord;      {Number of Sectors per FAT}
  ExtendedFlags:Word;            {Bits 0-3  -- Zero-based number of active FAT. Only valid if mirroring}
                                 {             is disabled.}
                                 {Bits 4-6  -- Reserved.}
                                 {Bit 7     -- 0 means the FAT is mirrored at runtime into all FATs.}
                                 {          -- 1 means only one FAT is active; it is the one referenced}
                                 {             in bits 0-3.
                                 {Bits 8-15 -- Reserved.}
  FileSysVersion:Word;           {FAT32 Version (Current 0:0)}
  RootCluster:LongWord;          {Usually Cluster 2}
  FileSysInfoSector:Word;        {Usually 1}
  BackupBootSector:Word;         {Usually 6}
  Reserved:array[0..11] of Byte; {Always 0}
 end;
 
type
 {NTFS BIOS Parameter Block}
 TNtfsBiosPB = packed record     
  BytesPerSector:Word;           {512,1024,2048,4096 - Usually 512}
  SectorsPerCluster:Byte;        {1,2,4,8,16,32,64,128 - Usually 8}
  ReservedSectors:Word;          {Must always be 0 on NTFS} {Win2K Volume Manager ?}
  Reserved1:array[0..2] of Byte; {Must always be 0 on NTFS}
  Reserved2:Word;                {Must always be 0 on NTFS}
  MediaId:Byte;                  {F8 for Fixed media, F0 usually for Removable media}
  Reserved3:Word;                {Must always be 0 on NTFS}
  SectorsPerTrack:Word;          {Sectors Per Track for Int13}
  NumberOfHeads:Word;            {Number of Header for Int13 eg 1.44MB = 2}
  HiddenSectors:LongWord;        {Number of Hidden Sectors preceeding Partition}
  Reserved4:LongWord;            {Must always be 0 on NTFS}
  Reserved5:LongWord;            {Not used by NTFS - Usually 80008000}
  TotalSectors:Int64;            {Total Sectors on the drive}
  MFTCluster:Int64;              {Start Cluster of $MFT}
  MFTMirror:Int64;               {Start Cluster of $MFTMirr}
  ClustersPerFile:LongInt;       {Clusters Per File Record (Can be negative) (F6 = 1024 - See Notes)}
  ClustersPerIndex:LongInt;      {Clusters Per Index Record (Can be negative) (F6 = 1024 - See Notes)}
  VolumeSerial:Int64;            {Volume Serial Number}
  Checksum:LongWord;             {Checksum} {Not Used}
 end;
 
type
 {Partition types} 
 TPartitionEntry = packed record
  BootIndicator:Byte;    {80 for active partition}
  StartHead:Byte;        {Either Bits 0-3 only or Bits 0-7 depending on BIOS}
  StartSector:Byte;      {Bits 0-5 = Sector, Bits 6-7 = Bits 8-9 of Cylinder}
  StartCylinder:Byte;    {Bits 0-7 Only, Bits 8-9 in Sector}
  TypeIndicator:Byte;    {See Table in Interrupt List and Below}
  EndHead:Byte;          {Either Bits 0-3 only or Bits 0-7 depending on BIOS}
  EndSector:Byte;        {Bits 0-5 = Sector, Bits 6-7 = Bits 8-9 of Cylinder}
  EndCylinder:Byte;      {Bits 0-7 Only, Bits 8-9 in Sector}
  SectorOffset:LongWord; {Offset in sectors from current position to Start of Partition}
  SectorCount:LongWord;  {Size in Sectors of the Partition}
 end;

 TPartitionTable = packed record
  PartitionEntry:array[MIN_PARTITION..MAX_PARTITION] of TPartitionEntry;
 end;

 TMasterBootCode = array[0..445] of Byte;

 PMasterBootRecord = ^TMasterBootRecord;
 TMasterBootRecord = packed record  {Standard Master Boot Record}
  BootCode:TMasterBootCode;
  PartitionTable:TPartitionTable;
  Signature:Word;     {Magic Number $AA55}
 end;
 
 TExtMasterBootCode = array[0..439] of Byte;

 PExtMasterBootRecord = ^TExtMasterBootRecord;
 TExtMasterBootRecord = packed record  {NT/2000/XP Master Boot Record}
  BootCode:TExtMasterBootCode;
  DiskSignature:LongWord;
  Reserved1:Word;
  PartitionTable:TPartitionTable;
  Signature:Word;     {Magic Number $AA55}
 end;

 PPartitionRecord = ^TPartitionRecord;
 TPartitionRecord = packed record {Similar to TMasterBootRecord}
  Dummy:array[0..445] of Byte;
  PartitionTable:TPartitionTable;  {Only first 2 ever used}
  Signature:Word;     {Magic Number $AA55}
 end;
 
type
 {Sector types} 
 PDiskSector = ^TDiskSector;
 TDiskSector = array[0..511] of Byte;

 TBootSectorJump = array[0..2] of Byte;
 TBootSectorCode = array[0..447] of Byte;
 
 PBootSector = ^TBootSector;
 TBootSector = packed record       {FAT12/FAT16 Boot Sector}
  BootJump:TBootSectorJump;        {JMP - EBh,??h,90h or E9h,??h,??h}
  OEMName:array[0..7] of Char;     {MSWIN4.0/MSWIN4.1/MSDOS5.0}
  BPB:TBiosPB;                     {See Above}
  DriveNumber:Byte;                {BIOS Int13 Drive No 00h, 80h, FFh etc}
  Reserved1:Byte;                  {Always 00h}
  BootSignature:Byte;              {Always 29h}
  VolumeSerial:LongWord;           {Serial No (Date/Time when Formatted)}
  VolumeName:array[0..10] of Char; {Volume Label or "NO NAME"}
  SystemName:array[0..7] of Char;  {System Type FAT12, FAT16, FAT32 etc}
  BootCode:TBootSectorCode;        {Executable Code}
  Signature:Word;                  {Magic Number $AA55}
 end;

 TExtBootSectorJump = array[0..2] of Byte;
 TExtBootSectorCode = array[0..419] of Byte;

 PExtBootSector = ^TExtBootSector;
 TExtBootSector = packed record    {FAT32 Boot Sector}
  BootJump:TExtBootSectorJump;     {JMP - EBh,??h,90h or E9h,??h,??h}
  OEMName:array[0..7] of Char;     {MSWIN4.1}
  BPB:TExtBiosPB;                  {See Above}
  DriveNumber:Byte;                {BIOS Int13 Drive No 00h, 80h, FFh etc}
  Reserved1:Byte;                  {Always 00h}
  BootSignature:Byte;              {Always 29h}
  VolumeSerial:LongWord;           {Serial No (Date/Time when Formatted)}
  VolumeName:array[0..10] of Char; {Volume Label or "NO NAME"}
  SystemName:array[0..7] of Char;  {System Type FAT12, FAT16, FAT32 etc}
  BootCode:TExtBootSectorCode;     {Executable Code}
  Signature:Word;                  {Magic Number $AA55}
 end;

 TNtfsBootSectorJump = array[0..2] of Byte;
 TNtfsBootSectorCode = array[0..425] of Byte;

 PNtfsBootSector = ^TNtfsBootSector;
 TNtfsBootSector = packed record   {NTFS Boot Sector}
  BootJump:TNtfsBootSectorJump;    {JMP - EBh,??h,90h}
  OEMName:array[0..7] of Char;     {Always NTFS} //To Do //Int64 as MS seem to use ?
  BPB:TNtfsBiosPB;                 {See Above (73 Bytes BPB and ExtBPB)}
  BootCode:TNtfsBootSectorCode;    {Executable Code}
  Signature:Word;                  {Magic Number $AA55}
 end;

 PExtfsBootSector = ^TExtfsBootSector;
 TExtfsBootSector = packed record    {EXTFS Boot Sector}
   //To Do //Lookup in sources
 end;
 
{==============================================================================}
type
 {FileSystem specific classes}
 TRawHandle = class;
 TEnumHandle = class;
 TFileHandle = class;
 TFindHandle = class;
 TFileSysList = class;
 TFileSysTree = class;
 TDiskDrive = class;
 TDiskController = class;
 TDiskDevice = class;
 TDiskPartition = class;
 TDiskVolume = class;
 TDiskImage = class;
 TDiskEntry = class;
 TDiskCatalog = class;
 TRecognizer = class;
 TRedirector = class;
 TFileSystem = class;
 TCache = class;
 TCachePage = class;
 THashCache = class;
 THashCachePage = class;
 TIncrementalCache = class;
 TIncrementalCachePage = class;
 TEntryTimer = class;
 TFileSysDriver = class(TObject)
   constructor Create;
   destructor Destroy; override;
  private
   {Internal Variables}
   FLock:TSynchronizerHandle;
   
   FCache:THashCache;
   FImages:TFileSysList;
   FDrives:TFileSysList;
   FVolumes:TFileSysList;
   FDevices:TFileSysList;
   FPartitions:TFileSysList;

   FControllers:TFileSysList;
   FRecognizers:TFileSysList;
   FRedirectors:TFileSysList;
   FFileSystems:TFileSysList;

   FRawHandles:TFileSysList;
   FEnumHandles:TFileSysList;
   FFileHandles:TFileSysList;
   FFindHandles:TFileSysList;

   FCurrentIndex:LongWord;   {TLS Index for storing current drive}
   FCurrentDrive:TDiskDrive; {Current drive when global current directory is enabled}
  
   FAllowFloppy:Boolean;     {Allow Scanning of Floppy Devices}
   FAllowDrives:Boolean;     {Allow Disk Drives to represent Volumes by drive letter}
   FOemConvert:Boolean;      {Convert OEM character strings to ANSI}

   FEntryTimer:TEntryTimer;
   
   FDefaultRecognizer:TRecognizer;

   {Private Methods}
   function ReaderLock:Boolean;
   function ReaderUnlock:Boolean;
   function WriterLock:Boolean;
   function WriterUnlock:Boolean;

   function GetCurrent:TDiskDrive; 
   function SetCurrent(ACurrent:TDiskDrive):Boolean; 
   
   function FindMatchingFile(ADrive:TDiskDrive;AVolume:TDiskVolume;var ASearchRec:TSearchRec):Integer; 
  public
   {Public Variables}
   property Cache:THashCache read FCache;

   property AllowFloppy:Boolean read FAllowFloppy write FAllowFloppy;
   property AllowDrives:Boolean read FAllowDrives write FAllowDrives;
   property OemConvert:Boolean read FOemConvert write FOemConvert;

   {Public Methods}
   
   {Cache Methods}
   function OpenCache(ACacheSize,ACacheKeys,APageSize:LongWord;ACacheMode:TCacheMode):Boolean;
   function CloseCache:Boolean;
   function FlushCache(AAll:Boolean):Boolean;
   function DiscardCache(AAll:Boolean):Boolean;
   function GetCacheStatistics(var AStatistics:TCacheStatistics):Boolean;
   
   {Catalog Methods}
   function GetCatalogByNo(const APath:String;ACatalogNo:LongWord;ALock:Boolean;AState:LongWord):TDiskCatalog;
   function GetCatalogByName(const APath,AName:String;ALock:Boolean;AState:LongWord):TDiskCatalog;
   function GetCatalogByNext(const APath:String;APrevious:TDiskCatalog;ALock,AUnlock:Boolean;AState:LongWord):TDiskCatalog;
   
   {Image Methods}
   function AddImage(AImage:TDiskImage):Boolean;
   function RemoveImage(AImage:TDiskImage):Boolean;
   function CheckImage(AImage:TDiskImage;ALock:Boolean;AState:LongWord):Boolean;
   
   function GetImageByNo(AImageNo:Integer;ALock:Boolean;AState:LongWord):TDiskImage;
   function GetImageByName(const AName:String;ALock:Boolean;AState:LongWord):TDiskImage;
   function GetImageByDevice(ADevice:TDiskDevice;ALock:Boolean;AState:LongWord):TDiskImage;
   function GetImageByController(AController:TDiskController;ALock:Boolean;AState:LongWord):TDiskImage;
   function GetImagesByController(AController:TDiskController;ALock:Boolean;AState:LongWord):TList; //To Do //Should this be something better than a TList ?
   function GetImageByNext(APrevious:TDiskImage;ALock,AUnlock:Boolean;AState:LongWord):TDiskImage;

   function GetNextImageNo:Integer;
   function GetMaxImageNo:Integer;

   {Drive Methods}
   function AddDrive(ADrive:TDiskDrive):Boolean;
   function RemoveDrive(ADrive:TDiskDrive):Boolean;
   function CheckDrive(ADrive:TDiskDrive;ALock:Boolean;AState:LongWord):Boolean;
   
   function GetDriveByNo(ADriveNo:Integer;ALock:Boolean;AState:LongWord):TDiskDrive;
   function GetDriveByName(const AName:String;ALock:Boolean;AState:LongWord):TDiskDrive;
   function GetDriveByParent(const AParent:String;ALock:Boolean;AState:LongWord):TDiskDrive;
   function GetDriveByVolume(AVolume:TDiskVolume;ALock:Boolean;AState:LongWord):TDiskDrive;
   function GetDriveByDevice(ADevice:TDiskDevice;ALock:Boolean;AState:LongWord):TDiskDrive;
   function GetDrivesByDevice(ADevice:TDiskDevice;ALock:Boolean;AState:LongWord):TList; //To Do //Should this be something better than a TList ?
   function GetDriveByPartition(APartition:TDiskPartition;ALock:Boolean;AState:LongWord):TDiskDrive;
   function GetDrivesByPartition(APartition:TDiskPartition;ALock:Boolean;AState:LongWord):TList; //To Do //Should this be something better than a TList ?
   function GetDriveByNext(APrevious:TDiskDrive;ALock,AUnlock:Boolean;AState:LongWord):TDiskDrive;

   function GetNextDriveNo(AMediaType:TMediaType):Integer;
   function GetMaxDriveNo(AMediaType:TMediaType):Integer;

   {Volume Methods}
   function AddVolume(AVolume:TDiskVolume):Boolean;
   function RemoveVolume(AVolume:TDiskVolume):Boolean;
   function CheckVolume(AVolume:TDiskVolume;ALock:Boolean;AState:LongWord):Boolean;

   function GetVolumeByNo(AVolumeNo:Integer;ALock:Boolean;AState:LongWord):TDiskVolume;
   function GetVolumeByName(const AName:String;ALock:Boolean;AState:LongWord):TDiskVolume;
   function GetVolumeByParent(const AParent:String;ALock:Boolean;AState:LongWord):TDiskVolume;
   function GetVolumeByDevice(ADevice:TDiskDevice;ALock:Boolean;AState:LongWord):TDiskVolume;
   function GetVolumesByDevice(ADevice:TDiskDevice;ALock:Boolean;AState:LongWord):TList; //To Do //Should this be something better than a TList ?
   function GetVolumeByPartition(APartition:TDiskPartition;ALock:Boolean;AState:LongWord):TDiskVolume;
   function GetVolumesByPartition(APartition:TDiskPartition;ALock:Boolean;AState:LongWord):TList; //To Do //Should this be something better than a TList ?
   function GetVolumeByNext(APrevious:TDiskVolume;ALock,AUnlock:Boolean;AState:LongWord):TDiskVolume;
   
   function GetNextVolumeNo:Integer;
   function GetMaxVolumeNo:Integer;

   {Device Methods}
   function AddDevice(ADevice:TDiskDevice):Boolean;
   function RemoveDevice(ADevice:TDiskDevice):Boolean;
   function CheckDevice(ADevice:TDiskDevice;ALock:Boolean;AState:LongWord):Boolean;
   
   function GetDeviceByNo(ADeviceNo:Integer;ALock:Boolean;AState:LongWord):TDiskDevice;
   function GetDeviceByName(const AName:String;ALock:Boolean;AState:LongWord):TDiskDevice;
   function GetDeviceByImage(AImage:TDiskImage;ALock:Boolean;AState:LongWord):TDiskDevice;
   function GetDeviceByStorage(AStorage:PStorageDevice;ALock:Boolean;AState:LongWord):TDiskDevice;
   function GetDeviceByController(AController:TDiskController;ALock:Boolean;AState:LongWord):TDiskDevice;
   function GetDevicesByController(AController:TDiskController;ALock:Boolean;AState:LongWord):TList; //To Do //Should this be something better than a TList ?
   function GetDeviceByIdentifier(AController:TDiskController;const AIdentifier:String;ALock:Boolean;AState:LongWord):TDiskDevice;
   function GetDeviceByNext(APrevious:TDiskDevice;ALock,AUnlock:Boolean;AState:LongWord):TDiskDevice;
   
   function GetNextDeviceNo(AMediaType:TMediaType):Integer;
   function GetMaxDeviceNo(AMediaType:TMediaType):Integer;

   {Partition Methods}
   function AddPartition(APartition:TDiskPartition):Boolean;
   function RemovePartition(APartition:TDiskPartition):Boolean;
   function CheckPartition(APartition:TDiskPartition;ALock:Boolean;AState:LongWord):Boolean;

   function GetPartitionByNo(ADevice:TDiskDevice;APartitionNo:Integer;AExtended,ALock:Boolean;AState:LongWord):TDiskPartition;
   function GetPartitionByName(ADevice:TDiskDevice;const AName:String;ALock:Boolean;AState:LongWord):TDiskPartition;
   function GetPartitionByPath(const APath:String;ALock:Boolean;AState:LongWord):TDiskPartition;
   function GetPartitionByEntryNo(ADevice:TDiskDevice;APartition:TDiskPartition;AEntryNo:Integer;ALock:Boolean;AState:LongWord):TDiskPartition;
   function GetPartitionByDevice(ADevice:TDiskDevice;ALock:Boolean;AState:LongWord):TDiskPartition;
   function GetPartitionsByDevice(ADevice:TDiskDevice;ALock:Boolean;AState:LongWord):TList; //To Do //Should this be something better than a TList ?
   function GetPartitionByPartition(APartition:TDiskPartition;ALock:Boolean;AState:LongWord):TDiskPartition;
   function GetPartitionsByPartition(APartition:TDiskPartition;ALock:Boolean;AState:LongWord):TList; //To Do //Should this be something better than a TList ?
   function GetPartitionByNext(APrevious:TDiskPartition;ALock,AUnlock:Boolean;AState:LongWord):TDiskPartition;
   
   function GetNextPartitionNo(ADevice:TDiskDevice;AExtended:Boolean):Integer;
   function GetMaxPartitionNo(ADevice:TDiskDevice;AExtended:Boolean):Integer;

   {Controller Methods}
   function AddController(AController:TDiskController):Boolean;
   function RemoveController(AController:TDiskController):Boolean;
   function CheckController(AController:TDiskController;ALock:Boolean;AState:LongWord):Boolean;
   
   function GetControllerByNo(AControllerNo:Integer;ALock:Boolean;AState:LongWord):TDiskController;
   function GetControllerByName(const AName:String;ALock:Boolean;AState:LongWord):TDiskController;
   function GetControllerByNext(APrevious:TDiskController;ALock,AUnlock:Boolean;AState:LongWord):TDiskController;
   
   function GetNextControllerNo:Integer;
   function GetMaxControllerNo:Integer;

   {Recognizer Methods}
   function AddRecognizer(ARecognizer:TRecognizer):Boolean;
   function RemoveRecognizer(ARecognizer:TRecognizer):Boolean;
   function CheckRecognizer(ARecognizer:TRecognizer;ALock:Boolean;AState:LongWord):Boolean;

   function GetRecognizerByImage(AImage:TDiskImage;ALock:Boolean;AState:LongWord):TRecognizer;
   function GetRecognizerByVolume(AVolume:TDiskVolume;ALock:Boolean;AState:LongWord):TRecognizer;
   function GetRecognizerByPartition(APartition:TDiskPartition;ALock:Boolean;AState:LongWord):TRecognizer;
   function GetRecognizerByPartitionId(APartitionId:Byte;ALock:Boolean;AState:LongWord):TRecognizer;       
   function GetRecognizerByBootSector(ABootSector:PBootSector;const AStartSector,ASectorCount:Int64;ALock:Boolean;AState:LongWord):TRecognizer;
   function GetRecognizerByNext(APrevious:TRecognizer;ALock,AUnlock:Boolean;AState:LongWord):TRecognizer;

   {Redirector Methods}
   function AddRedirector(ARedirector:TRedirector):Boolean;
   function RemoveRedirector(ARedirector:TRedirector):Boolean;
   function CheckRedirector(ARedirector:TRedirector;ALock:Boolean;AState:LongWord):Boolean;

   function GetRedirectorByPath(const APath:String;ALock:Boolean;AState:LongWord):TRedirector;
   function GetRedirectorByDrive(ADrive:TDiskDrive;ALock:Boolean;AState:LongWord):TRedirector;
   function GetRedirectorByNext(APrevious:TRedirector;ALock,AUnlock:Boolean;AState:LongWord):TRedirector;

   {File System Methods}
   function AddFileSystem(AFileSystem:TFileSystem):Boolean;
   function RemoveFileSystem(AFileSystem:TFileSystem):Boolean;
   function CheckFileSystem(AFileSystem:TFileSystem;ALock:Boolean;AState:LongWord):Boolean;

   function GetFileSystemByDrive(ADrive:TDiskDrive;ALock:Boolean;AState:LongWord):TFileSystem;
   function GetFileSystemByVolume(AVolume:TDiskVolume;ALock:Boolean;AState:LongWord):TFileSystem;
   function GetFileSystemByRootName(const AName:String;ALock:Boolean;AState:LongWord):TFileSystem;
   function GetFileSystemByRootPath(const APath:String;ALock:Boolean;AState:LongWord):TFileSystem;
   function GetFileSystemByNext(APrevious:TFileSystem;ALock,AUnlock:Boolean;AState:LongWord):TFileSystem;

   {Locate Methods}
   function LocateDevices:Boolean;
   function LocatePartitions:Boolean;
   function LocateVolumes:Boolean;
   function LocateDrives:Boolean;

   {Raw Handle Methods}
   function OpenRawHandle(ADevice:TDiskDevice;APartition:TDiskPartition;AVolume:TDiskVolume;ADrive:TDiskDrive;AMode:Integer;ALock:Boolean;AState:LongWord):TRawHandle;
   function CloseRawHandle(AHandle:TRawHandle):Boolean;
   function GetRawHandleByNext(APrevious:TRawHandle;ALock,AUnlock:Boolean;AState:LongWord):TRawHandle;
   
   function ReleaseRawHandles(ADevice:TDiskDevice;APartition:TDiskPartition;AVolume:TDiskVolume;ADrive:TDiskDrive):Boolean;

   {Enum Handle Methods}
   function OpenEnumHandle(AFileSystem:TFileSystem;ALock:Boolean;AState:LongWord):TEnumHandle;
   function CloseEnumHandle(AHandle:TEnumHandle):Boolean;
   function GetEnumHandleByNext(APrevious:TEnumHandle;ALock,AUnlock:Boolean;AState:LongWord):TEnumHandle;
   
   function UpdateEnumHandles(ADevice:TDiskDevice;APartition:TDiskPartition;ADrive:TDiskDrive;AVolume:TDiskVolume;AImage:TDiskImage;ACatalog:TDiskCatalog):Boolean;
   function ReleaseEnumHandles(AFileSystem:TFileSystem):Boolean;

   {File Handle Methods}
   function OpenFileHandle(AVolume:TDiskVolume;ADrive:TDiskDrive;AParent,AEntry:TDiskEntry;AMode:Integer;ALock:Boolean;AState:LongWord):TFileHandle;
   function CloseFileHandle(AHandle:TFileHandle):Boolean;
   function GetFileHandleByNext(APrevious:TFileHandle;ALock,AUnlock:Boolean;AState:LongWord):TFileHandle;
   
   function CheckFileHandles(AEntry:TDiskEntry):Boolean;
   function ReleaseFileHandles(AVolume:TDiskVolume;ADrive:TDiskDrive):Boolean;
   function DismountFileHandles(AVolume:TDiskVolume;ADrive:TDiskDrive):Boolean;

   {Find Handle Methods}
   function OpenFindHandle(AVolume:TDiskVolume;ADrive:TDiskDrive;AParent:TDiskEntry;const AMask:String;AAttr,AFlags:LongWord;ALock:Boolean;AState:LongWord):TFindHandle;
   function CloseFindHandle(AHandle:TFindHandle):Boolean;
   function GetFindHandleByNext(APrevious:TFindHandle;ALock,AUnlock:Boolean;AState:LongWord):TFindHandle;
   
   function UpdateFindHandles(AEntry:TDiskEntry):Boolean;
   function ReleaseFindHandles(AVolume:TDiskVolume;ADrive:TDiskDrive):Boolean;
   function DismountFindHandles(AVolume:TDiskVolume;ADrive:TDiskDrive):Boolean;

   {Device Methods}
   function LockMedia(const AName:String):Boolean;
   function UnlockMedia(const AName:String):Boolean;
   function EjectMedia(const AName:String):Boolean;

   function MediaReady(const AName:String):Boolean;
   function MediaChanged(const AName:String):Boolean;
   function MediaLocked(const AName:String):Boolean;

   function InsertDevice(const AName:String):Boolean;
   function EjectDevice(const AName:String):Boolean;
   
   function OpenDevice(const AName:String;AMode:Integer):Integer;
   procedure CloseDevice(AHandle:Integer);
   function ReadDevice(AHandle:Integer;var ABuffer;ACount:Integer):Integer;
   function WriteDevice(AHandle:Integer;const ABuffer;ACount:Integer):Integer;
   function EraseDevice(AHandle:Integer;ACount:Integer):Integer;
   function SeekDevice(AHandle:Integer;const AOffset:Int64;AOrigin:Integer):Int64;

   function FindFirstDevice(var ASearchRec:TDiskSearchRec;AVerbose:Boolean):Integer;
   function FindNextDevice(var ASearchRec:TDiskSearchRec):Integer;
   procedure FindDeviceClose(var ASearchRec:TDiskSearchRec);

   {Partition Methods}
   function CreatePartition(const ADevice,AParent:String;APartitionId:Byte;ACount:LongWord;AActive:Boolean):Boolean;
   function DeletePartition(const APath:String):Boolean;
   function ModifyPartition(const APath:String;APartitionId:Byte):Boolean;
   function ActivatePartition(const APath:String;AActive:Boolean):Boolean;
   function ShrinkPartition(const APath:String;const AStart,ASize:Int64):Boolean;
   function ExpandPartition(const APath:String;const AStart,ASize:Int64):Boolean;

   function OpenPartition(const APath:String;AMode:Integer):Integer;
   procedure ClosePartition(AHandle:Integer);
   function ReadPartition(AHandle:Integer;var ABuffer;ACount:Integer):Integer;
   function WritePartition(AHandle:Integer;const ABuffer;ACount:Integer):Integer;
   function SeekPartition(AHandle:Integer;const AOffset:Int64;AOrigin:Integer):Int64;

   function FindFirstPartition(const ADevice:String;var ASearchRec:TPartitionSearchRec;AVerbose:Boolean):Integer;
   function FindNextPartition(var ASearchRec:TPartitionSearchRec):Integer;
   procedure FindPartitionClose(var ASearchRec:TPartitionSearchRec);

   {Volume Methods}
   function CreateVolume(const AParent:String;ADriveNo:Integer):Boolean;
   function DeleteVolume(Const AName:String):Boolean;
   function MountVolume(const AName:String;ADriveNo:Integer):Boolean;
   function DismountVolume(const AName:String):Boolean;
   function FormatVolume(const AName:String;AFloppyType:TFloppyType;AFileSysType:TFileSysType):Boolean;
   function DefragmentVolume(const AName:String):Boolean;
   function ConvertVolume(const AName:String;AFileSysType:TFileSysType):Boolean;
   function RepairVolume(const AName:String):Boolean;
   function CopyVolume(const AName,ADest:String):Boolean;
   function ShrinkVolume(const AName:String;const AStart,ASize:Int64):Boolean;
   function ExpandVolume(const AName:String;const AStart,ASize:Int64):Boolean;

   function OpenVolume(const AName:String;AMode:Integer):Integer;
   procedure CloseVolume(AHandle:Integer);
   function ReadVolume(AHandle:Integer;var ABuffer;ACount:Integer):Integer;
   function WriteVolume(AHandle:Integer;const ABuffer;ACount:Integer):Integer;
   function SeekVolume(AHandle:Integer;const AOffset:Int64;AOrigin:Integer):Int64;

   function FindFirstVolume(var ASearchRec:TVolumeSearchRec;AVerbose:Boolean):Integer;
   function FindNextVolume(var ASearchRec:TVolumeSearchRec):Integer;
   procedure FindVolumeClose(var ASearchRec:TVolumeSearchRec);

   {Drive Methods}
   function CreateDrive(const AName,AParent:String):Boolean;
   function DeleteDrive(const AName:String):Boolean;
   function FormatDrive(const AName:String;AFloppyType:TFloppyType;AFileSysType:TFileSysType):Boolean;

   function OpenDrive(const AName:String;AMode:Integer):Integer;
   procedure CloseDrive(AHandle:Integer);
   function ReadDrive(AHandle:Integer;var ABuffer;ACount:Integer):Integer;
   function WriteDrive(AHandle:Integer;const ABuffer;ACount:Integer):Integer;
   function SeekDrive(AHandle:Integer;const AOffset:Int64;AOrigin:Integer):Int64;

   function FindFirstDrive(var ASearchRec:TDriveSearchRec;AVerbose:Boolean):Integer;
   function FindNextDrive(var ASearchRec:TDriveSearchRec):Integer;
   procedure FindDriveClose(var ASearchRec:TDriveSearchRec);

   {Image Methods}
   function MountImage(AImageNo:Integer):Boolean;
   function DismountImage(AImageNo:Integer):Boolean;
   function InsertImage(AImageNo:Integer):Boolean;
   function EjectImage(AImageNo:Integer):Boolean;
   function ConvertImage(AImageNo:Integer;AImageType:TImageType):Boolean;
   function CopyImage(AImageNo,ADestNo:Integer):Boolean;
   function ShrinkImage(AImageNo:Integer;const ASize:Int64):Boolean;
   function ExpandImage(AImageNo:Integer;const ASize:Int64):Boolean;

   function CreateImage(AImageNo:Integer;const AName:String;AImageType:TImageType;AMediaType:TMediaType;AFloppyType:TFloppyType;AAttributes:LongWord;ASectorSize:Word;const ASectorCount:Int64;ACylinders,AHeads,ASectors:LongWord;APartitionId:Byte):Integer;
   function OpenImage(AImageNo:Integer;const AName:String;AImageType:TImageType;AMediaType:TMediaType;AFloppyType:TFloppyType;AAttributes:LongWord;ASectorSize:Word;const ASectorCount:Int64;ACylinders,AHeads,ASectors:LongWord;APartitionId:Byte):Integer;
   function CloseImage(AImageNo:Integer):Boolean;

   function CreateSnapshot(AImageNo:Integer):Boolean;
   function DeleteSnapshot(AImageNo:Integer):Boolean;
   function MergeSnapshot(AImageNo:Integer):Boolean;

   function FindFirstImage(var ASearchRec:TImageSearchRec;AVerbose:Boolean):Integer;
   function FindNextImage(var ASearchRec:TImageSearchRec):Integer;
   procedure FindImageClose(var ASearchRec:TImageSearchRec);

   {Catalog Methods}
   function CreateCatalog(const APath,AName:String;AMediaType:TMediaType;AFloppyType:TFloppyType;AAttributes:LongWord;ASectorSize:Word;const ASectorCount:Int64):LongWord;
   function DeleteCatalog(const APath:String;ACatalogNo:LongWord):Boolean;

   function FindFirstCatalog(const APath:String;var ASearchRec:TCatalogSearchRec):Integer;
   function FindNextCatalog(var ASearchRec:TCatalogSearchRec):Integer;
   procedure FindCatalogClose(var ASearchRec:TCatalogSearchRec);

   {Entry Timer Methods}
   function CheckTimer:Boolean; 
   function ProcessTimer:Boolean;
   
   function ScheduleEntry(AEntry:TDiskEntry;ATimeout:LongWord):Boolean;
   function UnscheduleEntry(AEntry:TDiskEntry):Boolean; 
   
   {Delphi / FreePascal RTL Methods}
    {System Methods}
   function GetPathDrive(const APath:String):Byte;
   function GetDriveType(ADrive:Byte):TDriveType;
   function GetDriveData(ADrive:Byte):TDriveData;
   function GetDriveAttr(ADrive:Byte):LongWord;
   function GetDriveLabel(ADrive:Byte):String;
   function SetDriveLabel(ADrive:Byte;const ALabel:String):Boolean;
   function GetDriveSerial(ADrive:Byte):LongWord;
   function SetDriveSerial(ADrive:Byte;ASerial:LongWord):Boolean;
   function IsDriveValid(ADrive:Byte):Boolean;
   function GetValidDrives:LongWord;
   function GetValidDriveNames:TStringList;
   function GetValidDriveStrings:String;
   function GetDriveFreeSpace(ADrive:Byte):LongWord;
   function GetDriveFreeSpaceEx(ADrive:Byte):Int64;
   function GetDriveTotalSpace(ADrive:Byte):LongWord;
   function GetDriveTotalSpaceEx(ADrive:Byte):Int64;

   function GetDriveInformation(const APath:String;var AClusterSize:LongWord;var ATotalClusterCount,AFreeClusterCount:Int64):Boolean;
   
   function GetCurrentDrive:Byte;
   function SetCurrentDrive(const ADrive:String):Boolean;

   function GetPathVolume(const APath:String):String;
   function GetVolumeType(const AVolume:String):TDriveType;
   function GetVolumeData(const AVolume:String):TDriveData;
   function GetVolumeAttr(const AVolume:String):LongWord;
   function GetVolumeLabel(const AVolume:String):String;
   function SetVolumeLabel(const AVolume:String;const ALabel:String):Boolean;
   function GetVolumeSerial(const AVolume:String):LongWord;
   function SetVolumeSerial(const AVolume:String;ASerial:LongWord):Boolean;
   function IsVolumeValid(const AVolume:String):Boolean;
   function GetValidVolumeNames:TStringList;
   function GetVolumeFreeSpace(const AVolume:String):LongWord;
   function GetVolumeFreeSpaceEx(const AVolume:String):Int64;
   function GetVolumeTotalSpace(const AVolume:String):LongWord;
   function GetVolumeTotalSpaceEx(const AVolume:String):Int64;

    {File Methods}
   function FileOpen(const AFileName:String;AMode:Integer):THandle;
   function FileCreate(const AFileName:String;AMode:Integer = fmOpenReadWrite or fmShareExclusive):THandle;
   function DeleteFile(const AFileName:String):Boolean;
   procedure FileClose(AHandle:Integer);
   function RenameFile(const AOldName,ANewName:String):Boolean;
   function FileSeek(AHandle:THandle;AOffset,AOrigin:LongInt):LongInt;
   function FileFlush(AHandle:Integer):Boolean;
   function FileTruncate(AHandle:Integer):Boolean;
   function SetEndOfFile(AHandle:Integer):Boolean;

   function EndOfFile(AHandle:Integer):Boolean;
   function FilePos(AHandle:THandle):LongInt;
   function FileSize(AHandle:THandle):LongInt;

   function FileAge(const AFileName:String):Integer;
   function FileExists(const AFileName:String):Boolean;
   function FileGetAttr(const AFileName:String):Integer;
   function FileGetDate(AHandle:Integer):Integer;
   function FileSetAttr(const AFileName:String;AAttr:Integer):Integer;
   function FileSetDate(AHandle:Integer;AAge:Integer):Integer;

   function FileRead(AHandle:THandle;var ABuffer;ACount:LongInt):LongInt;
   function FileWrite(AHandle:THandle;const ABuffer;ACount:LongInt):LongInt;

    {Directory Methods}
   function CreateDir(const ADirName:String):Boolean;
   function RemoveDir(const ADirName:String):Boolean;
   function RenameDir(const AOldName,ANewName:String):Boolean;
   function GetCurrentDir:String;
   function GetCurrentDirEx(ADrive:Byte):String;
   function SetCurrentDir(const ADirName:String):Boolean;
   function SetCurrentDirEx(ADrive:Byte;const ADirName:String):Boolean;
   function DirectoryExists(const ADirName:String):Boolean;
   procedure ForceDirectories(ADirName:String);
   procedure DeleteTree(const ADirName:String);

    {Search Methods}
   function FindFirst(const APath:String;AAttr:Integer;var ASearchRec:TSearchRec):Integer;
   function FindNext(var ASearchRec:TSearchRec):Integer;                                  
   procedure FindClose(var ASearchRec:TSearchRec);                                        

   function FindFirstStream(const AFileName:String;var ASearchRec:TStreamSearchRec):Integer;
   function FindNextStream(var ASearchRec:TStreamSearchRec):Integer;
   procedure FindStreamClose(var ASearchRec:TStreamSearchRec);

   function FindFirstFileName(const AFileName:String;var ASearchRec:TLinkSearchRec):Integer;
   function FindNextFileName(var ASearchRec:TLinkSearchRec):Integer;
   procedure FindFileNameClose(var ASearchRec:TLinkSearchRec);

    {Additional Methods}
   function CreateHardLink(const ALinkName,AFileName:String):Boolean;
   function DeleteHardLink(const ALinkName:String):Boolean;

   function MountPointExists(const APathName:String):Boolean;
   function CreateMountPoint(const APathName,AVolumeName:String):Boolean;
   function DeleteMountPoint(const APathName:String):Boolean;

   function JunctionPointExists(const APathName:String):Boolean;
   function CreateJunctionPoint(const APathName,AFolderName:String):Boolean;
   function DeleteJunctionPoint(const APathName:String):Boolean;

   function SymbolicLinkExists(const ALinkName:String):Boolean;
   function CreateSymbolicLink(const ALinkName,ATargetName:String;ADirectory:Boolean):Boolean;
   function CreateSymbolicLinkEx(const ALinkName,AShortName,ATargetName:String;ADirectory:Boolean):Boolean;
   function DeleteSymbolicLink(const ALinkName:String):Boolean;

   function GetMountPointTarget(const APathName:String):String;
   function GetJunctionPointTarget(const APathName:String):String;
   function GetSymbolicLinkTarget(const ALinkName:String):String;

   function SetFileShortName(const AFileName,AShortName:String):Boolean;
   function SetFileShortNameEx(AHandle:Integer;const AShortName:String):Boolean;
   
   function GetFileSecurity(const AFileName:String;ADescriptor:Pointer;var ASize:LongWord):Boolean;
   function SetFileSecurity(const AFileName:String;ADescriptor:Pointer):Boolean;

   function FileCopy(const ASourceFile,ADestFile:String;AFailIfExists:Boolean):Boolean;
   function FileCopyEx(const ASourceFile,ADestFile:String;AFailIfExists:Boolean;AUseSourceDate:Boolean;ADestDate:Integer;AUseSourceAttr:Boolean;ADestAttr:Integer):Boolean;

   function FileMove(const ASourceFile,ADestFile:String;AFailIfExists:Boolean):Boolean;
   function FileMoveEx(const ASourceFile,ADestFile:String;AFailIfExists:Boolean;AUseSourceDate:Boolean;ADestDate:Integer;AUseSourceAttr:Boolean;ADestAttr:Integer):Boolean;

   function GetPathName(const AFileName:String):String;

   function GetShortName(const AFileName:String):String;
   function GetLongName(const AFileName:String):String;
   function GetTrueName(const AFileName:String):String;

   function AddSlash(const AFilePath:String;ALeading,ATrailing:Boolean):String;
   function DeleteSlash(const AFilePath:String;ALeading,ATrailing:Boolean):String;

    {Extended Methods}
   function FileCreateEx(const AFileName,AShortName:String;AMode:Integer = fmOpenReadWrite or fmShareExclusive):THandle;
   function CreateDirEx(const ADirName,AShortName:String):Boolean;

   function FileSeekEx(AHandle:THandle;const AOffset:Int64;AOrigin:LongInt):Int64;

   function EndOfFileEx(AHandle:Integer):Boolean;
   function FilePosEx(AHandle:THandle):Int64;
   function FileSizeEx(AHandle:THandle):Int64;

   function FileAgeEx(const AFileName:String):TFileTime;

   function FileGetAttrEx(AHandle:Integer):Integer;
   
   function FileGetDateEx(AHandle:Integer):TFileTime;
   function FileSetDateEx(AHandle:Integer;AAge:TFileTime):Integer;

   function GetFileTime(AHandle:Integer;ACreateTime,AAccessTime,AWriteTime:PFileTime):Boolean;
   function SetFileTime(AHandle:Integer;ACreateTime,AAccessTime,AWriteTime:PFileTime):Boolean;

   //function FindOne(const APath:String;var ASearchRec:TFileSearchRec):Integer; //To Do
   //function FindAll(const APath:String;var ASearchRec:TFileSearchRec):Integer; //To Do

   function FindFirstEx(const APath:String;var ASearchRec:TFileSearchRec):Integer;
   function FindNextEx(var ASearchRec:TFileSearchRec):Integer;
   procedure FindCloseEx(var ASearchRec:TFileSearchRec);

   {Win32 Compatibility Methods}
    {Drive Methods}
   function DefineDosDevice(const ADeviceName,ATargetPath:String;AFlags:LongWord):Boolean;
   function GetDiskType(const ARootPath:String):LongWord; {Equivalent to Win32 GetDriveType}
   function GetDiskFreeSpace(const ARootPath:String;var ASectorsPerCluster,ABytesPerSector,ANumberOfFreeClusters,ATotalNumberOfClusters:LongWord):Boolean;
   function GetDiskFreeSpaceEx(const APathName:String;var AFreeBytesAvailableToCaller,ATotalNumberOfBytes,ATotalNumberOfFreeBytes:QWord):Boolean;
   function GetLogicalDrives:LongWord;
   function GetLogicalDriveStrings:String;
   function GetVolumeInformation(const ARootPath:String;var AVolumeName:String;var AVolumeSerialNumber,AMaximumComponentLength,AFileSystemFlags:LongWord;var ASystemName:String):Boolean; 
   function QueryDosDevice(const ARootPath:String):String;
   {function SetVolumeLabel} {Already Defined}
   
    {File Methods}
   function AreFileApisANSI:Boolean;
   function CloseFile(AHandle:THandle):Boolean; {Equivalent to Win32 CloseHandle}
   function CopyFile(const AExistingName,ANewName:String;AFailIfExists:Boolean):Boolean;
   function CreateFile(const AFileName:String;AAccessMode,AShareMode,ACreateFlags,AFileAttributes:LongWord):THandle;
   {function DeleteFile}   {Already Defined}
   function FindCloseFile(AHandle:THandle):Boolean; {Equivalent to Win32 FindClose}
   function FindFirstFile(const AFileName:String;var AFindData:TWin32FindData):THandle;
   function FindNextFile(AHandle:THandle;var AFindData:TWin32FindData):Boolean;
   function FlushFileBuffers(AHandle:THandle):Boolean;
   //function GetBinaryType //To Do
   function GetFileAttributes(const AFileName:String):LongWord;
   function GetFileInformationByHandle(AHandle:THandle;var AFileInformation:TByHandleFileInformation):Boolean;
   function GetFileSize(AHandle:THandle;var AFileSizeHigh:LongWord):LongWord;
   {function GetFileSizeEx} {Same as FileSizeEx}
   {function GetFileTime}   {Already Defined}
   //function GetFileType //To Do
   function GetFullPathName(const AFileName:String):String;
   function GetShortPathName(const ALongPath:String):String;
   //function GetTempDrive //To Do
   //function GetTempFileName //To Do
   //function GetTempPath //To Do
   //function LockFile //To Do
   //function LockFileEx //To Do
   function MoveFile(const AExistingName,ANewName:String):Boolean;
   //function MoveFileEx //To Do
   function ReadFile(AHandle:THandle;var ABuffer;ABytesToRead:LongWord;var ABytesRead:LongWord):Boolean;
   //function ReadFileEx //To Do
   //function SearchPath //To Do
   {function SetEndOfFile} {Already Defined}
   function SetFileApisToANSI:Boolean;
   function SetFileApisToOEM:Boolean;
   function SetFileAttributes(const AFileName:String;AFileAttributes:LongWord):Boolean;
   function SetFilePointer(AHandle:THandle;ADistanceToMove:LongInt;var ADistanceToMoveHigh:LongInt;AMoveMethod:LongWord):LongWord;
   function SetFilePointerEx(AHandle:THandle;const ADistanceToMove:Int64;var ANewFilePointer:Int64;AMoveMethod:LongWord):Boolean;
   {function SetFileTime} {Already Defined}
   //function SetHandleCount //To Do
   //function UnlockFile //To Do
   //function UnlockFileEx //To Do
   function WriteFile(AHandle:THandle;const ABuffer;ABytesToWrite:LongWord;var ABytesWritten:LongWord):Boolean;
   //function WriteFileEx //To Do
   function GetLongPathName(const AShortPath:String):String;
   {function SetFileShortName}    {Already Defined}

    {Directory Methods}
   function CreateDirectory(const APathName:String):Boolean;
   //function CreateDirectoryEx //To Do
   function GetCurrentDirectory:String;
   function RemoveDirectory(const APathName:String):Boolean;
   function SetCurrentDirectory(const APathName:String):Boolean;
   
    {Stream Methods}
   {function FindFirstStream}    {Already Defined}
   {function FindNextStream}     {Already Defined}

    {HardLink Methods}
   {function CreateHardlink}    {Already Defined}
   {function FindFirstFileName} {Already Defined}
   {function FindNextFileName}  {Already Defined}

    {Mount Point Methods}
   //SetVolumeMountPoint    //To Do
   //DeleteVolumeMountPoint //To Do
   //FindFirstVolumeMountPoint    //To Do
   //FindNextVolumeMountPoint     //To Do
   //FindVolumeMountPointClose    //To Do

    {Symbolic Link Methods}
   {function CreateSymbolicLink}    {Already Defined}

    {Volume Methods}
   {function FindFirstVolume}    {Already Defined}
   {function FindNextVolume}     {Already Defined}
   {function FindVolumeClose}    {Already Defined}

    {Security Methods}
   {function GetFileSecurity}    {Already Defined}
   {function SetFileSecurity}    {Already Defined}
   //function GetNamedSecurityInfo //To Do
   //function SetNamedSecurityInfo //To Do

   {Misc Methods}
   function GetDeviceFromRaw(AHandle:Integer;ALock:Boolean;AState:LongWord):TDiskDevice;
   function GetDeviceFromEnum(AHandle:Integer;ALock:Boolean;AState:LongWord):TDiskDevice;
   
   function GetPartitionFromRaw(AHandle:Integer;ALock:Boolean;AState:LongWord):TDiskPartition;
   function GetPartitionFromEnum(AHandle:Integer;ALock:Boolean;AState:LongWord):TDiskPartition;
   
   function GetVolumeFromPath(const APath:String;ALock:Boolean;AState:LongWord):TDiskVolume;
   function GetVolumeFromRaw(AHandle:Integer;ALock:Boolean;AState:LongWord):TDiskVolume;
   function GetVolumeFromEnum(AHandle:Integer;ALock:Boolean;AState:LongWord):TDiskVolume;
   function GetVolumeFromFile(AHandle:Integer;ALock:Boolean;AState:LongWord):TDiskVolume;
   function GetVolumeFromFind(AHandle:Integer;ALock:Boolean;AState:LongWord):TDiskVolume;

   function GetDriveFromPath(const APath:String;ALock:Boolean;AState:LongWord):TDiskDrive;
   function GetDriveFromRaw(AHandle:Integer;ALock:Boolean;AState:LongWord):TDiskDrive;
   function GetDriveFromEnum(AHandle:Integer;ALock:Boolean;AState:LongWord):TDiskDrive;
   function GetDriveFromFile(AHandle:Integer;ALock:Boolean;AState:LongWord):TDiskDrive;
   function GetDriveFromFind(AHandle:Integer;ALock:Boolean;AState:LongWord):TDiskDrive;

   function GetImageFromEnum(AHandle:Integer;ALock:Boolean;AState:LongWord):TDiskImage;
   
   function GetCatalogFromEnum(AHandle:Integer;ALock:Boolean;AState:LongWord):TDiskCatalog;
   
   function GetFileSystemFromPath(const APath:String;ALock:Boolean;AState:LongWord):TFileSystem;
   function GetFileSystemFromEnum(AHandle:Integer;ALock:Boolean;AState:LongWord):TFileSystem;
   function GetFileSystemFromFile(AHandle:Integer;ALock:Boolean;AState:LongWord):TFileSystem;
   function GetFileSystemFromFind(AHandle:Integer;ALock:Boolean;AState:LongWord):TFileSystem;
   
   function GetRawFromHandle(AHandle:Integer;ALock:Boolean;AState:LongWord):TRawHandle;
   function GetEnumFromHandle(AHandle:Integer;ALock:Boolean;AState:LongWord):TEnumHandle;
   function GetFileFromHandle(AHandle:Integer;ALock:Boolean;AState:LongWord):TFileHandle;
   function GetFindFromHandle(AHandle:Integer;ALock:Boolean;AState:LongWord):TFindHandle;
 end;

 TFileSysList = class(TLinkedObjList)
   constructor Create;
   destructor Destroy; override;
  private
   {Internal Variables}
   FLock:TSynchronizerHandle; 
  public
   {Public Methods}
   procedure ClearList;

   function ReaderLock:Boolean;
   function ReaderUnlock:Boolean;
   function ReaderConvert:Boolean;
   function WriterLock:Boolean;
   function WriterUnlock:Boolean;
   function WriterConvert:Boolean;
 end;

 TFileSysListEx = class(TLinkedObjList)
   constructor Create(ALock:TSynchronizerHandle);
   destructor Destroy; override;
  private
   {Internal Variables}
   FLock:TSynchronizerHandle; 
  public
   {Public Methods}
   procedure ClearList;

   function ReaderLock:Boolean;
   function ReaderUnlock:Boolean;
   function ReaderConvert:Boolean;
   function WriterLock:Boolean;
   function WriterUnlock:Boolean;
   function WriterConvert:Boolean;
 end;
 
 TFileSysTree = class(TLinkedObjTree)
   constructor Create;
   destructor Destroy; override;
  private
   {Internal Variables}
   FLock:TSynchronizerHandle; 
  public
   {Public Methods}
   procedure ClearList;

   function ReaderLock:Boolean;
   function ReaderUnlock:Boolean;
   function ReaderConvert:Boolean;
   function WriterLock:Boolean;
   function WriterUnlock:Boolean;
   function WriterConvert:Boolean;
 end;
 
 TDiskDrive = class(TListObject)
   constructor Create(ADriver:TFileSysDriver;AVolume:TDiskVolume;ADriveNo:Integer);
   destructor Destroy; override;
  private
   {Internal Variables}
   FLock:TSynchronizerHandle;
   FLocalLock:TMutexHandle;

   {Private Methods}
   
  protected
   {Parent Objects}
   FDriver:TFileSysDriver;
   FVolume:TDiskVolume;
   
   {Protected Variables}
   FDriveNo:Integer;

   FDriveType:TDriveType;

   FFileSystem:TFileSystem;

   FRemovable:Boolean;       {Drive is removable - Set by DriveInit}
   FRecognizable:Boolean;    {Drive allows Recognize Drive}
   FRecognized:Boolean;      {Recognized Drive - Set by Recognizer}

   FSectorSize:Word;         {Sector Size of Drive or Device}
   FStartSector:Int64;       {Start Sector on Drive or Device}
   FSectorCount:LongWord;    {Total Sectors in Drive}          //To Do //Int64
   FSectorShiftCount:Word;   {Sectors to Bytes Shift Count}

   {Protected Methods}
   function AcquireLock:Boolean;
   function ReleaseLock:Boolean;

   function GetName:String;
   function GetRoot:String;
   function GetParent:String;

   function GetMaxFile:Integer;
   function GetMaxPath:Integer;
   function GetAttributes:LongWord;
   function GetSystemName:String;
   function GetVolumeName:String;
   function GetVolumeGUID:String;
   function GetVolumeSerial:LongWord;

   function GetDriveType:TDriveType;
   function GetFileSysType:TFileSysType;

   procedure SetFileSystem(AFileSystem:TFileSystem);

   function GetRemovable:Boolean;
   function GetRecognizable:Boolean;
   function GetRecognized:Boolean;

   function GetSectorSize:Word;
   function GetStartSector:Int64;
   function GetSectorCount:LongWord;
   function GetSectorShiftCount:Word;

   function GetDevice:TDiskDevice;
   function GetPartition:TDiskPartition;

   //function GetBootRecord(ARecord:Pointer,ASector:LongWord):Boolean; virtual;  //To Do
   //function SetBootRecord(ARecord:Pointer,ASector:LongWord):Boolean; virtual; //To Do
  public
   {Public Variables}
   property Name:String read GetName;
   property Root:String read GetRoot;
   property Parent:String read GetParent;
   property Volume:TDiskVolume read FVolume;
   property DriveNo:Integer read FDriveNo;

   property MaxFile:Integer read GetMaxFile;
   property MaxPath:Integer read GetMaxPath;
   property Attributes:LongWord read GetAttributes;
   property SystemName:String read GetSystemName;
   property VolumeName:String read GetVolumeName;
   property VolumeGUID:String read GetVolumeGUID;
   property VolumeSerial:LongWord read GetVolumeSerial;

   property DriveType:TDriveType read GetDriveType;
   property FileSysType:TFileSysType read GetFileSysType;

   property FileSystem:TFileSystem read FFileSystem write SetFileSystem;

   property Removable:Boolean read GetRemovable;
   property Recognizable:Boolean read GetRecognizable;
   property Recognized:Boolean read GetRecognized write FRecognized;

   property SectorSize:Word read GetSectorSize;
   property StartSector:Int64 read GetStartSector;
   property SectorCount:LongWord read GetSectorCount;
   property SectorShiftCount:Word read GetSectorShiftCount;

   property Device:TDiskDevice read GetDevice;
   property Partition:TDiskPartition read GetPartition;

   {Public Methods}
   function ReaderLock:Boolean;
   function ReaderUnlock:Boolean;
   function WriterLock:Boolean;
   function WriterUnlock:Boolean;

   function DriveInit:Boolean; virtual;

   {Drive Methods}
   
 end;
 
 TRawHandle = class(TListObject)
   constructor Create;
   destructor Destroy; override;
  private
   {Internal Variables}
   FLock:TSynchronizerHandle;
  public
   {Public Variables}
   Device:TDiskDevice;
   Partition:TDiskPartition;
   Volume:TDiskVolume;
   Drive:TDiskDrive;

   OpenMode:Integer;
   ShareMode:Integer;

   Size:Int64;
   Position:Int64;
   Handle:Integer;
   
   {Public Methods}
   function ReaderLock:Boolean;
   function ReaderUnlock:Boolean;
   function ReaderConvert:Boolean;
   function WriterLock:Boolean;
   function WriterUnlock:Boolean;
   function WriterConvert:Boolean;
 end;

 TEnumHandle = class(TListObject)
   constructor Create;
   destructor Destroy; override;
  private
   {Internal Variables}
   FLock:TSynchronizerHandle;
  public
   {Public Variables}
   FileSystem:TFileSystem;

   Handle:Integer;
   
   CurrentDevice:TDiskDevice;
   CurrentPartition:TDiskPartition;
   CurrentDrive:TDiskDrive;
   CurrentVolume:TDiskVolume;
   CurrentImage:TDiskImage;
   CurrentCatalog:TDiskCatalog;

   {Public Methods}
   function ReaderLock:Boolean;
   function ReaderUnlock:Boolean;
   function ReaderConvert:Boolean;
   function WriterLock:Boolean;
   function WriterUnlock:Boolean;
   function WriterConvert:Boolean;
 end;

 TFileHandle = class(TListObject)
   constructor Create;
   destructor Destroy; override;
  private
   {Internal Variables}
   FLock:TSynchronizerHandle;
  public
   {Public Variables}
   Volume:TDiskVolume;
   Drive:TDiskDrive;
   //To Do //FileSystem for ReleaseFileHandles when dismounting a FileSystem without dismounting the Volume/Drive

   OpenMode:Integer;
   ShareMode:Integer;

   Position:Int64;
   Handle:Integer;

   DataValue:LongWord;     {Available to FileSystem for private use}
   DataOffset:LongWord;    {Available to FileSystem for private use}

   ParentEntry:TDiskEntry;
   HandleEntry:TDiskEntry;
   
   {Public Methods}
   function ReaderLock:Boolean;
   function ReaderUnlock:Boolean;
   function ReaderConvert:Boolean;
   function WriterLock:Boolean;
   function WriterUnlock:Boolean;
   function WriterConvert:Boolean;
 end;

 TFindHandle = class(TListObject)
   constructor Create;
   destructor Destroy; override;
  private
   {Internal Variables}
   FLock:TSynchronizerHandle;
  public
   {Public Variables}
   Volume:TDiskVolume;
   Drive:TDiskDrive;
   //To Do //FileSystem for ReleaseFindHandles when dismounting a FileSystem without dismounting the Volume/Drive

   Any:Boolean;
   Mask:String;
   Attr:LongWord;
   Flags:LongWord;
   Handle:Integer;

   ParentEntry:TDiskEntry;
   CurrentEntry:TDiskEntry;
   
   {Public Methods}
   function ReaderLock:Boolean;
   function ReaderUnlock:Boolean;
   function ReaderConvert:Boolean;
   function WriterLock:Boolean;
   function WriterUnlock:Boolean;
   function WriterConvert:Boolean;
 end;
 
 TDiskController = class(TListObject)
   constructor Create(ADriver:TFileSysDriver);
   destructor Destroy; override;
  private
   {Internal Variables}
   FLock:TSynchronizerHandle;
   FLocalLock:TMutexHandle;

   {Private Methods}
   
  protected
   {Parent Objects}
   FDriver:TFileSysDriver;
   
   {Protected Variables}
   FControllerNo:Integer;  {\Controller0, \Controller1 etc - See Notes}
   FDescription:String;    {Description of Controller - eg "Standard ATA Controller"}

   {Protected Methods}
   function AcquireLock:Boolean;
   function ReleaseLock:Boolean;

   function GetName:String;
   function GetDescription:String;
   function GetFixedDiskCount:Integer; virtual;
   function GetFloppyDiskCount:Integer; virtual;
   function LCHStoLBA(ADevice:TDiskDevice;Cylinder,Head,Sector:Word;var LBA:LongWord):Boolean;
   function PCHStoLBA(ADevice:TDiskDevice;Cylinder,Head,Sector:LongWord;var LBA:LongWord):Boolean;
   function LBAtoLCHS(ADevice:TDiskDevice;LBA:LongWord;var Cylinder,Head,Sector:Word):Boolean;
   function LBAtoPCHS(ADevice:TDiskDevice;LBA:LongWord;var Cylinder,Head,Sector:LongWord):Boolean;
   function LCHStoPCHS(ADevice:TDiskDevice;LCylinder,LHead,LSector:Word;var PCylinder,PHead,PSector:LongWord):Boolean;
   function PCHStoLCHS(ADevice:TDiskDevice;PCylinder,PHead,PSector:LongWord;var LCylinder,LHead,LSector:Word):Boolean;
  public
   {Public Variables}
   property Name:String read GetName;
   property ControllerNo:Integer read FControllerNo;
   property Description:String read GetDescription;

   {Public Methods}
   function ReaderLock:Boolean;
   function ReaderUnlock:Boolean;
   function ReaderConvert:Boolean;
   function WriterLock:Boolean;
   function WriterUnlock:Boolean;
   function WriterConvert:Boolean;

   function ControllerInit:Boolean; virtual;

   function LocateDevices:Boolean; virtual;

   function Read(ADevice:TDiskDevice;ASector:LongWord;ACount:Word;var ABuffer):Boolean; virtual;
   function Write(ADevice:TDiskDevice;ASector:LongWord;ACount:Word;const ABuffer):Boolean; virtual;
   function Erase(ADevice:TDiskDevice;ASector:LongWord;ACount:Word):Boolean; virtual;

   function Reset(ADevice:TDiskDevice):Boolean; virtual;

   function LockMedia(ADevice:TDiskDevice):Boolean; virtual;
   function UnlockMedia(ADevice:TDiskDevice):Boolean; virtual;
   function EjectMedia(ADevice:TDiskDevice):Boolean; virtual;

   function MediaReady(ADevice:TDiskDevice):Boolean; virtual;
   function MediaChanged(ADevice:TDiskDevice):Boolean; virtual;
   function MediaLocked(ADevice:TDiskDevice):Boolean; virtual;

   {Device Methods}
   function Information(ADevice:TDiskDevice):String; virtual;

   function VendorId(ADevice:TDiskDevice):Word; virtual;
   function DeviceId(ADevice:TDiskDevice):Word; virtual;
   
   function Manufacturer(ADevice:TDiskDevice):String; virtual;
   function Product(ADevice:TDiskDevice):String; virtual;
   function SerialNumber(ADevice:TDiskDevice):String; virtual;
   
   function HostBus(ADevice:TDiskDevice):String; virtual;
   function BusNumber(ADevice:TDiskDevice):Word; virtual;
   function DeviceNumber(ADevice:TDiskDevice):Word; virtual;
   function FunctionNumber(ADevice:TDiskDevice):Word; virtual;
   function BaseAddress(ADevice:TDiskDevice):Word; virtual;
   function InterfaceType(ADevice:TDiskDevice):String; virtual;

   function Slave(ADevice:TDiskDevice):Boolean; virtual;
   function LogicalUnitNo(ADevice:TDiskDevice):LongWord; virtual;
   function FireWireGUID(ADevice:TDiskDevice):Int64; virtual;
   function WorldWideNo(ADevice:TDiskDevice):Int64; virtual;

   function PhysicalPort(ADevice:TDiskDevice):Word; virtual;
   function ControlPort(ADevice:TDiskDevice):Word; virtual;
   function IRQ(ADevice:TDiskDevice):LongWord; virtual;

   function PIO(ADevice:TDiskDevice):Boolean; virtual;
   function DMA(ADevice:TDiskDevice):Boolean; virtual;
   function LBA(ADevice:TDiskDevice):Boolean; virtual;
   function Version(ADevice:TDiskDevice):LongWord; virtual;

   function MediaType(ADevice:TDiskDevice):TMediaType; virtual;
   function FloppyType(ADevice:TDiskDevice):TFloppyType; virtual;
   function Ready(ADevice:TDiskDevice):Boolean; virtual;
   function Locked(ADevice:TDiskDevice):Boolean; virtual;
   function Lockable(ADevice:TDiskDevice):Boolean; virtual;
   function Ejectable(ADevice:TDiskDevice):Boolean; virtual;
   function Readable(ADevice:TDiskDevice):Boolean; virtual;
   function Writeable(ADevice:TDiskDevice):Boolean; virtual;
   function Eraseable(ADevice:TDiskDevice):Boolean; virtual;
   function Removable(ADevice:TDiskDevice):Boolean; virtual;
   function ChangeLine(ADevice:TDiskDevice):Boolean; virtual;

   function PhysicalCylinders(ADevice:TDiskDevice):LongWord; virtual;
   function PhysicalHeads(ADevice:TDiskDevice):LongWord; virtual;
   function PhysicalSectors(ADevice:TDiskDevice):LongWord; virtual;

   function LogicalCylinders(ADevice:TDiskDevice):LongWord; virtual;
   function LogicalHeads(ADevice:TDiskDevice):LongWord; virtual;
   function LogicalSectors(ADevice:TDiskDevice):LongWord; virtual;

   function SectorSize(ADevice:TDiskDevice):Word; virtual;
   function SectorCount(ADevice:TDiskDevice):Int64; virtual;
   function SectorShiftCount(ADevice:TDiskDevice):Word; virtual;
 end;
 
 TDiskDevice = class(TListObject)
   constructor Create(ADriver:TFileSysDriver;AController:TDiskController;AImage:TDiskImage;AStorage:PStorageDevice;ADeviceNo:Integer;const AIdentifier:String);
   destructor Destroy; override;
  private
   {Internal Variables}
   FLock:TSynchronizerHandle;
   FLocalLock:TMutexHandle;

   {Private Methods}
   
  protected
   {Parent Objects}
   FDriver:TFileSysDriver;
   FController:TDiskController;
   FImage:TDiskImage;
   FStorage:PStorageDevice;
   
   {Protected Variables}
   FDeviceNo:Integer;       {00h, 01h, 80h, 81h etc - See Notes}
   FIdentifier:String;      {Controller Specific Identifier}
   FInformation:String;     {Description of Device - eg "Standard ATA Disk"}

   FVendorId:Word;          {PCI or USB Vendor Id}
   FDeviceId:Word;          {PCI or USB Device Id}
   
   FManufacturer:String;    {Device Manufacturer name}
   FProduct:String;         {Device Product name}
   FSerialNumber:String;    {Device Serial Number}
   
   FHostBus:String;         {PCI, ISA etc}
   FBusNumber:Word;         {PCI Bus No}
   FDeviceNumber:Word;      {PCI Device No}
   FFunctionNumber:Word;    {PCI Function No}
   FBaseAddress:Word;       {ISA Base Address}
   FInterfaceType:String;   {ATA, ATAPI, SCSI, USB, 1394, FIBRE}

   FSlave:Boolean;          {Device is Slave}
   FLogicalUnitNo:LongWord; {LUN No eg SCSI, ATAPI or USB}
   FFireWireGUID:Int64;     {FireWire GUID No}
   FWorldWideNo:Int64;      {Fibre Channel WWN}

   FPhysicalPort:Word;      {Physical IO Port}
   FControlPort:Word;       {Drive Control Port}
   FIRQ:LongWord;           {IRQ No}

   FPIO:Boolean;            {PIO Transfer Enabled}
   FDMA:Boolean;            {DMA Transfer Enabled}
   FLBA:Boolean;            {Supports LBA (eg Int13 Extensions)}
   FVersion:LongWord;       {Version Information (eg Int13 Extensions Version 01h,20h,21h,30h)}

   FMediaType:TMediaType;   {Media Type eg Fixed, Removable, Floppy}
   FFloppyType:TFloppyType; {Floppy Type eg 360K, 1.44M, ATAPI}
   FReady:Boolean;          {Media is Inserted in Drive}
   FLocked:Boolean;         {Media is Locked in Drive}
   FLockable:Boolean;       {Media is Lockable}
   FEjectable:Boolean;      {Media is Ejectable}
   FReadable:Boolean;       {Media is Readable}
   FWriteable:Boolean;      {Media is Writeable}
   FEraseable:Boolean;      {Media is Eraseable}
   FRemovable:Boolean;      {Media is Removable}
   FChangeLine:Boolean;     {Supports ChangeLine detection}

   FPhysicalCylinders:LongWord; {Physical Cylinders on Drive}
   FPhysicalHeads:LongWord;     {Physical Heads on Drive}
   FPhysicalSectors:LongWord;   {Physical Sectors per Track}

   FLogicalCylinders:LongWord;  {Logical Cylinders on Drive}
   FLogicalHeads:LongWord;      {Logical Heads on Drive}
   FLogicalSectors:LongWord;    {Logical Sectors per Track}

   FSectorSize:Word;        {Bytes Per Sector}
   FSectorCount:Int64;      {Total Sectors}
   FSectorShiftCount:Word;  {Sectors to Bytes Shift Count}

   FPageCount:Word;         {Cache Page Count for this Device}
   FPageShift:Word;         {Cache Page Shift for this Device}
   FPageMask:LongWord;      {Cache Page Mask for this Device}

   {Protected Methods}
   function AcquireLock:Boolean;
   function ReleaseLock:Boolean;

   function GetName:String;
   
   function GetIdentifier:String;
   function GetInformation:String;
   
   function GetManufacturer:String;
   function GetProduct:String;
   function GetSerialNumber:String;
   
   function GetHostBus:String;
   function GetInterfaceType:String;
   
   function GetFreeSectors:Int64;        {Unused Sectors on Device}
   function GetAvailableSectors:Int64;   {Largest block of Unused Sectors}

   function GetAvailableBlock(var AStart,ACount:Int64):Boolean;

   function GetDiskSignature:LongWord; virtual;
   procedure SetDiskSignature(ADiskSignature:LongWord); virtual;

   //function GetBootRecord(ARecord:Pointer,ASector:LongWord):Boolean; virtual; //To Do
   //function SetBootRecord(ARecord:Pointer,ASector:LongWord):Boolean; virtual; //To Do
  public
   {Public Variables}
   property Name:String read GetName;
   property Controller:TDiskController read FController;
   property Image:TDiskImage read FImage;
   property Storage:PStorageDevice read FStorage;
   
   property DeviceNo:Integer read FDeviceNo;
   property Identifier:String read GetIdentifier;
   property Information:String read GetInformation;

   property VendorId:Word read FVendorId;
   property DeviceId:Word read FDeviceId;
   
   property Manufacturer:String read GetManufacturer;
   property Product:String read GetProduct;
   property SerialNumber:String read GetSerialNumber;
   
   property HostBus:String read GetHostBus;
   property BusNumber:Word read FBusNumber;
   property DeviceNumber:Word read FDeviceNumber;
   property FunctionNumber:Word read FFunctionNumber;
   property BaseAddress:Word read FBaseAddress;
   property InterfaceType:String read GetInterfaceType;

   property Slave:Boolean read FSlave;
   property LogicalUnitNo:LongWord read FLogicalUnitNo;
   property FireWireGUID:Int64 read FFireWireGUID;
   property WorldWideNo:Int64 read FWorldWideNo;

   property PhysicalPort:Word read FPhysicalPort;
   property ControlPort:Word read FControlPort;
   property IRQ:LongWord read FIRQ;

   property PIO:Boolean read FPIO;
   property DMA:Boolean read FDMA;
   property LBA:Boolean read FLBA;
   property Version:LongWord read FVersion;

   property MediaType:TMediaType read FMediaType;
   property FloppyType:TFloppyType read FFloppyType;
   property Ready:Boolean read FReady;
   property Locked:Boolean read FLocked;
   property Lockable:Boolean read FLockable;
   property Ejectable:Boolean read FEjectable;
   property Readable:Boolean read FReadable;
   property Writeable:Boolean read FWriteable;
   property Eraseable:Boolean read FEraseable;
   property Removable:Boolean read FRemovable;
   property ChangeLine:Boolean read FChangeLine;

   property PhysicalCylinders:LongWord read FPhysicalCylinders;
   property PhysicalHeads:LongWord read FPhysicalHeads;
   property PhysicalSectors:LongWord read FPhysicalSectors;

   property LogicalCylinders:LongWord read FLogicalCylinders;
   property LogicalHeads:LongWord read FLogicalHeads;
   property LogicalSectors:LongWord read FLogicalSectors;

   property SectorSize:Word read FSectorSize;
   property SectorCount:Int64 read FSectorCount;
   property SectorShiftCount:Word read FSectorShiftCount;

   property PageCount:Word read FPageCount write FPageCount;
   property PageShift:Word read FPageShift write FPageShift;
   property PageMask:LongWord read FPageMask write FPageMask;

   property FreeSectors:Int64 read GetFreeSectors;
   property AvailableSectors:Int64 read GetAvailableSectors;

   property DiskSignature:LongWord read GetDiskSignature write SetDiskSignature;

   {Public Methods}
   function ReaderLock:Boolean;
   function ReaderUnlock:Boolean;
   function WriterLock:Boolean;
   function WriterUnlock:Boolean;
   
   function DeviceInit:Boolean; virtual;

   function LocatePartitions:Boolean; virtual;
   function LocateVolumes:Boolean; virtual;

   function CreateVolume:TDiskVolume; virtual;
   function DeleteVolume(AVolume:TDiskVolume):Boolean; virtual;

   function CreatePartition(AParent:TDiskPartition;APartitionId:Byte;ACount:LongWord;AActive:Boolean):Boolean; virtual;
   function DeletePartition(APartition:TDiskPartition):Boolean; virtual;
   function ModifyPartition(APartition:TDiskPartition;APartitionId:Byte):Boolean; virtual;
   function ActivatePartition(APartition:TDiskPartition;AActive:Boolean):Boolean; virtual;
   function ShrinkPartition(APartition:TDiskPartition;const AStart,ASize:Int64):Boolean; virtual;
   function ExpandPartition(APartition:TDiskPartition;const AStart,ASize:Int64):Boolean; virtual;

   function Reset:Boolean;

   function LockMedia:Boolean;
   function UnlockMedia:Boolean;
   function EjectMedia:Boolean;

   function MediaReady:Boolean;
   function MediaChanged:Boolean;
   function MediaLocked:Boolean;

   {Device Methods}
   function InsertDevice:Boolean; virtual;
   function EjectDevice:Boolean; virtual;
   
   function OpenDevice(AMode:Integer):Integer; virtual;
   procedure CloseDevice(AHandle:Integer); virtual;
   function ReadDevice(AHandle:Integer;var ABuffer;ACount:Integer):Integer; virtual;
   function WriteDevice(AHandle:Integer;const ABuffer;ACount:Integer):Integer; virtual;
   function EraseDevice(AHandle:Integer;ACount:Integer):Integer; virtual;
   function SeekDevice(AHandle:Integer;const AOffset:Int64;AOrigin:Integer):Int64; virtual;
 end;
 
 TDiskPartition = class(TListObject)
   constructor Create(ADriver:TFileSysDriver;ADevice:TDiskDevice;APartition:TDiskPartition;APartitionNo:Integer);
   destructor Destroy; override;
  private
   {Internal Variables}
   FLock:TSynchronizerHandle;
   FLocalLock:TMutexHandle;

   {Private Methods}
   
  protected
   {Parent Objects}
   FDriver:TFileSysDriver;
   FDevice:TDiskDevice;
   FPartition:TDiskPartition;
   
   {Protected Variables}
   FPartitionNo:Integer;    {\Partition1, \Partition2 etc - See Notes}

   FEntryNo:Integer;        {0,1,2,3}
   FPartitionId:Byte;       {Partition Type from Table}

   FBeginHead:Word;         {Logical Starting Head (not Physical)}
   FBeginSector:Word;       {Logical Starting Sector (not Physical)}
   FBeginCylinder:Word;     {Logical Starting Cylinder (not Physical)}
   FEndHead:Word;           {Logical Ending Head (not Physical)}
   FEndSector:Word;         {Logical Ending Sector (not Physical)}
   FEndCylinder:Word;       {Logical Ending Cylinder (not Physical)}
   FSectorOffset:LongWord;  {Offset in Sectors from Location of Table to StartSector}

   FActive:Boolean;         {Active Partition Indicator ($80)}
   FExtended:Boolean;       {Extended Partition Type (no Volume) - Set by Recognizer}
   FRecognizable:Boolean;   {Partition allows Recognize Partition}
   FRecognized:Boolean;     {Recognized Partition Id - Set by Recognizer}

   FNonVolume:Boolean;      {Non Volume Partition (eg Linux Swap) - Set by Recognizer}
   FMultiVolume:Boolean;    {Multiple Volume Partition (eg Netware) - Set by Recognizer}

   FStartSector:Int64;      {Absolute Start Sector on Device}
   FSectorCount:LongWord;   {Total Sectors in Partition}

   {Protected Methods}
   function AcquireLock:Boolean;
   function ReleaseLock:Boolean;

   function GetName:String;
   function GetPath:String;
   function GetParent:String;
   function GetLogical:Boolean;
   function GetPrimary:Boolean;
   procedure SetExtended(AExtended:Boolean);

   function GetFreeSectors:LongWord;      {Unused Sectors in Partition}
   function GetAvailableSectors:LongWord; {Largest block of Unused Sectors}

   function GetAvailableBlock(var AStart,ACount:LongWord):Boolean;

   function GetRoot:TDiskPartition;
   function GetParentStart:LongWord; //To Do //Int64 ???

   //function GetPartitionRecord(ARecord:Pointer,ASector:LongWord):Boolean; virtual; //To Do
   //function SetPartitionRecord(ARecord:Pointer,ASector:LongWord):Boolean; virtual;  //To Do
  public
   {Public Variables}
   property Name:String read GetName;
   property Path:String read GetPath;
   property Parent:String read GetParent;
   property Device:TDiskDevice read FDevice;
   property Partition:TDiskPartition read FPartition;
   property PartitionNo:Integer read FPartitionNo;

   property EntryNo:Integer read FEntryNo write FEntryNo;
   property PartitionId:Byte read FPartitionId;

   property BeginHead:Word read FBeginHead;
   property BeginSector:Word read FBeginSector;
   property BeginCylinder:Word read FBeginCylinder;
   property EndHead:Word read FEndHead;
   property EndSector:Word read FEndSector;
   property EndCylinder:Word read FEndCylinder;
   property SectorOffset:LongWord read FSectorOffset;

   property Active:Boolean read FActive;
   property Logical:Boolean read GetLogical;
   property Primary:Boolean read GetPrimary;
   property Extended:Boolean read FExtended write SetExtended;
   property Recognizable:Boolean read FRecognizable;
   property Recognized:Boolean read FRecognized write FRecognized;

   property NonVolume:Boolean read FNonVolume write FNonVolume;
   property MultiVolume:Boolean read FMultiVolume write FMultiVolume;

   property StartSector:Int64 read FStartSector;
   property SectorCount:LongWord read FSectorCount;

   property FreeSectors:LongWord read GetFreeSectors;
   property AvailableSectors:LongWord read GetAvailableSectors;

   property Root:TDiskPartition read GetRoot;
   property ParentStart:LongWord read GetParentStart;

   {Public Methods}
   function ReaderLock:Boolean;
   function ReaderUnlock:Boolean;
   function ReaderConvert:Boolean;
   function WriterLock:Boolean;
   function WriterUnlock:Boolean;
   function WriterConvert:Boolean;

   function PartitionInit:Boolean; virtual;

   function LocatePartitions:Boolean; virtual;
   function LocateVolumes:Boolean; virtual;

   function CreateVolume:TDiskVolume; virtual;
   function DeleteVolume(AVolume:TDiskVolume):Boolean; virtual;
   
   {Partition Methods}
   function OpenPartition(AMode:Integer):Integer; virtual;
   procedure ClosePartition(AHandle:Integer); virtual;
   function ReadPartition(AHandle:Integer;var ABuffer;ACount:Integer):Integer; virtual;
   function WritePartition(AHandle:Integer;const ABuffer;ACount:Integer):Integer; virtual;
   function SeekPartition(AHandle:Integer;const AOffset:Int64;AOrigin:Integer):Int64; virtual;
 end;
 
 TDiskVolume = class(TListObject)
   constructor Create(ADriver:TFileSysDriver;ADevice:TDiskDevice;APartition:TDiskPartition;AVolumeNo:Integer);
   destructor Destroy; override;
  private
   {Internal Variables}
   FLock:TSynchronizerHandle;
   FLocalLock:TMutexHandle;

   {Private Methods}
   
  protected
   {Parent Objects}
   FDriver:TFileSysDriver;
   FDevice:TDiskDevice;
   FPartition:TDiskPartition;
   
   {Protected Variables}
   FVolumeNo:Integer;        {\Volume1 , \Volume2, etc - See Notes}
   FSegmentNo:Integer;       {Segment0, Segment1 etc - for Multiple Segment volumes (eg Netware)}

   FDriveType:TDriveType;

   FFileSystem:TFileSystem;

   FRemovable:Boolean;       {Volume is Removable - Set by VolumeInit}
   FRecognizable:Boolean;    {Volume allows Recognize Volume}
   FRecognized:Boolean;      {Recognized Volume - Set by Recognizer}

   FSectorSize:Word;         {Sector Size of Device}
   FStartSector:Int64;       {Absolute Start Sector on Device}
   FSectorCount:LongWord;    {Total Sectors in Volume}
   FSectorShiftCount:Word;   {Sectors to Bytes Shift Count}

   {Protected Methods}
   function AcquireLock:Boolean;
   function ReleaseLock:Boolean;

   function GetName:String;
   function GetParent:String;

   function GetMaxFile:Integer;
   function GetMaxPath:Integer;
   function GetAttributes:LongWord;
   function GetSystemName:String;
   function GetVolumeName:String;
   function GetVolumeGUID:String;
   function GetVolumeSerial:LongWord;
   function GetFileSysType:TFileSysType;

   procedure SetFileSystem(AFileSystem:TFileSystem);

   function GetSectorSize:Word;
   function GetStartSector:Int64;
   function GetSectorCount:LongWord;
   function GetSectorShiftCount:Word;

   function MediaTypeToDriveType(AMediaType:TMediaType):TDriveType;

   //function GetBootRecord(ARecord:Pointer,ASector:LongWord):Boolean; virtual;  //To Do
   //function SetBootRecord(ARecord:Pointer,ASector:LongWord):Boolean; virtual; //To Do
  public
   {Public Variables}
   property Name:String read GetName;
   property Parent:String read GetParent;
   property Device:TDiskDevice read FDevice;
   property Partition:TDiskPartition read FPartition;
   property VolumeNo:Integer read FVolumeNo;
   property SegmentNo:Integer read FSegmentNo;

   property MaxFile:Integer read GetMaxFile;
   property MaxPath:Integer read GetMaxPath;
   property Attributes:LongWord read GetAttributes;
   property SystemName:String read GetSystemName;
   property VolumeName:String read GetVolumeName;
   property VolumeGUID:String read GetVolumeGUID;
   property VolumeSerial:LongWord read GetVolumeSerial;

   property DriveType:TDriveType read FDriveType;
   property FileSysType:TFileSysType read GetFileSysType;

   property FileSystem:TFileSystem read FFileSystem write SetFileSystem;

   property Removable:Boolean read FRemovable;
   property Recognizable:Boolean read FRecognizable;
   property Recognized:Boolean read FRecognized write FRecognized;

   property SectorSize:Word read GetSectorSize;
   property StartSector:Int64 read GetStartSector;
   property SectorCount:LongWord read GetSectorCount;
   property SectorShiftCount:Word read GetSectorShiftCount;

   {Public Methods}
   function ReaderLock:Boolean;
   function ReaderUnlock:Boolean;
   function WriterLock:Boolean;
   function WriterUnlock:Boolean;

   function VolumeInit:Boolean; virtual;

   function CreateDrive(ADriveNo:Integer):TDiskDrive; virtual;
   function DeleteDrive(ADrive:TDiskDrive):Boolean; virtual;

   function MountVolume(ADriveNo:Integer):Boolean; virtual;
   function DismountVolume:Boolean; virtual;
   function FormatVolume(AFloppyType:TFloppyType;AFileSysType:TFileSysType):Boolean; virtual;
   function DefragmentVolume:Boolean; virtual;
   function ConvertVolume(AFileSysType:TFileSysType):Boolean; virtual;
   function RepairVolume:Boolean; virtual;
   function CopyVolume(ADest:TDiskVolume):Boolean; virtual;
   function ShrinkVolume(const AStart,ASize:Int64):Boolean; virtual;
   function ExpandVolume(const AStart,ASize:Int64):Boolean; virtual;

   {Volume Methods}
   function OpenVolume(AMode:Integer):Integer; virtual;
   procedure CloseVolume(AHandle:Integer); virtual;
   function ReadVolume(AHandle:Integer;var ABuffer;ACount:Integer):Integer; virtual;
   function WriteVolume(AHandle:Integer;const ABuffer;ACount:Integer):Integer; virtual;
   function SeekVolume(AHandle:Integer;const AOffset:Int64;AOrigin:Integer):Int64; virtual;
 end;

 TDiskImage = class(TListObject)
   constructor Create(ADriver:TFileSysDriver;AController:TDiskController;const AName:String;AImageNo:Integer);
   destructor Destroy; override;
  private
   {Internal Variables}
   FLock:TSynchronizerHandle;
   FLocalLock:TMutexHandle;
   
   {Private Methods}
   
  protected
   {Parent Objects}
   FDriver:TFileSysDriver;
   FController:TDiskController;
   
   {Protected Variables}
   FName:String;
   FImageNo:Integer;

   FLocked:Boolean;
   FChanged:Boolean;
   FAttributes:LongWord;

   FImageType:TImageType;
   FMediaType:TMediaType;
   FFloppyType:TFloppyType;

   FCylinders:LongWord;       {Physical Cylinders on Drive}
   FHeads:LongWord;           {Physical Heads on Drive}
   FSectors:LongWord;         {Physical Sectors per Track}
   FLogicalShiftCount:Word;   {Physical to Logical Shift Count}

   FSectorSize:Word;          {Bytes Per Sector}
   FSectorCount:Int64;        {Total Sectors}
   FSectorShiftCount:Word;    {Sectors to Bytes Shift Count}

   FPartitionId:Byte;         {Partition Type for Table}
   FFileSysType:TFileSysType; //To Do //Not Needed ?

   FDevice:TDiskDevice;

   {Protected Methods}
   function AcquireLock:Boolean;
   function ReleaseLock:Boolean;
   
   function GetReady:Boolean; virtual;
   function GetReadable:Boolean; virtual;
   function GetWriteable:Boolean; virtual;
   function GetEraseable:Boolean; virtual;

   function GetCylinders:LongWord; virtual;
   function GetHeads:LongWord; virtual;
   function GetSectors:LongWord; virtual;
   function GetLogicalShiftCount:Word; virtual;

   function GetSectorSize:Word; virtual;
   function GetSectorCount:Int64; virtual;
   function GetSectorShiftCount:Word; virtual;

   function GetPartitionId:Byte; virtual;

   function GetName:String; virtual;
   procedure SetName(const AName:String); virtual;
   procedure SetDevice(ADevice:TDiskDevice);
  public
   {Public Variables}
   property Controller:TDiskController read FController;

   property Name:String read GetName write SetName;
   property ImageNo:Integer read FImageNo;

   property Ready:Boolean read GetReady;
   property Locked:Boolean read FLocked;
   property Changed:Boolean read FChanged;
   property Readable:Boolean read GetReadable;
   property Writeable:Boolean read GetWriteable;
   property Eraseable:Boolean read GetEraseable;
   property Attributes:LongWord read FAttributes;

   property ImageType:TImageType read FImageType;
   property MediaType:TMediaType read FMediaType;
   property FloppyType:TFloppyType read FFloppyType;

   property Cylinders:LongWord read FCylinders;
   property Heads:LongWord read FHeads;
   property Sectors:LongWord read FSectors;
   property LogicalShiftCount:Word read FLogicalShiftCount;

   property SectorSize:Word read FSectorSize;
   property SectorCount:Int64 read FSectorCount;
   property SectorShiftCount:Word read FSectorShiftCount;

   property PartitionId:Byte read FPartitionId;
   property FileSysType:TFileSysType read FFileSysType;

   property Device:TDiskDevice read FDevice write SetDevice;

   {Public Methods}
   function ReaderLock:Boolean;
   function ReaderUnlock:Boolean;
   function ReaderConvert:Boolean; 
   function WriterLock:Boolean;
   function WriterUnlock:Boolean;
   function WriterConvert:Boolean;
   function WriterOwner:Boolean;
   
   function ImageInit:Boolean; virtual;

   function LockMedia:Boolean; virtual;
   function UnlockMedia:Boolean; virtual;
   function EjectMedia:Boolean; virtual;

   function MediaReady:Boolean; virtual;
   function MediaChanged:Boolean; virtual;
   function MediaLocked:Boolean; virtual;

   function Read(ASector:LongWord;ACount:Word;var ABuffer):Boolean; virtual;
   function Write(ASector:LongWord;ACount:Word;const ABuffer):Boolean; virtual;
   function Allocated(ASector:LongWord;ACount:Word):Word; virtual;

   function MountImage:Boolean; virtual;
   function DismountImage:Boolean; virtual;
   function InsertImage:Boolean; virtual;
   function EjectImage:Boolean; virtual;
   function ConvertImage(AImageType:TImageType):Boolean; virtual;
   function CopyImage(ADest:TDiskImage):Boolean; virtual;
   function ShrinkImage(const ASize:Int64):Boolean; virtual;
   function ExpandImage(const ASize:Int64):Boolean; virtual;

   {Image Methods}
   function CreateImage(AMediaType:TMediaType;AFloppyType:TFloppyType;AAttributes:LongWord;ASectorSize:Word;const ASectorCount:Int64;ACylinders,AHeads,ASectors:LongWord;APartitionId:Byte):Integer; virtual;
   function OpenImage(AMediaType:TMediaType;AFloppyType:TFloppyType;AAttributes:LongWord;ASectorSize:Word;const ASectorCount:Int64;ACylinders,AHeads,ASectors:LongWord;APartitionId:Byte):Integer; virtual;
   function CloseImage:Boolean; virtual;
   function ResizeImage(const ASectorCount:Int64):Boolean; virtual;

   function CreateSnapshot:Boolean; virtual;
   function DeleteSnapshot:Boolean; virtual;
   function MergeSnapshot:Boolean; virtual;
 end;
 
 TDiskPartitioner = class;
 TDiskFormatter = class;
 TDiskDefragger = class;
 TDiskConverter = class;
 TDiskRepairer = class;
 TDiskResizer = class;
 TDiskCopier = class;
 TDiskImager = class;
 TRecognizer = class(TListObject)
   constructor Create(ADriver:TFileSysDriver);
   destructor Destroy; override;
  private
   {Internal Variables}
   FLock:TSynchronizerHandle;
   FLocalLock:TMutexHandle;

   {Private Methods}
   
  protected
   {Parent Objects}
   FDriver:TFileSysDriver;

   {Protected Variables}
   FAllowDrive:Boolean;    {Enable mounting with an attached Drive}
   FAllowDefault:Boolean;  {Enable mounting of unrecognized media} {Unpartitioned Media Only}

   FDirtyCheck:Boolean;    {Enable checking Volume when dirty flag set on mount}
   FQuickCheck:Boolean;    {Enable quick check only when checking dirty Volume}

   FPartitioner:TDiskPartitioner;
   FFormatter:TDiskFormatter;
   FDefragger:TDiskDefragger;
   FConverter:TDiskConverter;
   FRepairer:TDiskRepairer;
   FResizer:TDiskResizer;
   FCopier:TDiskCopier;
   FImager:TDiskImager;

   {Protected Methods}
   function AcquireLock:Boolean;
   function ReleaseLock:Boolean;

   function GetName:String; virtual;
  public
   {Public Variables}
   property Name:String read GetName;

   property AllowDrive:Boolean read FAllowDrive write FAllowDrive;
   property AllowDefault:Boolean read FAllowDefault write FAllowDefault;

   property DirtyCheck:Boolean read FDirtyCheck write FDirtyCheck;
   property QuickCheck:Boolean read FQuickCheck write FQuickCheck;

   property Partitioner:TDiskPartitioner read FPartitioner write FPartitioner;
   property Formatter:TDiskFormatter read FFormatter write FFormatter;
   property Defragger:TDiskDefragger read FDefragger write FDefragger;
   property Converter:TDiskConverter read FConverter write FConverter;
   property Repairer:TDiskRepairer read FRepairer write FRepairer;
   property Resizer:TDiskResizer read FResizer write FResizer;
   property Copier:TDiskCopier read FCopier write FCopier;
   property Imager:TDiskImager read FImager write FImager;
   
   {Public Methods}
   function ReaderLock:Boolean;
   function ReaderUnlock:Boolean;
   function ReaderConvert:Boolean;
   function WriterLock:Boolean;
   function WriterUnlock:Boolean;
   function WriterConvert:Boolean;

   {Partition/Volume Methods}
   function RecognizePartitionId(APartitionId:Byte):Boolean; virtual;
   function RecognizeBootSector(ABootSector:PBootSector;const AStartSector,ASectorCount:Int64):Boolean; virtual;

   function RecognizePartition(APartition:TDiskPartition):Boolean; virtual;
   function RecognizeVolume(AVolume:TDiskVolume):Boolean; virtual;
   function MountVolume(AVolume:TDiskVolume;ADrive:TDiskDrive):Boolean; virtual;
   function DismountVolume(AVolume:TDiskVolume):Boolean; virtual;
   
   {Image Methods}
   function RecognizeImage(AImage:TDiskImage):Boolean; virtual;
   function MountImage(AImage:TDiskImage):Boolean; virtual;
   function DismountImage(AImage:TDiskImage):Boolean; virtual;
   function InsertImage(AImage:TDiskImage):Boolean; virtual;
   function EjectImage(AImage:TDiskImage):Boolean; virtual;
 end;

 TRedirector = class(TListObject)
   constructor Create(ADriver:TFileSysDriver);
   destructor Destroy; override;
  private
   {Internal Variables}
   FLock:TSynchronizerHandle;
   FLocalLock:TMutexHandle;

   {Private Methods}
   
  protected
   {Parent Objects}
   FDriver:TFileSysDriver;

   {Protected Variables}

   {Protected Methods}
   function AcquireLock:Boolean;
   function ReleaseLock:Boolean;
  public
   {Public Variables}

   {Public Methods}
   function ReaderLock:Boolean;
   function ReaderUnlock:Boolean;
   function WriterLock:Boolean;
   function WriterUnlock:Boolean;
   
   function LocateDrives:Boolean; virtual;

   {Redirector Methods}
   function RedirectPath(const APath:String):Boolean; virtual;
   function RedirectDrive(ADrive:TDiskDrive):Boolean; virtual;
   function AttachPath(const APath:String;ADrive:TDiskDrive):Boolean; virtual;
   function DetachDrive(ADrive:TDiskDrive):Boolean; virtual;
 end;
 
 TDiskPartitioner = class(TObject)
   constructor Create(ADriver:TFileSysDriver;ARecognizer:TRecognizer);
   destructor Destroy; override;
  private
   {Internal Variables}
   FLock:TSynchronizerHandle;
   FLocalLock:TMutexHandle;

   {Private Methods}
   
  protected
   {Parent Objects}
   FDriver:TFileSysDriver;
   FRecognizer:TRecognizer;

   {Protected Variables}
   FInitChar:Byte;       {Character to initialize sectors when adding partitions}

   {Protected Methods}
   function AcquireLock:Boolean;
   function ReleaseLock:Boolean;

   function CheckLogical(ADevice:TDiskDevice;AParent:TDiskPartition;APartitionId:Byte):Boolean; virtual;
   function CheckExtended(ADevice:TDiskDevice;AParent:TDiskPartition;APartitionId:Byte):Boolean; virtual;

   function GetLogicalChild(ADevice:TDiskDevice;APartition:TDiskPartition;ALock:Boolean;AState:LongWord):TDiskPartition;
   function GetExtendedSibling(ADevice:TDiskDevice;AParent:TDiskPartition;ALock:Boolean;AState:LongWord):TDiskPartition;
   function GetExtendedParent(ADevice:TDiskDevice;AParent:TDiskPartition;AStart:LongWord;ALock:Boolean;AState:LongWord):TDiskPartition;

   function GetEndCHS(ADevice:TDiskDevice;AStart,ACount:LongWord;var ACylinder,AHead,ASector:Word):Boolean; virtual;
   function GetStartCHS(ADevice:TDiskDevice;AStart,ACount:LongWord;var ACylinder,AHead,ASector:Word):Boolean; virtual;

   function GetSectorCount(ADevice:TDiskDevice;AStart,ACount:LongWord):LongWord; virtual;
   function GetStartSector(ADevice:TDiskDevice;AExtended,ALogical:Boolean;AStart:LongWord;var ACount:LongWord):LongWord; virtual;
   function GetSectorOffset(ADevice:TDiskDevice;AParent:TDiskPartition;AExtended:Boolean;AStart:LongWord):LongWord; virtual;
   function GetPartitionId(ADevice:TDiskDevice;AParent:TDiskPartition;AStart,ACount:LongWord;APartitionId:Byte):Byte; virtual;

   function InitPartition(ADevice:TDiskDevice;AParent:TDiskPartition;AStart,ACount:LongWord;APartitionId:Byte):Boolean; virtual;

   function CreatePartitionRecord(ADevice:TDiskDevice;ARecord:PPartitionRecord):Boolean;
   function CreatePartitionEntry(ADevice:TDiskDevice;AStart,ACount,AOffset:LongWord;APartitionId:Byte;AActive:Boolean;var AEntry:TPartitionEntry):Boolean;

   function FillSectors(ADevice:TDiskDevice;APartition:TDiskPartition;ASector,ACount:LongWord;AValue:Byte):Boolean;
   function ReadSectors(ADevice:TDiskDevice;APartition:TDiskPartition;ASector,ACount:LongWord;var ABuffer):Boolean;
   function WriteSectors(ADevice:TDiskDevice;APartition:TDiskPartition;ASector,ACount:LongWord;const ABuffer):Boolean;
  public
   {Public Variables}
   property InitChar:Byte read FInitChar write FInitChar;
   
   {Public Methods}
   function ReaderLock:Boolean;
   function ReaderUnlock:Boolean;
   function WriterLock:Boolean;
   function WriterUnlock:Boolean;
   
   {Partition Methods}
   function AcceptPartition(ADevice:TDiskDevice;APartition,AParent:TDiskPartition;APartitionId:Byte):Boolean; virtual;

   function CreatePartition(ADevice:TDiskDevice;AParent:TDiskPartition;APartitionId:Byte;ACount:LongWord;AActive:Boolean):Boolean; virtual;
   function DeletePartition(APartition:TDiskPartition):Boolean; virtual;
   function ModifyPartition(APartition:TDiskPartition;APartitionId:Byte;AOverride:Boolean):Boolean; virtual;
   function ActivatePartition(APartition:TDiskPartition;AActive:Boolean):Boolean; virtual;
 end;
 
 TDiskFormatter = class(TObject)
   constructor Create(ADriver:TFileSysDriver;ARecognizer:TRecognizer);
   destructor Destroy; override;
  private
   {Internal Variables}
   FLock:TSynchronizerHandle;
   FLocalLock:TMutexHandle;

   {Private Methods}
   
  protected
   {Parent Objects}
   FDriver:TFileSysDriver;
   FRecognizer:TRecognizer;
   
   {Protected Variables}

   {Protected Methods}
   function AcquireLock:Boolean;
   function ReleaseLock:Boolean;
   
   function FillSectors(AVolume:TDiskVolume;ADrive:TDiskDrive;ASector,ACount:LongWord;AValue:Byte):Boolean;
   function ReadSectors(AVolume:TDiskVolume;ADrive:TDiskDrive;ASector,ACount:LongWord;var ABuffer):Boolean;
   function WriteSectors(AVolume:TDiskVolume;ADrive:TDiskDrive;ASector,ACount:LongWord;const ABuffer):Boolean;
  public
   {Public Variables}

   {Public Methods}
   function ReaderLock:Boolean;
   function ReaderUnlock:Boolean;
   function WriterLock:Boolean;
   function WriterUnlock:Boolean;
   
   {Volume Methods}
   function AcceptVolume(AVolume:TDiskVolume;AFloppyType:TFloppyType;AFileSysType:TFileSysType):Boolean; virtual;

   function FormatVolume(AVolume:TDiskVolume;AFloppyType:TFloppyType;AFileSysType:TFileSysType):Boolean; virtual;
 end;
 
 TDiskDefragger = class(TObject)
   constructor Create(ADriver:TFileSysDriver;ARecognizer:TRecognizer);
   destructor Destroy; override;
  private
   {Internal Variables}
   FLock:TSynchronizerHandle;
   FLocalLock:TMutexHandle;

   {Private Methods}
   
  protected
   {Parent Objects}
   FDriver:TFileSysDriver;
   FRecognizer:TRecognizer;
   
   {Protected Variables}
   
   {Protected Methods}
   function AcquireLock:Boolean;
   function ReleaseLock:Boolean;
  public
   {Public Variables}

   {Public Methods}
   function ReaderLock:Boolean;
   function ReaderUnlock:Boolean;
   function WriterLock:Boolean;
   function WriterUnlock:Boolean;
   
   {Volume Methods}
   function AcceptVolume(AVolume:TDiskVolume):Boolean; virtual;

   function DefragmentVolume(AVolume:TDiskVolume):Boolean; virtual;
 end;

 TDiskConverter = class(TObject)
   constructor Create(ADriver:TFileSysDriver;ARecognizer:TRecognizer);
   destructor Destroy; override;
  private
   {Internal Variables}
   FLock:TSynchronizerHandle;
   FLocalLock:TMutexHandle;

   {Private Methods}
   
  protected
   {Parent Objects}
   FDriver:TFileSysDriver;
   FRecognizer:TRecognizer;
   
   {Protected Variables}
   
   {Protected Methods}
   function AcquireLock:Boolean;
   function ReleaseLock:Boolean;
  public
   {Public Variables}

   {Public Methods}
   function ReaderLock:Boolean;
   function ReaderUnlock:Boolean;
   function WriterLock:Boolean;
   function WriterUnlock:Boolean;
   
   {Volume Methods}
   function AcceptVolume(AVolume:TDiskVolume;AFileSysType:TFileSysType):Boolean; virtual;

   function ConvertVolume(AVolume:TDiskVolume;AFileSysType:TFileSysType):Boolean; virtual;

   {Image Methods}
   function AcceptImage(AImage:TDiskImage;AImageType:TImageType):Boolean; virtual;

   function ConvertImage(AImage:TDiskImage;AImageType:TImageType):Boolean; virtual;
 end;

 TDiskRepairer = class(TObject)
   constructor Create(ADriver:TFileSysDriver;ARecognizer:TRecognizer);
   destructor Destroy; override;
  private
   {Internal Variables}
   FLock:TSynchronizerHandle;
   FLocalLock:TMutexHandle;

   {Private Methods}
   
  protected
   {Parent Objects}
   FDriver:TFileSysDriver;
   FRecognizer:TRecognizer;
   
   {Protected Variables}
   
   {Protected Methods}
   function AcquireLock:Boolean;
   function ReleaseLock:Boolean;
  public
   {Public Variables}

   {Public Methods}
   function ReaderLock:Boolean;
   function ReaderUnlock:Boolean;
   function WriterLock:Boolean;
   function WriterUnlock:Boolean;
   
   {Volume Methods}
   function AcceptVolume(AVolume:TDiskVolume):Boolean; virtual;

   function RepairVolume(AVolume:TDiskVolume):Boolean; virtual;
 end;

 TDiskResizer = class(TObject)
   constructor Create(ADriver:TFileSysDriver;ARecognizer:TRecognizer);
   destructor Destroy; override;
  private
   {Internal Variables}
   FLock:TSynchronizerHandle;
   FLocalLock:TMutexHandle;

   {Private Methods}
   
  protected
   {Parent Objects}
   FDriver:TFileSysDriver;
   FRecognizer:TRecognizer;
   
   {Protected Variables}
   
   {Protected Methods}
   function AcquireLock:Boolean;
   function ReleaseLock:Boolean;
  public
   {Public Variables}

   {Public Methods}
   function ReaderLock:Boolean;
   function ReaderUnlock:Boolean;
   function WriterLock:Boolean;
   function WriterUnlock:Boolean;
   
   {Volume Methods}
   function AcceptVolume(AVolume:TDiskVolume;const AStart,ASize:Int64):Boolean; virtual;

   function ShrinkVolume(AVolume:TDiskVolume;const AStart,ASize:Int64):Boolean; virtual;
   function ExpandVolume(AVolume:TDiskVolume;const AStart,ASize:Int64):Boolean; virtual;

   {Partition Methods}
   function AcceptPartition(APartition:TDiskPartition;const AStart,ASize:Int64):Boolean; virtual;

   function ShrinkPartition(APartition:TDiskPartition;const AStart,ASize:Int64):Boolean; virtual;
   function ExpandPartition(APartition:TDiskPartition;const AStart,ASize:Int64):Boolean; virtual;

   {Image Methods}
   function AcceptImage(AImage:TDiskImage;const ASize:Int64):Boolean; virtual;

   function ShrinkImage(AImage:TDiskImage;const ASize:Int64):Boolean; virtual;
   function ExpandImage(AImage:TDiskImage;const ASize:Int64):Boolean; virtual;
 end;

 TDiskCopier = class(TObject)
   constructor Create(ADriver:TFileSysDriver;ARecognizer:TRecognizer);
   destructor Destroy; override;
  private
   {Internal Variables}
   FLock:TSynchronizerHandle;
   FLocalLock:TMutexHandle;

   {Private Methods}
   
  protected
   {Parent Objects}
   FDriver:TFileSysDriver;
   FRecognizer:TRecognizer;
   
   {Protected Variables}
   
   {Protected Methods}
   function AcquireLock:Boolean;
   function ReleaseLock:Boolean;
  public
   {Public Variables}

   {Public Methods}
   function ReaderLock:Boolean;
   function ReaderUnlock:Boolean;
   function WriterLock:Boolean;
   function WriterUnlock:Boolean;
   
   {Volume Methods}
   function AcceptVolume(AVolume,ADest:TDiskVolume):Boolean; virtual;

   function CopyVolume(AVolume,ADest:TDiskVolume):Boolean; virtual;

   {Image Methods}
   function AcceptImage(AImage,ADest:TDiskImage):Boolean; virtual;

   function CopyImage(AImage,ADest:TDiskImage):Boolean; virtual;
 end;

 TDiskImager = class(TObject)
   constructor Create(ADriver:TFileSysDriver;ARecognizer:TRecognizer);
   destructor Destroy; override;
  private
   {Internal Variables}
   FLock:TSynchronizerHandle;
   FLocalLock:TMutexHandle;

   {Private Methods}
   
  protected
   {Parent Objects}
   FDriver:TFileSysDriver;
   FRecognizer:TRecognizer;
   
   {Protected Variables}
   
   {Protected Methods}
   function AcquireLock:Boolean;
   function ReleaseLock:Boolean;
  public
   {Public Variables}

   {Public Methods}
   function ReaderLock:Boolean;
   function ReaderUnlock:Boolean;
   function WriterLock:Boolean;
   function WriterUnlock:Boolean;

   {Image Methods}
   function AcceptImage(AImage:TDiskImage;const AName:String;AImageType:TImageType;AMediaType:TMediaType;AFloppyType:TFloppyType;AAttributes:LongWord;ASectorSize:Word;const ASectorCount:Int64):Boolean; virtual;

   function CreateImage(AImage:TDiskImage;const AName:String;AImageType:TImageType;AMediaType:TMediaType;AFloppyType:TFloppyType;AAttributes:LongWord;ASectorSize:Word;const ASectorCount:Int64;ACylinders,AHeads,ASectors:LongWord;APartitionId:Byte):Integer; virtual;
   function OpenImage(AImage:TDiskImage;const AName:String;AImageType:TImageType;AMediaType:TMediaType;AFloppyType:TFloppyType;AAttributes:LongWord;ASectorSize:Word;const ASectorCount:Int64;ACylinders,AHeads,ASectors:LongWord;APartitionId:Byte):Integer; virtual;
   function CloseImage(AImage:TDiskImage):Boolean; virtual;

   function AcceptSnapshot(AImage:TDiskImage):Boolean; virtual;

   function CreateSnapshot(AImage:TDiskImage):Boolean; virtual;
   function DeleteSnapshot(AImage:TDiskImage):Boolean; virtual;
   function MergeSnapshot(AImage:TDiskImage):Boolean; virtual;
 end;
 
 TDiskTable = class;
 TDiskBlock = class;
 TDiskReparse = class;
 TDiskSecurity = class;
 TFileSystem = class(TListObject)
   constructor Create(ADriver:TFileSysDriver;AVolume:TDiskVolume;ADrive:TDiskDrive);
   destructor Destroy; override;
  private
   {Internal Variables}
   FLock:TSynchronizerHandle;
   FLocalLock:TMutexHandle;

   {Private Methods}
   
  protected
   {Parent Objects}
   FDriver:TFileSysDriver;
   FVolume:TDiskVolume;
   FDrive:TDiskDrive;
   
   {Protected Variables}
   FPathChar:String;     {Path separator character}
   FNameChar:String;     {Name separator character}
   FFileChar:String;     {File separator character}
   FRootChar:String;     {Root specifier character (eg C:)}
   FRootName:String;
   FRootPath:String;     {Root Path must be prefixed with \\.}
   FMaxFile:Integer;
   FMaxPath:Integer;
   FMaxAltFile:Integer;
   FMaxAltPath:Integer;
   FAttributes:LongWord;
   FMaxAttributes:LongWord;
   FMaskAttributes:LongWord;
   FMountPointTag:LongWord;
   FSymbolicLinkTag:LongWord;
   FSystemName:String;
   FVolumeName:String;
   FVolumeGUID:String;
   FVolumeSerial:LongWord;
   FFileSysType:TFileSysType;

   FSectorSize:Word;
   FStartSector:Int64;
   FSectorCount:LongWord;    //To Do //Int64 - Limits FileSystem to 2TB (if 512 byte sectors) (Ok for FAT, not good for NTFS etc)

   FRoot:TDiskEntry;
   
   FCurrentIndex:LongWord;   {TLS Index for storing current directory}
   FCurrentEntry:TDiskEntry; {Current directory when global current directory is enabled}
   
   FChunks:TFileSysList;
   FTables:TFileSysList;
   FBlocks:TFileSysList;
   FEntries:TFileSysTree;
   FCatalogs:TFileSysList;
   FAcls:TFileSysList;     

   FChunkLocal:TMutexHandle;   {Local Lock shared by all DiskChunk objects}
   FTableLocal:TMutexHandle;   {Local Lock shared by all DiskTable objects}
   FBlockLocal:TMutexHandle;   {Local Lock shared by all DiskBlock objects}
   FEntryLocal:TMutexHandle;   {Local Lock shared by all DiskEntry objects}
   FCatalogLocal:TMutexHandle; {Local Lock shared by all DiskCatalog objects}
   FSecurityLocal:TMutexHandle;{Local Lock shared by all DiskSecurity objects}
   FAclLocal:TMutexHandle;     {Local Lock shared by all DiskAcl objects}
   FAceLocal:TMutexHandle;     {Local Lock shared by all DiskAce objects}
   
   FMarkDirty:Boolean;        {Mark the volume as dirty when dismounting (Either by request or due to error)}
   FMarkClean:Boolean;        {Mark the volume as clean when dismounting (Only by request)}
   FMarkError:Boolean;        {Error was encounted on volume, mark as dirty when dismounting}
   FLogDirty:Boolean;         {LogFile was dirty when mounted (if supported by filesystem)}
   FMountDirty:Boolean;       {Volume was dirty when mounted, leave marked as dirty when dismounting}

   FOemConvert:Boolean;       {Default to True overidden by descendants if not supported}
   FNumericTail:Boolean;      {Default to True overidden by descendants if not supported}

   FReadOnly:Boolean;         {Default to False overidden by descendants if True}
   FLongNames:Boolean;        {Default to True overidden by descendants if not supported}
   FDataStreams:Boolean;      {Default to False overidden by descendants if supported}
   FReparsePoints:Boolean;    {Default to False overidden by descendants if supported}
   FCaseSensitive:Boolean;    {Default to False overidden by descendants if supported}
   FCasePreserved:Boolean;    {Default to False overidden by descendants if supported}
   FUnicodeNames:Boolean;     {Default to False overidden by descendants if supported}
   FPersistentAcls:Boolean;   {Default to False overidden by descendants if supported}
   FFileCompression:Boolean;  {Default to False overidden by descendants if supported}
   FVolumeQuotas:Boolean;     {Default to False overidden by descendants if supported}
   FSparseFiles:Boolean;      {Default to False overidden by descendants if supported}
   FRemoteStorage:Boolean;    {Default to False overidden by descendants if supported}
   FVolumeCompressed:Boolean; {Default to False overidden by descendants if supported}
   FObjectIds:Boolean;        {Default to False overidden by descendants if supported}
   FEncryption:Boolean;       {Default to False overidden by descendants if supported}

   FBootCatalog:Boolean;      {Default to False overidden by descendants if supported}
   FVirtualVolume:Boolean;    {Default to False overidden by descendants if supported}
   FFolderEncryption:Boolean; {Default to False overidden by descendants if supported}
   FFolderCompression:Boolean;{Default to False overidden by descendants if supported}

   FBootSector:LongWord;     {Relative to StartSector}
   FBootBackup:LongWord;     {Relative to StartSector}

   FSectorBuffer:Pointer;    {Buffer of exactly sector size}
   FSectorLock:TMutexHandle; {Lock for sector buffer}

   {Protected Methods}
   function AcquireLock:Boolean;
   function ReleaseLock:Boolean;
   
   function SectorLock:Boolean;
   function SectorUnlock:Boolean;
   
   procedure SetDrive(ADrive:TDiskDrive); virtual;
   procedure SetVolume(AVolume:TDiskVolume); virtual;

   function GetPathChar:String; virtual;
   function GetNameChar:String; virtual;
   function GetFileChar:String; virtual;
   function GetRootChar:String; virtual;
   function GetRootName:String; virtual;
   function GetRootPath:String; virtual;
   function GetSystemName:String; virtual;
   function GetVolumeName:String; virtual;
   function GetVolumeGUID:String; virtual;
   
   function LoadPathChar:String; virtual;
   function LoadNameChar:String; virtual;
   function LoadFileChar:String; virtual;
   function LoadRootChar:String; virtual;
   function LoadRootName:String; virtual;
   function LoadRootPath:String; virtual;
   function LoadMaxFile:Integer; virtual;
   function LoadMaxPath:Integer; virtual;
   function LoadMaxAltFile:Integer; virtual;
   function LoadMaxAltPath:Integer; virtual;
   function LoadAttributes:LongWord; virtual;     {Get the Volume Attributes}
   function LoadMaxAttributes:LongWord; virtual;  {Get the Maximum File Attributes (used when setting file attributes)}
   function LoadMaskAttributes:LongWord; virtual; {Get the File Attributes Mask (used when getting file attributes)}
   function LoadMountPointTag:LongWord; virtual;
   function LoadSymbolicLinkTag:LongWord; virtual;
   function LoadSystemName:String; virtual;
   function LoadVolumeName:String; virtual;
   function LoadVolumeGUID:String; virtual;
   function LoadVolumeSerial:LongWord; virtual;
   function LoadFileSysType:TFileSysType; virtual;

   function LoadSectorSize:Word; virtual;
   function LoadStartSector:Int64; virtual;
   function LoadSectorCount:LongWord; virtual;

   function GetCurrent:TDiskEntry; virtual;
   function SetCurrent(ACurrent:TDiskEntry):Boolean; virtual;
   
   function FillSectors(ASector,ACount:LongWord;AValue:Byte):Boolean;

   function ReadSectors(ASector,ACount:LongWord;var ABuffer):Boolean;
   function WriteSectors(ASector,ACount:LongWord;const ABuffer):Boolean;

   function ReadEntry(AParent,AEntry:TDiskEntry;var ABuffer;const AStart:Int64;ACount:LongWord;var AOffset,AValue:LongWord):Integer; virtual;
   function WriteEntry(AParent,AEntry:TDiskEntry;const ABuffer;const AStart:Int64;ACount:LongWord;var AOffset,AValue:LongWord):Integer; virtual;

   function LoadTables:Boolean; virtual;
   function LoadBlocks:Boolean; virtual;
   function LoadEntries(AParent:TDiskEntry):Boolean; virtual;
   function LoadCatalogs:Boolean; virtual;

   function LoadTable(ATableNo:LongWord):Boolean; virtual;
   function LoadBlock(ABlockNo:LongWord):Boolean; virtual;
   {Note: LoadEntry can be implemented if needed but is not defined here}
   {Note: LoadCatalog can be implemented if needed but is not defined here}

   function UnloadEntries(AParent:TDiskEntry):Boolean; virtual;
   
   function AddEntry(AParent:TDiskEntry;const AName:String;AAttributes:LongWord;AReference:Boolean):TDiskEntry; virtual;
   function AddEntryEx(AParent:TDiskEntry;const AName,AAltName:String;AAttributes:LongWord;AReference:Boolean):TDiskEntry; virtual;
   function RemoveEntry(AParent,AEntry:TDiskEntry):Boolean; virtual;
   function RenameEntry(AParent,AEntry:TDiskEntry;const AName:String):Boolean; virtual;
   function RenameEntryEx(AParent,AEntry:TDiskEntry;const AAltName:String):Boolean; virtual;
   function MoveEntry(ASource,ADest,AEntry:TDiskEntry):Boolean; virtual;

   function AddCatalog(AEntry:TDiskEntry;AMediaType:TMediaType;AFloppyType:TFloppyType;AAttributes:LongWord;ASectorSize:Word;const ASectorCount:Int64):TDiskCatalog; virtual;
   function RemoveCatalog(ACatalog:TDiskCatalog):Boolean; virtual;
   function CheckCatalog(ACatalog:TDiskCatalog;ALock:Boolean;AState:LongWord):Boolean; virtual;
   
   function GetCatalogByNo(ACatalogNo:LongWord;ALock:Boolean;AState:LongWord):TDiskCatalog; virtual;
   function GetCatalogByName(const AName:String;ALock:Boolean;AState:LongWord):TDiskCatalog; virtual;
   function GetCatalogByNext(APrevious:TDiskCatalog;ALock,AUnlock:Boolean;AState:LongWord):TDiskCatalog; virtual;
   
   function GetNextCatalogNo:LongWord; virtual;
   function GetMaxCatalogNo:LongWord; virtual;

   function AddHardlink(AEntry,AParent:TDiskEntry;const AName:String;AReference:Boolean):TDiskEntry; virtual;
   function RemoveHardlink(AParent,AEntry:TDiskEntry):Boolean; virtual;

   function AddMountPoint(AEntry:TDiskEntry;const ATarget:String):Boolean; virtual;
   function RemoveMountPoint(AEntry:TDiskEntry):Boolean; virtual;

   function AddJunctionPoint(AEntry:TDiskEntry;const ATarget:String):Boolean; virtual;
   function RemoveJunctionPoint(AEntry:TDiskEntry):Boolean; virtual;

   function AddSymbolicLink(AParent:TDiskEntry;const AName,ATarget:String;AFolder,AReference:Boolean):TDiskEntry; virtual;
   function AddSymbolicLinkEx(AParent:TDiskEntry;const AName,AAltName,ATarget:String;AFolder,AReference:Boolean):TDiskEntry; virtual;
   function RemoveSymbolicLink(AParent,AEntry:TDiskEntry):Boolean; virtual;

   function SetTable(ATable:TDiskTable):Boolean; virtual;
   function SetBlock(ABlock:TDiskBlock):Boolean; virtual;
   function SetEntry(AParent,AEntry:TDiskEntry):Boolean; virtual;
   function SetCatalog(ACatalog:TDiskCatalog):Boolean; virtual;
   function SetReparse(AParent,AEntry:TDiskEntry;AReparse:TDiskReparse):Boolean; virtual;
   function SetSecurity(AParent,AEntry:TDiskEntry;ASecurity:TDiskSecurity):Boolean; virtual;

   function SizeEntry(AParent,AEntry:TDiskEntry;const ASize:Int64):Boolean; virtual;

   function GetTable(ATableNo:LongWord):TDiskTable; virtual;
   function GetTableEx(ATableNo:LongWord;AWrite:Boolean):TDiskTable; virtual;
   function GetBlock(ABlockNo:LongWord):TDiskBlock; virtual;
   function GetBlockEx(ABlockNo:LongWord;AWrite:Boolean):TDiskBlock; virtual;
   function GetEntry(AParent:TDiskEntry;const AName:String;AAttributes:LongWord):TDiskEntry; virtual;
   function GetEntryEx(AParent:TDiskEntry;const AName:String;AAttributes:LongWord;AAdd,ARemove,AWrite:Boolean):TDiskEntry; virtual;
   function GetCatalog(ACatalogNo:LongWord):TDiskCatalog; virtual;
   function GetCatalogEx(ACatalogNo:LongWord;AWrite:Boolean):TDiskCatalog; virtual;
   function GetReparse(AEntry:TDiskEntry):TDiskReparse; virtual;
   function GetSecurity(AEntry:TDiskEntry):TDiskSecurity; virtual;

   function MatchEntry(AParent,APrevious:TDiskEntry;const AName:String;AAttributes:LongWord;AAny:Boolean):TDiskEntry; virtual;
   function MatchEntryEx(AParent,APrevious:TDiskEntry;const AName:String;AAttributes:LongWord;AAny,AAdd,ARemove,AWrite:Boolean):TDiskEntry; virtual;

   function GetEntryPath(AEntry:TDiskEntry;AAltName:Boolean):String;
   function GetEntryName(AEntry:TDiskEntry;AAltName:Boolean):String;

   function SplitPath(const APath:String;var ARelative:Boolean;AFolders:TStrings;var AName:String):Boolean; virtual;
   function SplitName(const AName:String;var AFile,AStream:String):Boolean; virtual;
   function SplitFile(const AFile:String;var AName,AExt:String):Boolean; virtual;
   function SplitStream(const AStream:String;var AName,AType:String):Boolean; virtual;

   function BuildPath(ARelative:Boolean;AFolders:TLinkedStringList;const AName:String):String; virtual;
   function BuildName(const AFile,AStream:String):String; virtual;
   function BuildFile(const AName,AExt:String):String; virtual;
   function BuildStream(const AName,AType:String):String; virtual;

   function CheckName(const AName:String):Boolean; virtual;
   function CompareName(const AName,AMatch:String;AWildcard:Boolean):Boolean; virtual;

   function CheckAltName(const AAltName:String):Boolean; virtual;
   function CompareAltName(const AAltName,AMatch:String;AWildcard:Boolean):Boolean; virtual;

   function CheckLinkName(const AName:String):Boolean; virtual;

   function GetSecurityFromDescriptor(ADescriptor:Pointer):TDiskSecurity; virtual;
   function GetDescriptorFromSecurity(ASecurity:TDiskSecurity;ADescriptor:Pointer;var ASize:LongWord):Boolean; virtual;
  public
   {Public Variables}
   property Volume:TDiskVolume read FVolume write SetVolume;
   property Drive:TDiskDrive read FDrive write SetDrive;

   property PathChar:String read GetPathChar;
   property NameChar:String read GetNameChar;
   property FileChar:String read GetFileChar;
   property RootChar:String read GetRootChar;
   property RootName:String read GetRootName;
   property RootPath:String read GetRootPath;
   property MaxFile:Integer read FMaxFile;
   property MaxPath:Integer read FMaxPath;
   property MaxAltFile:Integer read FMaxAltFile;
   property MaxAltPath:Integer read FMaxAltPath;
   property Attributes:LongWord read FAttributes;
   property MaxAttributes:LongWord read FMaxAttributes;
   property MaskAttributes:LongWord read FMaskAttributes;
   property MountPointTag:LongWord read FMountPointTag;
   property SymbolicLinkTag:LongWord read FSymbolicLinkTag;
   property SystemName:String read GetSystemName;
   property VolumeName:String read GetVolumeName;
   property VolumeGUID:String read GetVolumeGUID;
   property VolumeSerial:LongWord read FVolumeSerial;
   property FileSysType:TFileSysType read FFileSysType;

   property SectorSize:Word read FSectorSize;
   property StartSector:Int64 read FStartSector;
   property SectorCount:LongWord read FSectorCount;

   property MarkDirty:Boolean read FMarkDirty write FMarkDirty;
   property MarkClean:Boolean read FMarkClean write FMarkClean;
   property MarkError:Boolean read FMarkError;
   property LogDirty:Boolean read FLogDirty;
   property MountDirty:Boolean read FMountDirty;

   {Public Methods}
   function ReaderLock:Boolean;
   function ReaderUnlock:Boolean;
   function ReaderConvert:Boolean;
   function WriterLock:Boolean;
   function WriterUnlock:Boolean;
   function WriterConvert:Boolean;
   
   function FileSystemInit:Boolean; virtual;

   function MountFileSystem:Boolean; virtual;
   function DismountFileSystem:Boolean; virtual;
   function InitializeFileSystem(ASectorsPerCluster:LongWord;AFileSysType:TFileSysType):Boolean; virtual;

    {Catalog Functions}
   function CreateCatalog(const AName:String;AMediaType:TMediaType;AFloppyType:TFloppyType;AAttributes:LongWord;ASectorSize:Word;const ASectorCount:Int64):LongWord; virtual;
   function DeleteCatalog(ACatalogNo:LongWord):Boolean; virtual;

   function FindFirstCatalog(var ASearchRec:TCatalogSearchRec):Integer; virtual;
   function FindNextCatalog(var ASearchRec:TCatalogSearchRec):Integer; virtual;
   procedure FindCatalogClose(var ASearchRec:TCatalogSearchRec); virtual;

    {System Functions}
   function GetDriveLabel:String; virtual;
   function SetDriveLabel(const ALabel:String):Boolean; virtual;
   function GetDriveSerial:LongWord; virtual;
   function SetDriveSerial(ASerial:LongWord):Boolean; virtual;

   function GetDriveFreeSpace:LongWord; virtual;
   function GetDriveFreeSpaceEx:Int64; virtual;
   function GetDriveTotalSpace:LongWord; virtual;
   function GetDriveTotalSpaceEx:Int64; virtual;

   function GetDriveInformation(var AClusterSize:LongWord;var ATotalClusterCount,AFreeClusterCount:Int64):Boolean; virtual;
   
    {File Functions}
   function FileOpen(const FileName:String;Mode:Integer):THandle; virtual;
   function FileCreate(const FileName:String;Mode:Integer = fmOpenReadWrite or fmShareExclusive):THandle; virtual;
   function DeleteFile(const FileName:String):Boolean; virtual;
   procedure FileClose(Handle:Integer); virtual;
   function RenameFile(const OldName,NewName:String):Boolean; virtual;
   function FileSeek(Handle:THandle;Offset,Origin:LongInt):LongInt; virtual;
   function FileSeekEx(Handle:THandle;const Offset:Int64;Origin:LongInt):Int64; virtual;
   function FileFlush(Handle:Integer):Boolean; virtual;
   function FileTruncate(Handle:Integer):Boolean; virtual;

   function FilePos(Handle:THandle):LongInt; virtual;
   function FilePosEx(Handle:THandle):Int64; virtual;

   function FileGetAttr(const FileName:String):Integer; virtual;
   function FileGetDate(Handle:Integer):Integer; virtual;
   function FileGetSize(Handle:THandle):LongInt; virtual;
   function FileGetSizeEx(Handle:THandle):Int64; virtual;
   function FileSetAttr(const FileName:String;Attr:Integer):Integer; virtual;
   function FileSetDate(Handle:Integer;Age:Integer):Integer; virtual;
   function FileSetSize(Handle:THandle;Size:LongInt):LongInt; virtual;
   function FileSetSizeEx(Handle:THandle;const Size:Int64):LongInt; virtual;

   function FileRead(Handle:THandle;var Buffer;Count:LongInt):LongInt; virtual;
   function FileWrite(Handle:THandle;const Buffer;Count:LongInt):LongInt; virtual;

    {Directory Functions}
   function CreateDir(const DirName:String):Boolean; virtual;
   function RemoveDir(const DirName:String):Boolean; virtual;
   function GetCurrentDir:String; virtual;
   function SetCurrentDir(const DirName:String):Boolean; virtual; 

    {Search Functions}
   //function FindOne(const Path:String;var SearchRec:TFileSearchRec):Integer; virtual; //To Do ?
   //function FindAll(const Path:String;var SearchRec:TFileSearchRec):Integer; virtual; //To Do ?

   function FindFirstEx(const Path:String;var SearchRec:TFileSearchRec):Integer; virtual;
   function FindNextEx(var SearchRec:TFileSearchRec):Integer; virtual;
   procedure FindCloseEx(var SearchRec:TFileSearchRec); virtual;

   function FindFirstStream(const FileName:String;var SearchRec:TStreamSearchRec):Integer; virtual;
   function FindNextStream(var SearchRec:TStreamSearchRec):Integer; virtual;
   procedure FindStreamClose(var SearchRec:TStreamSearchRec); virtual;

   function FindFirstFileName(const FileName:String;var SearchRec:TLinkSearchRec):Integer; virtual;
   function FindNextFileName(var SearchRec:TLinkSearchRec):Integer; virtual;
   procedure FindFileNameClose(var SearchRec:TLinkSearchRec); virtual;

    {Additional Functions}
   function CreateHardLink(const LinkName,FileName:String):Boolean; virtual;
   function DeleteHardLink(const LinkName:String):Boolean; virtual;

   function CreateMountPoint(const PathName,VolumeName:String):Boolean; virtual;
   function DeleteMountPoint(const PathName:String):Boolean; virtual;

   function CreateJunctionPoint(const PathName,FolderName:String):Boolean; virtual;
   function DeleteJunctionPoint(const PathName:String):Boolean; virtual;

   function CreateSymbolicLink(const LinkName,TargetName:String;Directory:Boolean):Boolean; virtual;
   function CreateSymbolicLinkEx(const LinkName,ShortName,TargetName:String;Directory:Boolean):Boolean; virtual;
   function DeleteSymbolicLink(const LinkName:String):Boolean; virtual;

   function GetMountPointTarget(const PathName:String):String; virtual;
   function GetJunctionPointTarget(const PathName:String):String; virtual;
   function GetSymbolicLinkTarget(const LinkName:String):String; virtual;

   function SetFileShortName(const FileName,ShortName:String):Boolean; virtual;
   function SetFileShortNameEx(Handle:Integer;const ShortName:String):Boolean; virtual;
   
   function GetFileSecurity(const FileName:String;Descriptor:Pointer;var Size:LongWord):Boolean; virtual;
   function SetFileSecurity(const FileName:String;Descriptor:Pointer):Boolean; virtual;

   function GetPathName(const FileName:String):String; virtual;

   function GetShortName(const FileName:String):String; virtual;
   function GetLongName(const FileName:String):String; virtual;
   function GetTrueName(const FileName:String):String; virtual;

    {Extended Functions}
   function FileCreateEx(const FileName,ShortName:String;Mode:Integer = fmOpenReadWrite or fmShareExclusive):THandle; virtual;
   function CreateDirEx(const DirName,ShortName:String):Boolean; virtual;

   function FileGetAttrEx(Handle:Integer):Integer; virtual;
   
   function FileGetDateEx(Handle:Integer):TFileTime; virtual;
   function FileSetDateEx(Handle:Integer;Age:TFileTime):Integer; virtual;
   function GetFileTime(Handle:Integer;CreateTime,AccessTime,ModifyTime:PFileTime):Boolean; virtual;
   function SetFileTime(Handle:Integer;CreateTime,AccessTime,ModifyTime:PFileTime):Boolean; virtual;

    {Win32 Compatibility Functions} {Only File/Directory/Stream/Security}
    {File Functions}
   function CloseFile(Handle:THandle):Boolean; virtual; {Equivalent to Win32 CloseHandle}
    //To Do //Get/SetNamedSecurityInfo etc
 end;
 
 //To Do //for Multi segment volumes such as NWFS/NSS
 TDiskChunk = class(TListObject) {A disk chunk for multi segment Volumes such as NWFS/NSS}
   constructor Create(ALocalLock:TMutexHandle);
   destructor Destroy; override;
  private
   {Internal Variables}
   
   //FPartition:TDiskPartition;  //To Do
   //FStartSector:Int64;
   //FSectorCount:Int64;
   
   {Private Methods}
   
  protected
   {Protected Variables}
   FLocalLock:TMutexHandle;

   {Protected Methods}
   function AcquireLock:Boolean;
   function ReleaseLock:Boolean;
  public
   {Public Variables}
 end;
 
 //To Do //for Multi session devices such as CDROM/DVD //Should these be part of TFileSystem or TDiskController ?
 //TDiskSession = class(TListObject)
 
 TDiskTable = class(TListObject) {A disk table such as a FAT or MFT table}
   constructor Create(ALocalLock:TMutexHandle);
   destructor Destroy; override;
  private
   {Internal Variables}
   FTableNo:LongWord;
   
   {Private Methods}
   
  protected
   {Protected Variables}
   FLocalLock:TMutexHandle;

   {Protected Methods}
   function AcquireLock:Boolean;
   function ReleaseLock:Boolean;
  public
   {Public Variables}
   property TableNo:LongWord read FTableNo write FTableNo;
 end;
 
 TDiskBlock = class(TListObject) {A disk block such as a FAT entry}
   constructor Create(ALocalLock:TMutexHandle);
   destructor Destroy; override;
  private
   {Internal Variables}
   FBlockNo:LongWord;
   
   {Private Methods}
   
  protected
   {Protected Variables}
   FLocalLock:TMutexHandle;

   {Protected Methods}
   function AcquireLock:Boolean;
   function ReleaseLock:Boolean;
  public
   {Public Variables}
   property BlockNo:LongWord read FBlockNo write FBlockNo;
 end;
 
 TDiskEntry = class(TTreeObject) {A disk entry such as a File, Folder, Stream or Label}
   constructor Create(ALocalLock:TMutexHandle);
   destructor Destroy; override;
  private
   {Internal Variables}
   FName:String;
   FHash:LongWord; 
   FAltName:String;
   FAltHash:LongWord; 

   FSize:Int64;
   FAttributes:LongWord;
   FWriteTime:TFileTime;
   FCreateTime:TFileTime;
   FAccessTime:TFileTime;

   FReparseTag:LongWord;

   FEntriesLoaded:Boolean;

   FReferenceCount:LongWord;
   
   FRecent:TDiskEntry; 

   {Private Methods}
   function GetName:String;
   procedure SetName(const AName:String);
   function GetAltName:String;
   procedure SetAltName(const AAltName:String);
  protected
   {Protected Variables}
   FLocalLock:TMutexHandle;

   {Protected Methods}
   function AcquireLock:Boolean;
   function ReleaseLock:Boolean;
  public
   {Public Variables}
   property Name:String read GetName write SetName;
   property Hash:LongWord read FHash; 
   property AltName:String read GetAltName write SetAltName;
   property AltHash:LongWord read FAltHash; 

   property Size:Int64 read FSize write FSize;
   property Attributes:LongWord read FAttributes write FAttributes;
   property WriteTime:TFileTime read FWriteTime write FWriteTime;
   property CreateTime:TFileTime read FCreateTime write FCreateTime;
   property AccessTime:TFileTime read FAccessTime write FAccessTime;

   property ReparseTag:LongWord read FReparseTag write FReparseTag;

   property EntriesLoaded:Boolean read FEntriesLoaded write FEntriesLoaded;

   property ReferenceCount:LongWord read FReferenceCount;
   
   property Recent:TDiskEntry read FRecent write FRecent;
   
   {Public Methods}
   function AddReference:Boolean; virtual;
   function RemoveReference:Boolean; virtual;
   
   function FindFirstName(AHandle:TFindHandle;AReference:Boolean):TDiskEntry; virtual;
   function FindPrevName(AHandle:TFindHandle;AReference:Boolean):TDiskEntry; virtual;
   function FindNextName(AHandle:TFindHandle;AReference:Boolean):TDiskEntry; virtual;
   function FindLastName(AHandle:TFindHandle;AReference:Boolean):TDiskEntry; virtual;
 end;
 
 TDiskCatalog = class(TListObject) {A disk catalog such as a bootable section}
   constructor Create(ALocalLock:TMutexHandle);
   destructor Destroy; override;
  private
   {Internal Variables}

   {Private Methods}
   
  protected
   {Protected Variables}
   FLock:TSynchronizerHandle;
   FLocalLock:TMutexHandle;
   
   FName:String;
   FHash:LongWord; 
   FPath:String;
   FCatalogNo:LongWord;

   FMediaType:TMediaType;
   FFloppyType:TFloppyType;
   FAttributes:LongWord;    {Initial/Default, Bootable, No Emulation, 1.2M, 1.44M, 2.88M, Hard Disk}
   FSectorSize:Word;
   FSectorCount:Int64;

   {Protected Methods}
   function AcquireLock:Boolean;
   function ReleaseLock:Boolean;
   
   function GetName:String; virtual;
   procedure SetName(const AName:String); virtual;
   function GetPath:String; virtual;
   procedure SetPath(const APath:String); virtual;
   function GetMediaType:TMediaType; virtual;
   procedure SetMediaType(AMediaType:TMediaType); virtual;
   function GetFloppyType:TFloppyType; virtual;
   procedure SetFloppyType(AFloppyType:TFloppyType); virtual;
   function GetAttributes:LongWord; virtual;
   procedure SetAttributes(AAttributes:LongWord); virtual;
   function GetSectorSize:Word; virtual;
   procedure SetSectorSize(ASectorSize:Word); virtual;
   function GetSectorCount:Int64; virtual;
   procedure SetSectorCount(const ASectorCount:Int64); virtual;
  public
   {Public Variables}
   property Name:String read GetName write SetName;
   property Hash:LongWord read FHash; 
   property Path:String read GetPath write SetPath;
   property CatalogNo:LongWord read FCatalogNo write FCatalogNo;

   property MediaType:TMediaType read GetMediaType write SetMediaType;
   property FloppyType:TFloppyType read GetFloppyType write SetFloppyType;
   property Attributes:LongWord read GetAttributes write SetAttributes;
   property SectorSize:Word read GetSectorSize write SetSectorSize;
   property SectorCount:Int64 read GetSectorCount write SetSectorCount;
   
   {Public Methods}
   function ReaderLock:Boolean;
   function ReaderUnlock:Boolean;
   function WriterLock:Boolean;
   function WriterUnlock:Boolean;
 end;
 
 TDiskReparse = class(TObject)
   constructor Create(ALocalLock:TMutexHandle);
   destructor Destroy; override;
  private
   {Internal Variables}

   {Private Methods}
   
  protected
   {Protected Variables}
   FLocalLock:TMutexHandle;

   {Protected Methods}
   function AcquireLock:Boolean;
   function ReleaseLock:Boolean;
   
   function GetTarget:String; virtual;
   procedure SetTarget(const ATarget:String); virtual;
  public
   {Public Variables}
   property Target:String read GetTarget write SetTarget;

   {Public Methods}
 end;
 
 TDiskSecurity = class(TObject)    {A disk security descriptor}
   constructor Create(ALocalLock:TMutexHandle);
   constructor CreateFromSecurity(ALocalLock:TMutexHandle;ASecurity:TDiskSecurity); virtual;
   constructor CreateFromDescriptor(ALocalLock:TMutexHandle;ADescriptor:Pointer); virtual;
   destructor Destroy; override;
  private
   {Internal Variables}
   //FAcls:TFileSysList; //To Do
   //FAclLock:TMutexHandle;
   
   {Private Methods}
   
  protected
   {Protected Variables}
   FLocalLock:TMutexHandle;

   {Protected Methods}
   function AcquireLock:Boolean;
   function ReleaseLock:Boolean;
  public
   {Public Variables}

   {Public Methods}
   function SecuritySize:LongWord; virtual;

   function SecurityDescriptor:Pointer; virtual;
   function SecurityDescriptorEx(ALocal:Boolean):Pointer; virtual;
   function InheritedDescriptor:Pointer; virtual;
   function MergedDescriptor(AChild:Pointer):Pointer; virtual;
   function ReleaseDescriptor(ADescriptor:Pointer;AInherited,AMerged:Boolean):Boolean; virtual;

   function CopyToSecurity(ASecurity:TDiskSecurity):Boolean; virtual;
   function CopyFromSecurity(ASecurity:TDiskSecurity):Boolean; virtual;

   function CopyToDescriptor(ADescriptor:Pointer;ASize:LongWord):Boolean; virtual;
   function CopyToDescriptorEx(ADescriptor:Pointer;ASize:LongWord;ALocal:Boolean):Boolean; virtual;
   function CopyFromDescriptor(ADescriptor:Pointer;ASize:LongWord):Boolean; virtual;
 end;
 
 //To Do //for Get/SetFileSecurity Get/SetNamedSecurityInfo
 TDiskAcl = class(TListObject)     {A security descriptor access control list}
   constructor Create(ALocalLock:TMutexHandle);
   destructor Destroy; override;
  private
   {Internal Variables}
   //FAces:TFileSysList; //To Do
   //FAceLock:TMutexHandle;
   
  protected
   {Protected Variables}
   FLocalLock:TMutexHandle;

   {Protected Methods}
   function AcquireLock:Boolean;
   function ReleaseLock:Boolean;
  public
   {Public Variables}
 end;
 
 //To Do //for Get/SetFileSecurity Get/SetNamedSecurityInfo
 TDiskAce = class(TListObject)    {A security descriptor access control entry}
   constructor Create(ALocalLock:TMutexHandle);
   destructor Destroy; override;
  private
   {Internal Variables}
   
  protected
   {Protected Variables}
   FLocalLock:TMutexHandle;

   {Protected Methods}
   function AcquireLock:Boolean;
   function ReleaseLock:Boolean;
  public
   {Public Variables}
 end;
 
 TCacheTimer = class;
 TCacheThread = class;
 TCache = class(TObject)          {A simple block cache with Read Only / Read Write modes and Free/Clean/Dirty page tracking} {No longer used}
   constructor Create(ADriver:TFileSysDriver);
   destructor Destroy; override;
  private
   {Parent Objects}
   FDriver:TFileSysDriver;

   {Internal Variables}
   FLock:TCriticalSectionHandle; //To Do //Reader/Writer with LocalLock ?

   FBuffer:Pointer;
   FPageSize:LongWord;
   FPageCount:LongWord;
   FCacheSize:LongWord;
   FCacheMode:TCacheMode;
   FCacheState:TCacheState;
   FCacheTimeout:LongWord;

   FReadCached:Int64;
   FReadDirect:Int64;
   
   FWriteBack:Int64;
   FWriteThrough:Int64;
   FWriteDirect:Int64;

   FHitCount:Int64;
   FMissCount:Int64;

   FFailCount:Int64;
   FSuccessCount:Int64;

   FFlushCount:Int64;
   FDiscardCount:Int64;
   FUnknownCount:Int64;

   FFirstPage:TCachePage;     {First Cache Page (Any State)}
   FLastPage:TCachePage;      {Last Cache Page (Any State)}
   FFirstEmpty:TCachePage;    {First Free Page}
   FLastEmpty:TCachePage;     {Last Free Page}
   FFirstClean:TCachePage;    {First Clean Page (Used with no Write pending)}
   FLastClean:TCachePage;     {Last Clean Page (Used with no Write pending)}
   FFirstDirty:TCachePage;    {First Dirty Page (Used with Write pending)}
   FLastDirty:TCachePage;     {Last Dirty Page (Used with Write pending)}

   FTimer:TCacheTimer;
   FThread:TCacheThread;
   
   {Private Methods}
   function AcquireLock:Boolean;
   function ReleaseLock:Boolean;
   
   function AddPage(APage:TCachePage):Boolean;
   function RemovePage(APage:TCachePage):Boolean;
   function AddEmpty(APage:TCachePage):Boolean;
   function AddClean(APage:TCachePage):Boolean;
   function AddDirty(APage:TCachePage):Boolean;
   function AddUnknown(APage:TCachePage):Boolean;

   function UpdateClean(APage:TCachePage):Boolean;
   function UpdateDirty(APage:TCachePage):Boolean;

   function RoundPageSize(APageSize:LongWord):LongWord;
   function RoundCacheSize(ACacheSize,APageSize:LongWord):LongWord;

   function LinkPage(APage:TCachePage):Boolean;
   function UnlinkPage(APage:TCachePage):Boolean;
   function LinkEmpty(APage:TCachePage):Boolean;
   function UnlinkEmpty(APage:TCachePage):Boolean;
   function LinkClean(APage:TCachePage):Boolean;
   function UnlinkClean(APage:TCachePage):Boolean;
   function LinkDirty(APage:TCachePage):Boolean;
   function UnlinkDirty(APage:TCachePage):Boolean;
   
   function PrepareDeviceWrite(ADevice:TDiskDevice;APage:TCachePage;ASector,ACount:LongWord):Boolean;
   
   function CalculateDevicePage(ADevice:TDiskDevice;ASector:LongWord;var ACount:LongWord):Boolean;
  public
   {Public Properties}
   property PageSize:LongWord read FPageSize;
   property PageCount:LongWord read FPageCount;
   property CacheSize:LongWord read FCacheSize;
   property CacheMode:TCacheMode read FCacheMode;
   property CacheState:TCacheState read FCacheState;
   property CacheTimeout:LongWord read FCacheTimeout;

   property ReadCached:Int64 read FReadCached;
   property ReadDirect:Int64 read FReadDirect;
   
   property WriteBack:Int64 read FWriteBack;
   property WriteThrough:Int64 read FWriteThrough;
   property WriteDirect:Int64 read FWriteDirect;

   property HitCount:Int64 read FHitCount;
   property MissCount:Int64 read FMissCount;

   property FailCount:Int64 read FFailCount;
   property SuccessCount:Int64 read FSuccessCount;

   property FlushCount:Int64 read FFlushCount;
   property DiscardCount:Int64 read FDiscardCount;
   property UnknownCount:Int64 read FUnknownCount;

   {Public Methods}
   function OpenCache(ACacheSize,APageSize:LongWord;ACacheMode:TCacheMode):Boolean;
   function CloseCache:Boolean;

   function DeviceRead(ADevice:TDiskDevice;ASector,ACount:LongWord;var ABuffer):Boolean;
   function DeviceWrite(ADevice:TDiskDevice;ASector,ACount:LongWord;const ABuffer):Boolean;
   function DeviceErase(ADevice:TDiskDevice;ASector,ACount:LongWord):Boolean;
   
   function GetDevicePage(ADevice:TDiskDevice;ASector:LongWord):TCachePage; virtual;
   function GetEmptyPage:TCachePage;

   function AllocDevicePage(ADevice:TDiskDevice;ASector:LongWord;AWrite:Boolean):TCachePage; virtual;

   function DiscardPage(APage:TCachePage):Boolean;
   function DiscardCache(AFirst,AAll:Boolean):Boolean;

   function ReleaseDevicePages(ADevice:TDiskDevice):Boolean;

   function FlushPage(APage:TCachePage):Boolean;
   function FlushPageEx(APage:TCachePage):Boolean;
   function FlushCache(AFirst,AAll:Boolean):Boolean;

   {Timer/Thread Methods}   
   function CheckTimer:Boolean;
   function ProcessTimer:Boolean;
   
   function SchedulePage(APage:TCachePage;ATimeout:LongWord):Boolean;
   function UnschedulePage(APage:TCachePage):Boolean; 
 end;

 TCacheEx = class(TCache)         {A modified version of TCache which tracks the last used page for faster repeat access} {No longer used}
   constructor Create(ADriver:TFileSysDriver);
   destructor Destroy; override;
  private
   {Internal Variables}
   FLastUsed:TCachePage;      {Most recently used Page}
  public
   {}
   function GetDevicePage(ADevice:TDiskDevice;ASector:LongWord):TCachePage; override;

   function AllocDevicePage(ADevice:TDiskDevice;ASector:LongWord;AWrite:Boolean):TCachePage; override;
 end;

 THashCacheTimer = class;
 THashCacheThread = class;
 THashCache = class(TObject)      {A block cache with hash keys for faster page lookup} 
   constructor Create(ADriver:TFileSysDriver);
   destructor Destroy; override;
  private
   {Parent Objects}
   FDriver:TFileSysDriver;

   {Internal Variables}
   FLock:TCriticalSectionHandle; //To Do //Reader/Writer with LocalLock ?

   FKeyBits:Byte;
   FKeyMask:LongWord;
   FKeyBuckets:Pointer;

   FBuffer:Pointer;
   FPageSize:LongWord;
   FPageCount:LongWord;
   FCacheSize:LongWord;
   FCacheKeys:LongWord;
   FCacheMode:TCacheMode;
   FCacheState:TCacheState;
   FFlushTimeout:LongWord;
   FDiscardTimeout:LongWord;

   FReadCached:Int64;
   FReadDirect:Int64;
   
   FWriteBack:Int64;
   FWriteThrough:Int64;
   FWriteDirect:Int64;

   FHitCount:Int64;
   FMissCount:Int64;

   FFailCount:Int64;
   FSuccessCount:Int64;

   FFlushCount:Int64;
   FDiscardCount:Int64;
   FUnknownCount:Int64;

   FFirstPage:TCachePage;     {First Cache Page (Any State)}
   FLastPage:TCachePage;      {Last Cache Page (Any State)}
   FFirstEmpty:TCachePage;    {First Free Page}
   FLastEmpty:TCachePage;     {Last Free Page}
   FFirstClean:TCachePage;    {First Clean Page (Used with no Write pending)}
   FLastClean:TCachePage;     {Last Clean Page (Used with no Write pending)}
   FFirstDirty:TCachePage;    {First Dirty Page (Used with Write pending)}
   FLastDirty:TCachePage;     {Last Dirty Page (Used with Write pending)}

   FTimer:THashCacheTimer;
   FThread:THashCacheThread;
   
   {Private Methods}
   function AcquireLock:Boolean;
   function ReleaseLock:Boolean;

   function AddPage(APage:TCachePage):Boolean;
   function RemovePage(APage:TCachePage):Boolean;
   function AddEmpty(APage:TCachePage):Boolean;
   function AddClean(APage:TCachePage):Boolean;
   function AddDirty(APage:TCachePage):Boolean;
   function AddUnknown(APage:TCachePage):Boolean;

   function UpdateClean(APage:TCachePage):Boolean;
   function UpdateDirty(APage:TCachePage):Boolean;

   function RoundPageSize(APageSize:LongWord):LongWord;
   function RoundCacheSize(ACacheSize,APageSize:LongWord):LongWord;
   function AdjustCacheKeys(ACacheKeys:LongWord):LongWord;

   function CalculatePageCount(ADevice:TDiskDevice):Word;
   function CalculatePageShift(ADevice:TDiskDevice):Word;
   function CalculatePageMask(ADevice:TDiskDevice):LongWord;

   function KeyLink(APage:THashCachePage):Boolean;
   function KeyUnlink(APage:THashCachePage):Boolean;
   function KeyFirst(AKeyHash:LongWord):THashCachePage;

   function LinkPage(APage:TCachePage):Boolean;
   function UnlinkPage(APage:TCachePage):Boolean;
   function LinkEmpty(APage:TCachePage):Boolean;
   function UnlinkEmpty(APage:TCachePage):Boolean;
   function LinkClean(APage:TCachePage):Boolean;
   function UnlinkClean(APage:TCachePage):Boolean;
   function LinkDirty(APage:TCachePage):Boolean;
   function UnlinkDirty(APage:TCachePage):Boolean;
   
   function PrepareDeviceWrite(ADevice:TDiskDevice;APage:TCachePage;ASector,ACount:LongWord):Boolean;
   
   function CalculateDevicePage(ADevice:TDiskDevice;ASector:LongWord;var ACount:LongWord):Boolean;
  public
   {Public Properties}
   property PageSize:LongWord read FPageSize;
   property PageCount:LongWord read FPageCount;
   property CacheSize:LongWord read FCacheSize;
   property CacheKeys:LongWord read FCacheKeys;
   property CacheMode:TCacheMode read FCacheMode;
   property CacheState:TCacheState read FCacheState;
   property FlushTimeout:LongWord read FFlushTimeout;
   property DiscardTimeout:LongWord read FDiscardTimeout;

   property ReadCached:Int64 read FReadCached;
   property ReadDirect:Int64 read FReadDirect;
   
   property WriteBack:Int64 read FWriteBack;
   property WriteThrough:Int64 read FWriteThrough;
   property WriteDirect:Int64 read FWriteDirect;

   property HitCount:Int64 read FHitCount;
   property MissCount:Int64 read FMissCount;

   property FailCount:Int64 read FFailCount;
   property SuccessCount:Int64 read FSuccessCount;

   property FlushCount:Int64 read FFlushCount;
   property DiscardCount:Int64 read FDiscardCount;
   property UnknownCount:Int64 read FUnknownCount;

   {Public Methods}
   function OpenCache(ACacheSize,ACacheKeys,APageSize:LongWord;ACacheMode:TCacheMode):Boolean;
   function CloseCache:Boolean;

   function DeviceRead(ADevice:TDiskDevice;ASector,ACount:LongWord;var ABuffer):Boolean;
   function DeviceWrite(ADevice:TDiskDevice;ASector,ACount:LongWord;const ABuffer):Boolean;
   function DeviceErase(ADevice:TDiskDevice;ASector,ACount:LongWord):Boolean;

   function GetDevicePage(ADevice:TDiskDevice;ASector:LongWord):TCachePage; virtual;
   function GetEmptyPage:TCachePage;

   function AllocDevicePage(ADevice:TDiskDevice;ASector:LongWord;AWrite:Boolean):TCachePage; virtual;

   function DiscardPage(APage:TCachePage):Boolean;
   function DiscardCache(AFirst,AAll:Boolean):Boolean;

   function ReleaseDevicePages(ADevice:TDiskDevice):Boolean;

   function FlushPage(APage:TCachePage):Boolean;
   function FlushPageEx(APage:TCachePage):Boolean;
   function FlushCache(AFirst,AAll:Boolean):Boolean;
   
   {Timer/Thread Methods}   
   function CheckTimer:Boolean;
   function ProcessTimer:Boolean;
   
   function SchedulePage(APage:TCachePage;ATimeout:LongWord):Boolean;
   function UnschedulePage(APage:TCachePage):Boolean; 
 end;

 TIncrementalCacheTimer = class;
 TIncrementalCacheThread = class;
 TIncrementalCache = class(TObject)    {An expanded THashCache with incremental read ahead and dirty region write back} {Not yet completed}
   constructor Create(ADriver:TFileSysDriver);
   destructor Destroy; override;
  private
   {Parent Objects}
   FDriver:TFileSysDriver;

   {Internal Variables}
   FLock:TCriticalSectionHandle; //To Do //Reader/Writer with LocalLock ?

   FKeyBits:Byte;
   FKeyMask:LongWord;
   FKeyBuckets:Pointer;

   FBuffer:Pointer;
   FPageSize:LongWord;
   FPageCount:LongWord;
   FCacheSize:LongWord;
   FCacheKeys:LongWord;
   FCacheMode:TCacheMode;
   FCacheState:TCacheState;
   FFlushTimeout:LongWord;
   FDiscardTimeout:LongWord;

   FReadCached:Int64;
   FReadDirect:Int64;
   
   FWriteBack:Int64;
   FWriteThrough:Int64;
   FWriteDirect:Int64;

   FHitCount:Int64;
   FMissCount:Int64;

   FFailCount:Int64;
   FSuccessCount:Int64;

   FFlushCount:Int64;
   FDiscardCount:Int64;
   FUnknownCount:Int64;

   FFirstPage:TCachePage;     {First Cache Page (Any State)}
   FLastPage:TCachePage;      {Last Cache Page (Any State)}
   FFirstEmpty:TCachePage;    {First Free Page}
   FLastEmpty:TCachePage;     {Last Free Page}
   FFirstClean:TCachePage;    {First Clean Page (Used with no Write pending)}
   FLastClean:TCachePage;     {Last Clean Page (Used with no Write pending)}
   FFirstDirty:TCachePage;    {First Dirty Page (Used with Write pending)}
   FLastDirty:TCachePage;     {Last Dirty Page (Used with Write pending)}

   FTimer:TIncrementalCacheTimer;
   FThread:TIncrementalCacheThread;

   {Private Methods}
   function AcquireLock:Boolean;
   function ReleaseLock:Boolean;

   function AddPage(APage:TCachePage):Boolean;
   function RemovePage(APage:TCachePage):Boolean;
   function AddEmpty(APage:TCachePage):Boolean;
   function AddClean(APage:TCachePage):Boolean;
   function AddDirty(APage:TCachePage):Boolean;
   function AddUnknown(APage:TCachePage):Boolean;

   function UpdateClean(APage:TCachePage):Boolean;
   function UpdateDirty(APage:TCachePage):Boolean;

   function RoundPageSize(APageSize:LongWord):LongWord;
   function RoundCacheSize(ACacheSize,APageSize:LongWord):LongWord;
   function AdjustCacheKeys(ACacheKeys:LongWord):LongWord;

   function CalculatePageCount(ADevice:TDiskDevice):Word;
   function CalculatePageShift(ADevice:TDiskDevice):Word;
   function CalculatePageMask(ADevice:TDiskDevice):LongWord;

   function KeyLink(APage:THashCachePage):Boolean;
   function KeyUnlink(APage:THashCachePage):Boolean;
   function KeyFirst(AKeyHash:LongWord):THashCachePage;

   function LinkPage(APage:TCachePage):Boolean;
   function UnlinkPage(APage:TCachePage):Boolean;
   function LinkEmpty(APage:TCachePage):Boolean;
   function UnlinkEmpty(APage:TCachePage):Boolean;
   function LinkClean(APage:TCachePage):Boolean;
   function UnlinkClean(APage:TCachePage):Boolean;
   function LinkDirty(APage:TCachePage):Boolean;
   function UnlinkDirty(APage:TCachePage):Boolean;

   function PrepareDeviceRead(ADevice:TDiskDevice;APage:TCachePage;ASector,ACount:LongWord):Boolean;
   function PrepareDeviceWrite(ADevice:TDiskDevice;APage:TCachePage;ASector,ACount:LongWord):Boolean;
   
   function CalculateDevicePage(ADevice:TDiskDevice;ASector:LongWord;var ACount:LongWord):Boolean;
  public
   {Public Properties}
   property PageSize:LongWord read FPageSize;
   property PageCount:LongWord read FPageCount;
   property CacheSize:LongWord read FCacheSize;
   property CacheKeys:LongWord read FCacheKeys;
   property CacheMode:TCacheMode read FCacheMode;
   property CacheState:TCacheState read FCacheState;
   property FlushTimeout:LongWord read FFlushTimeout;
   property DiscardTimeout:LongWord read FDiscardTimeout;

   property ReadCached:Int64 read FReadCached;
   property ReadDirect:Int64 read FReadDirect;
   
   property WriteBack:Int64 read FWriteBack;
   property WriteThrough:Int64 read FWriteThrough;
   property WriteDirect:Int64 read FWriteDirect;

   property HitCount:Int64 read FHitCount;
   property MissCount:Int64 read FMissCount;

   property FailCount:Int64 read FFailCount;
   property SuccessCount:Int64 read FSuccessCount;

   property FlushCount:Int64 read FFlushCount;
   property DiscardCount:Int64 read FDiscardCount;
   property UnknownCount:Int64 read FUnknownCount;

   {Public Methods}
   function OpenCache(ACacheSize,ACacheKeys,APageSize:LongWord;ACacheMode:TCacheMode):Boolean;
   function CloseCache:Boolean;

   function DeviceRead(ADevice:TDiskDevice;ASector,ACount:LongWord;var ABuffer):Boolean;
   function DeviceWrite(ADevice:TDiskDevice;ASector,ACount:LongWord;const ABuffer):Boolean;
   function DeviceErase(ADevice:TDiskDevice;ASector,ACount:LongWord):Boolean;

   function GetDevicePage(ADevice:TDiskDevice;ASector:LongWord):TCachePage; virtual;
   function GetEmptyPage:TCachePage;

   function AllocDevicePage(ADevice:TDiskDevice;ASector:LongWord;AWrite:Boolean):TCachePage; virtual;

   function DiscardPage(APage:TCachePage):Boolean;
   function DiscardCache(AFirst,AAll:Boolean):Boolean;

   function ReleaseDevicePages(ADevice:TDiskDevice):Boolean;

   function FlushPage(APage:TCachePage):Boolean;
   function FlushPageEx(APage:TCachePage):Boolean;
   function FlushCache(AFirst,AAll:Boolean):Boolean;
   
   {Timer/Thread Methods}   
   function CheckTimer:Boolean;
   function ProcessTimer:Boolean;
   
   function SchedulePage(APage:TCachePage;ATimeout:LongWord):Boolean;
   function UnschedulePage(APage:TCachePage):Boolean; 
 end;
 
 TCachePage = class(TObject)
   constructor Create;
   destructor Destroy; override;
  private
   {Internal Variables}
   FDevice:TDiskDevice;

   FData:Pointer;

   FSector:LongWord; //Int64;    //To Do //when changed on Drive/Volume/Device etc
   FCount:Word;      //LongWord; //To Do //when changed on FileSystem/Drive/Volume/Device etc

   FPageTime:Int64;          {Time Page was Allocated from Empty (Ticks)}
   FWriteTime:Int64;         {Time Page was Allocated to Dirty (Ticks)}
   FPageType:TCachePageType;
   FPageState:TCachePageState;

   FPrevPage:TCachePage;     {Previous page in Page list}
   FNextPage:TCachePage;     {Next page in Page list}
   
   FPrevLink:TCachePage;     {Previous page in Empty/Clean/Dirty list}
   FNextLink:TCachePage;     {Next page in Empty/Clean/Dirty list}
  public
   {Public Properties}
   property Device:TDiskDevice read FDevice write FDevice;

   property Data:Pointer read FData write FData;

   property Sector:LongWord read FSector write FSector;
   property Count:Word read FCount write FCount;

   property PageTime:Int64 read FPageTime write FPageTime;
   property WriteTime:Int64 read FWriteTime write FWriteTime;
   property PageType:TCachePageType read FPageType write FPageType;
   property PageState:TCachePageState read FPageState write FPageState;

   property PrevPage:TCachePage read FPrevPage write FPrevPage;
   property NextPage:TCachePage read FNextPage write FNextPage;
   
   property PrevLink:TCachePage read FPrevLink write FPrevLink;
   property NextLink:TCachePage read FNextLink write FNextLink;
 end;

 THashCachePage = class(TCachePage)
  private
   {Internal Variables}
   FKeyHash:LongWord;
   FKeyPrev:THashCachePage;
   FKeyNext:THashCachePage;
  public
   {Public Properties}
   property KeyHash:LongWord read FKeyHash write FKeyHash;
   property KeyPrev:THashCachePage read FKeyPrev write FKeyPrev;
   property KeyNext:THashCachePage read FKeyNext write FKeyNext;
 end;

 TIncrementalCachePage = class(THashCachePage)
  private
   {Internal Variables}
   FReadSector:LongWord; //Int64;    //To Do //when changed on Drive/Volume/Device etc
   FReadCount:Word;      //LongWord; //To Do //when changed on FileSystem/Drive/Volume/Device etc

   FDirtySector:LongWord; //Int64;    //To Do //when changed on Drive/Volume/Device etc
   FDirtyCount:Word;      //LongWord; //To Do //when changed on FileSystem/Drive/Volume/Device etc
  public
   {Public Properties}
   property ReadSector:LongWord read FReadSector write FReadSector;
   property ReadCount:Word read FReadCount write FReadCount;

   property DirtySector:LongWord read FDirtySector write FDirtySector;
   property DirtyCount:Word read FDirtyCount write FDirtyCount;

   {Public Methods}
   function ReadData:Pointer;
   function DirtyData:Pointer;
 end;
 
 TCacheTimer = class(TObject)
   constructor Create(ACache:TCache);
   destructor Destroy; override;
  protected
   {Internal Variables}
   FCache:TCache;
   
   FLock:TMutexHandle;
   FInterval:LongWord;
   FCheckTimer:TTimerHandle;
   FProcessSemaphore:TSemaphoreHandle;
   
   FCount:LongWord;
   FMaxCount:LongWord;
   
   FFirst:PCacheTimerItem;
   FLast:PCacheTimerItem;
   
   {Internal Methods}
   function AcquireLock:Boolean;
   function ReleaseLock:Boolean;
   
   function Dequeue(AMax:Integer):TCachePage;
   
   function FirstKey:Integer;
   function InsertKey(APage:TCachePage;AKey:Integer):Boolean;
   function DeleteKey(APage:TCachePage):Boolean;
   function DecrementKey:Integer;
  public   
   {Public Properties}
   property Count:LongWord read FCount;
   property MaxCount:LongWord read FMaxCount;
   
   {Public Methods}
   function StartTimer(AInterval:LongWord):Boolean;
   function StopTimer:Boolean;
   
   function CheckTimer:Boolean;
   function ProcessTimer:Boolean;
   
   function SchedulePage(APage:TCachePage;ATimeout:LongWord):Boolean;
   function UnschedulePage(APage:TCachePage):Boolean; 
 end;

 THashCacheTimer = class(TObject)
   constructor Create(ACache:THashCache);
   destructor Destroy; override;
  protected
   {Internal Variables}
   FCache:THashCache;
   
   FLock:TMutexHandle;
   FInterval:LongWord;
   FCheckTimer:TTimerHandle;
   FProcessSemaphore:TSemaphoreHandle;
   
   FCount:LongWord;
   FMaxCount:LongWord;
   
   FFirst:PCacheTimerItem;
   FLast:PCacheTimerItem;
   
   {Internal Methods}
   function AcquireLock:Boolean;
   function ReleaseLock:Boolean;
   
   function Dequeue(AMax:Integer):TCachePage;
   
   function FirstKey:Integer;
   function InsertKey(APage:TCachePage;AKey:Integer):Boolean;
   function DeleteKey(APage:TCachePage):Boolean;
   function DecrementKey:Integer;
  public   
   {Public Properties}
   property Count:LongWord read FCount;
   property MaxCount:LongWord read FMaxCount;
   
   {Public Methods}
   function StartTimer(AInterval:LongWord):Boolean;
   function StopTimer:Boolean;
   
   function CheckTimer:Boolean;
   function ProcessTimer:Boolean;
   
   function SchedulePage(APage:TCachePage;ATimeout:LongWord):Boolean;
   function UnschedulePage(APage:TCachePage):Boolean; 
 end;

 TIncrementalCacheTimer = class(TObject)
   constructor Create(ACache:TIncrementalCache);
   destructor Destroy; override;
  protected
   {Internal Variables}
   FCache:TIncrementalCache;
   
   FLock:TMutexHandle;
   FInterval:LongWord;
   FCheckTimer:TTimerHandle;
   FProcessSemaphore:TSemaphoreHandle;
   
   FCount:LongWord;
   FMaxCount:LongWord;
   
   FFirst:PCacheTimerItem;
   FLast:PCacheTimerItem;
   
   {Internal Methods}
   function AcquireLock:Boolean;
   function ReleaseLock:Boolean;
   
   function Dequeue(AMax:Integer):TCachePage;
   
   function FirstKey:Integer;
   function InsertKey(APage:TCachePage;AKey:Integer):Boolean;
   function DeleteKey(APage:TCachePage):Boolean;
   function DecrementKey:Integer;
  public   
   {Public Properties}
   property Count:LongWord read FCount;
   property MaxCount:LongWord read FMaxCount;
   
   {Public Methods}
   function StartTimer(AInterval:LongWord):Boolean;
   function StopTimer:Boolean;
   
   function CheckTimer:Boolean;
   function ProcessTimer:Boolean;
   
   function SchedulePage(APage:TCachePage;ATimeout:LongWord):Boolean;
   function UnschedulePage(APage:TCachePage):Boolean; 
 end;
 
 TCacheThread = class(TThread)
   constructor Create(ACache:TCache);
   destructor Destroy; override;
  protected
   {Internal Variables}
   FCache:TCache;
   
   {Internal Methods}
   procedure Execute; override;
  public
   {Public Methods}
   
 end;
 
 THashCacheThread = class(TThread)
   constructor Create(ACache:THashCache);
   destructor Destroy; override;
  protected
   {Internal Variables}
   FCache:THashCache;
   
   {Internal Methods}
   procedure Execute; override;
  public
   {Public Methods}
   
 end;

 TIncrementalCacheThread = class(TThread)
   constructor Create(ACache:TIncrementalCache);
   destructor Destroy; override;
  protected
   {Internal Variables}
   FCache:TIncrementalCache;
   
   {Internal Methods}
   procedure Execute; override;
  public
   {Public Methods}
   
 end;
 
 TEntryTimer = class(TObject)
   constructor Create(ADriver:TFileSysDriver);
   destructor Destroy; override;
  protected
   {Internal Variables}
   FDriver:TFileSysDriver;
   
   FLock:TMutexHandle;
   FInterval:LongWord;
   FCheckTimer:TTimerHandle;
   FProcessTimer:TTimerHandle;
   
   FCount:LongWord;
   FMaxCount:LongWord;
   
   FFirst:PEntryTimerItem;
   FLast:PEntryTimerItem;
   
   {Internal Methods}
   function AcquireLock:Boolean;
   function ReleaseLock:Boolean;
   
   function Dequeue:TDiskEntry;
   
   function FirstKey:Integer;
   function InsertKey(AEntry:TDiskEntry;AKey:Integer):Boolean;
   function DeleteKey(AEntry:TDiskEntry):Boolean;
   function DecrementKey:Integer;
  public   
   {Public Properties}
   property Count:LongWord read FCount;
   property MaxCount:LongWord read FMaxCount;
   
   {Public Methods}
   function StartTimer(AInterval:LongWord):Boolean;
   function StopTimer:Boolean;
   
   function CheckTimer:Boolean;
   function ProcessTimer:Boolean;
   
   function ScheduleEntry(AEntry:TDiskEntry;ATimeout:LongWord):Boolean;
   function UnscheduleEntry(AEntry:TDiskEntry):Boolean; 
 end;
 
 TDefaultRecognizer = class(TRecognizer)
   constructor Create(ADriver:TFileSysDriver);
  private
   {Internal Variables}

   {Private Methods}
  protected
   {Protected Variables}

   {Protected Methods}
   function GetName:String; override;
  public
   {Public Variables}

   {Public Methods}
   function RecognizePartitionId(APartitionId:Byte):Boolean; override;

   function RecognizePartition(APartition:TDiskPartition):Boolean; override;
 end;

 TDefaultPartitioner = class(TDiskPartitioner)
   constructor Create(ADriver:TFileSysDriver;ARecognizer:TRecognizer);
  private
   {Internal Variables}

   {Private Methods}
  public
   {Public Variables}

   {Public Methods}
   function AcceptPartition(ADevice:TDiskDevice;APartition,AParent:TDiskPartition;APartitionId:Byte):Boolean; override;
 end;

 TExtDiskController = class(TDiskController) 
  protected
   {Protected Methods}
   function GetCylinders(ADevice:TDiskDevice):LongWord;
   function GetHeads(ADevice:TDiskDevice):LongWord;
   function GetSectors(ADevice:TDiskDevice):LongWord;
   function GetLogicalShiftCount(ADevice:TDiskDevice):Word;
 end;
 
 TATADiskController = class(TDiskController) 
   constructor Create(ADriver:TFileSysDriver);
  private
   {Internal Variables}

   {Private Methods}
  public
   {Public Variables}

   {Public Methods}
   function ControllerInit:Boolean; override;

   function LocateDevices:Boolean; override;

   //To do
 end;
   
 TATAPIDiskController = class(TDiskController) 
   constructor Create(ADriver:TFileSysDriver);
  private
   {Internal Variables}

   {Private Methods}
  public
   {Public Variables}

   {Public Methods}
   function ControllerInit:Boolean; override;

   function LocateDevices:Boolean; override;

   //To do
 end;
 
 TSCSIDiskController = class(TDiskController) 
   constructor Create(ADriver:TFileSysDriver);
  private
   {Internal Variables}

   {Private Methods}
  public
   {Public Variables}

   {Public Methods}
   function ControllerInit:Boolean; override;

   function LocateDevices:Boolean; override;

   //To do
 end;
 
 TUSBDiskController = class(TExtDiskController)
   constructor Create(ADriver:TFileSysDriver);
  private
   {Internal Variables}

   {Private Methods}
  public
   {Public Variables}

   {Public Methods}
   function ControllerInit:Boolean; override;

   function LocateDevices:Boolean; override;

   function Read(ADevice:TDiskDevice;ASector:LongWord;ACount:Word;var ABuffer):Boolean; override;
   function Write(ADevice:TDiskDevice;ASector:LongWord;ACount:Word;const ABuffer):Boolean; override;

   function Reset(ADevice:TDiskDevice):Boolean; override;

   function LockMedia(ADevice:TDiskDevice):Boolean; override;
   function UnlockMedia(ADevice:TDiskDevice):Boolean; override;
   function EjectMedia(ADevice:TDiskDevice):Boolean; override;

   function MediaReady(ADevice:TDiskDevice):Boolean; override;
   function MediaChanged(ADevice:TDiskDevice):Boolean; override;
   function MediaLocked(ADevice:TDiskDevice):Boolean; override;

   {Device Methods}
   function Information(ADevice:TDiskDevice):String; override;

   function VendorId(ADevice:TDiskDevice):Word; override;
   function DeviceId(ADevice:TDiskDevice):Word; override;
   
   function Manufacturer(ADevice:TDiskDevice):String; override;
   function Product(ADevice:TDiskDevice):String; override;
   function SerialNumber(ADevice:TDiskDevice):String; override;
   
   function LogicalUnitNo(ADevice:TDiskDevice):LongWord; override;
   
   function LBA(ADevice:TDiskDevice):Boolean; override;

   function MediaType(ADevice:TDiskDevice):TMediaType; override;
   function FloppyType(ADevice:TDiskDevice):TFloppyType; override;
   function Ready(ADevice:TDiskDevice):Boolean; override;
   function Locked(ADevice:TDiskDevice):Boolean; override;
   function Lockable(ADevice:TDiskDevice):Boolean; override;
   function Ejectable(ADevice:TDiskDevice):Boolean; override;
   function Readable(ADevice:TDiskDevice):Boolean; override;
   function Writeable(ADevice:TDiskDevice):Boolean; override;
   function Removable(ADevice:TDiskDevice):Boolean; override;
   function ChangeLine(ADevice:TDiskDevice):Boolean; override;

   function PhysicalCylinders(ADevice:TDiskDevice):LongWord; override;
   function PhysicalHeads(ADevice:TDiskDevice):LongWord; override;
   function PhysicalSectors(ADevice:TDiskDevice):LongWord; override;

   function LogicalCylinders(ADevice:TDiskDevice):LongWord; override;
   function LogicalHeads(ADevice:TDiskDevice):LongWord; override;
   function LogicalSectors(ADevice:TDiskDevice):LongWord; override;

   function SectorSize(ADevice:TDiskDevice):Word; override;
   function SectorCount(ADevice:TDiskDevice):Int64; override;
 end;
 
 TMMCDiskController = class(TExtDiskController) 
   constructor Create(ADriver:TFileSysDriver);
  private
   {Internal Variables}

   {Private Methods}
  public
   {Public Variables}

   {Public Methods}
   function ControllerInit:Boolean; override;

   function LocateDevices:Boolean; override;

   function Read(ADevice:TDiskDevice;ASector:LongWord;ACount:Word;var ABuffer):Boolean; override;
   function Write(ADevice:TDiskDevice;ASector:LongWord;ACount:Word;const ABuffer):Boolean; override;
   function Erase(ADevice:TDiskDevice;ASector:LongWord;ACount:Word):Boolean; override;

   function Reset(ADevice:TDiskDevice):Boolean; override;

   function LockMedia(ADevice:TDiskDevice):Boolean; override;
   function UnlockMedia(ADevice:TDiskDevice):Boolean; override;
   function EjectMedia(ADevice:TDiskDevice):Boolean; override;

   function MediaReady(ADevice:TDiskDevice):Boolean; override;
   function MediaChanged(ADevice:TDiskDevice):Boolean; override;
   function MediaLocked(ADevice:TDiskDevice):Boolean; override;

   {Device Methods}
   function Information(ADevice:TDiskDevice):String; override;

   function VendorId(ADevice:TDiskDevice):Word; override;
   function DeviceId(ADevice:TDiskDevice):Word; override;
   
   function Manufacturer(ADevice:TDiskDevice):String; override;
   function Product(ADevice:TDiskDevice):String; override;
   function SerialNumber(ADevice:TDiskDevice):String; override;
   
   function LogicalUnitNo(ADevice:TDiskDevice):LongWord; override;
   
   function LBA(ADevice:TDiskDevice):Boolean; override;

   function MediaType(ADevice:TDiskDevice):TMediaType; override;
   function FloppyType(ADevice:TDiskDevice):TFloppyType; override;
   function Ready(ADevice:TDiskDevice):Boolean; override;
   function Locked(ADevice:TDiskDevice):Boolean; override;
   function Lockable(ADevice:TDiskDevice):Boolean; override;
   function Ejectable(ADevice:TDiskDevice):Boolean; override;
   function Readable(ADevice:TDiskDevice):Boolean; override;
   function Writeable(ADevice:TDiskDevice):Boolean; override;
   function Eraseable(ADevice:TDiskDevice):Boolean; override;
   function Removable(ADevice:TDiskDevice):Boolean; override;
   function ChangeLine(ADevice:TDiskDevice):Boolean; override;

   function PhysicalCylinders(ADevice:TDiskDevice):LongWord; override;
   function PhysicalHeads(ADevice:TDiskDevice):LongWord; override;
   function PhysicalSectors(ADevice:TDiskDevice):LongWord; override;

   function LogicalCylinders(ADevice:TDiskDevice):LongWord; override;
   function LogicalHeads(ADevice:TDiskDevice):LongWord; override;
   function LogicalSectors(ADevice:TDiskDevice):LongWord; override;
   
   function SectorSize(ADevice:TDiskDevice):Word; override;
   function SectorCount(ADevice:TDiskDevice):Int64; override;
 end;
 
{==============================================================================}
type
 {FileSystem advanced classes}
 TFSHandleStream = class(TStream)
   constructor Create(AHandle:Integer);
  private
   {}
   FHandle:Integer;
  protected
   {}
   procedure SetSize(NewSize:LongInt); override;
  public
   {}
   function Read(var Buffer;Count:LongInt):LongInt; override;
   function Write(const Buffer;Count:LongInt):LongInt; override;
   function Seek(Offset:LongInt;Origin:Word):LongInt; override;
   property Handle:Integer read FHandle;
 end;
 
 TFSFileStream = class(TFSHandleStream)
   constructor Create(const FileName:String;Mode:Word);
   destructor Destroy; override;
  private
   {}
  public
   {}
 end;
 
 TFSHandleStreamEx = class(TStreamEx)
   constructor Create(AHandle:Integer);
  private
   {}
   FHandle:Integer;
  protected
   {}
   procedure SetSize(NewSize:LongInt); override;
   procedure SetSizeEx(const NewSize:Int64); override;
  public
   {}
   function Read(var Buffer;Count:LongInt):LongInt; override;
   function Write(const Buffer;Count:LongInt):LongInt; override;
   function Seek(Offset:LongInt;Origin:Word):LongInt; override;
   function SeekEx(const Offset:Int64;Origin:Word):Int64; override;
   property Handle:Integer read FHandle;
 end;

 TFSFileStreamEx = class(TFSHandleStreamEx)
   constructor Create(const FileName:String;Mode:Word);
   destructor Destroy; override;
  private
   {}
  public
   {}
 end;

{==============================================================================}
type
 {FileSystem Logging specific types}
 PFileSysLogging = ^TFileSysLogging;
 
 {FileSystem Logging}
 TFileSysLogging = record
  {Logging Properties}
  Logging:TLoggingDevice;
  {FileSystem Properties}
 end;
 
{==============================================================================}
var
 {FileSystem specific variables}
 FileSysDriver:TFileSysDriver;

{==============================================================================}
{Initialization Functions}
procedure FileSysInit;
function FileSysStart:LongWord;
function FileSysStop:LongWord;

function FileSysStartCompleted:Boolean;

procedure FileSysAsyncStart(Data:Pointer);

{==============================================================================}
{FileSystem Functions (Delphi / FreePascal RTL)}
{Drive Functions}
function FSGetPathDrive(const APath:String):Byte; inline;
function FSGetDriveType(ADrive:Byte):TDriveType; inline;
function FSGetDriveData(ADrive:Byte):TDriveData; inline;
function FSGetDriveAttr(ADrive:Byte):LongWord; inline;
function FSGetDriveLabel(ADrive:Byte):String; inline;
function FSSetDriveLabel(ADrive:Byte;const ALabel:String):Boolean; inline;
function FSGetDriveSerial(ADrive:Byte):LongWord; inline;
function FSSetDriveSerial(ADrive:Byte;ASerial:LongWord):Boolean; inline;
function FSIsDriveValid(ADrive:Byte):Boolean; inline;
function FSGetValidDrives:LongWord; inline;
function FSGetValidDriveNames:TStringList; inline;
function FSGetValidDriveStrings:String; inline;
function FSGetDriveFreeSpace(ADrive:Byte):LongWord; inline;
function FSGetDriveFreeSpaceEx(ADrive:Byte):Int64; inline;
function FSGetDriveTotalSpace(ADrive:Byte):LongWord; inline;
function FSGetDriveTotalSpaceEx(ADrive:Byte):Int64; inline;

function FSGetDriveInformation(const APath:String;var AClusterSize:LongWord;var ATotalClusterCount,AFreeClusterCount:Int64):Boolean; inline;

function FSGetCurrentDrive:Byte; inline;
function FSSetCurrentDrive(const ADrive:String):Boolean; inline;

{File Functions}
function FSFileOpen(const AFileName:String;AMode:Integer):THandle; inline;
function FSFileCreate(const AFileName:String):THandle; inline;
function FSDeleteFile(const AFileName:String):Boolean; inline;
procedure FSFileClose(AHandle:Integer); inline;
function FSRenameFile(const AOldName,ANewName:String):Boolean; inline;
function FSFileSeek(AHandle:THandle;AOffset,AOrigin:LongInt):LongInt; inline;
function FSFileFlush(AHandle:Integer):Boolean; inline;
function FSFileTruncate(AHandle:Integer):Boolean; inline;
function FSSetEndOfFile(AHandle:THandle):Boolean; inline;

function FSEndOfFile(AHandle:Integer):Boolean; inline;
function FSFilePos(AHandle:THandle):LongInt; inline;
function FSFileSize(AHandle:THandle):LongInt; inline;

function FSFileAge(const AFileName:String):Integer; inline;
function FSFileExists(const AFileName:String):Boolean; inline;
function FSFileGetAttr(const AFileName:String):Integer; inline;
function FSFileGetDate(AHandle:Integer):Integer; inline;
function FSFileSetAttr(const AFileName:String;AAttr:Integer):Integer; inline;
function FSFileSetDate(AHandle:Integer;AAge:Integer):Integer; inline;

function FSFileRead(AHandle:THandle;var ABuffer;ACount:LongInt):LongInt; inline;
function FSFileWrite(AHandle:THandle;const ABuffer;ACount:LongInt):LongInt; inline;

{Directory Functions}
function FSCreateDir(const ADirName:String):Boolean; inline;
function FSRemoveDir(const ADirName:String):Boolean; inline;
function FSRenameDir(const AOldName,ANewName:String):Boolean; inline;
function FSGetCurrentDir:String; inline;
function FSSetCurrentDir(const ADirName:String):Boolean; inline;
function FSDirectoryExists(const ADirName:String):Boolean; inline;
procedure FSForceDirectories(ADirName:String); inline;
procedure FSDeleteTree(const ADirName:String); inline;

{Search Functions}
function FSFindFirst(const APath:String;AAttr:Integer;var ASearchRec:TSearchRec):Integer; inline;
function FSFindNext(var ASearchRec:TSearchRec):Integer; inline;
procedure FSFindClose(var ASearchRec:TSearchRec); inline;

{Additional Functions}
function FSFileCopy(const ASourceFile,ADestFile:String;AFailIfExists:Boolean):Boolean; inline;
function FSFileCopyEx(const ASourceFile,ADestFile:String;AFailIfExists:Boolean;AUseSourceDate:Boolean;ADestDate:Integer;AUseSourceAttr:Boolean;ADestAttr:Integer):Boolean; inline;

function FSGetShortName(const AFileName:String):String; inline;
function FSGetLongName(const AFileName:String):String; inline;
function FSGetTrueName(const AFileName:String):String; inline;

{Extended Functions}
function FSFileSeekEx(AHandle:THandle;const AOffset:Int64;AOrigin:LongInt):Int64; inline;

function FSEndOfFileEx(AHandle:Integer):Boolean; inline;
function FSFilePosEx(AHandle:THandle):Int64; inline;
function FSFileSizeEx(AHandle:THandle):Int64; inline;

function FSFileAgeEx(const AFileName:String):TFileTime; inline;

function FSFileGetAttrEx(AHandle:Integer):Integer; inline;

function FSFileGetDateEx(AHandle:Integer):TFileTime; inline;
function FSFileSetDateEx(AHandle:Integer;AAge:TFileTime):Integer; inline;

function FSGetFileTime(AHandle:THandle;ACreateTime,AAccessTime,AWriteTime:PFileTime):Boolean; inline;
function FSSetFileTime(AHandle:THandle;ACreateTime,AAccessTime,AWriteTime:PFileTime):Boolean; inline; 

function FSFindFirstEx(const APath:String;var ASearchRec:TFileSearchRec):Integer; inline;
function FSFindNextEx(var ASearchRec:TFileSearchRec):Integer; inline;
procedure FSFindCloseEx(var ASearchRec:TFileSearchRec); inline;

{==============================================================================}
{FileSystem Functions (Win32 Compatibility)}
{Drive Functions}
function FSDefineDosDevice(const ADeviceName,ATargetPath:String;AFlags:LongWord):Boolean; inline;
function FSGetDiskType(const ARootPath:String):LongWord; inline; {Equivalent to Win32 GetDriveType}
function FSGetDiskFreeSpace(const ARootPath:String;var ASectorsPerCluster,ABytesPerSector,ANumberOfFreeClusters,ATotalNumberOfClusters:LongWord):Boolean; inline;
function FSGetDiskFreeSpaceEx(const APathName:String;var AFreeBytesAvailableToCaller,ATotalNumberOfBytes,ATotalNumberOfFreeBytes:QWord):Boolean; inline;
function FSGetLogicalDrives:LongWord; inline;
function FSGetLogicalDriveStrings:String; inline;
function FSGetVolumeInformation(const ARootPath:String;var AVolumeName:String;var AVolumeSerialNumber,AMaximumComponentLength,AFileSystemFlags:LongWord;var ASystemName:String):Boolean; inline;
function FSQueryDosDevice(const ARootPath:String):String; inline;
function FSSetVolumeLabel(const AVolume:String;const ALabel:String):Boolean; inline;

{File Functions}
function FSAreFileApisANSI:Boolean; inline;
function FSCloseFile(AHandle:THandle):Boolean; inline; {Equivalent to Win32 CloseHandle}
function FSCopyFile(const AExistingName,ANewName:String;AFailIfExists:Boolean):Boolean; inline;
function FSCreateFile(const AFileName:String;AAccessMode,AShareMode,ACreateFlags,AFileAttributes:LongWord):THandle; inline;
function FSFindCloseFile(AHandle:THandle):Boolean; inline; {Equivalent to Win32 FindClose}
function FSFindFirstFile(const AFileName:String;var AFindData:TWin32FindData):THandle; inline;
function FSFindNextFile(AHandle:THandle;var AFindData:TWin32FindData):Boolean; inline;
function FSFlushFileBuffers(AHandle:THandle):Boolean; inline;
function FSGetFileAttributes(const AFileName:String):LongWord; inline;
function FSGetFileInformationByHandle(AHandle:THandle;var AFileInformation:TByHandleFileInformation):Boolean; inline;
function FSGetFileSize(AHandle:THandle;var AFileSizeHigh:LongWord):LongWord; inline;
function FSGetFullPathName(const AFileName:String):String; inline;
function FSGetShortPathName(const ALongPath:String):String; inline;
function FSMoveFile(const AExistingName,ANewName:String):Boolean; inline;
function FSReadFile(AHandle:THandle;var ABuffer;ABytesToRead:LongWord;var ABytesRead:LongWord):Boolean; inline;
function FSSetFileApisToANSI:Boolean; inline;
function FSSetFileApisToOEM:Boolean; inline;
function FSSetFileAttributes(const AFileName:String;AFileAttributes:LongWord):Boolean; inline;
function FSSetFilePointer(AHandle:THandle;ADistanceToMove:LongInt;var ADistanceToMoveHigh:LongInt;AMoveMethod:LongWord):LongWord; inline;
function FSSetFilePointerEx(AHandle:THandle;const ADistanceToMove:Int64;var ANewFilePointer:Int64;AMoveMethod:LongWord):Boolean; inline;
function FSWriteFile(AHandle:THandle;const ABuffer;ABytesToWrite:LongWord;var ABytesWritten:LongWord):Boolean; inline;
function FSGetLongPathName(const AShortPath:String):String; inline;

function FSSetFileShortName(const AFileName,AShortName:String):Boolean; inline;
function FSSetFileShortNameEx(AHandle:THandle;const AShortName:String):Boolean; inline;
function FSCreateHardLink(const ALinkName,AFileName:String):Boolean; inline;
function FSCreateSymbolicLink(const ALinkName,ATargetName:String;ADirectory:Boolean):Boolean; inline;

{Directory Functions}
function FSCreateDirectory(const APathName:String):Boolean; inline;
function FSGetCurrentDirectory:String; inline;
function FSRemoveDirectory(const APathName:String):Boolean; inline;
function FSSetCurrentDirectory(const APathName:String):Boolean; inline;

{==============================================================================}
{RTL Text IO Functions}
function SysTextIOReadChar(var ACh:Char;AUserData:Pointer):Boolean;
function SysTextIOWriteChar(ACh:Char;AUserData:Pointer):Boolean;
function SysTextIOWriteBuffer(ABuffer:PChar;ACount:LongInt;AUserData:Pointer):LongInt;

{==============================================================================}
{RTL FileSystem Functions}
{System File Functions}
procedure SystemDoClose(Handle:THandle);
procedure SystemDoErase(Name:PChar;NameChangeable:Boolean);
procedure SystemDoRename(Name1,Name2:PChar;Name1Changeable,Name2Changeable:Boolean);
function SystemDoWrite(Handle:THandle;Address:Pointer;Len:LongInt):LongInt;
function SystemDoRead(Handle:THandle;Address:Pointer;Len:LongInt):LongInt;
function SystemDoFilePos(Handle:THandle):LongInt;
procedure SystemDoSeek(Handle:THandle;Pos:LongInt);
function SystemDoSeekEnd(Handle:THandle):LongInt;
function SystemDoFileSize(Handle:THandle):LongInt;
procedure SystemDoTruncate(Handle:THandle;Pos:LongInt);
procedure SystemDoOpen(var F;Name:PFileTextRecChar;Flags:LongInt;NameChangeable:Boolean);

{System Directory Functions}
procedure SystemDoMkDir(const Dir:RawByteString);
procedure SystemDoRmDir(const Dir:RawByteString);
procedure SystemDoChDir(const Dir:RawByteString);
procedure SystemDoGetDir(Drive:Byte;var Dir:RawByteString);

{Dos Disk Functions}
function DosDiskFree(Drive:Byte):Int64;
function DosDiskSize(Drive:Byte):Int64;

{Dos FindFirst/FindNext Functions}
function DosFindFirst(const Path:PathStr;Attr:Word;var f:SearchRec):Integer;
function DosFindNext(var f:SearchRec):Integer;
procedure DosFindClose(var f:SearchRec);

{Dos File Functions}
function DosGetFTime(var f;var Time:LongInt):Integer;
function DosSetFTime(var f;Time:LongInt):Integer;
function DosGetFAttr(var f;var Attr:Word):Integer;
function DosSetFAttr(var f;Attr:Word):Integer;
function DosGetShortName(var p:ShortString):Boolean;
function DosGetLongName(var p:ShortString):Boolean;

{SysUtils File Functions}
function SysUtilsFileOpen(const FileName:RawByteString;Mode:Integer):THandle;
function SysUtilsFileCreate(const FileName:RawByteString;ShareMode:Integer):THandle;
function SysUtilsDeleteFile(const FileName:RawByteString):Boolean;
procedure SysUtilsFileClose(Handle:THandle);
function SysUtilsRenameFile(const OldName,NewName:RawByteString):Boolean;
function SysUtilsFileSeek(Handle:THandle;Offset,Origin:LongInt):LongInt;
function SysUtilsFileTruncate(Handle:THandle;Size:Int64):Boolean;
function SysUtilsFileAge(const FileName:RawByteString):LongInt;
{$IFNDEF FPC_LEGACY}
function SysUtilsFileGetSymLinkTarget(const FileName:RawByteString;out SymLinkRec:TRawbyteSymLinkRec):Boolean;
{$ENDIF}
function SysUtilsFileExists(const FileName:RawByteString;FollowLink:Boolean):Boolean;
function SysUtilsFileGetAttr(const FileName:RawByteString):LongInt;
function SysUtilsFileGetDate(Handle:THandle):LongInt;
function SysUtilsFileSetAttr(const FileName:RawByteString;Attr:LongInt):LongInt;
function SysUtilsFileSetDate(Handle:THandle;Age:LongInt):LongInt;
function SysUtilsFileRead(Handle:THandle;out Buffer;Count:LongInt):LongInt;
function SysUtilsFileWrite(Handle:THandle;const Buffer;Count:LongInt):LongInt;

function SysUtilsFileSeekEx(Handle:THandle;Offset:Int64;Origin:LongInt):Int64;

function SysUtilsInternalFindFirst(const Path:RawByteString;Attr:LongInt;out SearchRec:TSearchRec;var Name:RawByteString):LongInt;
function SysUtilsInternalFindNext(var SearchRec:TSearchRec;var Name:RawByteString):LongInt;
procedure SysUtilsInternalFindClose(var Handle:THandle);

{SysUtils Disk Functions}
function SysUtilsDiskFree(Drive:Byte):Int64;
function SysUtilsDiskSize(Drive:Byte):Int64;
function SysUtilsDirectoryExists(const Directory:RawByteString;FollowLink:Boolean):Boolean;

{==============================================================================}
{FileSystem Logging Functions}
function FileSysLoggingStart(Logging:PLoggingDevice):LongWord;
function FileSysLoggingStop(Logging:PLoggingDevice):LongWord;

function FileSysLoggingOutput(Logging:PLoggingDevice;const Data:String):LongWord;

function FileSysLoggingSetTarget(Logging:PLoggingDevice;const Target:String):LongWord;

{==============================================================================}
{FileSystem Helper Functions}
function FileSysRedirectInput(Handle:THandle):Boolean;
function FileSysRedirectOutput(Handle:THandle):Boolean;

function FileSysStorageGetMediaType(Storage:PStorageDevice):TMediaType;
function FileSysStorageGetController(Storage:PStorageDevice):TDiskController;

procedure FileSysStorageDeviceAdd(Event:PStorageDeviceEvent);
procedure FileSysStorageDeviceInsert(Event:PStorageDeviceEvent);

function FileSysStorageDeviceRemove(Storage:PStorageDevice):LongWord;
function FileSysStorageDeviceEject(Storage:PStorageDevice):LongWord;

function FileSysStorageDeviceEnum(Storage:PStorageDevice;Data:Pointer):LongWord;
function FileSysStorageDeviceNotify(Device:PDevice;Data:Pointer;Notification:LongWord):LongWord;

function ComparePartitions(APartition1,APartition2:Pointer):Integer;

procedure FileSysLog(Level:Integer;const AText:String);
procedure FileSysLogInfo(const AText:String); inline;
procedure FileSysLogWarn(const AText:String); inline;
procedure FileSysLogError(const AText:String); inline;
procedure FileSysLogDebug(const AText:String); inline;

procedure CacheCheckTimer(Data:Pointer);

procedure EntryCheckTimer(Data:Pointer);
procedure EntryProcessTimer(Data:Pointer);

function MediaTypeToString(AType:TMediaType):String;
function FloppyTypeToString(AType:TFloppyType):String;
function ImageTypeToString(AType:TImageType):String;

function DriveTypeToString(AType:TDriveType):String;

function FileSysTypeToString(AType:TFileSysType):String;
function StringToFileSysType(const AFileSysType:String):TFileSysType;

function PartitionIdToString(AId:Byte):String;
function StringToPartitionId(const APartitionId:String):Byte;

function CacheModeToString(ACacheMode:TCacheMode):String;
function CacheStateToString(ACacheState:TCacheState):String;

function CachePageTimeToDateTime(const APageTime:Int64):TDateTime;

{==============================================================================}
{==============================================================================}

implementation

{==============================================================================}
{==============================================================================}
var
 {FileSystem specific variables}
 FileSysInitialized:Boolean;

 FileSysLock:TCriticalSectionHandle = INVALID_HANDLE_VALUE;
 FileSysStartupCount:LongWord;
 FileSysStartupError:LongWord;
 
 FileSysATAController:TATADiskController;
 FileSysATAPIController:TATAPIDiskController;
 FileSysSCSIController:TSCSIDiskController;
 FileSysUSBController:TUSBDiskController;
 FileSysMMCController:TMMCDiskController;
 
 FileSysTextIOInputHandle:THandle = INVALID_HANDLE_VALUE;
 FileSysTextIOOutputHandle:THandle = INVALID_HANDLE_VALUE;
 
var 
 {Partitioning Variables}
 MasterBootCode:TMasterBootCode = (
  $FA,$FC,$31,$C0,$8E,$D8,$BD,$00,$7C,$E8,$2F,$00,$49,$6E,$73,$65,
  $72,$74,$20,$62,$6F,$6F,$74,$20,$64,$69,$73,$6B,$20,$61,$6E,$64,
  $20,$70,$72,$65,$73,$73,$20,$61,$6E,$79,$20,$6B,$65,$79,$00,$30,
  $E4,$CD,$16,$CD,$19,$31,$DB,$B4,$0E,$CD,$10,$5E,$AC,$56,$3C,$00,
  $75,$F3,$C3,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,
  $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,
  $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,
  $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,
  $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,
  $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,
  $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,
  $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,
  $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,
  $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,
  $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,
  $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,
  $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,
  $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,
  $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,
  $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,
  $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,
  $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,
  $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,
  $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,
  $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,
  $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,
  $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,
  $00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
 );
 
{==============================================================================}
{==============================================================================}
{TFileSysDriver}
constructor TFileSysDriver.Create;
begin
 {}
 inherited Create;
 FLock:=SynchronizerCreate;
 
 {Create Cache, Lists and Buffers}
 FCache:=THashCache.Create(Self); {THashCache.Create(Self);} {TCacheEx.Create(Self);} {TCache.Create(Self);}
 FImages:=TFileSysList.Create;
 FDrives:=TFileSysList.Create;
 FVolumes:=TFileSysList.Create;
 FDevices:=TFileSysList.Create;
 FPartitions:=TFileSysList.Create;

 FControllers:=TFileSysList.Create;
 FRecognizers:=TFileSysList.Create;
 FRedirectors:=TFileSysList.Create;
 FFileSystems:=TFileSysList.Create;

 FRawHandles:=TFileSysList.Create;
 FEnumHandles:=TFileSysList.Create;
 FFileHandles:=TFileSysList.Create;
 FFindHandles:=TFileSysList.Create;

 FCurrentIndex:=TlsAlloc;
 FCurrentDrive:=nil;
 
 {Set Defaults}
 FAllowFloppy:=True;
 FAllowDrives:=True;
 FOemConvert:=True;

 FEntryTimer:=TEntryTimer.Create(Self);
 FEntryTimer.StartTimer(FILESYS_ENTRY_TIMER_INTERVAL);
 
 FDefaultRecognizer:=TDefaultRecognizer.Create(Self);
end;

{==============================================================================}

destructor TFileSysDriver.Destroy;
begin
 {}
 WriterLock;
 try
  FDefaultRecognizer.Free;
  
  FEntryTimer.StopTimer;
  FEntryTimer.Free;
  
  TlsFree(FCurrentIndex);

  FFindHandles.Free;
  FFileHandles.Free;
  FEnumHandles.Free;
  FRawHandles.Free;

  FFileSystems.Free;
  FRecognizers.Free;
  FRedirectors.Free;
  FControllers.Free;

  FPartitions.Free;
  FDevices.Free;
  FVolumes.Free;
  FDrives.Free;
  FImages.Free;
  FCache.Free;
  inherited Destroy;
 finally 
  {WriterUnlock;} {Can destroy Synchronizer while holding lock}
  SynchronizerDestroy(FLock);
 end;
end;

{==============================================================================}

function TFileSysDriver.ReaderLock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TFileSysDriver.ReaderUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TFileSysDriver.WriterLock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TFileSysDriver.WriterUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TFileSysDriver.GetCurrent:TDiskDrive; 
begin
 {}
 if FILESYS_GLOBAL_CURRENTDIR then
  begin
   Result:=FCurrentDrive;
  end
 else
  begin 
   Result:=TlsGetValue(FCurrentIndex);
  end; 
end;

{==============================================================================}

function TFileSysDriver.SetCurrent(ACurrent:TDiskDrive):Boolean; 
begin
 {}
 if FILESYS_GLOBAL_CURRENTDIR then
  begin
   FCurrentDrive:=ACurrent;
   
   Result:=(FCurrentDrive <> nil);
  end
 else
  begin
   Result:=TlsSetValue(FCurrentIndex,ACurrent)
  end; 
end;

{==============================================================================}

function TFileSysDriver.OpenCache(ACacheSize,ACacheKeys,APageSize:LongWord;ACacheMode:TCacheMode):Boolean;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {Check Cache}
  if FCache = nil then Exit;
  
  {Open Cache}
  Result:=FCache.OpenCache(ACacheSize,ACacheKeys,APageSize,ACacheMode);
 finally
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.CloseCache:Boolean;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {Check Cache}
  if FCache = nil then Exit;
  
  {Close Cache}
  Result:=FCache.CloseCache;
 finally
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FlushCache(AAll:Boolean):Boolean;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {Check Cache}
  if FCache = nil then Exit;
  
  {Flush Cache}
  Result:=FCache.FlushCache(False,AAll);
 finally
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.DiscardCache(AAll:Boolean):Boolean;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {Check Cache}
  if FCache = nil then Exit;
  
  {Discard Cache}
  Result:=FCache.DiscardCache(False,AAll);
 finally
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetCacheStatistics(var AStatistics:TCacheStatistics):Boolean;
var
 Page:TCachePage;
begin
 {}
 Result:=False;
 
 {Setup Statistics}
 FillChar(AStatistics,SizeOf(TCacheStatistics),0);
 
 if not ReaderLock then Exit;
 try
  {Check Cache}
  if FCache = nil then Exit;

  if FCache.AcquireLock then
   begin
    {Get Statistics}
    {Information}
    AStatistics.PageSize:=FCache.PageSize;
    AStatistics.PageCount:=FCache.PageCount;
    AStatistics.CacheSize:=FCache.CacheSize;
    AStatistics.CacheMode:=FCache.CacheMode;
    AStatistics.CacheState:=FCache.CacheState;
    AStatistics.FlushTimeout:=FCache.FlushTimeout;
    AStatistics.DiscardTimeout:=FCache.DiscardTimeout;
    {Read / Write}
    AStatistics.ReadCached:=FCache.ReadCached;
    AStatistics.ReadDirect:=FCache.ReadDirect;
    AStatistics.WriteBack:=FCache.WriteBack;
    AStatistics.WriteThrough:=FCache.WriteThrough;
    AStatistics.WriteDirect:=FCache.WriteDirect;  
    {Hit / Miss}
    AStatistics.HitCount:=FCache.HitCount;
    AStatistics.MissCount:=FCache.MissCount;
    {Allocate Success / Failure}
    AStatistics.FailCount:=FCache.FailCount;
    AStatistics.SuccessCount:=FCache.SuccessCount;
    {Page Flush / Discard}
    AStatistics.FlushCount:=FCache.FlushCount;
    AStatistics.DiscardCount:=FCache.DiscardCount;
    AStatistics.UnknownCount:=FCache.UnknownCount;
    {Page Times}
    Page:=FCache.FFirstClean;
    if Page <> nil then AStatistics.OldestClean:=GetTickCount64 - Page.PageTime;
    Page:=FCache.FLastClean;
    if Page <> nil then AStatistics.NewestClean:=GetTickCount64 - Page.PageTime;
    Page:=FCache.FFirstDirty;
    if Page <> nil then AStatistics.OldestDirty:=GetTickCount64 - Page.WriteTime;
    Page:=FCache.FLastDirty;
    if Page <> nil then AStatistics.NewestDirty:=GetTickCount64 - Page.WriteTime;
   
    FCache.ReleaseLock;
    
    {Return Result}
    Result:=True;
   end; 
 finally
  ReaderUnlock;
 end; 
end;
  
{==============================================================================}

function TFileSysDriver.GetCatalogByNo(const APath:String;ACatalogNo:LongWord;ALock:Boolean;AState:LongWord):TDiskCatalog;
var
 FileSystem:TFileSystem;
begin
 {}
 Result:=nil;
 
 if not ReaderLock then Exit;
 try
  if ACatalogNo = 0 then Exit;
 
  FileSystem:=GetFileSystemFromPath(APath,True,FILESYS_LOCK_READ);
  if FileSystem = nil then Exit;
 
  Result:=FileSystem.GetCatalogByNo(ACatalogNo,ALock,AState);

  {Unlock FileSystem}
  FileSystem.ReaderUnlock;
 finally
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetCatalogByName(const APath,AName:String;ALock:Boolean;AState:LongWord):TDiskCatalog;
var
 FileSystem:TFileSystem;
begin
 {}
 Result:=nil;
 
 if not ReaderLock then Exit;
 try
  if Trim(AName) = '' then Exit;
  
  FileSystem:=GetFileSystemFromPath(APath,True,FILESYS_LOCK_READ);
  if FileSystem = nil then Exit;
  
  Result:=FileSystem.GetCatalogByName(AName,ALock,AState);

  {Unlock FileSystem}
  FileSystem.ReaderUnlock;
 finally
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetCatalogByNext(const APath:String;APrevious:TDiskCatalog;ALock,AUnlock:Boolean;AState:LongWord):TDiskCatalog;
var
 FileSystem:TFileSystem;
begin
 {}
 Result:=nil;
 
 if not ReaderLock then Exit;
 try
  FileSystem:=GetFileSystemFromPath(APath,True,FILESYS_LOCK_READ);
  if FileSystem = nil then Exit;
  
  Result:=FileSystem.GetCatalogByNext(APrevious,ALock,AUnlock,AState);

  {Unlock FileSystem}
  FileSystem.ReaderUnlock;
 finally
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.AddImage(AImage:TDiskImage):Boolean;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  if AImage = nil then Exit;
  
  {Acquire Lock}
  FImages.WriterLock;

  {Add Image}
  Result:=FImages.Add(AImage);

  {Release Lock}
  FImages.WriterUnlock;
 finally
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.RemoveImage(AImage:TDiskImage):Boolean;
var
 Device:TDiskDevice;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if AImage = nil then Exit;
  
  {Update Enum Handles}
  UpdateEnumHandles(nil,nil,nil,nil,AImage,nil); //To Do //Move within WriterLock, see notes ?
  
  {Acquire Lock}
  FImages.WriterLock;
  try
   {Remove Image}
   Result:=FImages.Remove(AImage);
   if not Result then Exit;
  finally
   {Release Lock}
   FImages.WriterUnlock;
  end; 
  
  {Remove any Device using the Image}
  Device:=GetDeviceByImage(AImage,True,FILESYS_LOCK_WRITE);
  while Device <> nil do
   begin
    Device.Free;
    
    Device:=GetDeviceByImage(AImage,True,FILESYS_LOCK_WRITE);
   end;
 finally
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.CheckImage(AImage:TDiskImage;ALock:Boolean;AState:LongWord):Boolean;
var
 Image:TDiskImage;
begin
 {}
 Result:=False;

 if not FImages.ReaderLock then Exit;
 try
  if AImage = nil then Exit;
  
  Image:=TDiskImage(FImages.First);
  while Image <> nil do
   begin
    if Image = AImage then
     begin
      {Lock Image} 
      if ALock then 
       begin
        if AState = FILESYS_LOCK_AUTO then
         begin
          if not(Image.WriterOwner) then Image.ReaderLock else Image.WriterLock;
         end
        else
         begin        
          if AState = FILESYS_LOCK_READ then Image.ReaderLock else Image.WriterLock;
         end; 
       end; 
      
      Result:=True;
      Exit;
     end;
     
    Image:=TDiskImage(Image.Next);
   end;
 finally
  FImages.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetImageByNo(AImageNo:Integer;ALock:Boolean;AState:LongWord):TDiskImage;
{Note: ImageNo is one based}
var
 Image:TDiskImage;
begin
 {}
 Result:=nil;

 if not FImages.ReaderLock then Exit;
 try
  if AImageNo = 0 then Exit;
  
  Image:=TDiskImage(FImages.First);
  while Image <> nil do
   begin
    if Image.ImageNo = AImageNo then
     begin
      {Lock Image} 
      if ALock then 
       begin
        if AState = FILESYS_LOCK_AUTO then
         begin
          if not(Image.WriterOwner) then Image.ReaderLock else Image.WriterLock;
         end
        else
         begin        
          if AState = FILESYS_LOCK_READ then Image.ReaderLock else Image.WriterLock;
         end; 
       end; 
      
      Result:=Image;
      Exit;
     end;
     
    Image:=TDiskImage(Image.Next);
   end;
 finally
  FImages.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetImageByName(const AName:String;ALock:Boolean;AState:LongWord):TDiskImage;
var
 Image:TDiskImage;
begin
 {}
 Result:=nil;

 if not FImages.ReaderLock then Exit;
 try
  if Trim(AName) = '' then Exit;
  
  Image:=TDiskImage(FImages.First);
  while Image <> nil do
   begin
    if Uppercase(Image.Name) = Uppercase(AName) then
     begin
      {Lock Image} 
      if ALock then 
       begin
        if AState = FILESYS_LOCK_AUTO then
         begin
          if not(Image.WriterOwner) then Image.ReaderLock else Image.WriterLock;
         end
        else
         begin        
          if AState = FILESYS_LOCK_READ then Image.ReaderLock else Image.WriterLock;
         end; 
       end; 
     
      Result:=Image;
      Exit;
     end;
     
    Image:=TDiskImage(Image.Next);
   end;
 finally
  FImages.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetImageByDevice(ADevice:TDiskDevice;ALock:Boolean;AState:LongWord):TDiskImage;
var
 Image:TDiskImage;
begin
 {}
 Result:=nil;

 if not FImages.ReaderLock then Exit;
 try
  if ADevice = nil then Exit;
  
  Image:=TDiskImage(FImages.First);
  while Image <> nil do
   begin
    if Image.Device = ADevice then
     begin
      {Lock Image} 
      if ALock then 
       begin
        if AState = FILESYS_LOCK_AUTO then
         begin
          if not(Image.WriterOwner) then Image.ReaderLock else Image.WriterLock;
         end
        else
         begin        
          if AState = FILESYS_LOCK_READ then Image.ReaderLock else Image.WriterLock;
         end; 
       end; 
      
      Result:=Image;
      Exit;
     end;
     
    Image:=TDiskImage(Image.Next);
   end;
 finally
  FImages.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetImageByController(AController:TDiskController;ALock:Boolean;AState:LongWord):TDiskImage;
{Returns the first Image on the specified Controller}
var
 Image:TDiskImage;
begin
 {}
 Result:=nil;

 if not FImages.ReaderLock then Exit;
 try
  if AController = nil then Exit;
  
  Image:=TDiskImage(FImages.First);
  while Image <> nil do
   begin
    if Image.Controller = AController then
     begin
      {Lock Image} 
      if ALock then 
       begin
        if AState = FILESYS_LOCK_AUTO then
         begin
          if not(Image.WriterOwner) then Image.ReaderLock else Image.WriterLock;
         end
        else
         begin        
          if AState = FILESYS_LOCK_READ then Image.ReaderLock else Image.WriterLock;
         end; 
       end; 
      
      Result:=Image;
      Exit;
     end;
     
    Image:=TDiskImage(Image.Next);
   end;
 finally
  FImages.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetImagesByController(AController:TDiskController;ALock:Boolean;AState:LongWord):TList;
{Returns all Images on the specified Controller}
var
 Image:TDiskImage;
begin
 {}
 Result:=TList.Create;

 if not FImages.ReaderLock then Exit;
 try
  if AController = nil then Exit;
  
  Image:=TDiskImage(FImages.First);
  while Image <> nil do
   begin
    if Image.Controller = AController then
     begin
      {Lock Image} 
      if ALock then 
       begin
        if AState = FILESYS_LOCK_AUTO then
         begin
          if not(Image.WriterOwner) then Image.ReaderLock else Image.WriterLock;
         end
        else
         begin        
          if AState = FILESYS_LOCK_READ then Image.ReaderLock else Image.WriterLock;
         end; 
       end; 
      
      Result.Add(Image);
     end;
     
    Image:=TDiskImage(Image.Next);
   end;
 finally
  FImages.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetImageByNext(APrevious:TDiskImage;ALock,AUnlock:Boolean;AState:LongWord):TDiskImage;
var
 Image:TDiskImage;
begin
 {}
 Result:=nil;
 
 if not FImages.ReaderLock then Exit;
 try
  {Check Previous}
  if APrevious = nil then
   begin
    {Get First}
    Image:=TDiskImage(FImages.First);
    if Image <> nil then
     begin
      {Lock Image}
      if ALock then 
       begin
        if AState = FILESYS_LOCK_AUTO then
         begin
          if not(Image.WriterOwner) then Image.ReaderLock else Image.WriterLock;
         end
        else
         begin        
          if AState = FILESYS_LOCK_READ then Image.ReaderLock else Image.WriterLock;
         end; 
       end; 
      
      {Return Result}
      Result:=Image;
     end;
   end
  else
   begin
    {Get Next}
    Image:=TDiskImage(APrevious.Next);
    if Image <> nil then
     begin
      {Lock Image}
      if ALock then 
       begin
        if AState = FILESYS_LOCK_AUTO then
         begin
          if not(Image.WriterOwner) then Image.ReaderLock else Image.WriterLock;
         end
        else
         begin        
          if AState = FILESYS_LOCK_READ then Image.ReaderLock else Image.WriterLock;
         end; 
       end; 
      
      {Return Result}
      Result:=Image;
     end;

    {Unlock Previous}
    if AUnlock then 
     begin
      if AState = FILESYS_LOCK_AUTO then
       begin
        if not(APrevious.WriterOwner) then APrevious.ReaderUnlock else APrevious.WriterUnlock;
       end
      else
       begin        
        if AState = FILESYS_LOCK_READ then APrevious.ReaderUnlock else APrevious.WriterUnlock;
       end; 
     end; 
   end;   
 finally
  FImages.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetNextImageNo:Integer;
begin
 {}
 Result:=1;
 
 while GetImageByNo(Result,False,FILESYS_LOCK_NONE) <> nil do {Do not lock}
  begin
   Inc(Result);
  end;
end;

{==============================================================================}

function TFileSysDriver.GetMaxImageNo:Integer;
var
 Image:TDiskImage;
begin
 {}
 Result:=1;
 
 if not FImages.ReaderLock then Exit;
 try
  Image:=TDiskImage(FImages.First);
  while Image <> nil do
   begin
    if Image.ImageNo > Result then
     begin
      Result:=Image.ImageNo;
     end;
     
    Image:=TDiskImage(Image.Next);
   end;
 finally
  FImages.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.AddDrive(ADrive:TDiskDrive):Boolean;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if ADrive = nil then Exit;
 
  {Acquire Lock}
  FDrives.WriterLock;

  {Add Drive}
  Result:=FDrives.Add(ADrive);

  {Release Lock}
  FDrives.WriterUnlock;
 finally
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.RemoveDrive(ADrive:TDiskDrive):Boolean;
{Note: When dismounting a Drive without dismounting the volume and filesystem
       DeleteDrive will have unbound the drive from the filesystem and called
       DismountFindHandles and DismountFileHandles}
{Note: Caller must hold the drive writer lock}       
var
 FileSystem:TFileSystem;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if ADrive = nil then Exit;
  
  {Update Enum Handles}
  UpdateEnumHandles(nil,nil,ADrive,nil,nil,nil); //To Do //Move within WriterLock, see notes ?
  
  {Acquire Lock}
  FDrives.WriterLock;
  try
   {Remove Drive}
   Result:=FDrives.Remove(ADrive);
   if not Result then Exit;
  finally
   {Release Lock}
   FDrives.WriterUnlock;
  end; 
  
  {Release any Find Handles on the Drive}
  ReleaseFindHandles(nil,ADrive);
  
  {Release any File Handles on the Drive}
  ReleaseFileHandles(nil,ADrive);
  
  {Release any Raw Handles on the Drive}
  ReleaseRawHandles(nil,nil,nil,ADrive);
  
  {Remove any FileSystem using the Drive}
  FileSystem:=GetFileSystemByDrive(ADrive,True,FILESYS_LOCK_WRITE);
  while FileSystem <> nil do
   begin
    {Note: The FileSystem will automatically unbind from the volume/drive when Destroyed}
    FileSystem.DismountFileSystem;
    FileSystem.Free;
    
    FileSystem:=GetFileSystemByDrive(ADrive,True,FILESYS_LOCK_WRITE);
   end;
 finally
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.CheckDrive(ADrive:TDiskDrive;ALock:Boolean;AState:LongWord):Boolean;
var
 Drive:TDiskDrive;
begin
 {}
 Result:=False;

 if not FDrives.ReaderLock then Exit;
 try
  if ADrive = nil then Exit;
  
  Drive:=TDiskDrive(FDrives.First);
  while Drive <> nil do
   begin
    if Drive = ADrive then
     begin
      {Lock Drive} 
      if ALock then if AState = FILESYS_LOCK_READ then Drive.ReaderLock else Drive.WriterLock;
      
      Result:=True;
      Exit;
     end;
     
    Drive:=TDiskDrive(Drive.Next);
   end;
 finally
  FDrives.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetDriveByNo(ADriveNo:Integer;ALock:Boolean;AState:LongWord):TDiskDrive;
{Note: DriveNo is one based}
var
 Drive:TDiskDrive;
begin
 {}
 Result:=nil;

 if not FDrives.ReaderLock then Exit;
 try
  if ADriveNo < MIN_DRIVE then Exit;
  if ADriveNo > NON_DRIVE then Exit;
  
  Drive:=TDiskDrive(FDrives.First);
  while Drive <> nil do
   begin
    if Drive.DriveNo = ADriveNo then
     begin
      {Lock Drive} 
      if ALock then if AState = FILESYS_LOCK_READ then Drive.ReaderLock else Drive.WriterLock;
     
      Result:=Drive;
      Exit;
     end;
     
    Drive:=TDiskDrive(Drive.Next);
   end;
 finally
  FDrives.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetDriveByName(const AName:String;ALock:Boolean;AState:LongWord):TDiskDrive;
var
 Drive:TDiskDrive;
begin
 {}
 Result:=nil;
 
 if not FDrives.ReaderLock then Exit;
 try
  if Trim(AName) = '' then Exit;
  
  Drive:=TDiskDrive(FDrives.First);
  while Drive <> nil do
   begin
    if Uppercase(Drive.Name) = Uppercase(AName) then
     begin
      {Lock Drive} 
      if ALock then if AState = FILESYS_LOCK_READ then Drive.ReaderLock else Drive.WriterLock;

      Result:=Drive;
      Exit;
     end;
     
    Drive:=TDiskDrive(Drive.Next);
   end;
 finally
  FDrives.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetDriveByParent(const AParent:String;ALock:Boolean;AState:LongWord):TDiskDrive;
var
 Drive:TDiskDrive;
begin
 {}
 Result:=nil;

 if not FDrives.ReaderLock then Exit;
 try
  if Trim(AParent) = '' then Exit;
  
  Drive:=TDiskDrive(FDrives.First);
  while Drive <> nil do
   begin
    if Uppercase(Drive.Parent) = Uppercase(AParent) then
     begin
      {Lock Drive} 
      if ALock then if AState = FILESYS_LOCK_READ then Drive.ReaderLock else Drive.WriterLock;

      Result:=Drive;
      Exit;
     end;
     
    Drive:=TDiskDrive(Drive.Next);
   end;
 finally
  FDrives.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetDriveByVolume(AVolume:TDiskVolume;ALock:Boolean;AState:LongWord):TDiskDrive;
var
 Drive:TDiskDrive;
begin
 {}
 Result:=nil;
 
 if not FDrives.ReaderLock then Exit;
 try
  if AVolume = nil then Exit;
  
  Drive:=TDiskDrive(FDrives.First);
  while Drive <> nil do
   begin
    if Drive.Volume = AVolume then
     begin
      {Lock Drive} 
      if ALock then if AState = FILESYS_LOCK_READ then Drive.ReaderLock else Drive.WriterLock;

      Result:=Drive;
      Exit;
     end;
     
    Drive:=TDiskDrive(Drive.Next);
   end;
 finally
  FDrives.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetDriveByDevice(ADevice:TDiskDevice;ALock:Boolean;AState:LongWord):TDiskDrive;
{Returns the first Drive on the specified Device}
var
 Drive:TDiskDrive;
begin
 {}
 Result:=nil;

 if not FDrives.ReaderLock then Exit;
 try
  if ADevice = nil then Exit;
  
  Drive:=TDiskDrive(FDrives.First);
  while Drive <> nil do
   begin
    if Drive.Volume <> nil then
     begin
      if Drive.Volume.Device = ADevice then
       begin
        {Lock Drive} 
        if ALock then if AState = FILESYS_LOCK_READ then Drive.ReaderLock else Drive.WriterLock;

        Result:=Drive;
        Exit;
       end;
     end;
     
    Drive:=TDiskDrive(Drive.Next);
   end;
 finally
  FDrives.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetDrivesByDevice(ADevice:TDiskDevice;ALock:Boolean;AState:LongWord):TList;
{Returns all Drives on the specified Device}
var
 Drive:TDiskDrive;
begin
 {}
 Result:=TList.Create;

 if not FDrives.ReaderLock then Exit;
 try
  if ADevice = nil then Exit;
  
  Drive:=TDiskDrive(FDrives.First);
  while Drive <> nil do
   begin
    if Drive.Volume <> nil then
     begin
      if Drive.Volume.Device = ADevice then
       begin
        {Lock Drive} 
        if ALock then if AState = FILESYS_LOCK_READ then Drive.ReaderLock else Drive.WriterLock;
        
        Result.Add(Drive);
       end;
     end;
     
    Drive:=TDiskDrive(Drive.Next);
   end;
 finally
  FDrives.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetDriveByPartition(APartition:TDiskPartition;ALock:Boolean;AState:LongWord):TDiskDrive;
{Returns the first Drive on the specified Partition}
var
 Drive:TDiskDrive;
begin
 {}
 Result:=nil;

 if not FDrives.ReaderLock then Exit;
 try
  if APartition = nil then Exit;
  
  Drive:=TDiskDrive(FDrives.First);
  while Drive <> nil do
   begin
    if Drive.Volume <> nil then
     begin
      if Drive.Volume.Partition = APartition then
       begin
        {Lock Drive} 
        if ALock then if AState = FILESYS_LOCK_READ then Drive.ReaderLock else Drive.WriterLock;
        
        Result:=Drive;
        Exit;
       end;
     end;
     
    Drive:=TDiskDrive(Drive.Next);
   end;
 finally
  FDrives.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetDrivesByPartition(APartition:TDiskPartition;ALock:Boolean;AState:LongWord):TList;
{Returns all Drives on the specified Partition}
var
 Drive:TDiskDrive;
begin
 {}
 Result:=TList.Create;

 if not FDrives.ReaderLock then Exit;
 try
  if APartition = nil then Exit;
  
  Drive:=TDiskDrive(FDrives.First);
  while Drive <> nil do
   begin
    if Drive.Volume <> nil then
     begin
      if Drive.Volume.Partition = APartition then
       begin
        {Lock Drive} 
        if ALock then if AState = FILESYS_LOCK_READ then Drive.ReaderLock else Drive.WriterLock;
        
        Result.Add(Drive);
       end;
     end;
     
    Drive:=TDiskDrive(Drive.Next);
   end;
 finally
  FDrives.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetDriveByNext(APrevious:TDiskDrive;ALock,AUnlock:Boolean;AState:LongWord):TDiskDrive;
var
 Drive:TDiskDrive;
begin
 {}
 Result:=nil;
 
 if not FDrives.ReaderLock then Exit;
 try
  {Check Previous}
  if APrevious = nil then
   begin
    {Get First}
    Drive:=TDiskDrive(FDrives.First);
    if Drive <> nil then
     begin
      {Lock Drive}
      if ALock then if AState = FILESYS_LOCK_READ then Drive.ReaderLock else Drive.WriterLock;
      
      {Return Result}
      Result:=Drive;
     end;
   end
  else
   begin
    {Get Next}
    Drive:=TDiskDrive(APrevious.Next);
    if Drive <> nil then
     begin
      {Lock Drive}
      if ALock then if AState = FILESYS_LOCK_READ then Drive.ReaderLock else Drive.WriterLock;
      
      {Return Result}
      Result:=Drive;
     end;

    {Unlock Previous}
    if AUnlock then if AState = FILESYS_LOCK_READ then APrevious.ReaderUnlock else APrevious.WriterUnlock;
   end;   
 finally
  FDrives.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetNextDriveNo(AMediaType:TMediaType):Integer;
var
 Count:Integer;
begin
 {}
 Result:=0;
 
 case AMediaType of
  mtFIXED,mtREMOVABLE,mtCDROM,mtDVD,mtOTHER:begin
    {Fixed Device}
    for Count:=MIN_FIXED_DRIVE to MAX_FIXED_DRIVE do
     begin
      if GetDriveByNo(Count,False,FILESYS_LOCK_NONE) = nil then {Do not lock}
       begin
        Result:=Count;
        Exit;
       end;
     end;
   end;
  mtFLOPPY:begin
    {Floppy Device}
    for Count:=MIN_FLOPPY_DRIVE to MAX_FLOPPY_DRIVE do
     begin
      if GetDriveByNo(Count,False,FILESYS_LOCK_NONE) = nil then {Do not lock}
       begin
        Result:=Count;
        Exit;
       end;
     end;
     
    {If not found use Fixed Device Nos}
    for Count:=MIN_FIXED_DRIVE to MAX_FIXED_DRIVE do
     begin
      if GetDriveByNo(Count,False,FILESYS_LOCK_NONE) = nil then {Do not lock}
       begin
        Result:=Count;
        Exit;
       end;
     end;
   end;
 end;
end;

{==============================================================================}

function TFileSysDriver.GetMaxDriveNo(AMediaType:TMediaType):Integer;
var
 Drive:TDiskDrive;
begin
 {}
 Result:=0;
 
 if not FDrives.ReaderLock then Exit;
 try
  case AMediaType of
   mtFIXED,mtREMOVABLE,mtCDROM,mtDVD,mtOTHER:begin
     {Fixed Device}
     Result:=MIN_FIXED_DRIVE;
     
     Drive:=TDiskDrive(FDrives.First);
     while Drive <> nil do
      begin
       if Drive.DriveNo > Result then
        begin
         case Drive.DriveType of
          dtFIXED,dtREMOVABLE,dtCDROM:begin
            Result:=Drive.DriveNo;
           end;
         end;
        end;
        
       Drive:=TDiskDrive(Drive.Next);
      end;
    end;
   mtFLOPPY:begin
     {Floppy Device}
     Result:=MIN_FLOPPY_DRIVE;
     
     Drive:=TDiskDrive(FDrives.First);
     while Drive <> nil do
      begin
       if Drive.DriveNo > Result then
        begin
         case Drive.DriveType of
          dtFLOPPY:begin
            Result:=Drive.DriveNo;
           end;
         end;
        end;
        
       Drive:=TDiskDrive(Drive.Next);
      end;
    end;
  end;
 finally
  FDrives.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.AddVolume(AVolume:TDiskVolume):Boolean;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if AVolume = nil then Exit;
  
  {Acquire Lock}
  FVolumes.WriterLock;

  {Add Volume}
  Result:=FVolumes.Add(AVolume);

  {Release Lock}
  FVolumes.WriterUnlock;
 finally
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.RemoveVolume(AVolume:TDiskVolume):Boolean;
{Note: Caller must hold the volume writer lock}       
var
 Drive:TDiskDrive;
 FileSystem:TFileSystem;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if AVolume = nil then Exit;
  
  {Update Enum Handles}
  UpdateEnumHandles(nil,nil,nil,AVolume,nil,nil); //To Do //Move within WriterLock, see notes ?
  
  {Acquire Lock}
  FVolumes.WriterLock;
  try
   {Remove Volume}
   Result:=FVolumes.Remove(AVolume);
   if not Result then Exit;
  finally
   {Release Lock}
   FVolumes.WriterUnlock;
  end; 
  
  {Release any Find Handles on the Volume}
  ReleaseFindHandles(AVolume,nil);
  
  {Release any File Handles on the Volume}
  ReleaseFileHandles(AVolume,nil);
  
  {Release any Raw Handles on the Volume}
  ReleaseRawHandles(nil,nil,AVolume,nil);
  
  {Remove any FileSystem using the Volume}
  FileSystem:=GetFileSystemByVolume(AVolume,True,FILESYS_LOCK_WRITE);
  while FileSystem <> nil do
   begin
    {Note: The FileSystem will automatically unbind from any volume/drive when Destroyed}
    FileSystem.DismountFileSystem;
    FileSystem.Free;
    
    FileSystem:=GetFileSystemByVolume(AVolume,True,FILESYS_LOCK_WRITE);
   end;
  
  {Remove any Drive using the Volume}
  Drive:=GetDriveByVolume(AVolume,True,FILESYS_LOCK_WRITE);
  while Drive <> nil do
   begin
    Drive.Free;
    
    Drive:=GetDriveByVolume(AVolume,True,FILESYS_LOCK_WRITE);
   end;
 finally
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.CheckVolume(AVolume:TDiskVolume;ALock:Boolean;AState:LongWord):Boolean;
var
 Volume:TDiskVolume;
begin
 {}
 Result:=False;

 if not FVolumes.ReaderLock then Exit;
 try
  if AVolume = nil then Exit;
  
  Volume:=TDiskVolume(FVolumes.First);
  while Volume <> nil do
   begin
    if Volume = AVolume then
     begin
      {Lock Volume} 
      if ALock then if AState = FILESYS_LOCK_READ then Volume.ReaderLock else Volume.WriterLock;
      
      Result:=True;
      Exit;
     end;
     
    Volume:=TDiskVolume(Volume.Next);
   end;
 finally
  FVolumes.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetVolumeByNo(AVolumeNo:Integer;ALock:Boolean;AState:LongWord):TDiskVolume;
{Note: VolumeNo is one based}
var
 Volume:TDiskVolume;
begin
 {}
 Result:=nil;

 if not FVolumes.ReaderLock then Exit;
 try
  if AVolumeNo = 0 then Exit;
  
  Volume:=TDiskVolume(FVolumes.First);
  while Volume <> nil do
   begin
    if Volume.VolumeNo = AVolumeNo then
     begin
      {Lock Volume} 
      if ALock then if AState = FILESYS_LOCK_READ then Volume.ReaderLock else Volume.WriterLock;

      Result:=Volume;
      Exit;
     end;
     
    Volume:=TDiskVolume(Volume.Next);
   end;
 finally
  FVolumes.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetVolumeByName(const AName:String;ALock:Boolean;AState:LongWord):TDiskVolume;
var
 Volume:TDiskVolume;
begin
 {}
 Result:=nil;

 if not FVolumes.ReaderLock then Exit;
 try
  if Trim(AName) = '' then Exit;
  
  Volume:=TDiskVolume(FVolumes.First);
  while Volume <> nil do
   begin
    if Uppercase(Volume.Name) = Uppercase(AName) then
     begin
      {Lock Volume} 
      if ALock then if AState = FILESYS_LOCK_READ then Volume.ReaderLock else Volume.WriterLock;

      Result:=Volume;
      Exit;
     end;
     
    Volume:=TDiskVolume(Volume.Next);
   end;
 finally
  FVolumes.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetVolumeByParent(const AParent:String;ALock:Boolean;AState:LongWord):TDiskVolume;
var
 Volume:TDiskVolume;
begin
 {}
 Result:=nil;

 if not FVolumes.ReaderLock then Exit;
 try
  if Trim(AParent) = '' then Exit;
  
  Volume:=TDiskVolume(FVolumes.First);
  while Volume <> nil do
   begin
    if Uppercase(Volume.Parent) = Uppercase(AParent) then
     begin
      {Lock Volume} 
      if ALock then if AState = FILESYS_LOCK_READ then Volume.ReaderLock else Volume.WriterLock;

      Result:=Volume;
      Exit;
     end;
     
    Volume:=TDiskVolume(Volume.Next);
   end;
 finally
  FVolumes.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetVolumeByDevice(ADevice:TDiskDevice;ALock:Boolean;AState:LongWord):TDiskVolume;
{Returns the first Volume on the specified Device}
var
 Volume:TDiskVolume;
begin
 {}
 Result:=nil;

 if not FVolumes.ReaderLock then Exit;
 try
  if ADevice = nil then Exit;
  
  Volume:=TDiskVolume(FVolumes.First);
  while Volume <> nil do
   begin
    if Volume.Device = ADevice then
     begin
      {Lock Volume} 
      if ALock then if AState = FILESYS_LOCK_READ then Volume.ReaderLock else Volume.WriterLock;

      Result:=Volume;
      Exit;
     end;
     
    Volume:=TDiskVolume(Volume.Next);
   end;
 finally
  FVolumes.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetVolumesByDevice(ADevice:TDiskDevice;ALock:Boolean;AState:LongWord):TList;
{Returns all Volumes on the specified Device}
var
 Volume:TDiskVolume;
begin
 {}
 Result:=TList.Create;

 if not FVolumes.ReaderLock then Exit;
 try
  if ADevice = nil then Exit;
  
  Volume:=TDiskVolume(FVolumes.First);
  while Volume <> nil do
   begin
    if Volume.Device = ADevice then
     begin
      {Lock Volume} 
      if ALock then if AState = FILESYS_LOCK_READ then Volume.ReaderLock else Volume.WriterLock;

      Result.Add(Volume);
     end;
     
    Volume:=TDiskVolume(Volume.Next);
   end;
 finally
  FVolumes.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetVolumeByPartition(APartition:TDiskPartition;ALock:Boolean;AState:LongWord):TDiskVolume;
{Returns the first Volume on the specified Partition}
var
 Volume:TDiskVolume;
begin
 {}
 Result:=nil;

 if not FVolumes.ReaderLock then Exit;
 try
  if APartition = nil then Exit;
  
  Volume:=TDiskVolume(FVolumes.First);
  while Volume <> nil do
   begin
    if Volume.Partition = APartition then
     begin
      {Lock Volume} 
      if ALock then if AState = FILESYS_LOCK_READ then Volume.ReaderLock else Volume.WriterLock;

      Result:=Volume;
      Exit;
     end;
     
    Volume:=TDiskVolume(Volume.Next);
   end;
 finally
  FVolumes.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetVolumesByPartition(APartition:TDiskPartition;ALock:Boolean;AState:LongWord):TList;
{Returns all Volumes on the specified Partition}
var
 Volume:TDiskVolume;
begin
 {}
 Result:=TList.Create;

 if not FVolumes.ReaderLock then Exit;
 try
  if APartition = nil then Exit;
  
  Volume:=TDiskVolume(FVolumes.First);
  while Volume <> nil do
   begin
    if Volume.Partition = APartition then
     begin
      {Lock Volume} 
      if ALock then if AState = FILESYS_LOCK_READ then Volume.ReaderLock else Volume.WriterLock;

      Result.Add(Volume);
     end;
     
    Volume:=TDiskVolume(Volume.Next);
   end;
 finally
  FVolumes.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetVolumeByNext(APrevious:TDiskVolume;ALock,AUnlock:Boolean;AState:LongWord):TDiskVolume;
var
 Volume:TDiskVolume;
begin
 {}
 Result:=nil;
 
 if not FVolumes.ReaderLock then Exit;
 try
  {Check Previous}
  if APrevious = nil then
   begin
    {Get First}
    Volume:=TDiskVolume(FVolumes.First);
    if Volume <> nil then
     begin
      {Lock Volume}
      if ALock then if AState = FILESYS_LOCK_READ then Volume.ReaderLock else Volume.WriterLock;
      
      {Return Result}
      Result:=Volume;
     end;
   end
  else
   begin
    {Get Next}
    Volume:=TDiskVolume(APrevious.Next);
    if Volume <> nil then
     begin
      {Lock Volume}
      if ALock then if AState = FILESYS_LOCK_READ then Volume.ReaderLock else Volume.WriterLock;
      
      {Return Result}
      Result:=Volume;
     end;

    {Unlock Previous}
    if AUnlock then if AState = FILESYS_LOCK_READ then APrevious.ReaderUnlock else APrevious.WriterUnlock;
   end;   
 finally
  FVolumes.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetNextVolumeNo:Integer;
begin
 {}
 Result:=1;
 
 while GetVolumeByNo(Result,False,FILESYS_LOCK_NONE) <> nil do {Do not lock}
  begin
   Inc(Result);
  end;
end;

{==============================================================================}

function TFileSysDriver.GetMaxVolumeNo:Integer;
var
 Volume:TDiskVolume;
begin
 {}
 Result:=1;

 if not FVolumes.ReaderLock then Exit;
 try
  Volume:=TDiskVolume(FVolumes.First);
  while Volume <> nil do
   begin
    if Volume.VolumeNo > Result then
     begin
      Result:=Volume.VolumeNo;
     end;
     
    Volume:=TDiskVolume(Volume.Next);
   end;
 finally
  FVolumes.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.AddDevice(ADevice:TDiskDevice):Boolean;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if ADevice = nil then Exit;
  
  {Acquire Lock}
  FDevices.WriterLock;

  {Add Device}
  Result:=FDevices.Add(ADevice);

  {Release Lock}
  FDevices.WriterUnlock;
 finally
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.RemoveDevice(ADevice:TDiskDevice):Boolean;
var
 Volume:TDiskVolume;
 Partition:TDiskPartition;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if ADevice = nil then Exit;
  
  {Update Enum Handles}
  UpdateEnumHandles(ADevice,nil,nil,nil,nil,nil); //To Do //Move within WriterLock, see notes ?
  
  {Acquire Lock}
  FDevices.WriterLock;
  try
   {Remove Device}
   Result:=FDevices.Remove(ADevice);
   if not Result then Exit;
  finally
   {Release Lock}
   FDevices.WriterUnlock;
  end; 
  
  {Release any Raw Handles on the Device}
  ReleaseRawHandles(ADevice,nil,nil,nil);
  
  {Release any CachePages on the Device}
  FCache.ReleaseDevicePages(ADevice);
  
  {Remove any Volume on the Device}
  Volume:=GetVolumeByDevice(ADevice,True,FILESYS_LOCK_WRITE);
  while Volume <> nil do
   begin
    Volume.Free;
    
    Volume:=GetVolumeByDevice(ADevice,True,FILESYS_LOCK_WRITE);
   end;
  
  {Remove any Partition on the Device}
  Partition:=GetPartitionByDevice(ADevice,True,FILESYS_LOCK_WRITE);
  while Partition <> nil do
   begin
    Partition.Free;
    
    Partition:=GetPartitionByDevice(ADevice,True,FILESYS_LOCK_WRITE);
   end;
 finally
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.CheckDevice(ADevice:TDiskDevice;ALock:Boolean;AState:LongWord):Boolean;
var
 Device:TDiskDevice;
begin
 {}
 Result:=False;

 if not FDevices.ReaderLock then Exit;
 try
  if ADevice = nil then Exit;
  
  Device:=TDiskDevice(FDevices.First);
  while Device <> nil do
   begin
    if Device = ADevice then
     begin
      {Lock Device} 
      if ALock then if AState = FILESYS_LOCK_READ then Device.ReaderLock else Device.WriterLock;
      
      Result:=True;
      Exit;
     end;
     
    Device:=TDiskDevice(Device.Next);
   end;
 finally
  FDevices.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetDeviceByNo(ADeviceNo:Integer;ALock:Boolean;AState:LongWord):TDiskDevice;
{Note: DeviceNo is zero based}
var
 Device:TDiskDevice;
begin
 {}
 Result:=nil;

 if not FDevices.ReaderLock then Exit;
 try
  if ADeviceNo = -1 then Exit;
  
  Device:=TDiskDevice(FDevices.First);
  while Device <> nil do
   begin
    if Device.DeviceNo = ADeviceNo then
     begin
      {Lock Device} 
      if ALock then if AState = FILESYS_LOCK_READ then Device.ReaderLock else Device.WriterLock;

      Result:=Device;
      Exit;
     end;
     
    Device:=TDiskDevice(Device.Next);
   end;
 finally
  FDevices.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetDeviceByName(const AName:String;ALock:Boolean;AState:LongWord):TDiskDevice;
var
 Device:TDiskDevice;
begin
 {}
 Result:=nil;

 if not FDevices.ReaderLock then Exit;
 try
  if Trim(AName) = '' then Exit;
  
  Device:=TDiskDevice(FDevices.First);
  while Device <> nil do
   begin
    if Uppercase(Device.Name) = Uppercase(AName) then
     begin
      {Lock Device} 
      if ALock then if AState = FILESYS_LOCK_READ then Device.ReaderLock else Device.WriterLock;

      Result:=Device;
      Exit;
     end;
     
    Device:=TDiskDevice(Device.Next);
   end;
 finally
  FDevices.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetDeviceByImage(AImage:TDiskImage;ALock:Boolean;AState:LongWord):TDiskDevice;
var
 Device:TDiskDevice;
begin
 {}
 Result:=nil;

 if not FDevices.ReaderLock then Exit;
 try
  if AImage = nil then Exit;
  
  Device:=TDiskDevice(FDevices.First);
  while Device <> nil do
   begin
    if Device.Image = AImage then
     begin
      {Lock Device} 
      if ALock then if AState = FILESYS_LOCK_READ then Device.ReaderLock else Device.WriterLock;

      Result:=Device;
      Exit;
     end;
     
    Device:=TDiskDevice(Device.Next);
   end;
 finally
  FDevices.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetDeviceByStorage(AStorage:PStorageDevice;ALock:Boolean;AState:LongWord):TDiskDevice;
var
 Device:TDiskDevice;
begin
 {}
 Result:=nil;
 
 if not FDevices.ReaderLock then Exit;
 try
  if AStorage = nil then Exit;
 
  Device:=TDiskDevice(FDevices.First);
  while Device <> nil do
   begin
    if Device.Storage = AStorage then
     begin
      {Lock Device} 
      if ALock then if AState = FILESYS_LOCK_READ then Device.ReaderLock else Device.WriterLock;

      Result:=Device;
      Exit;
     end;
    
    Device:=TDiskDevice(Device.Next);
   end;
 finally
  FDevices.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetDeviceByController(AController:TDiskController;ALock:Boolean;AState:LongWord):TDiskDevice;
{Returns the first Device on the specified Controller}
var
 Device:TDiskDevice;
begin
 {}
 Result:=nil;
 
 if not FDevices.ReaderLock then Exit;
 try
  if AController = nil then Exit;
 
  Device:=TDiskDevice(FDevices.First);
  while Device <> nil do
   begin
    if Device.Controller = AController then
     begin
      {Lock Device} 
      if ALock then if AState = FILESYS_LOCK_READ then Device.ReaderLock else Device.WriterLock;

      Result:=Device;
      Exit;
     end;
    
    Device:=TDiskDevice(Device.Next);
   end;
 finally
  FDevices.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetDevicesByController(AController:TDiskController;ALock:Boolean;AState:LongWord):TList;
{Returns all Devices on the specified Controller}
var
 Device:TDiskDevice;
begin
 {}
 Result:=TList.Create;
 
 if not FDevices.ReaderLock then Exit;
 try
  if AController = nil then Exit;
 
  Device:=TDiskDevice(FDevices.First);
  while Device <> nil do
   begin
    if Device.Controller = AController then
     begin
      {Lock Device} 
      if ALock then if AState = FILESYS_LOCK_READ then Device.ReaderLock else Device.WriterLock;

      Result.Add(Device);
     end;
    
    Device:=TDiskDevice(Device.Next);
   end;
 finally
  FDevices.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetDeviceByIdentifier(AController:TDiskController;const AIdentifier:String;ALock:Boolean;AState:LongWord):TDiskDevice;
{Returns the specified Device on the specified Controller}
var
 Device:TDiskDevice;
begin
 {}
 Result:=nil;

 if not FDevices.ReaderLock then Exit;
 try
  if AController = nil then Exit;
  
  Device:=TDiskDevice(FDevices.First);
  while Device <> nil do
   begin
    if Device.Controller = AController then
     begin
      if Device.Identifier = AIdentifier then
       begin
        {Lock Device} 
        if ALock then if AState = FILESYS_LOCK_READ then Device.ReaderLock else Device.WriterLock;

        Result:=Device;
        Exit;
       end;
     end;
     
    Device:=TDiskDevice(Device.Next);
   end;
 finally
  FDevices.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetDeviceByNext(APrevious:TDiskDevice;ALock,AUnlock:Boolean;AState:LongWord):TDiskDevice;
var
 Device:TDiskDevice;
begin
 {}
 Result:=nil;
 
 if not FDevices.ReaderLock then Exit;
 try
  {Check Previous}
  if APrevious = nil then
   begin
    {Get First}
    Device:=TDiskDevice(FDevices.First);
    if Device <> nil then
     begin
      {Lock Device}
      if ALock then if AState = FILESYS_LOCK_READ then Device.ReaderLock else Device.WriterLock;
      
      {Return Result}
      Result:=Device;
     end;
   end
  else
   begin
    {Get Next}
    Device:=TDiskDevice(APrevious.Next);
    if Device <> nil then
     begin
      {Lock Device}
      if ALock then if AState = FILESYS_LOCK_READ then Device.ReaderLock else Device.WriterLock;
      
      {Return Result}
      Result:=Device;
     end;

    {Unlock Previous}
    if AUnlock then if AState = FILESYS_LOCK_READ then APrevious.ReaderUnlock else APrevious.WriterUnlock;
   end;   
 finally
  FDevices.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetNextDeviceNo(AMediaType:TMediaType):Integer;
var
 Count:Integer;
begin
 {}
 Result:=-1;
 
 case AMediaType of
  mtFLOPPY:begin
    for Count:=MIN_FLOPPY_DEVICE to MAX_FLOPPY_DEVICE do
     begin
      if GetDeviceByNo(Count,False,FILESYS_LOCK_NONE) = nil then {Do not lock}
       begin
        Result:=Count;
        Exit;
       end;
     end;
   end;
  mtFIXED,mtREMOVABLE:begin
    for Count:=MIN_FIXED_DEVICE to MAX_FIXED_DEVICE do
     begin
      if GetDeviceByNo(Count,False,FILESYS_LOCK_NONE) = nil then {Do not lock}
       begin
        Result:=Count;
        Exit;
       end;
     end;
   end;
  mtCDROM,mtDVD:begin
    for Count:=MIN_CDROM_DEVICE to MAX_CDROM_DEVICE do
     begin
      if GetDeviceByNo(Count,False,FILESYS_LOCK_NONE) = nil then {Do not lock}
       begin
        Result:=Count;
        Exit;
       end;
     end;
   end;
  mtOTHER:begin
    for Count:=MIN_OTHER_DEVICE to MAX_OTHER_DEVICE do
     begin
      if GetDeviceByNo(Count,False,FILESYS_LOCK_NONE) = nil then {Do not lock}
       begin
        Result:=Count;
        Exit;
       end;
     end;
   end;
 end;
end;

{==============================================================================}

function TFileSysDriver.GetMaxDeviceNo(AMediaType:TMediaType):Integer;
var
 Device:TDiskDevice;
begin
 {}
 Result:=-1;
 
 if not FDevices.ReaderLock then Exit;
 try
  case AMediaType of
   mtFLOPPY:begin
     Result:=MIN_FLOPPY_DEVICE;
     
     Device:=TDiskDevice(FDevices.First);
     while Device <> nil do
      begin
       if (Device.DeviceNo >= MIN_FLOPPY_DEVICE) and (Device.DeviceNo <= MAX_FLOPPY_DEVICE) then
        begin
         if Device.DeviceNo > Result then
          begin
           Result:=Device.DeviceNo;
          end;
        end;
        
       Device:=TDiskDevice(Device.Next);
      end;
    end;
   mtFIXED,mtREMOVABLE:begin
     Result:=MIN_FIXED_DEVICE;
     
     Device:=TDiskDevice(FDevices.First);
     while Device <> nil do
      begin
       if (Device.DeviceNo >= MIN_FIXED_DEVICE) and (Device.DeviceNo <= MAX_FIXED_DEVICE) then
        begin
         if Device.DeviceNo > Result then
          begin
           Result:=Device.DeviceNo;
          end;
        end;
        
       Device:=TDiskDevice(Device.Next);
      end;
    end;
   mtCDROM,mtDVD:begin
     Result:=MIN_CDROM_DEVICE;
     
     Device:=TDiskDevice(FDevices.First);
     while Device <> nil do
      begin
       if (Device.DeviceNo >= MIN_CDROM_DEVICE) and (Device.DeviceNo <= MAX_CDROM_DEVICE) then
        begin
         if Device.DeviceNo > Result then
          begin
           Result:=Device.DeviceNo;
          end;
        end;
        
       Device:=TDiskDevice(Device.Next);
      end;
    end;
   mtOTHER:begin
     Result:=MIN_OTHER_DEVICE;
     
     Device:=TDiskDevice(FDevices.First);
     while Device <> nil do
      begin
       if (Device.DeviceNo >= MIN_OTHER_DEVICE) and (Device.DeviceNo <= MAX_OTHER_DEVICE) then
        begin
         if Device.DeviceNo > Result then
          begin
           Result:=Device.DeviceNo;
          end;
        end;
        
       Device:=TDiskDevice(Device.Next);
      end;
    end;
  end;
 finally
  FDevices.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.AddPartition(APartition:TDiskPartition):Boolean;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if APartition = nil then Exit;

  {Acquire Lock}
  FPartitions.WriterLock;

  {Add Partition}
  Result:=FPartitions.Add(APartition);

  {Release Lock}
  FPartitions.WriterUnlock;
 finally
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.RemovePartition(APartition:TDiskPartition):Boolean;
var
 Volume:TDiskVolume;
 Partition:TDiskPartition;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if APartition = nil then Exit;
  
  {Update Enum Handles}
  UpdateEnumHandles(nil,APartition,nil,nil,nil,nil); //To Do //Move within WriterLock, see notes ?
  
  {Acquire Lock}
  FPartitions.WriterLock;
  try
   {Remove Partition}
   Result:=FPartitions.Remove(APartition);
   if not Result then Exit;
  finally
   {Release Lock}
   FPartitions.WriterUnlock;
  end; 
  
  {Release any Raw Handles on the Partition}
  ReleaseRawHandles(nil,APartition,nil,nil);
  
  {Remove any Volume on the Partition}
  Volume:=GetVolumeByPartition(APartition,True,FILESYS_LOCK_WRITE);
  while Volume <> nil do
   begin
    Volume.Free;
    
    Volume:=GetVolumeByPartition(APartition,True,FILESYS_LOCK_WRITE);
   end;
   
  {Remove any Partition on the Partition}
  Partition:=GetPartitionByPartition(APartition,True,FILESYS_LOCK_WRITE);
  while Partition <> nil do
   begin
    Partition.Free;
    
    Partition:=GetPartitionByPartition(APartition,True,FILESYS_LOCK_WRITE);
   end;
 finally
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.CheckPartition(APartition:TDiskPartition;ALock:Boolean;AState:LongWord):Boolean;
var
 Partition:TDiskPartition;
begin
 {}
 Result:=False;

 if not FPartitions.ReaderLock then Exit;
 try
  if APartition = nil then Exit;
  
  Partition:=TDiskPartition(FPartitions.First);
  while Partition <> nil do
   begin
    if Partition = APartition then
     begin
      {Lock Partition} 
      if ALock then if AState = FILESYS_LOCK_READ then Partition.ReaderLock else Partition.WriterLock;
      
      Result:=True;
      Exit;
     end;
     
    Partition:=TDiskPartition(Partition.Next);
   end;
 finally
  FPartitions.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetPartitionByNo(ADevice:TDiskDevice;APartitionNo:Integer;AExtended,ALock:Boolean;AState:LongWord):TDiskPartition;
{Note: PartitionNo is one based}
var
 Partition:TDiskPartition;
begin
 {}
 Result:=nil;

 if not FPartitions.ReaderLock then Exit;
 try
  if ADevice = nil then Exit;
  if APartitionNo = 0 then Exit;
  
  Partition:=TDiskPartition(FPartitions.First);
  while Partition <> nil do
   begin
    if (Partition.Device = ADevice) and (Partition.PartitionNo = APartitionNo) and (Partition.Extended = AExtended) then
     begin
      {Lock Partition} 
      if ALock then if AState = FILESYS_LOCK_READ then Partition.ReaderLock else Partition.WriterLock;

      Result:=Partition;
      Exit;
     end;
     
    Partition:=TDiskPartition(Partition.Next);
   end;
 finally
  FPartitions.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetPartitionByName(ADevice:TDiskDevice;const AName:String;ALock:Boolean;AState:LongWord):TDiskPartition;
var
 Partition:TDiskPartition;
begin
 {}
 Result:=nil;

 if not FPartitions.ReaderLock then Exit;
 try
  if ADevice = nil then Exit;
  if Trim(AName) = '' then Exit;
  
  Partition:=TDiskPartition(FPartitions.First);
  while Partition <> nil do
   begin
    if (Partition.Device = ADevice) and (Uppercase(Partition.Name) = Uppercase(AName)) then
     begin
      {Lock Partition} 
      if ALock then if AState = FILESYS_LOCK_READ then Partition.ReaderLock else Partition.WriterLock;

      Result:=Partition;
      Exit;
     end;
     
    Partition:=TDiskPartition(Partition.Next);
   end;
 finally
  FPartitions.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetPartitionByPath(const APath:String;ALock:Boolean;AState:LongWord):TDiskPartition;
var
 Partition:TDiskPartition;
begin
 {}
 Result:=nil;

 if not FPartitions.ReaderLock then Exit;
 try
  if Trim(APath) = '' then Exit;
  
  Partition:=TDiskPartition(FPartitions.First);
  while Partition <> nil do
   begin
    if Uppercase(Partition.Path) = Uppercase(APath) then
     begin
      {Lock Partition} 
      if ALock then if AState = FILESYS_LOCK_READ then Partition.ReaderLock else Partition.WriterLock;

      Result:=Partition;
      Exit;
     end;
     
    Partition:=TDiskPartition(Partition.Next);
   end;
 finally
  FPartitions.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetPartitionByEntryNo(ADevice:TDiskDevice;APartition:TDiskPartition;AEntryNo:Integer;ALock:Boolean;AState:LongWord):TDiskPartition;
var
 Partition:TDiskPartition;
begin
 {}
 Result:=nil;

 if not FPartitions.ReaderLock then Exit;
 try
  if ADevice = nil then Exit;
  if AEntryNo < MIN_PARTITION then Exit;
  if AEntryNo > MAX_PARTITION then Exit;
  
  Partition:=TDiskPartition(FPartitions.First);
  while Partition <> nil do
   begin
    if (Partition.Device = ADevice) and (Partition.Partition = APartition) and (Partition.EntryNo = AEntryNo) then
     begin
      {Lock Partition} 
      if ALock then if AState = FILESYS_LOCK_READ then Partition.ReaderLock else Partition.WriterLock;

      Result:=Partition;
      Exit;
     end;
     
    Partition:=TDiskPartition(Partition.Next);
   end;
 finally
  FPartitions.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetPartitionByDevice(ADevice:TDiskDevice;ALock:Boolean;AState:LongWord):TDiskPartition;
{Returns the first Partition on the specified Device}
var
 Partition:TDiskPartition;
begin
 {}
 Result:=nil;

 if not FPartitions.ReaderLock then Exit;
 try
  if ADevice = nil then Exit;
  
  Partition:=TDiskPartition(FPartitions.First);
  while Partition <> nil do
   begin
    if Partition.Device = ADevice then
     begin
      {Lock Partition} 
      if ALock then if AState = FILESYS_LOCK_READ then Partition.ReaderLock else Partition.WriterLock;

      Result:=Partition;
      Exit;
     end;
     
    Partition:=TDiskPartition(Partition.Next);
   end;
 finally
  FPartitions.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetPartitionsByDevice(ADevice:TDiskDevice;ALock:Boolean;AState:LongWord):TList;
{Returns all Partitions on the specified Device}
var
 Partition:TDiskPartition;
begin
 {}
 Result:=TList.Create;

 if not FPartitions.ReaderLock then Exit;
 try
  if ADevice = nil then Exit;
  
  Partition:=TDiskPartition(FPartitions.First);
  while Partition <> nil do
   begin
    if Partition.Device = ADevice then
     begin
      {Lock Partition} 
      if ALock then if AState = FILESYS_LOCK_READ then Partition.ReaderLock else Partition.WriterLock;

      Result.Add(Partition);
     end;
     
    Partition:=TDiskPartition(Partition.Next);
   end;
 finally
  FPartitions.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetPartitionByPartition(APartition:TDiskPartition;ALock:Boolean;AState:LongWord):TDiskPartition;
{Returns the first Partition in the specified Partition}
var
 Partition:TDiskPartition;
begin
 {}
 Result:=nil;

 if not FPartitions.ReaderLock then Exit;
 try
  if APartition = nil then Exit;
  
  Partition:=TDiskPartition(FPartitions.First);
  while Partition <> nil do
   begin
    if (Partition.Partition = APartition) or (Partition.Root = APartition) then
     begin
      {Lock Partition} 
      if ALock then if AState = FILESYS_LOCK_READ then Partition.ReaderLock else Partition.WriterLock;

      Result:=Partition;
      Exit;
     end;
     
    Partition:=TDiskPartition(Partition.Next);
   end;
 finally
  FPartitions.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetPartitionsByPartition(APartition:TDiskPartition;ALock:Boolean;AState:LongWord):TList;
{Returns all Partitions in the specified Partition}
var
 Partition:TDiskPartition;
begin
 {}
 Result:=TList.Create;

 if not FPartitions.ReaderLock then Exit;
 try
  if APartition = nil then Exit;
  
  Partition:=TDiskPartition(FPartitions.First);
  while Partition <> nil do
   begin
    if (Partition.Partition = APartition) or (Partition.Root = APartition) then
     begin
      {Lock Partition} 
      if ALock then if AState = FILESYS_LOCK_READ then Partition.ReaderLock else Partition.WriterLock;

      Result.Add(Partition);
     end;
     
    Partition:=TDiskPartition(Partition.Next);
   end;
 finally
  FPartitions.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetPartitionByNext(APrevious:TDiskPartition;ALock,AUnlock:Boolean;AState:LongWord):TDiskPartition;
var
 Partition:TDiskPartition;
begin
 {}
 Result:=nil;
 
 if not FPartitions.ReaderLock then Exit;
 try
  {Check Previous}
  if APrevious = nil then
   begin
    {Get First}
    Partition:=TDiskPartition(FPartitions.First);
    if Partition <> nil then
     begin
      {Lock Partition}
      if ALock then if AState = FILESYS_LOCK_READ then Partition.ReaderLock else Partition.WriterLock;
      
      {Return Result}
      Result:=Partition;
     end;
   end
  else
   begin
    {Get Next}
    Partition:=TDiskPartition(APrevious.Next);
    if Partition <> nil then
     begin
      {Lock Partition}
      if ALock then if AState = FILESYS_LOCK_READ then Partition.ReaderLock else Partition.WriterLock;
      
      {Return Result}
      Result:=Partition;
     end;

    {Unlock Previous}
    if AUnlock then if AState = FILESYS_LOCK_READ then APrevious.ReaderUnlock else APrevious.WriterUnlock;
   end;   
 finally
  FPartitions.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetNextPartitionNo(ADevice:TDiskDevice;AExtended:Boolean):Integer;
begin
 {}
 Result:=0;

 if ADevice = nil then Exit;

 Result:=1;
 
 while GetPartitionByNo(ADevice,Result,AExtended,False,FILESYS_LOCK_NONE) <> nil do {Do not lock}
  begin
   Inc(Result);
  end;
end;

{==============================================================================}

function TFileSysDriver.GetMaxPartitionNo(ADevice:TDiskDevice;AExtended:Boolean):Integer;
var
 Partition:TDiskPartition;
begin
 {}
 Result:=0;

 if not FPartitions.ReaderLock then Exit;
 try
  if ADevice = nil then Exit;
  
  Result:=1;
  
  Partition:=TDiskPartition(FPartitions.First);
  while Partition <> nil do
   begin
    if (Partition.Device = ADevice) and (Partition.Extended = AExtended) then
     begin
      if Partition.PartitionNo > Result then
       begin
        Result:=Partition.PartitionNo;
       end;
     end;
     
    Partition:=TDiskPartition(Partition.Next);
   end;
 finally
  FPartitions.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.AddController(AController:TDiskController):Boolean;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  if AController = nil then Exit;
 
  {Acquire Lock}
  FControllers.WriterLock;

  {Add Controller}
  Result:=FControllers.Add(AController);

  {Release Lock}
  FControllers.WriterUnlock;
 finally
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.RemoveController(AController:TDiskController):Boolean;
var
 Device:TDiskDevice;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  if AController = nil then Exit;
 
  {Acquire Lock}
  FControllers.WriterLock;
  try
   Result:=FControllers.Remove(AController);
   if not Result then Exit;
  finally
   {Release Lock}
   FControllers.WriterUnlock;
  end; 
 
  {Remove any Device on the Controller}
  Device:=GetDeviceByController(AController,True,FILESYS_LOCK_WRITE);
  while Device <> nil do
   begin
    Device.Free;
   
    Device:=GetDeviceByController(AController,True,FILESYS_LOCK_WRITE);
   end;
 finally
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.CheckController(AController:TDiskController;ALock:Boolean;AState:LongWord):Boolean;
var
 Controller:TDiskController;
begin
 {}
 Result:=False;

 if not FControllers.ReaderLock then Exit;
 try
  if AController = nil then Exit;
  
  Controller:=TDiskController(FControllers.First);
  while Controller <> nil do
   begin
    if Controller = AController then
     begin
      {Lock Controller} 
      if ALock then if AState = FILESYS_LOCK_READ then Controller.ReaderLock else Controller.WriterLock;
      
      Result:=True;
      Exit;
     end;
     
    Controller:=TDiskController(Controller.Next);
   end;
 finally
  FControllers.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetControllerByNo(AControllerNo:Integer;ALock:Boolean;AState:LongWord):TDiskController;
{Note: ControllerNo is zero based}
var
 Controller:TDiskController;
begin
 {}
 Result:=nil;

 if not FControllers.ReaderLock then Exit;
 try
  if AControllerNo = -1 then Exit;
  
  Controller:=TDiskController(FControllers.First);
  while Controller <> nil do
   begin
    if Controller.ControllerNo = AControllerNo then
     begin
      {Lock Controller} 
      if ALock then if AState = FILESYS_LOCK_READ then Controller.ReaderLock else Controller.WriterLock;

      Result:=Controller;
      Exit;
     end;
     
    Controller:=TDiskController(Controller.Next);
   end;
 finally
  FControllers.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetControllerByName(const AName:String;ALock:Boolean;AState:LongWord):TDiskController;
var
 Controller:TDiskController;
begin
 {}
 Result:=nil;

 if not FControllers.ReaderLock then Exit;
 try
  if Trim(AName) = '' then Exit;
  
  Controller:=TDiskController(FControllers.First);
  while Controller <> nil do
   begin
    if Uppercase(Controller.Name) = Uppercase(AName) then
     begin
      {Lock Controller} 
      if ALock then if AState = FILESYS_LOCK_READ then Controller.ReaderLock else Controller.WriterLock;

      Result:=Controller;
      Exit;
     end;
     
    Controller:=TDiskController(Controller.Next);
   end;
 finally
  FControllers.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetControllerByNext(APrevious:TDiskController;ALock,AUnlock:Boolean;AState:LongWord):TDiskController;
var
 Controller:TDiskController;
begin
 {}
 Result:=nil;
 
 if not FControllers.ReaderLock then Exit;
 try
  {Check Previous}
  if APrevious = nil then
   begin
    {Get First}
    Controller:=TDiskController(FControllers.First);
    if Controller <> nil then
     begin
      {Lock Controller}
      if ALock then if AState = FILESYS_LOCK_READ then Controller.ReaderLock else Controller.WriterLock;
      
      {Return Result}
      Result:=Controller;
     end;
   end
  else
   begin
    {Get Next}
    Controller:=TDiskController(APrevious.Next);
    if Controller <> nil then
     begin
      {Lock Controller}
      if ALock then if AState = FILESYS_LOCK_READ then Controller.ReaderLock else Controller.WriterLock;
      
      {Return Result}
      Result:=Controller;
     end;

    {Unlock Previous}
    if AUnlock then if AState = FILESYS_LOCK_READ then APrevious.ReaderUnlock else APrevious.WriterUnlock;
   end;   
 finally
  FControllers.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetNextControllerNo:Integer;
begin
 {}
 Result:=0;
 
 while GetControllerByNo(Result,False,FILESYS_LOCK_NONE) <> nil do {Do not lock}
  begin
   Inc(Result);
  end;
end;

{==============================================================================}

function TFileSysDriver.GetMaxControllerNo:Integer;
var
 Controller:TDiskController;
begin
 {}
 Result:=0;

 if not FControllers.ReaderLock then Exit;
 try
  Controller:=TDiskController(FControllers.First);
  while Controller <> nil do
   begin
    if Controller.ControllerNo > Result then
     begin
      Result:=Controller.ControllerNo;
     end;
    Controller:=TDiskController(Controller.Next);
   end;
 finally
  FControllers.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.AddRecognizer(ARecognizer:TRecognizer):Boolean;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if ARecognizer = nil then Exit;
  
  {Acquire Lock}
  FRecognizers.WriterLock;

  {Add Recognizer}
  Result:=FRecognizers.Add(ARecognizer);

  {Release Lock}
  FRecognizers.WriterUnlock;
 finally
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.RemoveRecognizer(ARecognizer:TRecognizer):Boolean;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if ARecognizer = nil then Exit;
  
  {Acquire Lock}
  FRecognizers.WriterLock;

  {Remove Recognizer}
  Result:=FRecognizers.Remove(ARecognizer);

  {Release Lock}
  FRecognizers.WriterUnlock;
 finally
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.CheckRecognizer(ARecognizer:TRecognizer;ALock:Boolean;AState:LongWord):Boolean;
var
 Recognizer:TRecognizer;
begin
 {}
 Result:=False;

 if not FRecognizers.ReaderLock then Exit;
 try
  if ARecognizer = nil then Exit;

  Recognizer:=TRecognizer(FRecognizers.First);
  while Recognizer <> nil do
   begin
    if Recognizer = ARecognizer then
     begin
      {Lock Recognizer} 
      if ALock then if AState = FILESYS_LOCK_READ then Recognizer.ReaderLock else Recognizer.WriterLock;
      
      Result:=True;
      Exit;
     end;
     
    Recognizer:=TRecognizer(Recognizer.Next);
   end;
 finally
  FRecognizers.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetRecognizerByImage(AImage:TDiskImage;ALock:Boolean;AState:LongWord):TRecognizer;
var
 Recognizer:TRecognizer;
begin
 {}
 Result:=nil;

 if not FRecognizers.ReaderLock then Exit;
 try
  if AImage = nil then Exit;

  Recognizer:=TRecognizer(FRecognizers.First);
  while Recognizer <> nil do
   begin
    if Recognizer.RecognizeImage(AImage) then
     begin
      {Lock Recognizer} 
      if ALock then if AState = FILESYS_LOCK_READ then Recognizer.ReaderLock else Recognizer.WriterLock;

      Result:=Recognizer;
      Exit;
     end;
     
    Recognizer:=TRecognizer(Recognizer.Next);
   end;
 finally
  FRecognizers.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetRecognizerByVolume(AVolume:TDiskVolume;ALock:Boolean;AState:LongWord):TRecognizer;
var
 Recognizer:TRecognizer;
begin
 {}
 Result:=nil;

 if not FRecognizers.ReaderLock then Exit;
 try
  if AVolume = nil then Exit;
  if not AVolume.Recognizable then Exit;

  Recognizer:=TRecognizer(FRecognizers.First);
  while Recognizer <> nil do
   begin
    if Recognizer.RecognizeVolume(AVolume) then
     begin
      {Lock Recognizer} 
      if ALock then if AState = FILESYS_LOCK_READ then Recognizer.ReaderLock else Recognizer.WriterLock;

      Result:=Recognizer;
      Exit;
     end;
     
    Recognizer:=TRecognizer(Recognizer.Next);
   end;
 finally
  FRecognizers.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetRecognizerByPartition(APartition:TDiskPartition;ALock:Boolean;AState:LongWord):TRecognizer;
var
 Recognizer:TRecognizer;
begin
 {}
 Result:=nil;

 if not FRecognizers.ReaderLock then Exit;
 try
  if APartition = nil then Exit;
  if not APartition.Recognizable then Exit;

  Recognizer:=TRecognizer(FRecognizers.First);
  while Recognizer <> nil do
   begin
    if Recognizer.RecognizePartition(APartition) then
     begin
      {Lock Recognizer} 
      if ALock then if AState = FILESYS_LOCK_READ then Recognizer.ReaderLock else Recognizer.WriterLock;

      Result:=Recognizer;
      Exit;
     end;
     
    Recognizer:=TRecognizer(Recognizer.Next);
   end;
 finally
  FRecognizers.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetRecognizerByPartitionId(APartitionId:Byte;ALock:Boolean;AState:LongWord):TRecognizer;       
var
 Recognizer:TRecognizer;
begin
 {}
 Result:=nil;

 if not FRecognizers.ReaderLock then Exit;
 try
  if APartitionId = pidUnused then Exit;

  Recognizer:=TRecognizer(FRecognizers.First);
  while Recognizer <> nil do
   begin
    if Recognizer.RecognizePartitionId(APartitionId) then
     begin
      {Lock Recognizer} 
      if ALock then if AState = FILESYS_LOCK_READ then Recognizer.ReaderLock else Recognizer.WriterLock;

      Result:=Recognizer;
      Exit;
     end;
     
    Recognizer:=TRecognizer(Recognizer.Next);
   end;
 finally
  FRecognizers.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetRecognizerByBootSector(ABootSector:PBootSector;const AStartSector,ASectorCount:Int64;ALock:Boolean;AState:LongWord):TRecognizer;
var
 Recognizer:TRecognizer;
begin
 {}
 Result:=nil;

 if not FRecognizers.ReaderLock then Exit;
 try
  if ABootSector = nil then Exit;
  if ASectorCount = 0 then Exit;

  Recognizer:=TRecognizer(FRecognizers.First);
  while Recognizer <> nil do
   begin
    if Recognizer.RecognizeBootSector(ABootSector,AStartSector,ASectorCount) then
     begin
      {Lock Recognizer} 
      if ALock then if AState = FILESYS_LOCK_READ then Recognizer.ReaderLock else Recognizer.WriterLock;

      Result:=Recognizer;
      Exit;
     end;
     
    Recognizer:=TRecognizer(Recognizer.Next);
   end;
 finally
  FRecognizers.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetRecognizerByNext(APrevious:TRecognizer;ALock,AUnlock:Boolean;AState:LongWord):TRecognizer;
var
 Recognizer:TRecognizer;
begin
 {}
 Result:=nil;
 
 if not FRecognizers.ReaderLock then Exit;
 try
  {Check Previous}
  if APrevious = nil then
   begin
    {Get First}
    Recognizer:=TRecognizer(FRecognizers.First);
    if Recognizer <> nil then
     begin
      {Lock Recognizer}
      if ALock then if AState = FILESYS_LOCK_READ then Recognizer.ReaderLock else Recognizer.WriterLock;
      
      {Return Result}
      Result:=Recognizer;
     end;
   end
  else
   begin
    {Get Next}
    Recognizer:=TRecognizer(APrevious.Next);
    if Recognizer <> nil then
     begin
      {Lock Recognizer}
      if ALock then if AState = FILESYS_LOCK_READ then Recognizer.ReaderLock else Recognizer.WriterLock;
      
      {Return Result}
      Result:=Recognizer;
     end;

    {Unlock Previous}
    if AUnlock then if AState = FILESYS_LOCK_READ then APrevious.ReaderUnlock else APrevious.WriterUnlock;
   end;   
 finally
  FRecognizers.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.AddRedirector(ARedirector:TRedirector):Boolean;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if ARedirector = nil then Exit;
  
  {Acquire Lock}
  FRedirectors.WriterLock;

  {Add Redirector}
  Result:=FRedirectors.Add(ARedirector);

  {Release Lock}
  FRedirectors.WriterUnlock;
 finally
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.RemoveRedirector(ARedirector:TRedirector):Boolean;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if ARedirector = nil then Exit;
  
  {Acquire Lock}
  FRedirectors.WriterLock;

  {Remove Redirector}
  Result:=FRedirectors.Remove(ARedirector);

  {Release Lock}
  FRedirectors.WriterUnlock;
 finally
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.CheckRedirector(ARedirector:TRedirector;ALock:Boolean;AState:LongWord):Boolean;
var
 Redirector:TRedirector;
begin
 {}
 Result:=False;

 if not FRedirectors.ReaderLock then Exit;
 try
  if ARedirector = nil then Exit;

  Redirector:=TRedirector(FRedirectors.First);
  while Redirector <> nil do
   begin
    if Redirector = ARedirector then
     begin
      {Lock Redirector} 
      if ALock then if AState = FILESYS_LOCK_READ then Redirector.ReaderLock else Redirector.WriterLock;
      
      Result:=True;
      Exit;
     end;
     
    Redirector:=TRedirector(Redirector.Next);
   end;
 finally
  FRedirectors.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetRedirectorByPath(const APath:String;ALock:Boolean;AState:LongWord):TRedirector;
var
 Redirector:TRedirector;
begin
 {}
 Result:=nil;

 if not FRedirectors.ReaderLock then Exit;
 try
  if Length(APath) = 0 then Exit;

  Redirector:=TRedirector(FRedirectors.First);
  while Redirector <> nil do
   begin
    if Redirector.RedirectPath(APath) then
     begin
      {Lock Redirector} 
      if ALock then if AState = FILESYS_LOCK_READ then Redirector.ReaderLock else Redirector.WriterLock;

      Result:=Redirector;
      Exit;
     end;
     
    Redirector:=TRedirector(Redirector.Next);
   end;
 finally
  FRedirectors.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetRedirectorByDrive(ADrive:TDiskDrive;ALock:Boolean;AState:LongWord):TRedirector;
var
 Redirector:TRedirector;
begin
 {}
 Result:=nil;

 if not FRedirectors.ReaderLock then Exit;
 try
  if ADrive = nil then Exit;

  Redirector:=TRedirector(FRedirectors.First);
  while Redirector <> nil do
   begin
    if Redirector.RedirectDrive(ADrive) then
     begin
      {Lock Redirector} 
      if ALock then if AState = FILESYS_LOCK_READ then Redirector.ReaderLock else Redirector.WriterLock;

      Result:=Redirector;
      Exit;
     end;
     
    Redirector:=TRedirector(Redirector.Next);
   end;
 finally
  FRedirectors.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetRedirectorByNext(APrevious:TRedirector;ALock,AUnlock:Boolean;AState:LongWord):TRedirector;
var
 Redirector:TRedirector;
begin
 {}
 Result:=nil;
 
 if not FRedirectors.ReaderLock then Exit;
 try
  {Check Previous}
  if APrevious = nil then
   begin
    {Get First}
    Redirector:=TRedirector(FRedirectors.First);
    if Redirector <> nil then
     begin
      {Lock Redirector}
      if ALock then if AState = FILESYS_LOCK_READ then Redirector.ReaderLock else Redirector.WriterLock;
      
      {Return Result}
      Result:=Redirector;
     end;
   end
  else
   begin
    {Get Next}
    Redirector:=TRedirector(APrevious.Next);
    if Redirector <> nil then
     begin
      {Lock Redirector}
      if ALock then if AState = FILESYS_LOCK_READ then Redirector.ReaderLock else Redirector.WriterLock;
      
      {Return Result}
      Result:=Redirector;
     end;

    {Unlock Previous}
    if AUnlock then if AState = FILESYS_LOCK_READ then APrevious.ReaderUnlock else APrevious.WriterUnlock;
   end;   
 finally
  FRedirectors.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.AddFileSystem(AFileSystem:TFileSystem):Boolean;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if AFileSystem = nil then Exit;
  
  {Acquire Lock}
  FFileSystems.WriterLock;

  {Add FileSystem}
  Result:=FFileSystems.Add(AFileSystem);

  {Release Lock}
  FFileSystems.WriterUnlock;
 finally
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.RemoveFileSystem(AFileSystem:TFileSystem):Boolean;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if AFileSystem = nil then Exit;
  
  {Acquire Lock}
  FFileSystems.WriterLock;
  try
   {Remove FileSystem}
   Result:=FFileSystems.Remove(AFileSystem);
   if not Result then Exit;
  finally
   {Release Lock}
   FFileSystems.WriterUnlock;
  end; 
  
  {Release any Enum Handles on the FileSystem}
  ReleaseEnumHandles(AFileSystem);
  
  {Note: The FileSystem will automatically unbind from any volume/drive when Destroyed}
 finally
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.CheckFileSystem(AFileSystem:TFileSystem;ALock:Boolean;AState:LongWord):Boolean;
var
 FileSystem:TFileSystem;
begin
 {}
 Result:=False;

 if not FFileSystems.ReaderLock then Exit;
 try
  if AFileSystem = nil then Exit;
  
  FileSystem:=TFileSystem(FFileSystems.First);
  while FileSystem <> nil do
   begin
    if FileSystem = AFileSystem then
     begin
      {Lock FileSystem} 
      if ALock then if AState = FILESYS_LOCK_READ then FileSystem.ReaderLock else FileSystem.WriterLock;
      
      Result:=True;
      Exit;
     end;
     
    FileSystem:=TFileSystem(FileSystem.Next);
   end;
 finally
  FFileSystems.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetFileSystemByDrive(ADrive:TDiskDrive;ALock:Boolean;AState:LongWord):TFileSystem;
var
 FileSystem:TFileSystem;
begin
 {}
 Result:=nil;

 if not FFileSystems.ReaderLock then Exit;
 try
  if ADrive = nil then Exit;
  
  FileSystem:=TFileSystem(FFileSystems.First);
  while FileSystem <> nil do
   begin
    if FileSystem.Drive = ADrive then
     begin
      {Lock FileSystem} 
      if ALock then if AState = FILESYS_LOCK_READ then FileSystem.ReaderLock else FileSystem.WriterLock;

      Result:=FileSystem;
      Exit;
     end;
     
    FileSystem:=TFileSystem(FileSystem.Next);
   end;
 finally
  FFileSystems.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetFileSystemByVolume(AVolume:TDiskVolume;ALock:Boolean;AState:LongWord):TFileSystem;
var
 FileSystem:TFileSystem;
begin
 {}
 Result:=nil;

 if not FFileSystems.ReaderLock then Exit;
 try
  if AVolume = nil then Exit;
  
  FileSystem:=TFileSystem(FFileSystems.First);
  while FileSystem <> nil do
   begin
    if FileSystem.Volume = AVolume then
     begin
      {Lock FileSystem} 
      if ALock then if AState = FILESYS_LOCK_READ then FileSystem.ReaderLock else FileSystem.WriterLock;

      Result:=FileSystem;
      Exit;
     end;
     
    FileSystem:=TFileSystem(FileSystem.Next);
   end;
 finally
  FFileSystems.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetFileSystemByRootName(const AName:String;ALock:Boolean;AState:LongWord):TFileSystem;
var
 FileSystem:TFileSystem;
begin
 {}
 Result:=nil;

 if not FFileSystems.ReaderLock then Exit;
 try
  if Length(AName) = 0 then Exit;
  
  FileSystem:=TFileSystem(FFileSystems.First);
  while FileSystem <> nil do
   begin
    if Uppercase(Trim(FileSystem.RootName)) = Uppercase(Trim(AName)) then
     begin
      {Lock FileSystem} 
      if ALock then if AState = FILESYS_LOCK_READ then FileSystem.ReaderLock else FileSystem.WriterLock;

      Result:=FileSystem;
      Exit;
     end;
     
    FileSystem:=TFileSystem(FileSystem.Next);
   end;
 finally
  FFileSystems.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetFileSystemByRootPath(const APath:String;ALock:Boolean;AState:LongWord):TFileSystem;
var
 FileSystem:TFileSystem;
begin
 {}
 Result:=nil;

 if not FFileSystems.ReaderLock then Exit;
 try
  if Length(APath) = 0 then Exit;
  
  FileSystem:=TFileSystem(FFileSystems.First);
  while FileSystem <> nil do
   begin
    if Uppercase(Trim(FileSystem.RootPath)) = Uppercase(Trim(APath)) then
     begin
      {Lock FileSystem} 
      if ALock then if AState = FILESYS_LOCK_READ then FileSystem.ReaderLock else FileSystem.WriterLock;

      Result:=FileSystem;
      Exit;
     end;
     
    FileSystem:=TFileSystem(FileSystem.Next);
   end;
 finally
  FFileSystems.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetFileSystemByNext(APrevious:TFileSystem;ALock,AUnlock:Boolean;AState:LongWord):TFileSystem;
var
 FileSystem:TFileSystem;
begin
 {}
 Result:=nil;
 
 if not FFileSystems.ReaderLock then Exit;
 try
  {Check Previous}
  if APrevious = nil then
   begin
    {Get First}
    FileSystem:=TFileSystem(FFileSystems.First);
    if FileSystem <> nil then
     begin
      {Lock FileSystem}
      if ALock then if AState = FILESYS_LOCK_READ then FileSystem.ReaderLock else FileSystem.WriterLock;
      
      {Return Result}
      Result:=FileSystem;
     end;
   end
  else
   begin
    {Get Next}
    FileSystem:=TFileSystem(APrevious.Next);
    if FileSystem <> nil then
     begin
      {Lock FileSystem}
      if ALock then if AState = FILESYS_LOCK_READ then FileSystem.ReaderLock else FileSystem.WriterLock;
      
      {Return Result}
      Result:=FileSystem;
     end;

    {Unlock Previous}
    if AUnlock then if AState = FILESYS_LOCK_READ then APrevious.ReaderUnlock else APrevious.WriterUnlock;
   end;   
 finally
  FFileSystems.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.LocateDevices:Boolean;
var
 Controller:TDiskController;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.LocateDevices');
  {$ENDIF}

  {Scan each Controller for Devices}
  Controller:=GetControllerByNext(nil,True,False,FILESYS_LOCK_READ); 
  while Controller <> nil do
   begin
    Controller.LocateDevices;
    
    Controller:=GetControllerByNext(Controller,True,True,FILESYS_LOCK_READ); 
   end;
   
  Result:=True;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.LocatePartitions:Boolean;
var
 Device:TDiskDevice;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.LocatePartitions');
  {$ENDIF}

  {Scan each Device for Partitions}
  Device:=GetDeviceByNext(nil,True,False,FILESYS_LOCK_WRITE); 
  while Device <> nil do
   begin
    Device.LocatePartitions;
    
    Device:=GetDeviceByNext(Device,True,True,FILESYS_LOCK_WRITE);
   end;
   
  Result:=True;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.LocateVolumes:Boolean;
var
 Device:TDiskDevice;
 DeviceCount:Integer;
 PartitionCount:Integer;
 Partition:TDiskPartition;
begin
 {}
 Result:=False;
    
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.LocateVolumes');
  {$ENDIF}

  {Check for Floppy}
  if FAllowFloppy then
   begin
    {Scan for Floppy Devices}
    for DeviceCount:=MIN_FLOPPY_DEVICE to GetMaxDeviceNo(mtFLOPPY) do
     begin
      Device:=GetDeviceByNo(DeviceCount,True,FILESYS_LOCK_WRITE);
      if Device <> nil then
       begin
        case Device.MediaType of
         mtFLOPPY:begin
           {Locate Volumes}
           Device.LocateVolumes;
          end;
        end;
       
        {Unlock Device}
        Device.WriterUnlock;
       end;
     end;
   end;
   
  {Scan for Fixed Devices (Active or First Primary Partitions)}
  for DeviceCount:=MIN_FIXED_DEVICE to GetMaxDeviceNo(mtFIXED) do {GetMaxDeviceNo(mtFIXED) includes mtREMOVABLE}
   begin
    Device:=GetDeviceByNo(DeviceCount,True,FILESYS_LOCK_WRITE);
    if Device <> nil then
     begin
      case Device.MediaType of
       mtFIXED,mtREMOVABLE:begin
         {Scan for Active Primary Partition}
         for PartitionCount:=1 to GetMaxPartitionNo(Device,False) do
          begin
           Partition:=GetPartitionByNo(Device,PartitionCount,False,True,FILESYS_LOCK_WRITE);
           if Partition <> nil then
            begin
             try
              {Check if Partition has no Parent is Active and is Recognized}
              if (Partition.Partition = nil) and (Partition.Active) and (Partition.Recognized) then
               begin
                {Check for Non Volume or Multi Volume}
                if not(Partition.NonVolume) and not(Partition.MultiVolume) then
                 begin
                  {Locate Volumes}
                  Partition.LocateVolumes;
                  Break; {Break on Active Primary Partition}
                 end;
               end;
             finally
              {Unlock Partition}
              Partition.WriterUnlock;
             end;
            end;
          end;
          
         {Check for Volume}
         if GetVolumeByDevice(Device,False,FILESYS_LOCK_NONE) = nil then {Do not lock}
          begin
           {Scan for First Primary Partition}
           for PartitionCount:=1 to GetMaxPartitionNo(Device,False) do
            begin
             Partition:=GetPartitionByNo(Device,PartitionCount,False,True,FILESYS_LOCK_WRITE);
             if Partition <> nil then
              begin
               try
                {Check if Partition has no Parent and is Recognized}
                if (Partition.Partition = nil) and (Partition.Recognized) then
                 begin
                  {Check for Non Volume or Multi Volume}
                  if not(Partition.NonVolume) and not(Partition.MultiVolume) then
                   begin
                    {Locate Volumes}
                    Partition.LocateVolumes;
                    Break; {Break on First Primary Partition}
                   end;
                 end;
               finally
                {Unlock Partition}
                Partition.WriterUnlock;
               end;               
              end;
            end;
          end;
        end;
      end;
     
      {Unlock Device}
      Device.WriterUnlock;
     end;
   end;
     
  {Scan for Fixed Devices (Extended Partitions)}
  for DeviceCount:=MIN_FIXED_DEVICE to GetMaxDeviceNo(mtFIXED) do {GetMaxDeviceNo(mtFIXED) includes mtREMOVABLE}
   begin
    Device:=GetDeviceByNo(DeviceCount,True,FILESYS_LOCK_WRITE);
    if Device <> nil then
     begin
      case Device.MediaType of
       mtFIXED,mtREMOVABLE:begin
         {Scan for Extended Partitions}
         for PartitionCount:=1 to GetMaxPartitionNo(Device,False) do
          begin
           Partition:=GetPartitionByNo(Device,PartitionCount,False,True,FILESYS_LOCK_WRITE);
           if Partition <> nil then
            begin
             {Check if Partition has a Parent and is Recognized}
             if (Partition.Partition <> nil) and (Partition.Recognized) then
              begin
               {Check for Non Volume or Multi Volume}
               if not(Partition.NonVolume) and not(Partition.MultiVolume) then
                begin
                 {Locate Volumes}
                 Partition.LocateVolumes;
                end
               else if Partition.MultiVolume then
                begin
                 {Locate Volumes}
                 Partition.LocateVolumes;
                end;
              end;
              
             {Unlock Partition}
             Partition.WriterUnlock;
            end;
          end;
        end;
      end;
     
     
      {Unlock Device}
      Device.WriterUnlock;
     end;
   end;
     
  {Scan for Fixed Devices (Primary Partitions)}
  for DeviceCount:=MIN_FIXED_DEVICE to GetMaxDeviceNo(mtFIXED) do {GetMaxDeviceNo(mtFIXED) includes mtREMOVABLE}
   begin
    Device:=GetDeviceByNo(DeviceCount,True,FILESYS_LOCK_WRITE);
    if Device <> nil then
     begin
      case Device.MediaType of
       mtFIXED,mtREMOVABLE:begin
         {Scan for Primary Partitions}
         for PartitionCount:=1 to GetMaxPartitionNo(Device,False) do
          begin
           Partition:=GetPartitionByNo(Device,PartitionCount,False,True,FILESYS_LOCK_WRITE);
           if Partition <> nil then
            begin
             {Check if Partition has no Parent and is Recognized}
             if (Partition.Partition = nil) and (Partition.Recognized) then
              begin
               {Check for Non Volume or Multi Volume}
               if not(Partition.NonVolume) and not(Partition.MultiVolume) then
                begin
                 {Locate Volumes}
                 Partition.LocateVolumes;
                end
               else if Partition.MultiVolume then
                begin
                 {Locate Volumes}
                 Partition.LocateVolumes;
                end;
              end;
              
             {Unlock Partition}
             Partition.WriterUnlock;
            end;
          end;
        end;
      end;
     
      {Unlock Device}
      Device.WriterUnlock;
     end;
   end;
  
  {Scan for Removable Devices}
  for DeviceCount:=MIN_FIXED_DEVICE to GetMaxDeviceNo(mtREMOVABLE) do {GetMaxDeviceNo(mtREMOVABLE) includes mtFIXED}
   begin
    Device:=GetDeviceByNo(DeviceCount,True,FILESYS_LOCK_WRITE);
    if Device <> nil then
     begin
      case Device.MediaType of
       mtREMOVABLE:begin
         {Locate Volumes}
         Device.LocateVolumes;
        end;
      end;
     
      {Unlock Device}
      Device.WriterUnlock;
     end;
   end;
    
  {Scan for CDROM and DVD Devices}
  for DeviceCount:=MIN_CDROM_DEVICE to GetMaxDeviceNo(mtCDROM) do {GetMaxDeviceNo(mtCDROM) includes mtDVD}
   begin
    Device:=GetDeviceByNo(DeviceCount,True,FILESYS_LOCK_WRITE);
    if Device <> nil then
     begin
      case Device.MediaType of
       mtCDROM,mtDVD:begin
         {Locate Volumes}
         Device.LocateVolumes;
        end;
      end;
     
      {Unlock Device}
      Device.WriterUnlock;
     end;
   end;
    
  {Scan for Other Devices}
  for DeviceCount:=MIN_OTHER_DEVICE to GetMaxDeviceNo(mtOTHER) do
   begin
    Device:=GetDeviceByNo(DeviceCount,True,FILESYS_LOCK_WRITE);
    if Device <> nil then
     begin
      case Device.MediaType of
       mtOTHER:begin
         {Locate Volumes}
         Device.LocateVolumes;
        end;
      end;
     
      {Unlock Device}
      Device.WriterUnlock;
     end;
   end;
    
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.LocateVolumes completed');
  {$ENDIF}
    
  Result:=True;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.LocateDrives:Boolean;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
 DriveCount:Integer;
 VolumeCount:Integer;
 Recognizer:TRecognizer;
 Redirector:TRedirector;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.LocateDrives');
  {$ENDIF}

  {Scan for Volumes}
  for VolumeCount:=1 to GetMaxVolumeNo do
   begin
    Volume:=GetVolumeByNo(VolumeCount,True,FILESYS_LOCK_WRITE);
    if Volume <> nil then
     begin
      if Volume.Device <> nil then
       begin
        {Get the Recognizer}
        Recognizer:=GetRecognizerByVolume(Volume,True,FILESYS_LOCK_READ);
        if Recognizer <> nil then
         begin
          {Check Drive}
          Drive:=GetDriveByVolume(Volume,False,FILESYS_LOCK_NONE); {Do not lock}
          if Drive = nil then
           begin
            {Get Drive}
            DriveCount:=GetNextDriveNo(Volume.Device.MediaType);
            if (FAllowDrives) and (Recognizer.AllowDrive) and (DriveCount <> INVALID_DRIVE) then
             begin
              {$IFDEF FILESYS_DEBUG}
              if FILESYS_LOG_ENABLED then FileSysLogDebug(' Creating Drive ' + DRIVE_NAMES[DriveCount] + ' on Volume ' + Volume.Name);
              {$ENDIF}
              
              {Create Drive}
              Drive:=TDiskDrive.Create(Self,Volume,DriveCount);
              Drive.DriveInit;
              
              {$IFDEF FILESYS_DEBUG}
              if FILESYS_LOG_ENABLED then FileSysLogDebug(' Mounting Volume ' + Volume.Name);
              {$ENDIF}
              
              {Mount Volume}
              Recognizer.MountVolume(Volume,Drive);
             end
            else
             begin
              {$IFDEF FILESYS_DEBUG}
              if FILESYS_LOG_ENABLED then FileSysLogDebug(' Mounting Volume ' + Volume.Name);
              {$ENDIF}
              
              {Mount Volume}
              Recognizer.MountVolume(Volume,nil);
             end;
           end;
           
          {Unlock Recognizer}
          Recognizer.ReaderUnlock;
         end;
       end;
       
      {Unlock Volume}
      Volume.WriterUnlock;
     end;
   end;
       
  {Scan each Redirector for Drives}
  Redirector:=GetRedirectorByNext(nil,True,False,FILESYS_LOCK_READ); 
  while Redirector <> nil do
   begin
    Redirector.LocateDrives;
    
    Redirector:=GetRedirectorByNext(Redirector,True,True,FILESYS_LOCK_READ); 
   end;

  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.LocateDrives completed');
  {$ENDIF}
  
  Result:=True;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.OpenRawHandle(ADevice:TDiskDevice;APartition:TDiskPartition;AVolume:TDiskVolume;ADrive:TDiskDrive;AMode:Integer;ALock:Boolean;AState:LongWord):TRawHandle;
{Open a handle for the specified object with the specified mode}
{Check existing handles for compatible Modes}
{Note: Only one type of object can be specified}
var
 OpenMode:Integer;
 ShareMode:Integer;
 NextHandle:TRawHandle;
 CurrentHandle:TRawHandle;
begin
 {}
 Result:=nil;

 if not ReaderLock then Exit;
 try
  {Check Supplied Params}
  if (ADevice = nil) and (APartition = nil) and (AVolume = nil) and (ADrive = nil) then Exit;
  
  {Check Open Mode}
  if AMode = fmCreate then Exit; {Cannot Create on a Device/Partition/Volume/Drive}
  OpenMode:=AMode and fmOpenMask;
  ShareMode:=AMode and fmShareMask;
  
  if not FRawHandles.ReaderLock then Exit;
  try
   {Check for Existing Handles}
   NextHandle:=TRawHandle(FRawHandles.First);
   while NextHandle <> nil do
    begin
     CurrentHandle:=nil;
    
     if (ADevice <> nil) and (NextHandle.Device = ADevice) then
      begin
       CurrentHandle:=NextHandle;
      end
     else if (APartition <> nil) and (NextHandle.Partition = APartition) then
      begin
       CurrentHandle:=NextHandle;
      end
     else if (AVolume <> nil) and (NextHandle.Volume = AVolume) then
      begin
       CurrentHandle:=NextHandle;
      end
     else if (ADrive <> nil) and (NextHandle.Drive = ADrive) then
      begin
       CurrentHandle:=NextHandle;
      end;
     
     if CurrentHandle <> nil then
      begin
       {Check for Share Exclusive}
       if ShareMode = fmShareCompat then Exit;   {Compat is same as Exclusive}
       if ShareMode = fmShareExclusive then Exit;
       
       {Check requested Open Mode}
       case OpenMode of
        fmOpenRead:begin
          {Check Share Mode of previous handle}
          if CurrentHandle.ShareMode = fmShareCompat then Exit;   {Compat is same as Exclusive}
          if CurrentHandle.ShareMode = fmShareExclusive then Exit;
          if CurrentHandle.ShareMode = fmShareDenyRead then Exit;
         end;
        fmOpenWrite:begin
          {Check Share Mode of previous handle}
          if CurrentHandle.ShareMode = fmShareCompat then Exit;   {Compat is same as Exclusive}
          if CurrentHandle.ShareMode = fmShareExclusive then Exit;
          if CurrentHandle.ShareMode = fmShareDenyWrite then Exit;
         end;
        fmOpenReadWrite:begin
          {Check Share Mode of previous handle}
          if CurrentHandle.ShareMode = fmShareCompat then Exit;   {Compat is same as Exclusive}
          if CurrentHandle.ShareMode = fmShareExclusive then Exit;
          if CurrentHandle.ShareMode = fmShareDenyRead then Exit;
          if CurrentHandle.ShareMode = fmShareDenyWrite then Exit;
         end;
       end;
      
       {Check requested Share Mode}
       case ShareMode of
        fmShareDenyWrite:begin
          {Check Open Mode of previous handle}
          if CurrentHandle.OpenMode = fmOpenWrite then Exit;
          if CurrentHandle.OpenMode = fmOpenReadWrite then Exit;
         end;
        fmShareDenyRead:begin
          {Check Open Mode of previous handle}
          if CurrentHandle.OpenMode = fmOpenRead then Exit;
          if CurrentHandle.OpenMode = fmOpenReadWrite then Exit;
         end;
        end;
      end;
    
     NextHandle:=TRawHandle(NextHandle.Next); 
    end;
  finally
   FRawHandles.ReaderUnlock;
  end;   
  
  {Create new Handle}
  Result:=TRawHandle.Create;
  Result.Device:=ADevice;
  Result.Partition:=APartition;
  Result.Volume:=AVolume;
  Result.Drive:=ADrive;
  Result.OpenMode:=OpenMode;
  Result.ShareMode:=ShareMode;
  
  {Lock Handle}
  if ALock then if AState = FILESYS_LOCK_READ then Result.ReaderLock else Result.WriterLock;
  
  {Acquire Lock}
  FRawHandles.WriterLock;
  
  {Add the Handle}
  FRawHandles.Add(Result);
  
  {Release Lock}
  FRawHandles.WriterUnlock;
  
  {Size and Position are set by the caller}
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.CloseRawHandle(AHandle:TRawHandle):Boolean;
{Close an existing handle}
{Note: Caller must hold the handle writer lock}
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if AHandle = nil then Exit;
  
  {Acquire Lock}
  FRawHandles.WriterLock;

  {Remove and Free Handle}
  FRawHandles.Remove(AHandle);
  
  {Release Lock}
  FRawHandles.WriterUnlock;
  
  AHandle.Free;
  
  Result:=True;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetRawHandleByNext(APrevious:TRawHandle;ALock,AUnlock:Boolean;AState:LongWord):TRawHandle;
var
 Handle:TRawHandle;
begin
 {}
 Result:=nil;
 
 if not FRawHandles.ReaderLock then Exit;
 try
  {Check Previous}
  if APrevious = nil then
   begin
    {Get First}
    Handle:=TRawHandle(FRawHandles.First);
    if Handle <> nil then
     begin
      {Lock Handle}
      if ALock then if AState = FILESYS_LOCK_READ then Handle.ReaderLock else Handle.WriterLock;
      
      {Return Result}
      Result:=Handle;
     end;
   end
  else
   begin
    {Get Next}
    Handle:=TRawHandle(APrevious.Next);
    if Handle <> nil then
     begin
      {Lock Handle}
      if ALock then if AState = FILESYS_LOCK_READ then Handle.ReaderLock else Handle.WriterLock;
      
      {Return Result}
      Result:=Handle;
     end;

    {Unlock Previous}
    if AUnlock then if AState = FILESYS_LOCK_READ then APrevious.ReaderUnlock else APrevious.WriterUnlock;
   end;   
 finally
  FRawHandles.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.ReleaseRawHandles(ADevice:TDiskDevice;APartition:TDiskPartition;AVolume:TDiskVolume;ADrive:TDiskDrive):Boolean;
{Release all existing handles on the specified object}
{Usually because the object is being removed}
{Note: Only one type of object can be specified}
var
 NextHandle:TRawHandle;
 CurrentHandle:TRawHandle;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Supplied Params}
  if (ADevice = nil) and (APartition = nil) and (AVolume = nil) and (ADrive = nil) then Exit;
  
  {Check each Handle}
  NextHandle:=GetRawHandleByNext(nil,True,False,FILESYS_LOCK_READ);
  while NextHandle <> nil do
   begin
    CurrentHandle:=NextHandle;
    NextHandle:=GetRawHandleByNext(CurrentHandle,True,False,FILESYS_LOCK_READ);
    
    {Close Handle if on Device/Partition/Volume/Drive}
    if (ADevice <> nil) and (CurrentHandle.Device = ADevice) then
     begin
      {Convert Handle}
      CurrentHandle.ReaderConvert;
      
      {Close Handle}
      CloseRawHandle(CurrentHandle);
      CurrentHandle:=nil;
     end
    else if (APartition <> nil) and (CurrentHandle.Partition = APartition) then
     begin
      {Convert Handle}
      CurrentHandle.ReaderConvert;
      
      {Close Handle}
      CloseRawHandle(CurrentHandle);
      CurrentHandle:=nil;
     end
    else if (AVolume <> nil) and (CurrentHandle.Volume = AVolume) then
     begin
      {Convert Handle}
      CurrentHandle.ReaderConvert;
      
      {Close Handle}
      CloseRawHandle(CurrentHandle);
      CurrentHandle:=nil;
     end
    else if (ADrive <> nil) and (CurrentHandle.Drive = ADrive) then
     begin
      {Convert Handle}
      CurrentHandle.ReaderConvert;
      
      {Close Handle}
      CloseRawHandle(CurrentHandle);
      CurrentHandle:=nil;
     end;
     
    {Unlock Handle}
    if CurrentHandle <> nil then CurrentHandle.ReaderUnlock;
   end;
  
  Result:=True;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.OpenEnumHandle(AFileSystem:TFileSystem;ALock:Boolean;AState:LongWord):TEnumHandle;
{Open a handle with the details}
{Note: FileSystem does not need to be specified}
begin
 {}
 Result:=nil;

 if not ReaderLock then Exit;
 try
  {Check Supplied Params}
  {if AFileSystem = nil then Exit;} {FileSystem may be nil}
  
  {Create new Handle}
  Result:=TEnumHandle.Create;
  Result.FileSystem:=AFileSystem;
  
  {Lock Handle}
  if ALock then if AState = FILESYS_LOCK_READ then Result.ReaderLock else Result.WriterLock;
  
  {Acquire Lock}
  FEnumHandles.WriterLock;
  
  {Add the Handle}
  FEnumHandles.Add(Result);
  
  {Release Lock}
  FEnumHandles.WriterUnlock;
  
  {Current is set by the caller}
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.CloseEnumHandle(AHandle:TEnumHandle):Boolean;
{Close an existing handle}
{Note: Caller must hold the handle writer lock}
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if AHandle = nil then Exit;
  
  {Acquire Lock}
  FEnumHandles.WriterLock;
  
  {Remove and Free Handle}
  FEnumHandles.Remove(AHandle);

  {Release Lock}
  FEnumHandles.WriterUnlock;

  AHandle.Free;
  
  Result:=True;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetEnumHandleByNext(APrevious:TEnumHandle;ALock,AUnlock:Boolean;AState:LongWord):TEnumHandle;
var
 Handle:TEnumHandle;
begin
 {}
 Result:=nil;
 
 if not FEnumHandles.ReaderLock then Exit;
 try
  {Check Previous}
  if APrevious = nil then
   begin
    {Get First}
    Handle:=TEnumHandle(FEnumHandles.First);
    if Handle <> nil then
     begin
      {Lock Handle}
      if ALock then if AState = FILESYS_LOCK_READ then Handle.ReaderLock else Handle.WriterLock;
      
      {Return Result}
      Result:=Handle;
     end;
   end
  else
   begin
    {Get Next}
    Handle:=TEnumHandle(APrevious.Next);
    if Handle <> nil then
     begin
      {Lock Handle}
      if ALock then if AState = FILESYS_LOCK_READ then Handle.ReaderLock else Handle.WriterLock;
      
      {Return Result}
      Result:=Handle;
     end;

    {Unlock Previous}
    if AUnlock then if AState = FILESYS_LOCK_READ then APrevious.ReaderUnlock else APrevious.WriterUnlock;
   end;   
 finally
  FEnumHandles.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.UpdateEnumHandles(ADevice:TDiskDevice;APartition:TDiskPartition;ADrive:TDiskDrive;AVolume:TDiskVolume;AImage:TDiskImage;ACatalog:TDiskCatalog):Boolean;
{Update enum handles with matching device, partition, drive, volume, image or catalog}
{Called by Delete to update open handles}
{Returns True if successfully updated or no match found}
var
 EnumHandle:TEnumHandle;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Supplied Params}
  if (ADevice = nil) and (APartition = nil) and (ADrive = nil) and (AVolume = nil) and (AImage = nil) and (ACatalog = nil) then Exit;
  
  {Check each Handle}
  EnumHandle:=GetEnumHandleByNext(nil,True,False,FILESYS_LOCK_READ);
  while EnumHandle <> nil do
   begin
    {Update Handle if on Device/Partition/Volume/Drive}
    if (ADevice <> nil) and (EnumHandle.CurrentDevice = ADevice) then
     begin
      {Convert Handle}
      EnumHandle.ReaderConvert;
      
      {Update Handle}
      EnumHandle.CurrentDevice:=TDiskDevice(ADevice.Prev); //To Do //Lock //GetByPrev ? //Protect by caller Writerlock on list ?
      
      {Convert Handle}
      EnumHandle.WriterConvert;
     end
    else if (APartition <> nil) and (EnumHandle.CurrentPartition = APartition) then
     begin
      {Convert Handle}
      EnumHandle.ReaderConvert;
      
      {Update Handle}
      EnumHandle.CurrentPartition:=TDiskPartition(APartition.Prev); //To Do //Lock //GetByPrev ? //Protect by caller Writerlock on list ?
      
      {Convert Handle}
      EnumHandle.WriterConvert;
     end
    else if (ADrive <> nil) and (EnumHandle.CurrentDrive = ADrive) then
     begin
      {Convert Handle}
      EnumHandle.ReaderConvert;
      
      {Update Handle}
      EnumHandle.CurrentDrive:=TDiskDrive(ADrive.Prev); //To Do //Lock //GetByPrev ? //Protect by caller Writerlock on list ?
      
      {Convert Handle}
      EnumHandle.WriterConvert;
     end
    else if (AVolume <> nil) and (EnumHandle.CurrentVolume = AVolume) then
     begin
      {Convert Handle}
      EnumHandle.ReaderConvert;
      
      {Update Handle}
      EnumHandle.CurrentVolume:=TDiskVolume(AVolume.Prev); //To Do //Lock //GetByPrev ? //Protect by caller Writerlock on list ?
      
      {Convert Handle}
      EnumHandle.WriterConvert;
     end
    else if (AImage <> nil) and (EnumHandle.CurrentImage = AImage) then
     begin
      {Convert Handle}
      EnumHandle.ReaderConvert;
      
      {Update Handle}
      EnumHandle.CurrentImage:=TDiskImage(AImage.Prev); //To Do //Lock //GetByPrev ? //Protect by caller Writerlock on list ?
      
      {Convert Handle}
      EnumHandle.WriterConvert;
     end
    else if (ACatalog <> nil) and (EnumHandle.CurrentCatalog = ACatalog) then
     begin
      {Convert Handle}
      EnumHandle.ReaderConvert;
      
      {Update Handle}
      EnumHandle.CurrentCatalog:=TDiskCatalog(ACatalog.Prev); //To Do //Lock //GetByPrev ? //Protect by caller Writerlock on list ?
      
      {Convert Handle}
      EnumHandle.WriterConvert;
     end;
    
    EnumHandle:=GetEnumHandleByNext(EnumHandle,True,True,FILESYS_LOCK_READ);
   end;
  
  Result:=True;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.ReleaseEnumHandles(AFileSystem:TFileSystem):Boolean;
{Release all existing handles on the specified filesystem}
{Usually because the filesystem is being removed}
var
 NextHandle:TEnumHandle;
 CurrentHandle:TEnumHandle;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Supplied Params}
  if AFileSystem = nil then Exit;
  
  {Check each Handle}
  NextHandle:=GetEnumHandleByNext(nil,True,False,FILESYS_LOCK_READ);
  while NextHandle <> nil do
   begin
    CurrentHandle:=NextHandle;
    NextHandle:=GetEnumHandleByNext(CurrentHandle,True,False,FILESYS_LOCK_READ);
    
    {Close Handle if on FileSystem}
    if CurrentHandle.FileSystem = AFileSystem then
     begin
      {Convert Handle}
      CurrentHandle.ReaderConvert;
      
      {Close Handle}
      CloseEnumHandle(CurrentHandle);
     end
    else
     begin
      {Unlock Handle}
      CurrentHandle.ReaderUnlock;
     end;     
   end;
  
  Result:=True;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.OpenFileHandle(AVolume:TDiskVolume;ADrive:TDiskDrive;AParent,AEntry:TDiskEntry;AMode:Integer;ALock:Boolean;AState:LongWord):TFileHandle;
{Open a handle for the specified entry with the specified mode}
{Check existing handles for compatible Modes}
{Note: Both Drive and Volume are allowed}
var
 OpenMode:Integer;
 ShareMode:Integer;
 NextHandle:TFileHandle;
 CurrentHandle:TFileHandle;
begin
 {}
 Result:=nil;

 if not ReaderLock then Exit;
 try
  {Check Supplied Params}
  if AEntry = nil then Exit;
  if AParent = nil then Exit; {Cannot open Root}
  if (AVolume = nil) and (ADrive = nil) then Exit;
  
  {Check Open Mode}
  if AMode = fmCreate then Exit; {FileCreate must call with OpenReadWrite / ShareExclusive}
  OpenMode:=AMode and fmOpenMask;
  ShareMode:=AMode and fmShareMask;
  
  if not FFileHandles.ReaderLock then Exit;
  try
   {Check for Existing Handles}
   NextHandle:=TFileHandle(FFileHandles.First); 
   while NextHandle <> nil do
    begin
     CurrentHandle:=nil;
    
     if (AVolume <> nil) and (NextHandle.Volume = AVolume) then
      begin
       if NextHandle.HandleEntry = AEntry then
        begin
         CurrentHandle:=NextHandle;
        end;
      end
     else if (ADrive <> nil) and (NextHandle.Drive = ADrive) then
      begin
       if NextHandle.HandleEntry = AEntry then
        begin
         CurrentHandle:=NextHandle;
        end;
      end;
      
     if CurrentHandle <> nil then
      begin
       {Check for Share Exclusive}
       if ShareMode = fmShareCompat then Exit;   {Compat is same as Exclusive}
       if ShareMode = fmShareExclusive then Exit;
       
       {Check requested Open Mode}
       case OpenMode of
        fmOpenRead:begin
          {Check Share Mode of previous handle}
          if CurrentHandle.ShareMode = fmShareCompat then Exit;   {Compat is same as Exclusive}
          if CurrentHandle.ShareMode = fmShareExclusive then Exit;
          if CurrentHandle.ShareMode = fmShareDenyRead then Exit;
         end;
        fmOpenWrite:begin
          {Check Share Mode of previous handle}
          if CurrentHandle.ShareMode = fmShareCompat then Exit;   {Compat is same as Exclusive}
          if CurrentHandle.ShareMode = fmShareExclusive then Exit;
          if CurrentHandle.ShareMode = fmShareDenyWrite then Exit;
         end;
        fmOpenReadWrite:begin
          {Check Share Mode of previous handle}
          if CurrentHandle.ShareMode = fmShareCompat then Exit;   {Compat is same as Exclusive}
          if CurrentHandle.ShareMode = fmShareExclusive then Exit;
          if CurrentHandle.ShareMode = fmShareDenyRead then Exit;
          if CurrentHandle.ShareMode = fmShareDenyWrite then Exit;
         end;
       end;
       
       {Check requested Share Mode}
       case ShareMode of
        fmShareDenyWrite:begin
          {Check Open Mode of previous handle}
          if CurrentHandle.OpenMode = fmOpenWrite then Exit;
          if CurrentHandle.OpenMode = fmOpenReadWrite then Exit;
         end;
        fmShareDenyRead:begin
          {Check Open Mode of previous handle}
          if CurrentHandle.OpenMode = fmOpenRead then Exit;
          if CurrentHandle.OpenMode = fmOpenReadWrite then Exit;
         end;
       end;
      end;
    
     NextHandle:=TFileHandle(NextHandle.Next); 
    end;
  finally
   FFileHandles.ReaderUnlock;
  end;   
  
  {Create new Handle}
  Result:=TFileHandle.Create;
  Result.Volume:=AVolume;
  Result.Drive:=ADrive;
  Result.Position:=0;
  Result.OpenMode:=OpenMode;
  Result.ShareMode:=ShareMode;
  Result.HandleEntry:=AEntry;
  Result.ParentEntry:=AParent;
  
  {Lock Handle}
  if ALock then if AState = FILESYS_LOCK_READ then Result.ReaderLock else Result.WriterLock;
  
  {Acquire Lock}
  FFileHandles.WriterLock;
  
  {Add the Handle}
  FFileHandles.Add(Result);
  
  {Release Lock}
  FFileHandles.WriterUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.CloseFileHandle(AHandle:TFileHandle):Boolean;
{Close an existing handle}
{Note: Caller must hold the handle writer lock}
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if AHandle = nil then Exit;
  
  {Acquire Lock}
  FFileHandles.WriterLock;
  
  {Remove and Free Handle}
  FFileHandles.Remove(AHandle);

  {Release Lock}
  FFileHandles.WriterUnlock;

  AHandle.Free;
  
  Result:=True;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetFileHandleByNext(APrevious:TFileHandle;ALock,AUnlock:Boolean;AState:LongWord):TFileHandle;
var
 Handle:TFileHandle;
begin
 {}
 Result:=nil;
 
 if not FFileHandles.ReaderLock then Exit;
 try
  {Check Previous}
  if APrevious = nil then
   begin
    {Get First}
    Handle:=TFileHandle(FFileHandles.First);
    if Handle <> nil then
     begin
      {Lock Handle}
      if ALock then if AState = FILESYS_LOCK_READ then Handle.ReaderLock else Handle.WriterLock;
      
      {Return Result}
      Result:=Handle;
     end;
   end
  else
   begin
    {Get Next}
    Handle:=TFileHandle(APrevious.Next);
    if Handle <> nil then
     begin
      {Lock Handle}
      if ALock then if AState = FILESYS_LOCK_READ then Handle.ReaderLock else Handle.WriterLock;
      
      {Return Result}
      Result:=Handle;
     end;

    {Unlock Previous}
    if AUnlock then if AState = FILESYS_LOCK_READ then APrevious.ReaderUnlock else APrevious.WriterUnlock;
   end;   
 finally
  FFileHandles.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.CheckFileHandles(AEntry:TDiskEntry):Boolean;
{Check file handles for any with matching entry}
{Called by Delete, Rename etc to check for open handles}
{Returns True if no matching handle is found}
var
 FileHandle:TFileHandle;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Supplied Params}
  if AEntry = nil then Exit;
  
  if not FFileHandles.ReaderLock then Exit;
  try
   {Check each Handle}
   FileHandle:=TFileHandle(FFileHandles.First);
   while FileHandle <> nil do
    begin
     {Check Entry}
     if FileHandle.HandleEntry = AEntry then
      begin
       Exit;
      end;
     
     FileHandle:=TFileHandle(FileHandle.Next); 
    end;
  finally
   FFileHandles.ReaderUnlock;
  end;   
   
  Result:=True;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.ReleaseFileHandles(AVolume:TDiskVolume;ADrive:TDiskDrive):Boolean;
{Release all existing handles on the specified object}
{Usually because the object is being removed}
{Note: Both Drive and Volume can be specified}
var
 NextHandle:TFileHandle;
 CurrentHandle:TFileHandle;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Supplied Params}
  if (AVolume = nil) and (ADrive = nil) then Exit;
  
  {Check each Handle}
  NextHandle:=GetFileHandleByNext(nil,True,False,FILESYS_LOCK_READ);
  while NextHandle <> nil do
   begin
    CurrentHandle:=NextHandle;
    NextHandle:=GetFileHandleByNext(CurrentHandle,True,False,FILESYS_LOCK_READ); 
    
    {Close Handle if on Volume/Drive}
    if (AVolume <> nil) and (CurrentHandle.Volume = AVolume) then
     begin
      {Convert Handle}
      CurrentHandle.ReaderConvert;
      
      {Close Handle}
      CloseFileHandle(CurrentHandle);
      CurrentHandle:=nil;
     end
    else if (ADrive <> nil) and (CurrentHandle.Drive = ADrive) then
     begin
      {Convert Handle}
      CurrentHandle.ReaderConvert;
      
      {Close Handle}
      CloseFileHandle(CurrentHandle);
      CurrentHandle:=nil;
     end;
     
     
    {Unlock Handle}
    if CurrentHandle <> nil then CurrentHandle.ReaderUnlock;
   end;
   
  Result:=True;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.DismountFileHandles(AVolume:TDiskVolume;ADrive:TDiskDrive):Boolean;
{Update or Release all existing handles on the specified object}
{Usually because the object is being dismounted and removed}
{Note: Both Drive and Volume can be specified but nothing currently passes Volume}
var
 NextHandle:TFileHandle;
 CurrentHandle:TFileHandle;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {Check Supplied Params}
  if (AVolume = nil) and (ADrive = nil) then Exit;
  
  {Check each Handle}
  NextHandle:=GetFileHandleByNext(nil,True,False,FILESYS_LOCK_READ); 
  while NextHandle <> nil do
    begin
    CurrentHandle:=NextHandle;
    NextHandle:=GetFileHandleByNext(CurrentHandle,True,False,FILESYS_LOCK_READ);
    
    {Update or Close Handle if on Volume/Drive}
    if (AVolume <> nil) and (CurrentHandle.Volume = AVolume) then
     begin
      if CurrentHandle.Drive <> nil then
       begin
        {Convert Handle}
        CurrentHandle.ReaderConvert;
        
        {Update Handle}
        CurrentHandle.Volume:=nil;
        
        {Convert Handle}
        CurrentHandle.WriterConvert;
       end
      else
       begin
        {Convert Handle}
        CurrentHandle.ReaderConvert;
        
        {Close Handle}
        CloseFileHandle(CurrentHandle);
        CurrentHandle:=nil;
       end;
     end
    else if (ADrive <> nil) and (CurrentHandle.Drive = ADrive) then
     begin
      if CurrentHandle.Volume <> nil then
       begin
        {Convert Handle}
        CurrentHandle.ReaderConvert;
        
        {Update Handle}
        CurrentHandle.Drive:=nil;
        
        {Convert Handle}
        CurrentHandle.WriterConvert;
       end
      else
       begin
        {Convert Handle}
        CurrentHandle.ReaderConvert;
        
        {Close Handle}
        CloseFileHandle(CurrentHandle);
        CurrentHandle:=nil;
       end;
     end;
     
     
    {Unlock Handle}
    if CurrentHandle <> nil then CurrentHandle.ReaderUnlock;
   end;
   
  Result:=True;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.OpenFindHandle(AVolume:TDiskVolume;ADrive:TDiskDrive;AParent:TDiskEntry;const AMask:String;AAttr,AFlags:LongWord;ALock:Boolean;AState:LongWord):TFindHandle;
{Open a handle with the specified parent and mask}
{Note: Both Drive and Volume can be specified}
begin
 {}
 Result:=nil;

 if not ReaderLock then Exit;
 try
  {Check Supplied Params}
  if AParent = nil then Exit;
  if TrimRight(AMask) = '' then Exit;
  if (AAttr and faMatchMask) = faNone then Exit;
  if (AVolume = nil) and (ADrive = nil) then Exit;
  
  {Create new Handle}
  Result:=TFindHandle.Create;
  Result.Volume:=AVolume;
  Result.Drive:=ADrive;
  Result.Mask:=AMask;
  Result.Attr:=AAttr;
  Result.Flags:=AFlags;
  Result.ParentEntry:=AParent;
  
  {Lock Handle}
  if ALock then if AState = FILESYS_LOCK_READ then Result.ReaderLock else Result.WriterLock;
  
  {Acquire Lock}
  FFindHandles.WriterLock;
  
  {Add the Handle}
  FFindHandles.Add(Result);
  
  {Release Lock}
  FFindHandles.WriterUnlock;
  
  {Current is set by the caller}
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.CloseFindHandle(AHandle:TFindHandle):Boolean;
{Close an existing handle}
{Note: Caller must hold the handle writer lock}
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if AHandle = nil then Exit;
  
  {Acquire Lock}
  FFindHandles.WriterLock;
  
  {Remove and Free Handle}
  FFindHandles.Remove(AHandle);

  {Release Lock}
  FFindHandles.WriterUnlock;

  AHandle.Free;
  
  Result:=True;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetFindHandleByNext(APrevious:TFindHandle;ALock,AUnlock:Boolean;AState:LongWord):TFindHandle;
var
 Handle:TFindHandle;
begin
 {}
 Result:=nil;
 
 if not FFindHandles.ReaderLock then Exit;
 try
  {Check Previous}
  if APrevious = nil then
   begin
    {Get First}
    Handle:=TFindHandle(FFindHandles.First);
    if Handle <> nil then
     begin
      {Lock Handle}
      if ALock then if AState = FILESYS_LOCK_READ then Handle.ReaderLock else Handle.WriterLock;
      
      {Return Result}
      Result:=Handle;
     end;
   end
  else
   begin
    {Get Next}
    Handle:=TFindHandle(APrevious.Next);
    if Handle <> nil then
     begin
      {Lock Handle}
      if ALock then if AState = FILESYS_LOCK_READ then Handle.ReaderLock else Handle.WriterLock;
      
      {Return Result}
      Result:=Handle;
     end;

    {Unlock Previous}
    if AUnlock then if AState = FILESYS_LOCK_READ then APrevious.ReaderUnlock else APrevious.WriterUnlock;
   end;   
 finally
  FFindHandles.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.UpdateFindHandles(AEntry:TDiskEntry):Boolean;
{Update find handles with matching entry}
{Called by Delete, Rename (Move) etc to update open handles}
{Returns True if successfully updated or no match found}
var
 FindHandle:TFindHandle;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Supplied Params}
  if AEntry = nil then Exit;
  
  {Check each Handle}
  FindHandle:=GetFindHandleByNext(nil,True,False,FILESYS_LOCK_READ);
  while FindHandle <> nil do
   begin
    {Check Parent}
    if FindHandle.ParentEntry = AEntry then
     begin
      {Convert Handle}
      FindHandle.ReaderConvert;
      
      {Update Handle}
      FindHandle.ParentEntry:=nil;

      {Convert Handle}
      FindHandle.WriterConvert;
     end;
     
    {Check Current}
    if FindHandle.CurrentEntry = AEntry then
     begin
      {Convert Handle}
      FindHandle.ReaderConvert;

      if (FindHandle.Flags and FIND_FLAG_FILE_NAMES) = FIND_FLAG_FILE_NAMES then
       begin
        if FindHandle.ParentEntry <> nil then
         begin
          {Update Handle}
          FindHandle.CurrentEntry:=FindHandle.ParentEntry.FindPrevName(FindHandle,False);
         end
        else
         begin
          {Update Handle}
          FindHandle.CurrentEntry:=nil;
         end;
       end
      else
       begin
        {Update Handle}
        FindHandle.CurrentEntry:=TDiskEntry(AEntry.Prev); //To Do //Lock //Protect by caller Writerlock on list ?
       end;
       
      {Convert Handle}
      FindHandle.WriterConvert;
     end;
     
    FindHandle:=GetFindHandleByNext(FindHandle,True,True,FILESYS_LOCK_READ);
   end;
   
  Result:=True;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.ReleaseFindHandles(AVolume:TDiskVolume;ADrive:TDiskDrive):Boolean;
{Release all existing handles on the specified object}
{Usually because the object is being removed}
{Note: Both Drive and Volume can be specified}
var
 NextHandle:TFindHandle;
 CurrentHandle:TFindHandle;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Supplied Params}
  if (AVolume = nil) and (ADrive = nil) then Exit;
  
  {Check each Handle}
  NextHandle:=GetFindHandleByNext(nil,True,False,FILESYS_LOCK_READ);
  while NextHandle <> nil do
   begin
    CurrentHandle:=NextHandle;
    NextHandle:=GetFindHandleByNext(CurrentHandle,True,False,FILESYS_LOCK_READ);
    
    {Close Handle if on Volume/Drive}
    if (AVolume <> nil) and (CurrentHandle.Volume = AVolume) then
     begin
      {Convert Handle}
      CurrentHandle.ReaderConvert;
      
      {Close Handle}
      CloseFindHandle(CurrentHandle);
      CurrentHandle:=nil;
     end
    else if (ADrive <> nil) and (CurrentHandle.Drive = ADrive) then
     begin
      {Convert Handle}
      CurrentHandle.ReaderConvert;
      
      {Close Handle}
      CloseFindHandle(CurrentHandle);
      CurrentHandle:=nil;
     end;
     
    {Unlock Handle}
    if CurrentHandle <> nil then CurrentHandle.ReaderUnlock;
   end;
  
  Result:=True;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.DismountFindHandles(AVolume:TDiskVolume;ADrive:TDiskDrive):Boolean;
{Update or Release all existing handles on the specified object}
{Usually because the object is being dismounted and removed}
{Note: Both Drive and Volume can be specified but nothing currently passes Volume}
var
 NextHandle:TFindHandle;
 CurrentHandle:TFindHandle;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Supplied Params}
  if (AVolume = nil) and (ADrive = nil) then Exit;
  
  {Check each Handle}
  NextHandle:=GetFindHandleByNext(nil,True,False,FILESYS_LOCK_READ);
  while NextHandle <> nil do
   begin
    CurrentHandle:=NextHandle;
    NextHandle:=GetFindHandleByNext(CurrentHandle,True,False,FILESYS_LOCK_READ); 
    
    {Update or Close Handle if on Volume/Drive}
    if (AVolume <> nil) and (CurrentHandle.Volume = AVolume) then
     begin
      if CurrentHandle.Drive <> nil then
       begin
        {Convert Handle}
        CurrentHandle.ReaderConvert;
      
        {Update Handle}
        CurrentHandle.Volume:=nil;
        
        {Convert Handle}
        CurrentHandle.WriterConvert;
       end
      else
       begin
        {Convert Handle}
        CurrentHandle.ReaderConvert;
      
        {Close Handle}
        CloseFindHandle(CurrentHandle);
        CurrentHandle:=nil;
       end;
     end
    else if (ADrive <> nil) and (CurrentHandle.Drive = ADrive) then
     begin
      if CurrentHandle.Volume <> nil then
       begin
        {Convert Handle}
        CurrentHandle.ReaderConvert;
      
        {Update Handle}
        CurrentHandle.Drive:=nil;
        
        {Convert Handle}
        CurrentHandle.WriterConvert;
       end
      else
       begin
        {Convert Handle}
        CurrentHandle.ReaderConvert;
      
        {Close Handle}
        CloseFindHandle(CurrentHandle);
        CurrentHandle:=nil;
       end;
     end;
     
    {Unlock Handle}
    if CurrentHandle <> nil then CurrentHandle.ReaderUnlock;
   end;
   
  Result:=True;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.LockMedia(const AName:String):Boolean;
var
 Device:TDiskDevice;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.LockMedia');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Name = ' + AName);
  {$ENDIF}

  if TrimRight(AName) = '' then Exit;
  
  {Get the Device}
  Device:=GetDeviceByName(AName,True,FILESYS_LOCK_READ);
  if Device = nil then Exit;
  
  Result:=Device.LockMedia;

  {Unlock Device}
  Device.ReaderUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.UnlockMedia(const AName:String):Boolean;
var
 Device:TDiskDevice;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.UnlockMedia');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Name = ' + AName);
  {$ENDIF}

  if TrimRight(AName) = '' then Exit;
  
  {Get the Device}
  Device:=GetDeviceByName(AName,True,FILESYS_LOCK_READ);
  if Device = nil then Exit;
  
  Result:=Device.UnlockMedia;

  {Unlock Device}
  Device.ReaderUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.EjectMedia(const AName:String):Boolean;
var
 Device:TDiskDevice;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.EjectMedia');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Name = ' + AName);
  {$ENDIF}

  if TrimRight(AName) = '' then Exit;
  
  {Get the Device}
  Device:=GetDeviceByName(AName,True,FILESYS_LOCK_READ);
  if Device = nil then Exit;
  
  Result:=Device.EjectMedia;

  {Unlock Device}
  Device.ReaderUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.MediaReady(const AName:String):Boolean;
var
 Device:TDiskDevice;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.MediaReady');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Name = ' + AName);
  {$ENDIF}

  if TrimRight(AName) = '' then Exit;
  
  {Get the Device}
  Device:=GetDeviceByName(AName,True,FILESYS_LOCK_READ);
  if Device = nil then Exit;
  
  Result:=Device.MediaReady;

  {Unlock Device}
  Device.ReaderUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.MediaChanged(const AName:String):Boolean;
var
 Device:TDiskDevice;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.MediaChanged');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Name = ' + AName);
  {$ENDIF}

  if TrimRight(AName) = '' then Exit;
  
  {Get the Device}
  Device:=GetDeviceByName(AName,True,FILESYS_LOCK_READ);
  if Device = nil then Exit;
  
  Result:=Device.MediaChanged;

  {Unlock Device}
  Device.ReaderUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.MediaLocked(const AName:String):Boolean;
var
 Device:TDiskDevice;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.MediaLocked');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Name = ' + AName);
  {$ENDIF}

  if TrimRight(AName) = '' then Exit;
  
  {Get the Device}
  Device:=GetDeviceByName(AName,True,FILESYS_LOCK_READ);
  if Device = nil then Exit;
  
  Result:=Device.MediaLocked;

  {Unlock Device}
  Device.ReaderUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.InsertDevice(const AName:String):Boolean;
var
 Device:TDiskDevice;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.InsertDevice');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Name = ' + AName);
  {$ENDIF}

  if TrimRight(AName) = '' then Exit;
  
  {Get the Device}
  Device:=GetDeviceByName(AName,True,FILESYS_LOCK_WRITE);
  if Device = nil then Exit;
  
  Result:=Device.InsertDevice;

  {Unlock Device}
  Device.WriterUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.EjectDevice(const AName:String):Boolean;
var
 Device:TDiskDevice;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.EjectDevice');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Name = ' + AName);
  {$ENDIF}

  if TrimRight(AName) = '' then Exit;
  
  {Get the Device}
  Device:=GetDeviceByName(AName,True,FILESYS_LOCK_WRITE);
  if Device = nil then Exit;
  
  Result:=Device.EjectDevice;

  {Unlock Device}
  Device.WriterUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.OpenDevice(const AName:String;AMode:Integer):Integer;
var
 Device:TDiskDevice;
begin
 {}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.OpenDevice');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Name = ' + AName);
  {$ENDIF}

  if TrimRight(AName) = '' then Exit;
  
  {Check the Mode}
  if AMode = fmCreate then Exit; {Cannot Create a Device}
  
  {Get the Device}
  Device:=GetDeviceByName(AName,True,FILESYS_LOCK_READ);
  if Device = nil then Exit;
  
  Result:=Device.OpenDevice(AMode);

  {Unlock Device}
  Device.ReaderUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

procedure TFileSysDriver.CloseDevice(AHandle:Integer);
var
 Device:TDiskDevice;
begin
 {}
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.CloseDevice');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}

  {Get the Device}
  Device:=GetDeviceFromRaw(AHandle,True,FILESYS_LOCK_READ);
  if Device = nil then Exit;
  
  Device.CloseDevice(AHandle);
  
  {Unlock Device}
  Device.ReaderUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.ReadDevice(AHandle:Integer;var ABuffer;ACount:Integer):Integer;
{Note: Raw Reads must be in Sector sized multiples}
var
 Device:TDiskDevice;
begin
 {}
 Result:=0;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.ReadDevice');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}

  if ACount < 1 then Exit;
  
  {Get the Device}
  Device:=GetDeviceFromRaw(AHandle,True,FILESYS_LOCK_READ);
  if Device = nil then Exit;
  
  Result:=Device.ReadDevice(AHandle,ABuffer,ACount);

  {Unlock Device}
  Device.ReaderUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.WriteDevice(AHandle:Integer;const ABuffer;ACount:Integer):Integer;
{Note: Raw Writes must be in Sector sized multiples}
var
 Device:TDiskDevice;
begin
 {}
 Result:=0;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.WriteDevice');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}

  if ACount < 1 then Exit;
  
  {Get the Device}
  Device:=GetDeviceFromRaw(AHandle,True,FILESYS_LOCK_READ);
  if Device = nil then Exit;
  
  Result:=Device.WriteDevice(AHandle,ABuffer,ACount);

  {Unlock Device}
  Device.ReaderUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.EraseDevice(AHandle:Integer;ACount:Integer):Integer;
{Note: Raw Erases must be in Sector sized multiples}
var
 Device:TDiskDevice;
begin
 {}
 Result:=0;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.EraseDevice');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}

  if ACount < 1 then Exit;
 
  {Get the Device}
  Device:=GetDeviceFromRaw(AHandle,True,FILESYS_LOCK_READ);
  if Device = nil then Exit;
 
  Result:=Device.EraseDevice(AHandle,ACount);

  {Unlock Device}
  Device.ReaderUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.SeekDevice(AHandle:Integer;const AOffset:Int64;AOrigin:Integer):Int64;
{Note: Raw Seeks must be in Sector sized multiples}
{Note: Raw Seeks cannot extend the size of the Device}
var
 Device:TDiskDevice;
begin
 {}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.SeekDevice');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}

  {Get the Device}
  Device:=GetDeviceFromRaw(AHandle,True,FILESYS_LOCK_READ);
  if Device = nil then Exit;
  
  Result:=Device.SeekDevice(AHandle,AOffset,AOrigin);

  {Unlock Device}
  Device.ReaderUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FindFirstDevice(var ASearchRec:TDiskSearchRec;AVerbose:Boolean):Integer;
//To Do //Handle Verbose - See DwDisk/DwVirtual etc
var
 Handle:TEnumHandle;
 Current:TDiskDevice;
begin
 {Base Implementation}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  ASearchRec.FindHandle:=INVALID_HANDLE_VALUE;

  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FindFirstDevice');
  {$ENDIF}
  
  {Find First Device}
  Current:=GetDeviceByNext(nil,True,False,FILESYS_LOCK_READ); 
  if Current = nil then Exit;
  try
   {Open Handle}
   Handle:=OpenEnumHandle(nil,True,FILESYS_LOCK_WRITE);
   if Handle = nil then Exit;
  
   {Set the Handle properties}
   Handle.CurrentDevice:=Current;
  
   {Return Device}
   ASearchRec.FindHandle:=Handle.Handle;
   ASearchRec.Name:=Current.Name;
   ASearchRec.MediaType:=Current.MediaType;
   ASearchRec.FloppyType:=Current.FloppyType;
  
   Result:=0;  
   
   {Unlock Handle}
   Handle.WriterUnlock;
  finally 
   {Unlock Device}
   Current.ReaderUnlock;
  end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FindNextDevice(var ASearchRec:TDiskSearchRec):Integer;
var
 Handle:TEnumHandle;
 Current:TDiskDevice;
begin
 {Base Implementation}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FindNextDevice');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Handle = ' + IntToHex(ASearchRec.FindHandle,8));
  {$ENDIF}
  
  {Get the Handle}
  Handle:=GetEnumFromHandle(ASearchRec.FindHandle,True,FILESYS_LOCK_WRITE);
  if Handle = nil then Exit;
  try
   {Check Device}
   if not CheckDevice(Handle.CurrentDevice,True,FILESYS_LOCK_READ) then Exit;
  
   {Find Next Device}
   Current:=GetDeviceByNext(Handle.CurrentDevice,True,True,FILESYS_LOCK_READ); 
   if Current = nil then Exit;
  
   {Update Handle}
   Handle.CurrentDevice:=Current;
  
   {Return Device}
   ASearchRec.FindHandle:=Handle.Handle;
   ASearchRec.Name:=Current.Name;
   ASearchRec.MediaType:=Current.MediaType;
   ASearchRec.FloppyType:=Current.FloppyType;
  
   {Unlock Device}
   Current.ReaderUnlock;
  
   Result:=0;
  finally
   {Unlock Handle}
   Handle.WriterUnlock;
  end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

procedure TFileSysDriver.FindDeviceClose(var ASearchRec:TDiskSearchRec);
{Close an open find Handle}
var
 Handle:TEnumHandle;
begin
 {Base Implementation}
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FindDeviceClose');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Handle = ' + IntToHex(ASearchRec.FindHandle,8));
  {$ENDIF}
  
  {Get the Handle}
  Handle:=GetEnumFromHandle(ASearchRec.FindHandle,True,FILESYS_LOCK_WRITE);
  if Handle = nil then Exit;
  
  {Close the Handle} {Do not unlock}
  CloseEnumHandle(Handle);
  
  ASearchRec.FindHandle:=INVALID_HANDLE_VALUE;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.CreatePartition(const ADevice,AParent:String;APartitionId:Byte;ACount:LongWord;AActive:Boolean):Boolean;
var
 Device:TDiskDevice;
 Parent:TDiskPartition;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.CreatePartition');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Device = ' + ADevice);
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Parent = ' + AParent);
  {$ENDIF}

  if TrimRight(ADevice) = '' then Exit;
  
  {Get the Device}
  Device:=GetDeviceByName(ADevice,True,FILESYS_LOCK_WRITE);
  if Device = nil then Exit;
  
  {Get the Parent}
  Parent:=GetPartitionByName(Device,AParent,True,FILESYS_LOCK_WRITE);
  {if Parent = nil then Exit;} {Parent may be nil}
  
  Result:=Device.CreatePartition(Parent,APartitionId,ACount,AActive);
  
  {Unlock Parent}
  if Parent <> nil then Parent.WriterUnlock;
  
  {Unlock Device}
  Device.WriterUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.DeletePartition(const APath:String):Boolean;
var
 Device:TDiskDevice;
 Partition:TDiskPartition;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.DeletePartition');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Path = ' + APath);
  {$ENDIF}

  if TrimRight(APath) = '' then Exit;
  
  {Get the Partition}
  Partition:=GetPartitionByPath(APath,True,FILESYS_LOCK_WRITE);
  if Partition = nil then Exit;
  try
   {Get the Device}
   if CheckDevice(Partition.Device,True,FILESYS_LOCK_WRITE) then
    begin
     Device:=Partition.Device;
  
     {Delete Partition}
     Result:=Device.DeletePartition(Partition);
     
     {Unlock Device}
     Device.WriterUnlock;
    end; 
  finally
   {Unlock Partition}
   if not Result then Partition.WriterUnlock;
  end;  
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.ModifyPartition(const APath:String;APartitionId:Byte):Boolean;
var
 Device:TDiskDevice;
 Partition:TDiskPartition;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.ModifyPartition');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Path = ' + APath);
  {$ENDIF}

  if TrimRight(APath) = '' then Exit;
  
  {Get the Partition}
  Partition:=GetPartitionByPath(APath,True,FILESYS_LOCK_WRITE);
  if Partition = nil then Exit;
  try
   {Get the Device}
   if CheckDevice(Partition.Device,True,FILESYS_LOCK_READ) then
    begin
     Device:=Partition.Device;
  
     {Modify Partition}
     Result:=Device.ModifyPartition(Partition,APartitionId);
     
     {Unlock Device}
     Device.ReaderUnlock;
    end; 
  finally
   {Unlock Partition}
   Partition.WriterUnlock;
  end;  
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.ActivatePartition(const APath:String;AActive:Boolean):Boolean;
var
 Device:TDiskDevice;
 Partition:TDiskPartition;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.ActivatePartition');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Path = ' + APath);
  {$ENDIF}

  if TrimRight(APath) = '' then Exit;
  
  {Get the Partition}
  Partition:=GetPartitionByPath(APath,True,FILESYS_LOCK_WRITE);
  if Partition = nil then Exit;
  try
   {Get the Device}
   if CheckDevice(Partition.Device,True,FILESYS_LOCK_READ) then
    begin
     Device:=Partition.Device;
  
     {Activate Partition}
     Result:=Device.ActivatePartition(Partition,AActive);
     
     {Unlock Device}
     Device.ReaderUnlock;
    end; 
  finally
   {Unlock Partition}
   Partition.WriterUnlock;
  end;  
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.ShrinkPartition(const APath:String;const AStart,ASize:Int64):Boolean;
var
 Device:TDiskDevice;
 Partition:TDiskPartition;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.ShrinkPartition');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Path = ' + APath);
  {$ENDIF}

  if TrimRight(APath) = '' then Exit;
  
  {Get the Partition}
  Partition:=GetPartitionByPath(APath,True,FILESYS_LOCK_WRITE);
  if Partition = nil then Exit;
  try
   {Get the Device}
   if CheckDevice(Partition.Device,True,FILESYS_LOCK_READ) then
    begin
     Device:=Partition.Device;
  
     {Shrink Partition}
     Result:=Device.ShrinkPartition(Partition,AStart,ASize);
     
     {Unlock Device}
     Device.ReaderUnlock;
    end; 
  finally
   {Unlock Partition}
   Partition.WriterUnlock;
  end;  
finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.ExpandPartition(const APath:String;const AStart,ASize:Int64):Boolean;
var
 Device:TDiskDevice;
 Partition:TDiskPartition;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.ExpandPartition');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Path = ' + APath);
  {$ENDIF}

  if TrimRight(APath) = '' then Exit;
  
  {Get the Partition}
  Partition:=GetPartitionByPath(APath,True,FILESYS_LOCK_WRITE);
  if Partition = nil then Exit;
  try
   {Get the Device}
   if CheckDevice(Partition.Device,True,FILESYS_LOCK_READ) then
    begin
     Device:=Partition.Device;
  
     {Expand Partition}
     Result:=Partition.Device.ExpandPartition(Partition,AStart,ASize);
     
     {Unlock Device}
     Device.ReaderUnlock;
    end; 
  finally
   {Unlock Partition}
   Partition.WriterUnlock;
  end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.OpenPartition(const APath:String;AMode:Integer):Integer;
var
 Partition:TDiskPartition;
begin
 {}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.OpenPartition');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Path = ' + APath);
  {$ENDIF}

  if TrimRight(APath) = '' then Exit;
  
  {Check the Mode}
  if AMode = fmCreate then Exit; {Cannot Create a Partition}
  
  {Get the Partition}
  Partition:=GetPartitionByPath(APath,True,FILESYS_LOCK_READ);
  if Partition = nil then Exit;
  
  Result:=Partition.OpenPartition(AMode);
  
  {Unlock Partition}
  Partition.ReaderUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

procedure TFileSysDriver.ClosePartition(AHandle:Integer);
var
 Partition:TDiskPartition;
begin
 {}
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.ClosePartition');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}

  {Get the Partition}
  Partition:=GetPartitionFromRaw(AHandle,True,FILESYS_LOCK_READ);
  if Partition = nil then Exit;
  
  Partition.ClosePartition(AHandle);
  
  {Unlock Partition}
  Partition.ReaderUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.ReadPartition(AHandle:Integer;var ABuffer;ACount:Integer):Integer;
{Note: Raw Reads must be in Sector sized multiples}
var
 Partition:TDiskPartition;
begin
 {}
 Result:=0;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.ReadPartition');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}

  if ACount < 1 then Exit;
  
  {Get the Partition}
  Partition:=GetPartitionFromRaw(AHandle,True,FILESYS_LOCK_READ);
  if Partition = nil then Exit;
  
  Result:=Partition.ReadPartition(AHandle,ABuffer,ACount);

  {Unlock Partition}
  Partition.ReaderUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.WritePartition(AHandle:Integer;const ABuffer;ACount:Integer):Integer;
{Note: Raw Writes must be in Sector sized multiples}
var
 Partition:TDiskPartition;
begin
 {}
 Result:=0;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.WritePartition');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}

  if ACount < 1 then Exit;
  
  {Get the Partition}
  Partition:=GetPartitionFromRaw(AHandle,True,FILESYS_LOCK_READ);
  if Partition = nil then Exit;
  
  Result:=Partition.WritePartition(AHandle,ABuffer,ACount);

  {Unlock Partition}
  Partition.ReaderUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.SeekPartition(AHandle:Integer;const AOffset:Int64;AOrigin:Integer):Int64;
{Note: Raw Seeks must be in Sector sized multiples}
{Note: Raw Seeks cannot extend the size of the Partition}
var
 Partition:TDiskPartition;
begin
 {}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.SeekPartition');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}

  {Get the Partition}
  Partition:=GetPartitionFromRaw(AHandle,True,FILESYS_LOCK_READ);
  if Partition = nil then Exit;
  
  Result:=Partition.SeekPartition(AHandle,AOffset,AOrigin);

  {Unlock Partition}
  Partition.ReaderUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FindFirstPartition(const ADevice:String;var ASearchRec:TPartitionSearchRec;AVerbose:Boolean):Integer;
//To Do //Handle Verbose - See DwDisk/DwVirtual etc
var
 Handle:TEnumHandle;
 Device:TDiskDevice;
 Current:TDiskPartition;
begin
 {Base Implementation}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  ASearchRec.FindHandle:=INVALID_HANDLE_VALUE;

  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FindFirstPartition');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Device = ' + ADevice);
  {$ENDIF}
  
  {Get the Device}
  Device:=GetDeviceByName(ADevice,True,FILESYS_LOCK_READ);
  if Device = nil then Exit;
  try
   {Find First Partition}
   Current:=GetPartitionByNext(nil,True,False,FILESYS_LOCK_READ);
   while Current <> nil do
    begin
     if Current.Device = Device then Break;
    
     Current:=GetPartitionByNext(Current,True,True,FILESYS_LOCK_READ);
    end;
   if Current = nil then Exit;
   try
    {Open Handle}
    Handle:=OpenEnumHandle(nil,True,FILESYS_LOCK_WRITE);
    if Handle = nil then Exit;
  
    {Set the Handle properties}
    Handle.CurrentPartition:=Current;
  
    {Return Partition}
    ASearchRec.FindHandle:=Handle.Handle;
    ASearchRec.Name:=Current.Name;
  
    Result:=0;
    
    {Unlock Handle}
    Handle.WriterUnlock;
   finally
    {Unlock Partition}
    Current.ReaderUnlock;
   end;
  finally
   {Unlock Device}
   Device.ReaderUnlock;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FindNextPartition(var ASearchRec:TPartitionSearchRec):Integer;
var
 Handle:TEnumHandle;
 Device:TDiskDevice;
 Current:TDiskPartition;
begin
 {Base Implementation}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FindNextPartition');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Handle = ' + IntToHex(ASearchRec.FindHandle,8));
  {$ENDIF}
  
  {Get the Handle}
  Handle:=GetEnumFromHandle(ASearchRec.FindHandle,True,FILESYS_LOCK_WRITE);
  if Handle = nil then Exit;
  try
   {Check Partition}
   if not CheckPartition(Handle.CurrentPartition,True,FILESYS_LOCK_READ) then Exit;
  
   {Check Device}
   if not CheckDevice(Handle.CurrentPartition.Device,True,FILESYS_LOCK_READ) then
    begin
     {Unlock Partition}
     Handle.CurrentPartition.ReaderUnlock;
     Exit;
    end; 
  
   {Get the Device}
   Device:=Handle.CurrentPartition.Device;
  
   {Find Next Partition}
   Current:=GetPartitionByNext(Handle.CurrentPartition,True,True,FILESYS_LOCK_READ);
   while Current <> nil do
    begin
     if Current.Device = Device then Break;
    
     Current:=GetPartitionByNext(Current,True,True,FILESYS_LOCK_READ);
    end;
   
   {Unlock Device}
   Device.ReaderUnlock;
  
   {Check the Partition}
   if Current = nil then Exit;
  
   {Update Handle}
   Handle.CurrentPartition:=Current;
  
   {Return Partition}
   ASearchRec.FindHandle:=Handle.Handle;
   ASearchRec.Name:=Current.Name;
  
   {Unlock Partition}
   Current.ReaderUnlock;
 
   Result:=0;
  finally
   {Unlock Handle}
   Handle.WriterUnlock;
  end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

procedure TFileSysDriver.FindPartitionClose(var ASearchRec:TPartitionSearchRec);
{Close an open find Handle}
var
 Handle:TEnumHandle;
begin
 {Base Implementation}
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FindPartitionClose');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Handle = ' + IntToHex(ASearchRec.FindHandle,8));
  {$ENDIF}
  
  {Get the Handle}
  Handle:=GetEnumFromHandle(ASearchRec.FindHandle,True,FILESYS_LOCK_WRITE);
  if Handle = nil then Exit;
  
  {Close the Handle} {Do not unlock}
  CloseEnumHandle(Handle);
  
  ASearchRec.FindHandle:=INVALID_HANDLE_VALUE;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.CreateVolume(const AParent:String;ADriveNo:Integer):Boolean;
var
 Volume:TDiskVolume;
 Device:TDiskDevice;
 Partition:TDiskPartition;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.CreateVolume');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Parent = ' + AParent);
  {$ENDIF}

  if TrimRight(AParent) = '' then Exit;
  
  {Get the Parent}
  Device:=GetDeviceByName(AParent,True,FILESYS_LOCK_READ);
  if Device <> nil then
   begin
    try
     {Check for Partition}
     if GetPartitionByDevice(Device,False,FILESYS_LOCK_NONE) <> nil then Exit; {Do not lock}
    
     {Check for Volume}
     if GetVolumeByDevice(Device,False,FILESYS_LOCK_NONE) <> nil then Exit; {Do not lock}
    
     {Check for Drive}
     if ADriveNo <> INVALID_DRIVE then if GetDriveByNo(ADriveNo,False,FILESYS_LOCK_NONE) <> nil then Exit; {Do not lock}
    
     {Create the Volume}
     Volume:=Device.CreateVolume;
     if Volume = nil then Exit;
     Volume.VolumeInit;
    
     {Mount the Volume}
     if not Volume.MountVolume(ADriveNo) then Exit;
    
     Result:=True;
    finally
     {Unlock Device}
     Device.ReaderUnlock;
    end;    
   end
  else
   begin
    Partition:=GetPartitionByPath(AParent,True,FILESYS_LOCK_READ);
    if Partition <> nil then
     begin
      try
       {Check for Volume}
       if GetVolumeByPartition(Partition,False,FILESYS_LOCK_NONE) <> nil then Exit; {Do not lock}
      
       {Check for Drive}
       if ADriveNo <> INVALID_DRIVE then if GetDriveByNo(ADriveNo,False,FILESYS_LOCK_NONE) <> nil then Exit; {Do not lock}
      
       {Create the Volume}
       Volume:=Partition.CreateVolume;
       if Volume = nil then Exit;
       Volume.VolumeInit;
      
       {Mount the Volume}
       if not Volume.MountVolume(ADriveNo) then Exit;
      
       Result:=True;
      finally
       {Unlock Partition}
       Partition.ReaderUnlock;
      end;      
     end;
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.DeleteVolume(Const AName:String):Boolean;
var
 Volume:TDiskVolume;
 Device:TDiskDevice;
 Partition:TDiskPartition;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.DeleteVolume');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Name = ' + AName);
  {$ENDIF}

  if TrimRight(AName) = '' then Exit;
  
  {Get the Volume}
  Volume:=GetVolumeByName(AName,True,FILESYS_LOCK_WRITE);
  if Volume = nil then Exit;
  
  {Get the Device}
  if CheckDevice(Volume.Device,True,FILESYS_LOCK_READ) then
   begin
    Device:=Volume.Device;
    
    if Volume.Partition = nil then
     begin
      {Delete the Volume} {Note: The Volume will automatically dismount and destroy any filesystems/drives when destroyed}
      Result:=Device.DeleteVolume(Volume);
     end
    else
     begin
      {Get the Partition}
      if CheckPartition(Volume.Partition,True,FILESYS_LOCK_READ) then
       begin
        Partition:=Volume.Partition;
      
        {Delete the Volume} {Note: The Volume will automatically dismount and destroy any filesystems/drives when destroyed}
        Result:=Partition.DeleteVolume(Volume);
      
        {Unlock Partition}
        Partition.ReaderUnlock;
       end;
     end;
     
    {Unlock Device} 
    Device.ReaderUnlock;
   end;
    
  {Unlock Volume}
  if not Result then Volume.WriterUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.MountVolume(const AName:String;ADriveNo:Integer):Boolean;
var
 Volume:TDiskVolume;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.MountVolume');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Name = ' + AName);
  {$ENDIF}

  if TrimRight(AName) = '' then Exit;
  
  {Get the Volume}
  Volume:=GetVolumeByName(AName,True,FILESYS_LOCK_WRITE);
  if Volume = nil then Exit;
  
  Result:=Volume.MountVolume(ADriveNo);
  
  {Unlock Volume}
  Volume.WriterUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.DismountVolume(const AName:String):Boolean;
var
 Volume:TDiskVolume;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.DismountVolume');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Name = ' + AName);
  {$ENDIF}

  if TrimRight(AName) = '' then Exit;
  
  {Get the Volume}
  Volume:=GetVolumeByName(AName,True,FILESYS_LOCK_WRITE);
  if Volume = nil then Exit;
  
  Result:=Volume.DismountVolume;
  
  {Unlock Volume}
  Volume.WriterUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FormatVolume(const AName:String;AFloppyType:TFloppyType;AFileSysType:TFileSysType):Boolean;
var
 Volume:TDiskVolume;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FormatVolume');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Name = ' + AName);
  {$ENDIF}

  if TrimRight(AName) = '' then Exit;
  
  {Get the Volume}
  Volume:=GetVolumeByName(AName,True,FILESYS_LOCK_WRITE);
  if Volume = nil then Exit;
  
  Result:=Volume.FormatVolume(AFloppyType,AFileSysType);
  
  {Unlock Volume}
  Volume.WriterUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.DefragmentVolume(const AName:String):Boolean;
var
 Volume:TDiskVolume;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.DefragmentVolume');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Name = ' + AName);
  {$ENDIF}

  if TrimRight(AName) = '' then Exit;
  
  {Get the Volume}
  Volume:=GetVolumeByName(AName,True,FILESYS_LOCK_WRITE);
  if Volume = nil then Exit;
  
  Result:=Volume.DefragmentVolume;
  
  {Unlock Volume}
  Volume.WriterUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.ConvertVolume(const AName:String;AFileSysType:TFileSysType):Boolean;
var
 Volume:TDiskVolume;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.ConvertVolume');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Name = ' + AName);
  {$ENDIF}

  if TrimRight(AName) = '' then Exit;
  
  {Get the Volume}
  Volume:=GetVolumeByName(AName,True,FILESYS_LOCK_WRITE);
  if Volume = nil then Exit;
  
  Result:=Volume.ConvertVolume(AFileSysType);
  
  {Unlock Volume}
  Volume.WriterUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.RepairVolume(const AName:String):Boolean;
var
 Volume:TDiskVolume;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.RepairVolume');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Name = ' + AName);
  {$ENDIF}

  if TrimRight(AName) = '' then Exit;
  
  {Get the Volume}
  Volume:=GetVolumeByName(AName,True,FILESYS_LOCK_WRITE);
  if Volume = nil then Exit;
  
  Result:=Volume.RepairVolume;
  
  {Unlock Volume}
  Volume.WriterUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.CopyVolume(const AName,ADest:String):Boolean;
var
 Dest:TDiskVolume;
 Volume:TDiskVolume;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.CopyVolume');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Name = ' + AName);
  {$ENDIF}

  if TrimRight(AName) = '' then Exit;
  
  {Get the Volume}
  Volume:=GetVolumeByName(AName,True,FILESYS_LOCK_WRITE);
  if Volume = nil then Exit;
  try
   {Get the Dest}
   Dest:=GetVolumeByName(ADest,True,FILESYS_LOCK_WRITE);
   if Dest = nil then Exit;
   
   Result:=Volume.CopyVolume(Dest);
  
   {Unlock Dest}
   Dest.WriterUnlock;
  finally
   {Unlock Volume}
   Volume.WriterUnlock;
  end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.ShrinkVolume(const AName:String;const AStart,ASize:Int64):Boolean;
var
 Volume:TDiskVolume;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.ShrinkVolume');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Name = ' + AName);
  {$ENDIF}

  if TrimRight(AName) = '' then Exit;
  
  {Get the Volume}
  Volume:=GetVolumeByName(AName,True,FILESYS_LOCK_WRITE);
  if Volume = nil then Exit;
  
  Result:=Volume.ShrinkVolume(AStart,ASize);
  
  {Unlock Volume}
  Volume.WriterUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.ExpandVolume(const AName:String;const AStart,ASize:Int64):Boolean;
var
 Volume:TDiskVolume;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.ExpandVolume');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Name = ' + AName);
  {$ENDIF}

  if TrimRight(AName) = '' then Exit;
  
  {Get the Volume}
  Volume:=GetVolumeByName(AName,True,FILESYS_LOCK_WRITE);
  if Volume = nil then Exit;
  
  Result:=Volume.ExpandVolume(AStart,ASize);
  
  {Unlock Volume}
  Volume.WriterUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.OpenVolume(const AName:String;AMode:Integer):Integer;
var
 Volume:TDiskVolume;
begin
 {}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.OpenVolume');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Name = ' + AName);
  {$ENDIF}

  if TrimRight(AName) = '' then Exit;
  
  {Check the Mode}
  if AMode = fmCreate then Exit; {Cannot Create a Volume}
  
  {Get the Volume}
  Volume:=GetVolumeByName(AName,True,FILESYS_LOCK_READ);
  if Volume = nil then Exit;
  
  Result:=Volume.OpenVolume(AMode);

  {Unlock Volume}
  Volume.ReaderUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

procedure TFileSysDriver.CloseVolume(AHandle:Integer);
var
 Volume:TDiskVolume;
begin
 {}
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.CloseVolume');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}

  {Get the Volume}
  Volume:=GetVolumeFromRaw(AHandle,True,FILESYS_LOCK_READ);
  if Volume = nil then Exit;
  
  Volume.CloseVolume(AHandle);

  {Unlock Volume}
  Volume.ReaderUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.ReadVolume(AHandle:Integer;var ABuffer;ACount:Integer):Integer;
{Note: Raw Reads must be in Sector sized multiples}
var
 Volume:TDiskVolume;
begin
 {}
 Result:=0;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.ReadVolume');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}

  if ACount < 1 then Exit;
  
  {Get the Volume}
  Volume:=GetVolumeFromRaw(AHandle,True,FILESYS_LOCK_READ);
  if Volume = nil then Exit;
  
  Result:=Volume.ReadVolume(AHandle,ABuffer,ACount);

  {Unlock Volume}
  Volume.ReaderUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.WriteVolume(AHandle:Integer;const ABuffer;ACount:Integer):Integer;
{Note: Raw Writes must be in Sector sized multiples}
var
 Volume:TDiskVolume;
begin
 {}
 Result:=0;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.WriteVolume');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}

  if ACount < 1 then Exit;
 
  {Get the Volume}
  Volume:=GetVolumeFromRaw(AHandle,True,FILESYS_LOCK_READ);
  if Volume = nil then Exit;
  
  Result:=Volume.WriteVolume(AHandle,ABuffer,ACount);
  
  {Unlock Volume}
  Volume.ReaderUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.SeekVolume(AHandle:Integer;const AOffset:Int64;AOrigin:Integer):Int64;
{Note: Raw Seeks must be in Sector sized multiples}
{Note: Raw Seeks cannot extend the size of the Volume}
var
 Volume:TDiskVolume;
begin
 {}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.SeekVolume');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}

  {Get the Volume}
  Volume:=GetVolumeFromRaw(AHandle,True,FILESYS_LOCK_READ);
  if Volume = nil then Exit;
  
  Result:=Volume.SeekVolume(AHandle,AOffset,AOrigin);
  
  {Unlock Volume}
  Volume.ReaderUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FindFirstVolume(var ASearchRec:TVolumeSearchRec;AVerbose:Boolean):Integer;
//To Do //Handle Verbose - See DwDisk/DwVirtual etc
var
 Handle:TEnumHandle;
 Current:TDiskVolume;
begin
 {Base Implementation}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  ASearchRec.FindHandle:=INVALID_HANDLE_VALUE;

  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FindFirstVolume');
  {$ENDIF}
  
  {Find First Volume}
  Current:=GetVolumeByNext(nil,True,False,FILESYS_LOCK_READ); 
  if Current = nil then Exit;
  try
   {Open Handle}
   Handle:=OpenEnumHandle(nil,True,FILESYS_LOCK_WRITE);
   if Handle = nil then Exit;
  
   {Set the Handle properties}
   Handle.CurrentVolume:=Current;
  
   {Return Volume}
   ASearchRec.FindHandle:=Handle.Handle;
   ASearchRec.Name:=Current.Name;
   ASearchRec.Attributes:=Current.Attributes;
   ASearchRec.VolumeLabel:=Current.VolumeName;
   ASearchRec.VolumeGUID:=Current.VolumeGUID;
   ASearchRec.VolumeSerial:=Current.VolumeSerial;
   ASearchRec.DriveType:=Current.DriveType;
   ASearchRec.FileSysType:=Current.FileSysType;
  
   Result:=0;
   
   {Unlock Handle}
   Handle.WriterUnlock;
  finally 
   {Unlock Volume}
   Current.ReaderUnlock;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FindNextVolume(var ASearchRec:TVolumeSearchRec):Integer;
var
 Handle:TEnumHandle;
 Current:TDiskVolume;
begin
 {Base Implementation}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FindNextVolume');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Handle = ' + IntToHex(ASearchRec.FindHandle,8));
  {$ENDIF}
  
  {Get the Handle}
  Handle:=GetEnumFromHandle(ASearchRec.FindHandle,True,FILESYS_LOCK_WRITE);
  if Handle = nil then Exit;
  try
   {Check Volume}
   if not CheckVolume(Handle.CurrentVolume,True,FILESYS_LOCK_READ) then Exit;
  
   {Find Next Volume}
   Current:=GetVolumeByNext(Handle.CurrentVolume,True,True,FILESYS_LOCK_READ);
   if Current = nil then Exit;
  
   {Update Handle}
   Handle.CurrentVolume:=Current;
  
   {Return Volume}
   ASearchRec.FindHandle:=Handle.Handle;
   ASearchRec.Name:=Current.Name;
   ASearchRec.Attributes:=Current.Attributes;
   ASearchRec.VolumeLabel:=Current.VolumeName;
   ASearchRec.VolumeGUID:=Current.VolumeGUID;
   ASearchRec.VolumeSerial:=Current.VolumeSerial;
   ASearchRec.DriveType:=Current.DriveType;
   ASearchRec.FileSysType:=Current.FileSysType;
  
   {Unlock Volume}
   Current.ReaderUnlock;
  
   Result:=0;
  finally
   {Unlock Handle}
   Handle.WriterUnlock;
  end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

procedure TFileSysDriver.FindVolumeClose(var ASearchRec:TVolumeSearchRec);
{Close an open find Handle}
var
 Handle:TEnumHandle;
begin
 {Base Implementation}
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FindVolumeClose');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Handle = ' + IntToHex(ASearchRec.FindHandle,8));
  {$ENDIF}
  
  {Get the Handle}
  Handle:=GetEnumFromHandle(ASearchRec.FindHandle,True,FILESYS_LOCK_WRITE);
  if Handle = nil then Exit;
  
  {Close the Handle} {Do not unlock}
  CloseEnumHandle(Handle);
  
  ASearchRec.FindHandle:=INVALID_HANDLE_VALUE;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.CreateDrive(const AName,AParent:String):Boolean;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
 Device:TDiskDevice;
 Partition:TDiskPartition;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.CreateDrive');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Name = ' + AName);
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Parent = ' + AParent);
  {$ENDIF}

  if TrimRight(AName) = '' then Exit;
  if TrimRight(AParent) = '' then Exit;
  
  {Check for Drive}
  if GetDriveByName(AName,False,FILESYS_LOCK_NONE) <> nil then Exit; {Do not lock}
  
  {Get the Parent}
  Device:=GetDeviceByName(AParent,True,FILESYS_LOCK_READ);
  if Device <> nil then
   begin
    try
     {$IFDEF FILESYS_DEBUG}
     if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.CreateDrive Device = ' + Device.Name);
     {$ENDIF}
    
     {Check for Partition}
     if GetPartitionByDevice(Device,False,FILESYS_LOCK_NONE) <> nil then Exit; {Do not lock}
    
     {Get the Volume}
     Volume:=GetVolumeByDevice(Device,True,FILESYS_LOCK_WRITE);
     if Volume = nil then Exit;
     try
      {$IFDEF FILESYS_DEBUG}
      if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.CreateDrive Volume = ' + Volume.Name);
      {$ENDIF}
    
      {Check for Drive}
      if GetDriveByVolume(Volume,False,FILESYS_LOCK_NONE) <> nil then Exit; {Do not lock}
    
      {Create the Drive}
      Drive:=Volume.CreateDrive(GetPathDrive(AName));
      if Drive = nil then Exit;
      Drive.DriveInit;
    
      {$IFDEF FILESYS_DEBUG}
      if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.CreateDrive Drive = ' + Drive.Name);
      {$ENDIF}
    
      {Bind to FileSystem}
      if Volume.FileSystem <> nil then Volume.FileSystem.Drive:=Drive;
    
      Result:=True;
     finally
      {Unlock Volume}
      Volume.WriterUnlock;
     end;    
    finally
     {Unlock Device}
     Device.ReaderUnlock;
    end;    
   end
  else
   begin
    Partition:=GetPartitionByPath(AParent,True,FILESYS_LOCK_READ);
    if Partition <> nil then
     begin
      try
       {$IFDEF FILESYS_DEBUG}
       if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.CreateDrive Partition = ' + Partition.Path);
       {$ENDIF}
      
       {Get the Volume}
       Volume:=GetVolumeByPartition(Partition,True,FILESYS_LOCK_WRITE);
       if Volume = nil then Exit;
       try
        {$IFDEF FILESYS_DEBUG}
        if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.CreateDrive Volume = ' + Volume.Name);
        {$ENDIF}
      
        {Check for Drive}
        if GetDriveByVolume(Volume,False,FILESYS_LOCK_NONE) <> nil then Exit; {Do not lock}
      
        {Create the Drive}
        Drive:=Volume.CreateDrive(GetPathDrive(AName));
        if Drive = nil then Exit;
        Drive.DriveInit;
      
        {$IFDEF FILESYS_DEBUG}
        if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.CreateDrive Drive = ' + Drive.Name);
        {$ENDIF}
      
        {Bind to FileSystem}
        if Volume.FileSystem <> nil then Volume.FileSystem.Drive:=Drive;
       
        Result:=True;
       finally
        {Unlock Volume}
        Volume.WriterUnlock;
       end;      
      finally
       {Unlock Partition}
       Partition.ReaderUnlock;
      end;      
     end;
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.DeleteDrive(const AName:String):Boolean;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.DeleteDrive');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Name = ' + AName);
  {$ENDIF}

  if TrimRight(AName) = '' then Exit;
  
  {Get the Drive}
  Drive:=GetDriveByName(AName,True,FILESYS_LOCK_WRITE);
  if Drive = nil then Exit;
  
  {Get the Volume}
  if CheckVolume(Drive.Volume,True,FILESYS_LOCK_WRITE) then
   begin
    Volume:=Drive.Volume;
   
    {Dismount Find Handles}
    DismountFindHandles(nil,Drive);
  
    {Dismount File Handles}
    DismountFileHandles(nil,Drive);
  
    {Unbind from FileSystem}
    if Drive.FileSystem <> nil then Drive.FileSystem.Drive:=nil;
  
    {Delete the Drive}
    Result:=Volume.DeleteDrive(Drive);
    
    {Unlock Volume}
    Volume.WriterUnlock;
   end; 

  {Unlock Drive}
  if not Result then Drive.WriterUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FormatDrive(const AName:String;AFloppyType:TFloppyType;AFileSysType:TFileSysType):Boolean;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FormatDrive');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Name = ' + AName);
  {$ENDIF}

  if TrimRight(AName) = '' then Exit;
  
  {Get the Drive}
  Drive:=GetDriveByName(AName,True,FILESYS_LOCK_READ);
  if Drive = nil then Exit;
  
  {Get the Volume}
  Volume:=Drive.Volume;
  
  {Unlock Drive}
  Drive.ReaderUnlock;
  
  {Get the Volume}
  if CheckVolume(Volume,True,FILESYS_LOCK_WRITE) then
   begin
    {Format Volume}
    Result:=Volume.FormatVolume(AFloppyType,AFileSysType);
  
    {Unlock Volume}
    Volume.WriterUnlock;
   end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.OpenDrive(const AName:String;AMode:Integer):Integer;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.OpenDrive');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Name = ' + AName);
  {$ENDIF}

  if TrimRight(AName) = '' then Exit;
  
  {Check the Mode}
  if AMode = fmCreate then Exit; {Cannot Create on a Drive}
  
  {Get the Drive}
  Drive:=GetDriveByName(AName,True,FILESYS_LOCK_READ);
  if Drive = nil then Exit;

  {Get the Volume}
  if CheckVolume(Drive.Volume,True,FILESYS_LOCK_READ) then
   begin
    Volume:=Drive.Volume;

    {Open Volume}
    Result:=Volume.OpenVolume(AMode);
     
    {Unlock Volume}
    Volume.ReaderUnlock;
   end; 

  {Unlock Drive}
  Drive.ReaderUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

procedure TFileSysDriver.CloseDrive(AHandle:Integer);
var
 Volume:TDiskVolume;
begin
 {}
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.CloseDrive');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}

  {Check the Volume}
  Volume:=GetVolumeFromRaw(AHandle,True,FILESYS_LOCK_READ);
  if Volume = nil then Exit;

  {Close Volume}
  Volume.CloseVolume(AHandle);
    
  {Unlock Volume}
  Volume.ReaderUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.ReadDrive(AHandle:Integer;var ABuffer;ACount:Integer):Integer;
{Note: Raw Reads must be in Sector sized multiples}
var
 Volume:TDiskVolume;
begin
 {}
 Result:=0;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.ReadDrive');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}

  if ACount < 1 then Exit;
  
  {Check the Volume}
  Volume:=GetVolumeFromRaw(AHandle,True,FILESYS_LOCK_READ);
  if Volume = nil then Exit;

  {Read Volume}
  Result:=Volume.ReadVolume(AHandle,ABuffer,ACount);

  {Unlock Volume}
  Volume.ReaderUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.WriteDrive(AHandle:Integer;const ABuffer;ACount:Integer):Integer;
{Note: Raw Writes must be in Sector sized multiples}
var
 Volume:TDiskVolume;
begin
 {}
 Result:=0;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.WriteDrive');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}

  if ACount < 1 then Exit;
  
  {Check the Volume}
  Volume:=GetVolumeFromRaw(AHandle,True,FILESYS_LOCK_READ);
  if Volume = nil then Exit;

  {Write Volume}
  Result:=Volume.WriteVolume(AHandle,ABuffer,ACount);

  {Unlock Volume}
  Volume.ReaderUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.SeekDrive(AHandle:Integer;const AOffset:Int64;AOrigin:Integer):Int64;
{Note: Raw Seeks must be in Sector sized multiples}
{Note: Raw Seeks cannot extend the size of the Drive}
var
 Volume:TDiskVolume;
begin
 {}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.SeekDrive');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}

  {Check the Volume}
  Volume:=GetVolumeFromRaw(AHandle,True,FILESYS_LOCK_READ);
  if Volume = nil then Exit;

  {Seek Volume}
  Result:=Volume.SeekVolume(AHandle,AOffset,AOrigin);

  {Unlock Volume}
  Volume.ReaderUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FindFirstDrive(var ASearchRec:TDriveSearchRec;AVerbose:Boolean):Integer;
//To Do //Handle Verbose - See DwDisk/DwVirtual etc
var
 Handle:TEnumHandle;
 Current:TDiskDrive;
begin
 {Base Implementation}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  ASearchRec.FindHandle:=INVALID_HANDLE_VALUE;

  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FindFirstDrive');
  {$ENDIF}
  
  {Find First Drive}
  Current:=GetDriveByNext(nil,True,False,FILESYS_LOCK_READ);
  if Current = nil then Exit;
  try
   {Open Handle}
   Handle:=OpenEnumHandle(nil,True,FILESYS_LOCK_WRITE);
   if Handle = nil then Exit;
  
   {Set the Handle properties}
   Handle.CurrentDrive:=Current;
  
   {Return Drive}
   ASearchRec.FindHandle:=Handle.Handle;
   ASearchRec.Name:=Current.Name;
   ASearchRec.Attributes:=Current.Attributes;
   ASearchRec.VolumeLabel:=Current.VolumeName;
   ASearchRec.VolumeGUID:=Current.VolumeGUID;
   ASearchRec.VolumeSerial:=Current.VolumeSerial;
   ASearchRec.DriveType:=Current.DriveType;
   ASearchRec.FileSysType:=Current.FileSysType;
   
   Result:=0;
   
   {Unlock Handle}
   Handle.WriterUnlock;
  finally 
   {Unlock Drive}
   Current.ReaderUnlock;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FindNextDrive(var ASearchRec:TDriveSearchRec):Integer;
var
 Handle:TEnumHandle;
 Current:TDiskDrive;
begin
 {Base Implementation}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FindNextDrive');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Handle = ' + IntToHex(ASearchRec.FindHandle,8));
  {$ENDIF}
  
  {Get the Handle}
  Handle:=GetEnumFromHandle(ASearchRec.FindHandle,True,FILESYS_LOCK_WRITE);
  if Handle = nil then Exit;
  try
   {Check Drive}
   if not CheckDrive(Handle.CurrentDrive,True,FILESYS_LOCK_READ) then Exit;
  
   {Find Next Drive}
   Current:=GetDriveByNext(Handle.CurrentDrive,True,True,FILESYS_LOCK_READ);
   if Current = nil then Exit;
  
   {Update Handle}
   Handle.CurrentDrive:=Current;
  
   {Return Drive}
   ASearchRec.FindHandle:=Handle.Handle;
   ASearchRec.Name:=Current.Name;
   ASearchRec.Attributes:=Current.Attributes;
   ASearchRec.VolumeLabel:=Current.VolumeName;
   ASearchRec.VolumeGUID:=Current.VolumeGUID;
   ASearchRec.VolumeSerial:=Current.VolumeSerial;
   ASearchRec.DriveType:=Current.DriveType;
   ASearchRec.FileSysType:=Current.FileSysType;
  
   {Unlock Drive}
   Current.ReaderUnlock;
  
   Result:=0;
  finally
   {Unlock Handle}
   Handle.WriterUnlock;
  end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

procedure TFileSysDriver.FindDriveClose(var ASearchRec:TDriveSearchRec);
{Close an open find Handle}
var
 Handle:TEnumHandle;
begin
 {Base Implementation}
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FindDriveClose');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Handle = ' + IntToHex(ASearchRec.FindHandle,8));
  {$ENDIF}
  
  {Get the Handle}
  Handle:=GetEnumFromHandle(ASearchRec.FindHandle,True,FILESYS_LOCK_WRITE);
  if Handle = nil then Exit;
  
  {Close the Handle} {Do not unlock}
  CloseEnumHandle(Handle);
  
  ASearchRec.FindHandle:=INVALID_HANDLE_VALUE;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.MountImage(AImageNo:Integer):Boolean;
var
 Image:TDiskImage;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.MountImage');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                ImageNo = ' + IntToStr(AImageNo));
  {$ENDIF}

  if AImageNo = 0 then Exit;
  
  {Get the Image}
  Image:=GetImageByNo(AImageNo,True,FILESYS_LOCK_WRITE);
  if Image = nil then Exit;
  
  Result:=Image.MountImage;
  
  {Unlock Image}
  Image.WriterUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.DismountImage(AImageNo:Integer):Boolean;
var
 Image:TDiskImage;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.DismountImage');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                ImageNo = ' + IntToStr(AImageNo));
  {$ENDIF}

  if AImageNo = 0 then Exit;
  
  {Get the Image}
  Image:=GetImageByNo(AImageNo,True,FILESYS_LOCK_WRITE);
  if Image = nil then Exit;
  
  Result:=Image.DismountImage;
  
  {Unlock Image}
  Image.WriterUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.InsertImage(AImageNo:Integer):Boolean;
var
 Image:TDiskImage;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.InsertImage');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                ImageNo = ' + IntToStr(AImageNo));
  {$ENDIF}

  if AImageNo = 0 then Exit;
  
  {Get the Image}
  Image:=GetImageByNo(AImageNo,True,FILESYS_LOCK_WRITE);
  if Image = nil then Exit;
  
  Result:=Image.InsertImage;

  {Unlock Image}
  Image.WriterUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.EjectImage(AImageNo:Integer):Boolean;
var
 Image:TDiskImage;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.EjectImage');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                ImageNo = ' + IntToStr(AImageNo));
  {$ENDIF}

  if AImageNo = 0 then Exit;
  
  {Get the Image}
  Image:=GetImageByNo(AImageNo,True,FILESYS_LOCK_WRITE);
  if Image = nil then Exit;
  
  Result:=Image.EjectImage;

  {Unlock Image}
  Image.WriterUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.ConvertImage(AImageNo:Integer;AImageType:TImageType):Boolean;
var
 Image:TDiskImage;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.ConvertImage');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                ImageNo = ' + IntToStr(AImageNo));
  {$ENDIF}

  if AImageNo = 0 then Exit;
  
  {Get the Image}
  Image:=GetImageByNo(AImageNo,True,FILESYS_LOCK_WRITE);
  if Image = nil then Exit;
  
  Result:=Image.ConvertImage(AImageType);

  {Unlock Image}
  Image.WriterUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.CopyImage(AImageNo,ADestNo:Integer):Boolean;
var
 Dest:TDiskImage;
 Image:TDiskImage;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.CopyImage');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                ImageNo = ' + IntToStr(AImageNo));
  {$ENDIF}

  if AImageNo = 0 then Exit;
  
  {Get the Image}
  Image:=GetImageByNo(AImageNo,True,FILESYS_LOCK_WRITE);
  if Image = nil then Exit;
  try
   {Get the Dest}
   Dest:=GetImageByNo(ADestNo,True,FILESYS_LOCK_WRITE);
   if Dest = nil then Exit;
   
   Result:=Image.CopyImage(Dest); 
   
   {Unlock Dest}
   Dest.WriterUnlock;
  finally
   {Unlock Image}
   Image.WriterUnlock;
  end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.ShrinkImage(AImageNo:Integer;const ASize:Int64):Boolean;
var
 Image:TDiskImage;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.ShrinkImage');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                ImageNo = ' + IntToStr(AImageNo));
  {$ENDIF}

  if AImageNo = 0 then Exit;
  
  {Get the Image}
  Image:=GetImageByNo(AImageNo,True,FILESYS_LOCK_WRITE);
  if Image = nil then Exit;
  
  Result:=Image.ShrinkImage(ASize);
  
  {Unlock Image}
  Image.WriterUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.ExpandImage(AImageNo:Integer;const ASize:Int64):Boolean;
var
 Image:TDiskImage;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.ExpandImage');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                ImageNo = ' + IntToStr(AImageNo));
  {$ENDIF}

  if AImageNo = 0 then Exit;
  
  {Get the Image}
  Image:=GetImageByNo(AImageNo,True,FILESYS_LOCK_WRITE);
  if Image = nil then Exit;
  
  Result:=Image.ExpandImage(ASize);
  
  {Unlock Image}
  Image.WriterUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.CreateImage(AImageNo:Integer;const AName:String;AImageType:TImageType;AMediaType:TMediaType;AFloppyType:TFloppyType;AAttributes:LongWord;ASectorSize:Word;const ASectorCount:Int64;ACylinders,AHeads,ASectors:LongWord;APartitionId:Byte):Integer;
var
 Image:TDiskImage;
 Recognizer:TRecognizer;
begin
 {}
 Result:=0; {Return is an ImageNo}
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.CreateImage');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                ImageNo = ' + IntToStr(AImageNo));
  {$ENDIF}

  {Get the Image}
  Image:=GetImageByNo(AImageNo,True,FILESYS_LOCK_WRITE);
  {if Image = nil then Exit;} {Image may be nil}
  try
   {Get the Recognizer}
   Recognizer:=GetRecognizerByNext(nil,True,False,FILESYS_LOCK_READ);
   while Recognizer <> nil do
    begin
     if Recognizer.Imager <> nil then
      begin
       if Recognizer.Imager.AcceptImage(Image,AName,AImageType,AMediaType,AFloppyType,AAttributes,ASectorSize,ASectorCount) then
        begin
         {Create Image}
         Result:=Recognizer.Imager.CreateImage(Image,AName,AImageType,AMediaType,AFloppyType,AAttributes,ASectorSize,ASectorCount,ACylinders,AHeads,ASectors,APartitionId);
        
         {Unlock Recognizer}
         Recognizer.ReaderUnlock;
         Exit;
        end;
      end;
      
     Recognizer:=GetRecognizerByNext(Recognizer,True,True,FILESYS_LOCK_READ);
    end;
  finally
   {Unlock Image}
   if Image <> nil then Image.WriterUnlock;
  end;  
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.OpenImage(AImageNo:Integer;const AName:String;AImageType:TImageType;AMediaType:TMediaType;AFloppyType:TFloppyType;AAttributes:LongWord;ASectorSize:Word;const ASectorCount:Int64;ACylinders,AHeads,ASectors:LongWord;APartitionId:Byte):Integer;
var
 Image:TDiskImage;
 Recognizer:TRecognizer;
begin
 {}
 Result:=0; {Return is an ImageNo}
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.OpenImage');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                ImageNo = ' + IntToStr(AImageNo));
  {$ENDIF}

  {Get the Image}
  Image:=GetImageByNo(AImageNo,True,FILESYS_LOCK_WRITE);
  {if Image = nil then Exit;} {Image may be nil}
  try
   {Get the Recognizer}
   Recognizer:=GetRecognizerByNext(nil,True,False,FILESYS_LOCK_READ); 
   while Recognizer <> nil do
    begin
     if Recognizer.Imager <> nil then
      begin
       if Recognizer.Imager.AcceptImage(Image,AName,AImageType,AMediaType,AFloppyType,AAttributes,ASectorSize,ASectorCount) then
        begin
         {Open Image}
         Result:=Recognizer.Imager.OpenImage(Image,AName,AImageType,AMediaType,AFloppyType,AAttributes,ASectorSize,ASectorCount,ACylinders,AHeads,ASectors,APartitionId);
         
         {Unlock Recognizer}
         Recognizer.ReaderUnlock;
         Exit;
        end;
      end;
     
     Recognizer:=GetRecognizerByNext(Recognizer,True,True,FILESYS_LOCK_READ);
    end;
  finally
   {Unlock Image}
   if Image <> nil then Image.WriterUnlock;
  end;  
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.CloseImage(AImageNo:Integer):Boolean;
var
 Image:TDiskImage;
 Recognizer:TRecognizer;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.CloseImage');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                ImageNo = ' + IntToStr(AImageNo));
  {$ENDIF}

  if AImageNo = 0 then Exit;
 
  {Get the Image}
  Image:=GetImageByNo(AImageNo,True,FILESYS_LOCK_WRITE);
  if Image = nil then Exit;
  try
   {Get the Recognizer}
   Recognizer:=GetRecognizerByImage(Image,True,FILESYS_LOCK_READ);
   if Recognizer = nil then Exit;
   try
    if Recognizer.Imager = nil then Exit;
  
    Recognizer.Imager.CloseImage(Image);
 
    {Unlock Image}
    {Image.WriterUnlock;} {Can destroy Synchronizer while holding lock}
 
    {Destroy the Image}
    Image.Free;
  
    Result:=True;
   finally
    {Unlock Recognizer}
    Recognizer.ReaderUnlock;
   end;   
  finally
   {Unlock Image}
   if not Result then Image.WriterUnlock;
  end;  
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.CreateSnapshot(AImageNo:Integer):Boolean;
var
 Image:TDiskImage;
 Recognizer:TRecognizer;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.CreateSnapshot');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                ImageNo = ' + IntToStr(AImageNo));
  {$ENDIF}

  if AImageNo = 0 then Exit;
  
  {Get the Image}
  Image:=GetImageByNo(AImageNo,True,FILESYS_LOCK_WRITE);
  if Image = nil then Exit;
  try
   {Get the Recognizer}
   Recognizer:=GetRecognizerByImage(Image,True,FILESYS_LOCK_READ);
   if Recognizer = nil then Exit;
   try
    if Recognizer.Imager = nil then Exit;
  
    Result:=Recognizer.Imager.CreateSnapshot(Image);
   finally
    {Unlock Recognizer}
    Recognizer.ReaderUnlock;
   end;   
  finally
   {Unlock Image}
   Image.WriterUnlock;
  end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.DeleteSnapshot(AImageNo:Integer):Boolean;
var
 Image:TDiskImage;
 Recognizer:TRecognizer;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.DeleteSnapshot');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                ImageNo = ' + IntToStr(AImageNo));
  {$ENDIF}

  if AImageNo = 0 then Exit;
  
  {Get the Image}
  Image:=GetImageByNo(AImageNo,True,FILESYS_LOCK_WRITE);
  if Image = nil then Exit;
  try
   {Get the Recognizer}
   Recognizer:=GetRecognizerByImage(Image,True,FILESYS_LOCK_READ);
   if Recognizer = nil then Exit;
   try
    if Recognizer.Imager = nil then Exit;
  
    Result:=Recognizer.Imager.DeleteSnapshot(Image);
   finally
    {Unlock Recognizer}
    Recognizer.ReaderUnlock;
   end;   
  finally
   {Unlock Image}
   Image.WriterUnlock;
  end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.MergeSnapshot(AImageNo:Integer):Boolean;
var
 Image:TDiskImage;
 Recognizer:TRecognizer;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.MergeSnapshot');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                ImageNo = ' + IntToStr(AImageNo));
  {$ENDIF}

  if AImageNo = 0 then Exit;
  
  {Get the Image}
  Image:=GetImageByNo(AImageNo,True,FILESYS_LOCK_WRITE);
  if Image = nil then Exit;
  try
   {Get the Recognizer}
   Recognizer:=GetRecognizerByImage(Image,True,FILESYS_LOCK_READ);
   if Recognizer = nil then Exit;
   try
    if Recognizer.Imager = nil then Exit;
  
    Result:=Recognizer.Imager.MergeSnapshot(Image);
   finally
    {Unlock Recognizer}
    Recognizer.ReaderUnlock;
   end;   
  finally
   {Unlock Image}
   Image.WriterUnlock;
  end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FindFirstImage(var ASearchRec:TImageSearchRec;AVerbose:Boolean):Integer;
//To Do //Handle Verbose - See DwDisk/DwVirtual etc //FindNext as well ?
var
 Handle:TEnumHandle;
 Current:TDiskImage;
begin
 {Base Implementation}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  ASearchRec.FindHandle:=INVALID_HANDLE_VALUE;

  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FindFirstImage');
  {$ENDIF}
  
  {Find First Image}
  Current:=GetImageByNext(nil,True,False,FILESYS_LOCK_READ); 
  if Current = nil then Exit;
  try
   {Open Handle}
   Handle:=OpenEnumHandle(nil,True,FILESYS_LOCK_WRITE);
   if Handle = nil then Exit;
  
   {Set the Handle properties}
   Handle.CurrentImage:=Current;
  
   {Return Image}
   ASearchRec.FindHandle:=Handle.Handle;
   ASearchRec.Name:=Current.Name;
   ASearchRec.ImageNo:=Current.ImageNo;
   ASearchRec.ImageType:=Current.ImageType;
   ASearchRec.MediaType:=Current.MediaType;
   ASearchRec.FloppyType:=Current.FloppyType;
   ASearchRec.Attributes:=Current.Attributes;
   ASearchRec.SectorSize:=Current.SectorSize;
   ASearchRec.SectorCount:=Current.SectorCount;
   ASearchRec.Cylinders:=Current.Cylinders;
   ASearchRec.Heads:=Current.Heads;
   ASearchRec.Sectors:=Current.Sectors;
   ASearchRec.PartitionId:=Current.PartitionId;
 
   Result:=0;
   
   {Unlock Handle}
   Handle.WriterUnlock;
  finally 
   {Unlock Image}
   Current.ReaderUnlock;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FindNextImage(var ASearchRec:TImageSearchRec):Integer;
var
 Handle:TEnumHandle;
 Current:TDiskImage;
begin
 {Base Implementation}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FindNextImage');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Handle = ' + IntToHex(ASearchRec.FindHandle,8));
  {$ENDIF}
  
  {Get the Handle}
  Handle:=GetEnumFromHandle(ASearchRec.FindHandle,True,FILESYS_LOCK_WRITE);
  if Handle = nil then Exit;
  try
   {Check Image}
   if not CheckImage(Handle.CurrentImage,True,FILESYS_LOCK_READ) then Exit;
   
   {Find Next Image}
   Current:=GetImageByNext(Handle.CurrentImage,True,True,FILESYS_LOCK_READ);
   if Current = nil then Exit;
  
   {Update Handle}
   Handle.CurrentImage:=Current;
  
   {Return Image}
   ASearchRec.FindHandle:=Handle.Handle;
   ASearchRec.Name:=Current.Name;
   ASearchRec.ImageNo:=Current.ImageNo;
   ASearchRec.ImageType:=Current.ImageType;
   ASearchRec.MediaType:=Current.MediaType;
   ASearchRec.FloppyType:=Current.FloppyType;
   ASearchRec.Attributes:=Current.Attributes;
   ASearchRec.SectorSize:=Current.SectorSize;
   ASearchRec.SectorCount:=Current.SectorCount;
   ASearchRec.Cylinders:=Current.Cylinders;
   ASearchRec.Heads:=Current.Heads;
   ASearchRec.Sectors:=Current.Sectors;
   ASearchRec.PartitionId:=Current.PartitionId;
  
   {Unlock Image}
   Current.ReaderUnlock;
  
   Result:=0;
  finally
   {Unlock Handle}
   Handle.WriterUnlock;
  end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

procedure TFileSysDriver.FindImageClose(var ASearchRec:TImageSearchRec);
{Close an open find Handle}
var
 Handle:TEnumHandle;
begin
 {Base Implementation}
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FindImageClose');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Handle = ' + IntToHex(ASearchRec.FindHandle,8));
  {$ENDIF}
 
  {Get the Handle}
  Handle:=GetEnumFromHandle(ASearchRec.FindHandle,True,FILESYS_LOCK_WRITE);
  if Handle = nil then Exit;
  
  {Close the Handle} {Do not unlock}
  CloseEnumHandle(Handle);
  
  ASearchRec.FindHandle:=INVALID_HANDLE_VALUE;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.CreateCatalog(const APath,AName:String;AMediaType:TMediaType;AFloppyType:TFloppyType;AAttributes:LongWord;ASectorSize:Word;const ASectorCount:Int64):LongWord;
var
 FileSystem:TFileSystem;
begin
 {}
 Result:=0; {Return is a CatalogNo}

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.CreateCatalog');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Path = ' + APath);
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Name = ' + AName);
  {$ENDIF}
  
  FileSystem:=GetFileSystemFromPath(APath,True,FILESYS_LOCK_READ);
  if FileSystem = nil then Exit;
  
  Result:=FileSystem.CreateCatalog(AName,AMediaType,AFloppyType,AAttributes,ASectorSize,ASectorCount);
  
  {Unlock FileSystem}
  FileSystem.ReaderUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.DeleteCatalog(const APath:String;ACatalogNo:LongWord):Boolean;
var
 FileSystem:TFileSystem;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  if ACatalogNo = 0 then Exit;
  
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.DeleteCatalog');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Path = ' + APath);
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                CatalogNo = ' + IntToStr(ACatalogNo));
  {$ENDIF}
  
  FileSystem:=GetFileSystemFromPath(APath,True,FILESYS_LOCK_READ);
  if FileSystem = nil then Exit;
  
  Result:=FileSystem.DeleteCatalog(ACatalogNo);

  {Unlock FileSystem}
  FileSystem.ReaderUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FindFirstCatalog(const APath:String;var ASearchRec:TCatalogSearchRec):Integer;
var
 FileSystem:TFileSystem;
begin
 {}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FindFirstCatalog');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Path = ' + APath);
  {$ENDIF}
  
  FileSystem:=GetFileSystemFromPath(APath,True,FILESYS_LOCK_READ);
  if FileSystem = nil then Exit;
  
  Result:=FileSystem.FindFirstCatalog(ASearchRec);

  {Unlock FileSystem}
  FileSystem.ReaderUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FindNextCatalog(var ASearchRec:TCatalogSearchRec):Integer;
var
 FileSystem:TFileSystem;
begin
 {}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FindNextCatalog');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Handle = ' + IntToHex(ASearchRec.FindHandle,8));
  {$ENDIF}
  
  {Get the FileSystem}  
  FileSystem:=GetFileSystemFromEnum(ASearchRec.FindHandle,True,FILESYS_LOCK_READ);  
  if FileSystem = nil then Exit;
  
  Result:=FileSystem.FindNextCatalog(ASearchRec);
  
  {Unlock FileSystem}
  FileSystem.ReaderUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

procedure TFileSysDriver.FindCatalogClose(var ASearchRec:TCatalogSearchRec);
var
 FileSystem:TFileSystem;
begin
 {}
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FindCatalogClose');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Handle = ' + IntToHex(ASearchRec.FindHandle,8));
  {$ENDIF}
  
  {Get the FileSystem}
  FileSystem:=GetFileSystemFromEnum(ASearchRec.FindHandle,True,FILESYS_LOCK_READ);  
  if FileSystem = nil then Exit;
  
  FileSystem.FindCatalogClose(ASearchRec);
 
  {Unlock FileSystem}
  FileSystem.ReaderUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.CheckTimer:Boolean; 
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {Check Timer}
  if FEntryTimer = nil then Exit;
 
  {Check Timer}
  Result:=FEntryTimer.CheckTimer;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.ProcessTimer:Boolean;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {Check Timer}
  if FEntryTimer = nil then Exit;
 
  {Process Timer}
  Result:=FEntryTimer.ProcessTimer;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.ScheduleEntry(AEntry:TDiskEntry;ATimeout:LongWord):Boolean;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {Check Timer}
  if FEntryTimer = nil then Exit;
  
  {Check Entry}
  {if AEntry = nil then Exit;} {Do not check}
  
  {Schedule Entry}
  Result:=FEntryTimer.ScheduleEntry(AEntry,ATimeout);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.UnscheduleEntry(AEntry:TDiskEntry):Boolean; 
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {Check Timer}
  if FEntryTimer = nil then Exit;
  
  {Check Entry}
  {if AEntry = nil then Exit;} {Do not check}
  
  {Unschedule Entry}
  Result:=FEntryTimer.UnscheduleEntry(AEntry);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetPathDrive(const APath:String):Byte;
{No Volume Support}
var
 Drive:TDiskDrive;
begin
 {}
 Result:=DEFAULT_DRIVE;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.GetPathDrive');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Path = ' + APath);
  {$ENDIF}

  Drive:=GetDriveFromPath(APath,True,FILESYS_LOCK_READ);
  if Drive = nil then
   begin
    {Get Default}
    Result:=Ultibo.GetPathDrive(APath);
   end
  else
   begin  
    Result:=Drive.DriveNo;
    
    {Unlock Drive}
    Drive.ReaderUnlock;
   end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetDriveType(ADrive:Byte):TDriveType;
{No Volume Support}
var
 Drive:TDiskDrive;
begin
 {}
 Result:=dtINVALID;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.GetDriveType');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Drive = ' + IntToStr(ADrive));
  {$ENDIF}

  if ADrive > NON_DRIVE then Exit;
  if ADrive = DEFAULT_DRIVE then ADrive:=GetCurrentDrive;
  
  Drive:=GetDriveByNo(ADrive,True,FILESYS_LOCK_READ);
  if Drive = nil then Exit;
 
  Result:=Drive.DriveType;
  
  {Unlock Drive}
  Drive.ReaderUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetDriveData(ADrive:Byte):TDriveData;
{No Volume Support}
var
 Drive:TDiskDrive;
begin
 {}
 FillChar(Result,SizeOf(TDriveData),0);
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.GetDriveData');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Drive = ' + IntToStr(ADrive));
  {$ENDIF}

  if ADrive > NON_DRIVE then Exit;
  if ADrive = DEFAULT_DRIVE then ADrive:=GetCurrentDrive;
  
  Drive:=GetDriveByNo(ADrive,True,FILESYS_LOCK_READ);
  if Drive = nil then Exit;
 
  Result.Drive:=Drive.DriveNo;
  Result.DriveType:=Drive.DriveType;
  Result.FileSysType:=Drive.FileSysType;
  Result.MaxFile:=Drive.MaxFile;
  Result.MaxPath:=Drive.MaxPath;
  Result.Attributes:=Drive.Attributes;
  Result.SystemName:=Drive.SystemName;
  Result.VolumeName:=Drive.VolumeName;
  Result.VolumeSerial:=Drive.VolumeSerial;
  
  {Unlock Drive}
  Drive.ReaderUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetDriveAttr(ADrive:Byte):LongWord;
{No Volume Support}
var
 Drive:TDiskDrive;
begin
 {}
 Result:=0;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.GetDriveAttr');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Drive = ' + IntToStr(ADrive));
  {$ENDIF}

  if ADrive > NON_DRIVE then Exit;
  if ADrive = DEFAULT_DRIVE then ADrive:=GetCurrentDrive;
  
  Drive:=GetDriveByNo(ADrive,True,FILESYS_LOCK_READ);
  if Drive = nil then Exit;
 
  Result:=Drive.Attributes;

  {Unlock Drive}
  Drive.ReaderUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetDriveLabel(ADrive:Byte):String;
{No Volume Support}
var
 Drive:TDiskDrive;
begin
 {}
 Result:='';
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.GetDriveLabel');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Drive = ' + IntToStr(ADrive));
  {$ENDIF}

  if ADrive > MAX_DRIVE then Exit;
  if ADrive = DEFAULT_DRIVE then ADrive:=GetCurrentDrive;
  
  Drive:=GetDriveByNo(ADrive,True,FILESYS_LOCK_READ);
  if Drive = nil then Exit;
  try 
   if Drive.FileSystem = nil then Exit;
 
   Result:=Drive.FileSystem.GetDriveLabel;
  finally
   {Unlock Drive}
   Drive.ReaderUnlock;
  end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.SetDriveLabel(ADrive:Byte;const ALabel:String):Boolean;
{No Volume Support}
var
 Drive:TDiskDrive;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.SetDriveLabel');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Drive = ' + IntToStr(ADrive));
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Label = ' + ALabel);
  {$ENDIF}

  if ADrive > MAX_DRIVE then Exit;
  if ADrive = DEFAULT_DRIVE then ADrive:=GetCurrentDrive;
  
  Drive:=GetDriveByNo(ADrive,True,FILESYS_LOCK_READ);
  if Drive = nil then Exit;
  try
   if Drive.FileSystem = nil then Exit;
 
   Result:=Drive.FileSystem.SetDriveLabel(ALabel);
  finally
   {Unlock Drive}
   Drive.ReaderUnlock;
  end;  
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetDriveSerial(ADrive:Byte):LongWord;
{No Volume Support}
var
 Drive:TDiskDrive;
begin
 {}
 Result:=0;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.GetDriveSerial');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Drive = ' + IntToStr(ADrive));
  {$ENDIF}

  if ADrive > MAX_DRIVE then Exit;
  if ADrive = DEFAULT_DRIVE then ADrive:=GetCurrentDrive;
  
  Drive:=GetDriveByNo(ADrive,True,FILESYS_LOCK_READ);
  if Drive = nil then Exit;
  try
   if Drive.FileSystem = nil then Exit;
 
   Result:=Drive.FileSystem.GetDriveSerial;
  finally
   {Unlock Drive}
   Drive.ReaderUnlock;
  end;  
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.SetDriveSerial(ADrive:Byte;ASerial:LongWord):Boolean;
{No Volume Support}
var
 Drive:TDiskDrive;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.SetDriveSerial');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Drive = ' + IntToStr(ADrive));
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Serial = ' + IntToHex(ASerial,8));
  {$ENDIF}

  if ADrive > MAX_DRIVE then Exit;
  if ADrive = DEFAULT_DRIVE then ADrive:=GetCurrentDrive;
  
  Drive:=GetDriveByNo(ADrive,True,FILESYS_LOCK_READ);
  if Drive = nil then Exit;
  try
   if Drive.FileSystem = nil then Exit;
 
   Result:=Drive.FileSystem.SetDriveSerial(ASerial);
  finally
   {Unlock Drive}
   Drive.ReaderUnlock;
  end;  
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.IsDriveValid(ADrive:Byte):Boolean;
{No Volume Support}
var
 Drive:TDiskDrive;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.IsDriveValid');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Drive = ' + IntToStr(ADrive));
  {$ENDIF}
 
  if ADrive > NON_DRIVE then Exit;
 
  if ADrive = DEFAULT_DRIVE then
   begin
    Drive:=GetDriveByNo(GetCurrentDrive,True,FILESYS_LOCK_READ);
    if Drive = nil then Exit;
   end
  else
   begin
    Drive:=GetDriveByNo(ADrive,True,FILESYS_LOCK_READ);
    if Drive = nil then Exit;
   end;
  
  if (Drive.DriveType <> dtUNKNOWN) and (Drive.DriveType <> dtINVALID) then
   begin
    Result:=True;
   end;
   
  {Unlock Drive}
  Drive.ReaderUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetValidDrives:LongWord;
{No Volume Support}
var
 Count:Integer;
begin
 {}
 Result:=0;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.GetValidDrives');
  {$ENDIF}

  for Count:=MIN_DRIVE to MAX_DRIVE do
   begin
    if IsDriveValid(Count) then
     begin
      Result:=(Result or DRIVE_MASKS[Count]);
     end;
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetValidDriveNames:TStringList;
{No Volume Support}
var
 Count:Integer;
 Mask:LongWord;
begin
 {}
 Result:=TStringList.Create;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.GetValidDriveNames');
  {$ENDIF}

  Mask:=GetValidDrives;
  for Count:=MIN_DRIVE to MAX_DRIVE do
   begin
    if (Mask and DRIVE_MASKS[Count]) <> 0 then
     begin
      Result.Add(DRIVE_NAMES[Count]);
     end;
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetValidDriveStrings:String;
{No Volume Support}
var
 Count:Integer;
 Mask:LongWord;
begin
 {}
 Result:='';
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.GetValidDriveStrings');
  {$ENDIF}

  Mask:=GetValidDrives;
  for Count:=MIN_DRIVE to MAX_DRIVE do
   begin
    if (Mask and DRIVE_MASKS[Count]) <> 0 then
     begin
      if Length(Result) <> 0 then
       begin
        Result:=Result + ',';
       end;
       
      Result:=Result + DRIVE_NAMES[Count];
     end;
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetDriveFreeSpace(ADrive:Byte):LongWord;
{No Volume Support}
var
 Drive:TDiskDrive;
begin
 {}
 Result:=0;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.GetDriveFreeSpace');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Drive = ' + IntToStr(ADrive));
  {$ENDIF}

  if ADrive > MAX_DRIVE then Exit;
  if ADrive = DEFAULT_DRIVE then ADrive:=GetCurrentDrive;
  
  Drive:=GetDriveByNo(ADrive,True,FILESYS_LOCK_READ);
  if Drive = nil then Exit;
  try
   if Drive.FileSystem = nil then Exit;
   
   Result:=Drive.FileSystem.GetDriveFreeSpace;
  finally
   {Unlock Drive}
   Drive.ReaderUnlock;
  end;  
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetDriveFreeSpaceEx(ADrive:Byte):Int64;
{No Volume Support}
var
 Drive:TDiskDrive;
begin
 {}
 Result:=0;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.GetDriveFreeSpaceEx');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Drive = ' + IntToStr(ADrive));
  {$ENDIF}

  if ADrive > MAX_DRIVE then Exit;
  if ADrive = DEFAULT_DRIVE then ADrive:=GetCurrentDrive;
  
  Drive:=GetDriveByNo(ADrive,True,FILESYS_LOCK_READ);
  if Drive = nil then Exit;
  try
   if Drive.FileSystem = nil then Exit;
 
   Result:=Drive.FileSystem.GetDriveFreeSpaceEx;
  finally
   {Unlock Drive}
   Drive.ReaderUnlock;
  end;  
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetDriveTotalSpace(ADrive:Byte):LongWord;
{No Volume Support}
var
 Drive:TDiskDrive;
begin
 {}
 Result:=0;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.GetDriveTotalSpace');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Drive = ' + IntToStr(ADrive));
  {$ENDIF}

  if ADrive > MAX_DRIVE then Exit;
  if ADrive = DEFAULT_DRIVE then ADrive:=GetCurrentDrive;
  
  Drive:=GetDriveByNo(ADrive,True,FILESYS_LOCK_READ);
  if Drive = nil then Exit;
  try
   if Drive.FileSystem = nil then Exit;
 
   Result:=Drive.FileSystem.GetDriveTotalSpace;
  finally
   {Unlock Drive}
   Drive.ReaderUnlock;
  end;  
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetDriveTotalSpaceEx(ADrive:Byte):Int64;
{No Volume Support}
var
 Drive:TDiskDrive;
begin
 {}
 Result:=0;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.GetDriveTotalSpaceEx');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Drive = ' + IntToStr(ADrive));
  {$ENDIF}

  if ADrive > MAX_DRIVE then Exit;
  if ADrive = DEFAULT_DRIVE then ADrive:=GetCurrentDrive;
  
  Drive:=GetDriveByNo(ADrive,True,FILESYS_LOCK_READ);
  if Drive = nil then Exit;
  try
   if Drive.FileSystem = nil then Exit;
 
   Result:=Drive.FileSystem.GetDriveTotalSpaceEx;
  finally
   {Unlock Drive}
   Drive.ReaderUnlock;
  end;  
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetDriveInformation(const APath:String;var AClusterSize:LongWord;var ATotalClusterCount,AFreeClusterCount:Int64):Boolean;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.GetDriveInformation');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Path = ' + APath);
  {$ENDIF}

  Volume:=GetVolumeFromPath(APath,True,FILESYS_LOCK_READ);  
  if Volume <> nil then
   begin
    try
     if Volume.FileSystem = nil then Exit;
     
     Result:=Volume.FileSystem.GetDriveInformation(AClusterSize,ATotalClusterCount,AFreeClusterCount);
    finally
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    Drive:=GetDriveFromPath(APath,True,FILESYS_LOCK_READ);
    if Drive = nil then Exit;
    try
     if Drive.FileSystem = nil then Exit;
    
     Result:=Drive.FileSystem.GetDriveInformation(AClusterSize,ATotalClusterCount,AFreeClusterCount);
    finally
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetCurrentDrive:Byte;
{No Volume Support}
var
 Drive:TDiskDrive;
begin
 {}
 Result:=INVALID_DRIVE;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.GetCurrentDrive');
  {$ENDIF}

  {Get Current}
  Drive:=GetCurrent;
  if Drive = nil then
   begin
    {Get Default}
    Drive:=GetDriveByNo(DRIVE_C,True,FILESYS_LOCK_READ);
    if Drive = nil then
     begin
      {Get First}
      Drive:=GetDriveByNext(nil,True,False,FILESYS_LOCK_READ);
      if Drive = nil then Exit;
     end;
    
    {Set Current}
    SetCurrent(Drive);
   end
  else
   begin  
    if not CheckDrive(Drive,True,FILESYS_LOCK_READ) then
     begin
      {Get Default}
      Drive:=GetDriveByNo(DRIVE_C,True,FILESYS_LOCK_READ);
      if Drive = nil then
       begin
        {Get First}
        Drive:=GetDriveByNext(nil,True,False,FILESYS_LOCK_READ);
        if Drive = nil then Exit;
       end;
      
      {Set Current}
      SetCurrent(Drive);
     end;
   end; 
 
  Result:=Drive.DriveNo;
  
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.GetCurrentDrive Result = ' + IntToStr(Result));
  {$ENDIF}

  {Unlock Drive}
  Drive.ReaderUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.SetCurrentDrive(const ADrive:String):Boolean;
{No Volume Support}
var
 DriveNo:Byte;
 Drive:TDiskDrive;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.SetCurrentDrive');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Drive = ' + ADrive);
  {$ENDIF}

  DriveNo:=GetPathDrive(ADrive);
  if DriveNo < MIN_DRIVE then Exit;
  if DriveNo > MAX_DRIVE then Exit;
 
  Drive:=GetDriveByNo(DriveNo,True,FILESYS_LOCK_READ);
  if Drive = nil then Exit;
  
  Result:=SetCurrent(Drive);
  
  {Unlock Drive}
  Drive.ReaderUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetPathVolume(const APath:String):String;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:='';
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.GetPathVolume');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Path = ' + APath);
  {$ENDIF}

  Volume:=GetVolumeFromPath(APath,True,FILESYS_LOCK_READ);  
  if Volume <> nil then
   begin
    Result:=Volume.Name;
    
    {Unlock Volume}
    Volume.ReaderUnlock;
   end
  else
   begin
    Drive:=GetDriveFromPath(APath,True,FILESYS_LOCK_READ);
    if Drive = nil then Exit;
   
    Result:=Drive.Name;
    
    {Unlock Drive}
    Drive.ReaderUnlock;
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetVolumeType(const AVolume:String):TDriveType;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=dtINVALID;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.GetVolumeType');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Volume = ' + AVolume);
  {$ENDIF}

  Volume:=GetVolumeByName(AVolume,True,FILESYS_LOCK_READ);
  if Volume <> nil then
   begin
    Result:=Volume.DriveType;
    
    {Unlock Volume}
    Volume.ReaderUnlock;
   end
  else
   begin
    Drive:=GetDriveByName(AVolume,True,FILESYS_LOCK_READ);
    if Drive = nil then Exit;
   
    Result:=Drive.DriveType;
    
    {Unlock Drive}
    Drive.ReaderUnlock;
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetVolumeData(const AVolume:String):TDriveData;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 FillChar(Result,SizeOf(TDriveData),0);
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.GetVolumeData');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Volume = ' + AVolume);
  {$ENDIF}

  Volume:=GetVolumeByName(AVolume,True,FILESYS_LOCK_READ);
  if Volume <> nil then
   begin
    Result.Drive:=INVALID_DRIVE;
    Result.DriveType:=Volume.DriveType;
    Result.FileSysType:=Volume.FileSysType;
    Result.MaxFile:=Volume.MaxFile;
    Result.MaxPath:=Volume.MaxPath;
    Result.Attributes:=Volume.Attributes;
    Result.SystemName:=Volume.SystemName;
    Result.VolumeName:=Volume.VolumeName;
    Result.VolumeSerial:=Volume.VolumeSerial;
    
    {Unlock Volume}
    Volume.ReaderUnlock;
   end
  else
   begin
    Drive:=GetDriveByName(AVolume,True,FILESYS_LOCK_READ);
    if Drive = nil then Exit;
   
    Result.Drive:=Drive.DriveNo;
    Result.DriveType:=Drive.DriveType;
    Result.FileSysType:=Drive.FileSysType;
    Result.MaxFile:=Drive.MaxFile;
    Result.MaxPath:=Drive.MaxPath;
    Result.Attributes:=Drive.Attributes;
    Result.SystemName:=Drive.SystemName;
    Result.VolumeName:=Drive.VolumeName;
    Result.VolumeSerial:=Drive.VolumeSerial;
    
    {Unlock Drive}
    Drive.ReaderUnlock;
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetVolumeAttr(const AVolume:String):LongWord;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=0;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.GetVolumeAttr');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Volume = ' + AVolume);
  {$ENDIF}

  Volume:=GetVolumeByName(AVolume,True,FILESYS_LOCK_READ);
  if Volume <> nil then
   begin
    Result:=Volume.Attributes;
    
    {Unlock Volume}
    Volume.ReaderUnlock;
   end
  else
   begin
    Drive:=GetDriveByName(AVolume,True,FILESYS_LOCK_READ);
    if Drive = nil then Exit;
   
    Result:=Drive.Attributes;

    {Unlock Drive}
    Drive.ReaderUnlock;
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetVolumeLabel(const AVolume:String):String;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:='';
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.GetVolumeLabel');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Volume = ' + AVolume);
  {$ENDIF}

  Volume:=GetVolumeByName(AVolume,True,FILESYS_LOCK_READ);
  if Volume <> nil then
   begin
    try
     if Volume.FileSystem = nil then Exit;
   
     Result:=Volume.FileSystem.GetDriveLabel;
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    Drive:=GetDriveByName(AVolume,True,FILESYS_LOCK_READ);
    if Drive = nil then Exit;
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.GetDriveLabel;
    finally
     {Unlock Drive}
     Drive.ReaderUnlock;
    end;    
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.SetVolumeLabel(const AVolume:String;const ALabel:String):Boolean;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  //Continuing Debug
  
  Volume:=GetVolumeByName(AVolume,True,FILESYS_LOCK_READ);
  if Volume <> nil then
   begin
    try
     if Volume.FileSystem = nil then Exit;
   
     Result:=Volume.FileSystem.SetDriveLabel(ALabel);
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    Drive:=GetDriveByName(AVolume,True,FILESYS_LOCK_READ);
    if Drive = nil then Exit;
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.SetDriveLabel(ALabel);
    finally
     {Unlock Drive}
     Drive.ReaderUnlock;
    end;    
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetVolumeSerial(const AVolume:String):LongWord;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=0;
 
 if not ReaderLock then Exit;
 try
  Volume:=GetVolumeByName(AVolume,True,FILESYS_LOCK_READ);
  if Volume <> nil then
   begin
    try
     if Volume.FileSystem = nil then Exit;
   
     Result:=Volume.FileSystem.GetDriveSerial;
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    Drive:=GetDriveByName(AVolume,True,FILESYS_LOCK_READ);
    if Drive = nil then Exit;
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.GetDriveSerial;
    finally
     {Unlock Drive}
     Drive.ReaderUnlock;
    end;    
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.SetVolumeSerial(const AVolume:String;ASerial:LongWord):Boolean;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  Volume:=GetVolumeByName(AVolume,True,FILESYS_LOCK_READ);
  if Volume <> nil then
   begin
    try
     if Volume.FileSystem = nil then Exit;
   
     Result:=Volume.FileSystem.SetDriveSerial(ASerial);
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    Drive:=GetDriveByName(AVolume,True,FILESYS_LOCK_READ);
    if Drive = nil then Exit;
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.SetDriveSerial(ASerial);
    finally
     {Unlock Drive}
     Drive.ReaderUnlock;
    end;    
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.IsVolumeValid(const AVolume:String):Boolean;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  Volume:=GetVolumeByName(AVolume,True,FILESYS_LOCK_READ);
  if Volume <> nil then
   begin
    if (Volume.DriveType <> dtUNKNOWN) and (Volume.DriveType <> dtINVALID) then
     begin
      Result:=True;
     end;
     
    {Unlock Volume}
    Volume.ReaderUnlock;
   end
  else
   begin
    Drive:=GetDriveByName(AVolume,True,FILESYS_LOCK_READ);
    if Drive = nil then Exit;
   
    if (Drive.DriveType <> dtUNKNOWN) and (Drive.DriveType <> dtINVALID) then
     begin
      Result:=True;
     end;
     
    {Unlock Drive}
    Drive.ReaderUnlock;
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetValidVolumeNames:TStringList;
var
 Volume:TDiskVolume;
begin
 {}
 Result:=TStringList.Create;
 
 if not ReaderLock then Exit;
 try
  Volume:=GetVolumeByNext(nil,True,False,FILESYS_LOCK_READ); 
  while Volume <> nil do
   begin
    if (Volume.DriveType <> dtUNKNOWN) and (Volume.DriveType <> dtINVALID) then
     begin
      Result.Add(Volume.Name);
     end;
     
    Volume:=GetVolumeByNext(Volume,True,True,FILESYS_LOCK_READ); 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetVolumeFreeSpace(const AVolume:String):LongWord;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=0;
 
 if not ReaderLock then Exit;
 try
  Volume:=GetVolumeByName(AVolume,True,FILESYS_LOCK_READ);
  if Volume <> nil then
   begin
    try
     if Volume.FileSystem = nil then Exit;
   
     Result:=Volume.FileSystem.GetDriveFreeSpace;
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    Drive:=GetDriveByName(AVolume,True,FILESYS_LOCK_READ);
    if Drive = nil then Exit;
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.GetDriveFreeSpace;
    finally
     {Unlock Drive}
     Drive.ReaderUnlock;
    end;    
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetVolumeFreeSpaceEx(const AVolume:String):Int64;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=0;
 
 if not ReaderLock then Exit;
 try
  Volume:=GetVolumeByName(AVolume,True,FILESYS_LOCK_READ);
  if Volume <> nil then
   begin
    try
     if Volume.FileSystem = nil then Exit;
   
     Result:=Volume.FileSystem.GetDriveFreeSpaceEx;
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    Drive:=GetDriveByName(AVolume,True,FILESYS_LOCK_READ);
    if Drive = nil then Exit;
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.GetDriveFreeSpaceEx;
    finally
     {Unlock Drive}
     Drive.ReaderUnlock;
    end;    
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetVolumeTotalSpace(const AVolume:String):LongWord;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=0;
 
 if not ReaderLock then Exit;
 try
  Volume:=GetVolumeByName(AVolume,True,FILESYS_LOCK_READ);
  if Volume <> nil then
   begin
    try
     if Volume.FileSystem = nil then Exit;
   
     Result:=Volume.FileSystem.GetDriveTotalSpace;
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    Drive:=GetDriveByName(AVolume,True,FILESYS_LOCK_READ);
    if Drive = nil then Exit;
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.GetDriveTotalSpace;
    finally
     {Unlock Drive}
     Drive.ReaderUnlock;
    end;    
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetVolumeTotalSpaceEx(const AVolume:String):Int64;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=0;
 
 if not ReaderLock then Exit;
 try
  Volume:=GetVolumeByName(AVolume,True,FILESYS_LOCK_READ);
  if Volume <> nil then
   begin
    try
     if Volume.FileSystem = nil then Exit;
    
     Result:=Volume.FileSystem.GetDriveTotalSpaceEx;
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    Drive:=GetDriveByName(AVolume,True,FILESYS_LOCK_READ);
    if Drive = nil then Exit;
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.GetDriveTotalSpaceEx;
    finally
     {Unlock Drive}
     Drive.ReaderUnlock;
    end;    
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FileOpen(const AFileName:String;AMode:Integer):THandle;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=INVALID_HANDLE_VALUE;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FileOpen FileName = ' + AFileName + ' Mode = ' + IntToHex(AMode,4));
  {$ENDIF}
 
  Drive:=GetDriveFromPath(AFileName,True,FILESYS_LOCK_READ);
  if Drive = nil then
   begin
    Volume:=GetVolumeFromPath(AFileName,True,FILESYS_LOCK_READ);  
    if Volume = nil then Exit;
    try
     if Volume.FileSystem = nil then Exit;
   
     Result:=Volume.FileSystem.FileOpen(AFileName,AMode);
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    try
     if Drive.FileSystem = nil then Exit;
    
     Result:=Drive.FileSystem.FileOpen(AFileName,AMode);
    finally 
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FileCreate(const AFileName:String;AMode:Integer = fmOpenReadWrite or fmShareExclusive):THandle;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=INVALID_HANDLE_VALUE;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FileCreate FileName = ' + AFileName + ' Mode = ' + IntToHex(AMode,4));
  {$ENDIF}
 
  Drive:=GetDriveFromPath(AFileName,True,FILESYS_LOCK_READ);
  if Drive = nil then
   begin
    Volume:=GetVolumeFromPath(AFileName,True,FILESYS_LOCK_READ);
    if Volume = nil then Exit;
    try
     if Volume.FileSystem = nil then Exit;
   
     Result:=Volume.FileSystem.FileCreate(AFileName,AMode);
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.FileCreate(AFileName,AMode);
    finally 
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.DeleteFile(const AFileName:String):Boolean;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.DeleteFile FileName = ' + AFileName);
  {$ENDIF}
 
  Drive:=GetDriveFromPath(AFileName,True,FILESYS_LOCK_READ);
  if Drive = nil then
   begin
    Volume:=GetVolumeFromPath(AFileName,True,FILESYS_LOCK_READ);
    if Volume = nil then Exit;
    try
     if Volume.FileSystem = nil then Exit;
   
     Result:=Volume.FileSystem.DeleteFile(AFileName);
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    try
     if Drive.FileSystem = nil then Exit;
    
     Result:=Drive.FileSystem.DeleteFile(AFileName);
    finally 
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

procedure TFileSysDriver.FileClose(AHandle:Integer);
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FileClose Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}
 
  Drive:=GetDriveFromFile(AHandle,True,FILESYS_LOCK_READ);  
  if Drive <> nil then
   begin
    try
     if Drive.FileSystem = nil then Exit;
    
     Drive.FileSystem.FileClose(AHandle);
    finally
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end
  else
   begin
    Volume:=GetVolumeFromFile(AHandle,True,FILESYS_LOCK_READ);  
    if Volume <> nil then
     begin
      try
       if Volume.FileSystem = nil then Exit;
     
       Volume.FileSystem.FileClose(AHandle);
      finally
       {Unlock Volume}
       Volume.ReaderUnlock;
      end; 
     end;
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.RenameFile(const AOldName,ANewName:String):Boolean;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 //To Do //Should handle Rename from Drive to Drive ?? (ie Move by Copy/Delete)
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.RenameFile OldName = ' + AOldName + ' NewName = ' + ANewName);
  {$ENDIF}
 
  Drive:=GetDriveFromPath(AOldName,True,FILESYS_LOCK_READ);
  if Drive = nil then
   begin
    Volume:=GetVolumeFromPath(AOldName,True,FILESYS_LOCK_READ);
    if Volume = nil then Exit;
    try
     if Volume.FileSystem = nil then Exit;
    
     Result:=Volume.FileSystem.RenameFile(AOldName,ANewName);
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    try
     if Drive.FileSystem = nil then Exit;
    
     Result:=Drive.FileSystem.RenameFile(AOldName,ANewName);
    finally 
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FileSeek(AHandle:THandle;AOffset,AOrigin:LongInt):LongInt;
begin
 {}
 Result:=FileSeekEx(AHandle,AOffset,AOrigin);
end;

{==============================================================================}

function TFileSysDriver.FileFlush(AHandle:Integer):Boolean;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FileFlush Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}
 
  Drive:=GetDriveFromFile(AHandle,True,FILESYS_LOCK_READ);  
  if Drive <> nil then
   begin
    try
     if Drive.FileSystem = nil then Exit;
    
     Result:=Drive.FileSystem.FileFlush(AHandle);
    finally
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end
  else
   begin
    Volume:=GetVolumeFromFile(AHandle,True,FILESYS_LOCK_READ);  
    if Volume <> nil then
     begin
      try
       if Volume.FileSystem = nil then Exit;
     
       Result:=Volume.FileSystem.FileFlush(AHandle);
      finally
       {Unlock Volume}
       Volume.ReaderUnlock;
      end; 
     end;
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FileTruncate(AHandle:Integer):Boolean;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FileTruncate Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}
 
  Drive:=GetDriveFromFile(AHandle,True,FILESYS_LOCK_READ);  
  if Drive <> nil then
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.FileTruncate(AHandle);
    finally
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end
  else
   begin
    Volume:=GetVolumeFromFile(AHandle,True,FILESYS_LOCK_READ);  
    if Volume <> nil then
     begin
      try
       if Volume.FileSystem = nil then Exit;
     
       Result:=Volume.FileSystem.FileTruncate(AHandle);
      finally
       {Unlock Volume}
       Volume.ReaderUnlock;
      end; 
     end;
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.SetEndOfFile(AHandle:Integer):Boolean;
begin
 {}
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.SetEndOfFile Handle = ' + IntToHex(AHandle,8));
 {$ENDIF}
 
 Result:=FileTruncate(AHandle);
end;

{==============================================================================}

function TFileSysDriver.EndOfFile(AHandle:Integer):Boolean;
begin
 {}
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.EndOfFile Handle = ' + IntToHex(AHandle,8));
 {$ENDIF}
 
 Result:=FilePosEx(AHandle) >= FileSizeEx(AHandle);
end;

{==============================================================================}

function TFileSysDriver.FilePos(AHandle:THandle):LongInt;
begin
 {}
 Result:=FilePosEx(AHandle);
end;

{==============================================================================}

function TFileSysDriver.FileSize(AHandle:THandle):LongInt;
begin
 {}
 Result:=FileSizeEx(AHandle);
end;

{==============================================================================}

function TFileSysDriver.FileAge(const AFileName:String):Integer;
var
 Code:Integer;
 SearchRec:TFileSearchRec;
begin
 {}
 Result:=-1;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FileAge FileName = ' + AFileName);
  {$ENDIF}
 
  Code:=FindFirstEx(AFileName,SearchRec);
  if Code = 0 then
   begin
    Result:=Ultibo.FileTimeToFileDate(SearchRec.FindData.ftLastWriteTime); {Dos Date Time Format}
   end;
  
  FindCloseEx(SearchRec);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FileExists(const AFileName:String):Boolean;
var
 Code:Integer;
begin
 {}
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FileExists FileName = ' + AFileName);
 {$ENDIF}
 
 {Result:=FileAge(AFileName) <> -1;} {Modified to Allow Streams}
 Code:=FileGetAttr(AFileName);
 Result:=(Code <> -1) and ((faDirectory and Code) = 0);
end;

{==============================================================================}

function TFileSysDriver.FileGetAttr(const AFileName:String):Integer;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=-1;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FileGetAttr FileName = ' + AFileName);
  {$ENDIF}
 
  Drive:=GetDriveFromPath(AFileName,True,FILESYS_LOCK_READ);
  if Drive = nil then
   begin
    Volume:=GetVolumeFromPath(AFileName,True,FILESYS_LOCK_READ);
    if Volume = nil then Exit;
    try
     if Volume.FileSystem = nil then Exit;
    
     Result:=Volume.FileSystem.FileGetAttr(AFileName);
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.FileGetAttr(AFileName);
    finally 
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FileGetDate(AHandle:Integer):Integer;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=-1;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FileGetDate Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}
 
  Drive:=GetDriveFromFile(AHandle,True,FILESYS_LOCK_READ);  
  if Drive <> nil then
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.FileGetDate(AHandle);
    finally
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end
  else
   begin
    Volume:=GetVolumeFromFile(AHandle,True,FILESYS_LOCK_READ);  
    if Volume <> nil then
     begin
      try
       if Volume.FileSystem = nil then Exit;
     
       Result:=Volume.FileSystem.FileGetDate(AHandle);
      finally
       {Unlock Volume}
       Volume.ReaderUnlock;
      end; 
     end;
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FileSetAttr(const AFileName:String;AAttr:Integer):Integer;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=-1;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FileSetAttr FileName = ' + AFileName);
  {$ENDIF}
 
  Drive:=GetDriveFromPath(AFileName,True,FILESYS_LOCK_READ);
  if Drive = nil then
   begin
    Volume:=GetVolumeFromPath(AFileName,True,FILESYS_LOCK_READ);
    if Volume = nil then Exit;
    try
     if Volume.FileSystem = nil then Exit;
   
     Result:=Volume.FileSystem.FileSetAttr(AFileName,AAttr);
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.FileSetAttr(AFileName,AAttr);
    finally 
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FileSetDate(AHandle:Integer;AAge:Integer):Integer;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=-1;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FileSetDate Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}
 
  Drive:=GetDriveFromFile(AHandle,True,FILESYS_LOCK_READ);  
  if Drive <> nil then
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.FileSetDate(AHandle,AAge);
    finally
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end
  else
   begin
    Volume:=GetVolumeFromFile(AHandle,True,FILESYS_LOCK_READ);  
    if Volume <> nil then
     begin
      try
       if Volume.FileSystem = nil then Exit;
     
       Result:=Volume.FileSystem.FileSetDate(AHandle,AAge);
      finally
       {Unlock Volume}
       Volume.ReaderUnlock;
      end; 
     end;
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FileRead(AHandle:THandle;var ABuffer;ACount:LongInt):LongInt;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=-1;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FileRead Handle = ' + IntToHex(AHandle,8) + ' Count = ' + IntToStr(ACount));
  {$ENDIF}
 
  Drive:=GetDriveFromFile(AHandle,True,FILESYS_LOCK_READ);  
  if Drive <> nil then
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.FileRead(AHandle,ABuffer,ACount);
    finally
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end
  else
   begin
    Volume:=GetVolumeFromFile(AHandle,True,FILESYS_LOCK_READ);  
    if Volume <> nil then
     begin
      try
       if Volume.FileSystem = nil then Exit;
     
       Result:=Volume.FileSystem.FileRead(AHandle,ABuffer,ACount);
      finally
       {Unlock Volume}
       Volume.ReaderUnlock;
      end; 
     end;
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FileWrite(AHandle:THandle;const ABuffer;ACount:LongInt):LongInt;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=-1;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FileWrite Handle = ' + IntToHex(AHandle,8) + ' Count = ' + IntToStr(ACount));
  {$ENDIF}
 
  Drive:=GetDriveFromFile(AHandle,True,FILESYS_LOCK_READ);  
  if Drive <> nil then
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.FileWrite(AHandle,ABuffer,ACount);
    finally
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end
  else
   begin
    Volume:=GetVolumeFromFile(AHandle,True,FILESYS_LOCK_READ);  
    if Volume <> nil then
     begin
      try
       if Volume.FileSystem = nil then Exit;
     
       Result:=Volume.FileSystem.FileWrite(AHandle,ABuffer,ACount);
      finally
       {Unlock Volume}
       Volume.ReaderUnlock;
      end; 
     end;
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.CreateDir(const ADirName:String):Boolean;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.CreateDir DirName = ' + ADirName);
  {$ENDIF}
 
  Drive:=GetDriveFromPath(ADirName,True,FILESYS_LOCK_READ);
  if Drive = nil then
   begin
    Volume:=GetVolumeFromPath(ADirName,True,FILESYS_LOCK_READ);
    if Volume = nil then Exit;
    try
     if Volume.FileSystem = nil then Exit;
   
     Result:=Volume.FileSystem.CreateDir(ADirName);
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.CreateDir(ADirName);
    finally 
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.RemoveDir(const ADirName:String):Boolean;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.RemoveDir DirName = ' + ADirName);
  {$ENDIF}
 
  Drive:=GetDriveFromPath(ADirName,True,FILESYS_LOCK_READ);
  if Drive = nil then
   begin
    Volume:=GetVolumeFromPath(ADirName,True,FILESYS_LOCK_READ);
    if Volume = nil then Exit;
    try
     if Volume.FileSystem = nil then Exit;
   
     Result:=Volume.FileSystem.RemoveDir(ADirName);
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.RemoveDir(ADirName);
    finally 
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.RenameDir(const AOldName,ANewName:String):Boolean;
begin
 {}
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.RenameDir OldName = ' + AOldName + ' NewName = ' + ANewName);
 {$ENDIF}
 
 Result:=RenameFile(AOldName,ANewName);
end;

{==============================================================================}

function TFileSysDriver.GetCurrentDir:String;
{No Volume Support}
var
 Drive:TDiskDrive;
begin
 {}
 Result:='';
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.GetCurrentDir');
  {$ENDIF}
 
  Drive:=GetDriveByNo(GetCurrentDrive,True,FILESYS_LOCK_READ);
  if Drive = nil then Exit;
  try
   if Drive.FileSystem = nil then Exit;
 
   Result:=Drive.FileSystem.GetCurrentDir;
   
   {$IFDEF FILESYS_DEBUG}
   if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.GetCurrentDir Result = ' + Result);
   {$ENDIF}
  finally
   {Unlock Drive}
   Drive.ReaderUnlock;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetCurrentDirEx(ADrive:Byte):String;
{No Volume Support}
var
 Drive:TDiskDrive;
begin
 {}
 Result:='';
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.GetCurrentDirEx Drive=' + DRIVE_NAMES[ADrive]);
  {$ENDIF}
  
  if ADrive = DEFAULT_DRIVE then ADrive:=GetCurrentDrive;
  
  Drive:=GetDriveByNo(ADrive,True,FILESYS_LOCK_READ);
  if Drive = nil then Exit;
  try
   if Drive.FileSystem = nil then Exit;
 
   Result:=Drive.FileSystem.GetCurrentDir;
   
   {$IFDEF FILESYS_DEBUG}
   if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.GetCurrentDirEx Result = ' + Result);
   {$ENDIF}
  finally
   {Unlock Drive}
   Drive.ReaderUnlock;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.SetCurrentDir(const ADirName:String):Boolean;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.SetCurrentDir DirName = ' + ADirName);
  {$ENDIF}
 
  Drive:=GetDriveFromPath(ADirName,True,FILESYS_LOCK_READ);
  if Drive = nil then
   begin
    Volume:=GetVolumeFromPath(ADirName,True,FILESYS_LOCK_READ);
    if Volume = nil then Exit;
    try
     if Volume.FileSystem = nil then Exit;
   
     Result:=Volume.FileSystem.SetCurrentDir(ADirName);
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    try
     if Drive.FileSystem = nil then Exit;
    
     Result:=Drive.FileSystem.SetCurrentDir(ADirName);
    
     if Result then SetCurrent(Drive);
    finally 
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.SetCurrentDirEx(ADrive:Byte;const ADirName:String):Boolean;
{Set the current directory on the specified drive}
{Note: Does not update the current drive}
{Note: No Volume Support}
var
 Drive:TDiskDrive;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.SetCurrentDirEx Drive=' + DRIVE_NAMES[ADrive] + ' DirName = ' + ADirName);
  {$ENDIF}

  if ADrive = DEFAULT_DRIVE then ADrive:=GetCurrentDrive;
  
  Drive:=GetDriveByNo(ADrive,True,FILESYS_LOCK_READ);
  if Drive = nil then Exit;
  try
   if Drive.FileSystem = nil then Exit;
   
   {Check Path}
   if GetDriveFromPath(ADirName,False,FILESYS_LOCK_NONE) <> Drive then Exit;
   
   Result:=Drive.FileSystem.SetCurrentDir(ADirName);
  finally
   {Unlock Drive}
   Drive.ReaderUnlock;
  end;
 finally  
  ReaderUnlock;
 end; 
end;
  
{==============================================================================}

function TFileSysDriver.DirectoryExists(const ADirName:String):Boolean;
var
 Code:Integer;
begin
 {}
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.DirectoryExists DirName = ' + ADirName);
 {$ENDIF}
 
 Code:=FileGetAttr(ADirName);
 Result:=(Code <> -1) and ((faDirectory and Code) <> 0);
end;

{==============================================================================}

procedure TFileSysDriver.ForceDirectories(ADirName:String);
begin
 {}
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.ForceDirectories DirName = ' + ADirName);
 {$ENDIF}
 
 if Length(ADirName) = 0 then Exit;
 
 if (AnsiLastChar(ADirName) <> nil) and (AnsiLastChar(ADirName)^ = '\') then Delete(ADirName,Length(ADirName),1); //To Do //Need to fix use of non portable '\'
 
 if (Length(ADirName) < 3) or DirectoryExists(ADirName) or (ExtractFilePath(ADirName) = ADirName) then Exit; {Avoid 'xyz:\' problem}
 
 ForceDirectories(ExtractFilePath(ADirName)); //To Do //Need to fix use of non portable ExtractFilePath
 
 CreateDir(ADirName);
end;

{==============================================================================}

procedure TFileSysDriver.DeleteTree(const ADirName:String);
var
 Code:Integer;
 SearchRec:TFileSearchRec;
begin
 {}
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.DeleteTree DirName = ' + ADirName);
 {$ENDIF}
 
 if Trim(ADirName) = '' then Exit;
 
 if UltiboUtils.IsRootDirectory(ADirName) then Exit;  //To Do //Need to fix use of non portable IsRoot
                                                              //Use the GetPathType etc functions and GetPathRoot etc //Need to build these into UltiboUtils ?

 Code:=FindFirstEx(AddSlash(ADirName,False,True) + '*.*',SearchRec);
 while Code = 0 do
  begin
   if (SearchRec.FindData.dwFileAttributes and faDirectory) = faDirectory then
    begin
     {Delete Sub Directory}
     {if (TrimRight(SearchRec.FindData.cFileName) <> '.') and (SearchRec.FindData.cFileName <> '..') then} {Quick check for length equal to 1 or 2 characters}
     if ((SearchRec.FindData.cFileName[1] <> #0) and (SearchRec.FindData.cFileName[2] <> #0)) or ((TrimRight(SearchRec.FindData.cFileName) <> '.') and (SearchRec.FindData.cFileName <> '..')) then
      begin
       DeleteTree(AddSlash(ADirName,False,True) + SearchRec.FindData.cFileName);
      end;
    end
   else
    begin
     {Delete File}
     FileSetAttr(AddSlash(ADirName,False,True) + SearchRec.FindData.cFileName,FileGetAttr(AddSlash(ADirName,False,True) + SearchRec.FindData.cFileName) and not(faStandard)); {FileSetAttr(AddSlash(ADirName,False,True) + SearchRec.FindData.cFileName,faNone);}
     DeleteFile(AddSlash(ADirName,False,True) + SearchRec.FindData.cFileName);
    end;
   Code:=FindNextEx(SearchRec);
  end;
 FindCloseEx(SearchRec);

 {Delete the Directory}
 FileSetAttr(DeleteSlash(ADirName,False,True),FileGetAttr(DeleteSlash(ADirName,False,True)) and not(faStandard)); {FileSetAttr(DeleteSlash(ADirName,False,True),faNone);}
 RemoveDir(DeleteSlash(ADirName,False,True));
end;

{==============================================================================}

function TFileSysDriver.FindMatchingFile(ADrive:TDiskDrive;AVolume:TDiskVolume;var ASearchRec:TSearchRec):Integer;
{Internal Only}
{Note: Caller must hold the drive and volume lock}
var
 DosDateTime:LongInt;
 LocalFileTime:TFileTime;
 FileSearchRec:TFileSearchRec;
begin
 {}
 Result:=-1;
 
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FindMatchingFile Handle = ' + IntToHex(ASearchRec.FindHandle,8));
 {$ENDIF}
 
 if (ADrive <> nil) or (AVolume <> nil) then
  begin
   while (ASearchRec.FindData.dwFileAttributes and ASearchRec.ExcludeAttr) <> 0 do
    begin
     if ADrive <> nil then
      begin
       if ADrive.FileSystem = nil then Exit;
       
       FileSearchRec.FindHandle:=ASearchRec.FindHandle;
       
       Result:=ADrive.FileSystem.FindNextEx(FileSearchRec);
      end
     else
      begin
       if AVolume.FileSystem = nil then Exit;
       
       FileSearchRec.FindHandle:=ASearchRec.FindHandle;
       
       Result:=AVolume.FileSystem.FindNextEx(FileSearchRec);
      end;
     if Result = 0 then
      begin
       ASearchRec.FindData:=FileSearchRec.FindData;
      end
     else
      begin
       Exit;
      end;
    end;
    
   {Update the SearchRec from the FindData record}
   Ultibo.FileTimeToLocalFileTime(ASearchRec.FindData.ftLastWriteTime,LocalFileTime);
   Ultibo.FileTimeToDosDateTime(LocalFileTime,LongRec(DosDateTime).Hi,LongRec(DosDateTime).Lo);
   ASearchRec.Time:=DosDateTime; {FPC RTL now declares Time as Int64}
   TULargeInteger(ASearchRec.Size).HighPart:=ASearchRec.FindData.nFileSizeHigh;
   TULargeInteger(ASearchRec.Size).LowPart:=ASearchRec.FindData.nFileSizeLow;
   ASearchRec.Attr:=ASearchRec.FindData.dwFileAttributes;
   ASearchRec.Name:=ASearchRec.FindData.cFileName;
   
   Result:=0;
  end;
end;

{==============================================================================}

function TFileSysDriver.FindFirst(const APath:String;AAttr:Integer;var ASearchRec:TSearchRec):Integer;
{Notes: FindFirst/FindNext/FindClose - To be compatible with the DOS
FindFirst/FindNext we always allow faReadOnly and faArchive but only
allow other attributes if requested. This is done by matching all
files and filtering with FindMatchingFile}

{Apparently there is an oddity with faVolumeId where you shouldn't
allow any other attributes at all, this needs to be tested and added}
const
 faSpecial = faHidden or faSysFile or faVolumeID or faDirectory;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
 FileSearchRec:TFileSearchRec;
begin
 {}
 Result:=-1;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FindFirst Path = ' + APath);
  {$ENDIF}
 
  Drive:=GetDriveFromPath(APath,True,FILESYS_LOCK_READ);
  if Drive = nil then
   begin
    Volume:=GetVolumeFromPath(APath,True,FILESYS_LOCK_READ);
    if Volume = nil then Exit;
    try
     if Volume.FileSystem = nil then Exit;
   
     if Volume.FileSystem.FindFirstEx(APath,FileSearchRec) = 0 then
      begin
       ASearchRec.ExcludeAttr:=not AAttr and faSpecial;
       ASearchRec.FindHandle:=FileSearchRec.FindHandle;
       ASearchRec.FindData:=FileSearchRec.FindData;
      
       Result:=FindMatchingFile(nil,Volume,ASearchRec);
       if Result <> 0 then FindClose(ASearchRec);
      end;
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     if Drive.FileSystem.FindFirstEx(APath,FileSearchRec) = 0 then
      begin
       ASearchRec.ExcludeAttr:=not AAttr and faSpecial;
       ASearchRec.FindHandle:=FileSearchRec.FindHandle;
       ASearchRec.FindData:=FileSearchRec.FindData;
      
       Result:=FindMatchingFile(Drive,nil,ASearchRec);
       if Result <> 0 then FindClose(ASearchRec);
      end;
    finally 
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FindNext(var ASearchRec:TSearchRec):Integer;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
 FileSearchRec:TFileSearchRec;
begin
 {}
 Result:=-1;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FindNext Handle = ' + IntToHex(ASearchRec.FindHandle,8));
  {$ENDIF}
 
  Drive:=GetDriveFromFind(ASearchRec.FindHandle,True,FILESYS_LOCK_READ);  
  if Drive <> nil then
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     FileSearchRec.FindHandle:=ASearchRec.FindHandle;
     if Drive.FileSystem.FindNextEx(FileSearchRec) = 0 then
      begin
       ASearchRec.FindData:=FileSearchRec.FindData;
     
       Result:=FindMatchingFile(Drive,nil,ASearchRec);
      end;
    finally
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end
  else
   begin
    Volume:=GetVolumeFromFind(ASearchRec.FindHandle,True,FILESYS_LOCK_READ);  
    if Volume <> nil then
     begin
      try
       if Volume.FileSystem = nil then Exit;
     
       FileSearchRec.FindHandle:=ASearchRec.FindHandle;
       if Volume.FileSystem.FindNextEx(FileSearchRec) = 0 then
        begin
         ASearchRec.FindData:=FileSearchRec.FindData;
       
         Result:=FindMatchingFile(nil,Volume,ASearchRec);
        end;
      finally
       {Unlock Volume}
       Volume.ReaderUnlock;
      end; 
     end;
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

procedure TFileSysDriver.FindClose(var ASearchRec:TSearchRec);
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
 FileSearchRec:TFileSearchRec;
begin
 {}
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FindClose Handle = ' + IntToHex(ASearchRec.FindHandle,8));
  {$ENDIF}
 
  Drive:=GetDriveFromFind(ASearchRec.FindHandle,True,FILESYS_LOCK_READ);  
  if Drive <> nil then
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     FileSearchRec.FindHandle:=ASearchRec.FindHandle;
   
     Drive.FileSystem.FindCloseEx(FileSearchRec);
    finally
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end
  else
   begin
    Volume:=GetVolumeFromFind(ASearchRec.FindHandle,True,FILESYS_LOCK_READ);  
    if Volume <> nil then
     begin
      try
       if Volume.FileSystem = nil then Exit;
      
       FileSearchRec.FindHandle:=ASearchRec.FindHandle;
     
       Volume.FileSystem.FindCloseEx(FileSearchRec);
      finally
       {Unlock Volume}
       Volume.ReaderUnlock;
      end; 
     end;
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FindFirstStream(const AFileName:String;var ASearchRec:TStreamSearchRec):Integer;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=-1;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FindFirstStream FileName = ' + AFileName);
  {$ENDIF}
 
  Drive:=GetDriveFromPath(AFileName,True,FILESYS_LOCK_READ);
  if Drive = nil then
   begin
    Volume:=GetVolumeFromPath(AFileName,True,FILESYS_LOCK_READ);
    if Volume = nil then Exit;
    try
     if Volume.FileSystem = nil then Exit;
   
     Result:=Volume.FileSystem.FindFirstStream(AFileName,ASearchRec);
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.FindFirstStream(AFileName,ASearchRec);
    finally 
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FindNextStream(var ASearchRec:TStreamSearchRec):Integer;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=-1;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FindNextStream Handle = ' + IntToHex(ASearchRec.FindHandle,8));
  {$ENDIF}
 
  Drive:=GetDriveFromFind(ASearchRec.FindHandle,True,FILESYS_LOCK_READ);  
  if Drive <> nil then
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.FindNextStream(ASearchRec);
    finally
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end
  else
   begin
    Volume:=GetVolumeFromFind(ASearchRec.FindHandle,True,FILESYS_LOCK_READ);  
    if Volume <> nil then
     begin
      try
       if Volume.FileSystem = nil then Exit;
     
       Result:=Volume.FileSystem.FindNextStream(ASearchRec);
      finally
       {Unlock Volume}
       Volume.ReaderUnlock;
      end; 
     end;
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

procedure TFileSysDriver.FindStreamClose(var ASearchRec:TStreamSearchRec);
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FindStreamClose Handle = ' + IntToHex(ASearchRec.FindHandle,8));
  {$ENDIF}
  
  Drive:=GetDriveFromFind(ASearchRec.FindHandle,True,FILESYS_LOCK_READ);  
  if Drive <> nil then
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     Drive.FileSystem.FindStreamClose(ASearchRec);
    finally
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end
  else
   begin
    Volume:=GetVolumeFromFind(ASearchRec.FindHandle,True,FILESYS_LOCK_READ);  
    if Volume <> nil then
     begin
      try
       if Volume.FileSystem = nil then Exit;
     
       Volume.FileSystem.FindStreamClose(ASearchRec);
      finally
       {Unlock Volume}
       Volume.ReaderUnlock;
      end; 
     end;
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FindFirstFileName(const AFileName:String;var ASearchRec:TLinkSearchRec):Integer;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=-1;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FindFirstFileName FileName = ' + AFileName);
  {$ENDIF}
 
  Drive:=GetDriveFromPath(AFileName,True,FILESYS_LOCK_READ);
  if Drive = nil then
   begin
    Volume:=GetVolumeFromPath(AFileName,True,FILESYS_LOCK_READ);
    if Volume = nil then Exit;
    try
     if Volume.FileSystem = nil then Exit;
   
     Result:=Volume.FileSystem.FindFirstFileName(AFileName,ASearchRec);
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.FindFirstFileName(AFileName,ASearchRec);
    finally 
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FindNextFileName(var ASearchRec:TLinkSearchRec):Integer;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=-1;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FindNextFileName Handle = ' + IntToHex(ASearchRec.FindHandle,8));
  {$ENDIF}
 
  Drive:=GetDriveFromFind(ASearchRec.FindHandle,True,FILESYS_LOCK_READ);  
  if Drive <> nil then
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.FindNextFileName(ASearchRec);
    finally
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end
  else
   begin
    Volume:=GetVolumeFromFind(ASearchRec.FindHandle,True,FILESYS_LOCK_READ);  
    if Volume <> nil then
     begin
      try
       if Volume.FileSystem = nil then Exit;
     
       Result:=Volume.FileSystem.FindNextFileName(ASearchRec);
      finally
       {Unlock Volume}
       Volume.ReaderUnlock;
      end; 
     end;
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

procedure TFileSysDriver.FindFileNameClose(var ASearchRec:TLinkSearchRec);
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FindFileNameClose Handle = ' + IntToHex(ASearchRec.FindHandle,8));
  {$ENDIF}
 
  Drive:=GetDriveFromFind(ASearchRec.FindHandle,True,FILESYS_LOCK_READ);  
  if Drive <> nil then
   begin
    try
     if Drive.FileSystem = nil then Exit;
    
     Drive.FileSystem.FindFileNameClose(ASearchRec);
    finally
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end
  else
   begin
    Volume:=GetVolumeFromFind(ASearchRec.FindHandle,True,FILESYS_LOCK_READ);  
    if Volume <> nil then
     begin
      try
       if Volume.FileSystem = nil then Exit;
     
       Volume.FileSystem.FindFileNameClose(ASearchRec);
      finally
       {Unlock Volume}
       Volume.ReaderUnlock;
      end; 
     end;
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.CreateHardLink(const ALinkName,AFileName:String):Boolean;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.CreateHardLink LinkName = ' + ALinkName + ' FileName = ' + AFileName);
  {$ENDIF}
 
  Drive:=GetDriveFromPath(ALinkName,True,FILESYS_LOCK_READ);
  if Drive = nil then
   begin
    Volume:=GetVolumeFromPath(ALinkName,True,FILESYS_LOCK_READ);
    if Volume = nil then Exit;
    try
     if Volume.FileSystem = nil then Exit;
   
     Result:=Volume.FileSystem.CreateHardLink(ALinkName,AFileName);
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.CreateHardLink(ALinkName,AFileName);
    finally 
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.DeleteHardLink(const ALinkName:String):Boolean;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.DeleteHardLink LinkName = ' + ALinkName);
  {$ENDIF}
 
  Drive:=GetDriveFromPath(ALinkName,True,FILESYS_LOCK_READ);
  if Drive = nil then
   begin
    Volume:=GetVolumeFromPath(ALinkName,True,FILESYS_LOCK_READ);
    if Volume = nil then Exit;
    try
     if Volume.FileSystem = nil then Exit;
    
     Result:=Volume.FileSystem.DeleteHardLink(ALinkName);
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    try
     if Drive.FileSystem = nil then Exit;
    
     Result:=Drive.FileSystem.DeleteHardLink(ALinkName);
    finally 
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.MountPointExists(const APathName:String):Boolean;
var
 Code:Integer;
 Target:String;
 Drive:TDiskDrive;
 Volume:TDiskVolume;
 FileSystem:TFileSystem;
 SearchRec:TFileSearchRec;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  Drive:=GetDriveFromPath(APathName,True,FILESYS_LOCK_READ);
  if Drive = nil then
   begin
    Volume:=GetVolumeFromPath(APathName,True,FILESYS_LOCK_READ);
    if Volume = nil then Exit;
    try
     FileSystem:=Volume.FileSystem;
     
     //To Do //Lock
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    try
     FileSystem:=Drive.FileSystem;
     
     //To Do //Lock
    finally 
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end;
  if FileSystem = nil then Exit;

  Code:=FileSystem.FindFirstEx(APathName,SearchRec);
  if Code = 0 then
   begin
    if (SearchRec.FindData.dwFileAttributes and faReparse) = faReparse then
     begin
      if SearchRec.FindData.dwReserved0 = FileSystem.MountPointTag then
       begin
        Target:=FileSystem.GetMountPointTarget(APathName);
       
        Result:=(Copy(Target,2,1) <> ':'); {Target is a Volume path (eg \??\Volume(2345)) not a Folder path}
       end;
     end;
   end;
  
  FileSystem.FindCloseEx(SearchRec);
  
  //To Do //Unlock FileSystem
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.CreateMountPoint(const APathName,AVolumeName:String):Boolean;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.CreateMountPoint PathName = ' + APathName + ' VolumeName = ' + AVolumeName);
  {$ENDIF}
 
  Drive:=GetDriveFromPath(APathName,True,FILESYS_LOCK_READ);
  if Drive = nil then
   begin
    Volume:=GetVolumeFromPath(APathName,True,FILESYS_LOCK_READ);
    if Volume = nil then Exit;
    try
     if Volume.FileSystem = nil then Exit;
    
     Result:=Volume.FileSystem.CreateMountPoint(APathName,AVolumeName);
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    try
     if Drive.FileSystem = nil then Exit;
    
     Result:=Drive.FileSystem.CreateMountPoint(APathName,AVolumeName);
    finally 
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.DeleteMountPoint(const APathName:String):Boolean;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.DeleteMountPoint PathName = ' + APathName);
  {$ENDIF}
 
  Drive:=GetDriveFromPath(APathName,True,FILESYS_LOCK_READ);
  if Drive = nil then
   begin
    Volume:=GetVolumeFromPath(APathName,True,FILESYS_LOCK_READ);
    if Volume = nil then Exit;
    try
     if Volume.FileSystem = nil then Exit;
   
     Result:=Volume.FileSystem.DeleteMountPoint(APathName);
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.DeleteMountPoint(APathName);
    finally 
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.JunctionPointExists(const APathName:String):Boolean;
var
 Code:Integer;
 Target:String;
 Drive:TDiskDrive;
 Volume:TDiskVolume;
 FileSystem:TFileSystem;
 SearchRec:TFileSearchRec;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  Drive:=GetDriveFromPath(APathName,True,FILESYS_LOCK_READ);
  if Drive = nil then
   begin
    Volume:=GetVolumeFromPath(APathName,True,FILESYS_LOCK_READ);
    if Volume = nil then Exit;
    try
     FileSystem:=Volume.FileSystem;
     //To Do //Lock
     
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    try
     FileSystem:=Drive.FileSystem;
     //To Do //Lock
     
    finally 
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end;
  if FileSystem = nil then Exit;

  Code:=FileSystem.FindFirstEx(APathName,SearchRec);
  if Code = 0 then
   begin
    if (SearchRec.FindData.dwFileAttributes and faReparse) = faReparse then
     begin
      if SearchRec.FindData.dwReserved0 = FileSystem.MountPointTag then
       begin
        Target:=FileSystem.GetJunctionPointTarget(APathName);
       
        Result:=(Copy(Target,2,1) = ':'); {Target is a Folder path (eg C:\Home) not a Volume path}
       end;
     end;
   end;
  
  FileSystem.FindCloseEx(SearchRec);
  
  //To Do //Unlock FileSystem
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.CreateJunctionPoint(const APathName,AFolderName:String):Boolean;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.CreateJunctionPoint PathName = ' + APathName + ' FolderName = ' + AFolderName);
  {$ENDIF}
 
  Drive:=GetDriveFromPath(APathName,True,FILESYS_LOCK_READ);
  if Drive = nil then
   begin
    Volume:=GetVolumeFromPath(APathName,True,FILESYS_LOCK_READ);
    if Volume = nil then Exit;
    try
     if Volume.FileSystem = nil then Exit;
   
     Result:=Volume.FileSystem.CreateJunctionPoint(APathName,AFolderName);
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.CreateJunctionPoint(APathName,AFolderName);
    finally 
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.DeleteJunctionPoint(const APathName:String):Boolean;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.DeleteJunctionPoint PathName = ' + APathName);
  {$ENDIF}
 
  Drive:=GetDriveFromPath(APathName,True,FILESYS_LOCK_READ);
  if Drive = nil then
   begin
    Volume:=GetVolumeFromPath(APathName,True,FILESYS_LOCK_READ);
    if Volume = nil then Exit;
    try
     if Volume.FileSystem = nil then Exit;
   
     Result:=Volume.FileSystem.DeleteJunctionPoint(APathName);
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.DeleteJunctionPoint(APathName);
    finally 
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.SymbolicLinkExists(const ALinkName:String):Boolean;
var
 Code:Integer;
 Drive:TDiskDrive;
 Volume:TDiskVolume;
 FileSystem:TFileSystem;
 SearchRec:TFileSearchRec;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  Drive:=GetDriveFromPath(ALinkName,True,FILESYS_LOCK_READ);
  if Drive = nil then
   begin
    Volume:=GetVolumeFromPath(ALinkName,True,FILESYS_LOCK_READ);
    if Volume = nil then Exit;
    try
     FileSystem:=Volume.FileSystem;
     //To Do //Lock
     
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    try
     FileSystem:=Drive.FileSystem;
     //To Do //Lock
     
    finally 
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end;
  if FileSystem = nil then Exit;

  Code:=FileSystem.FindFirstEx(ALinkName,SearchRec);
  if Code = 0 then
   begin
    if (SearchRec.FindData.dwFileAttributes and faReparse) = faReparse then
     begin
      if SearchRec.FindData.dwReserved0 = FileSystem.SymbolicLinkTag then
       begin
        Result:=True;
       end;
     end;
   end;
  
  FileSystem.FindCloseEx(SearchRec);
  
  //To Do //Unlock FileSystem
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.CreateSymbolicLink(const ALinkName,ATargetName:String;ADirectory:Boolean):Boolean;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.CreateSymbolicLink LinkName = ' + ALinkName + ' TargetName = ' + ATargetName + ' Directory = ' + BoolToStr(ADirectory));
  {$ENDIF}
 
  Drive:=GetDriveFromPath(ALinkName,True,FILESYS_LOCK_READ);
  if Drive = nil then
   begin
    Volume:=GetVolumeFromPath(ALinkName,True,FILESYS_LOCK_READ);
    if Volume = nil then Exit;
    try
     if Volume.FileSystem = nil then Exit;
   
     Result:=Volume.FileSystem.CreateSymbolicLink(ALinkName,ATargetName,ADirectory);
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.CreateSymbolicLink(ALinkName,ATargetName,ADirectory);
    finally 
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.CreateSymbolicLinkEx(const ALinkName,AShortName,ATargetName:String;ADirectory:Boolean):Boolean;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.CreateSymbolicLinkEx LinkName = ' + ALinkName + ' ShortName = ' + AShortName + ' TargetName = ' + ATargetName + ' Directory = ' + BoolToStr(ADirectory));
  {$ENDIF}
 
  Drive:=GetDriveFromPath(ALinkName,True,FILESYS_LOCK_READ);
  if Drive = nil then
   begin
    Volume:=GetVolumeFromPath(ALinkName,True,FILESYS_LOCK_READ);
    if Volume = nil then Exit;
    try
     if Volume.FileSystem = nil then Exit;
   
     Result:=Volume.FileSystem.CreateSymbolicLinkEx(ALinkName,AShortName,ATargetName,ADirectory);
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.CreateSymbolicLinkEx(ALinkName,AShortName,ATargetName,ADirectory);
    finally 
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.DeleteSymbolicLink(const ALinkName:String):Boolean;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.DeleteSymbolicLink LinkName = ' + ALinkName);
  {$ENDIF}
 
  Drive:=GetDriveFromPath(ALinkName,True,FILESYS_LOCK_READ);
  if Drive = nil then
   begin
    Volume:=GetVolumeFromPath(ALinkName,True,FILESYS_LOCK_READ);
    if Volume = nil then Exit;
    try
     if Volume.FileSystem = nil then Exit;
   
     Result:=Volume.FileSystem.DeleteSymbolicLink(ALinkName);
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.DeleteSymbolicLink(ALinkName);
    finally 
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetMountPointTarget(const APathName:String):String;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:='';
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.GetMountPointTarget PathName = ' + APathName);
  {$ENDIF}
 
  Drive:=GetDriveFromPath(APathName,True,FILESYS_LOCK_READ);
  if Drive = nil then
   begin
    Volume:=GetVolumeFromPath(APathName,True,FILESYS_LOCK_READ);
    if Volume = nil then Exit;
    try
     if Volume.FileSystem = nil then Exit;
   
     Result:=Volume.FileSystem.GetMountPointTarget(APathName);
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.GetMountPointTarget(APathName);
    finally 
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetJunctionPointTarget(const APathName:String):String;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:='';
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.GetJunctionPointTarget PathName = ' + APathName);
  {$ENDIF}
 
  Drive:=GetDriveFromPath(APathName,True,FILESYS_LOCK_READ);
  if Drive = nil then
   begin
    Volume:=GetVolumeFromPath(APathName,True,FILESYS_LOCK_READ);
    if Volume = nil then Exit;
    try
     if Volume.FileSystem = nil then Exit;
   
     Result:=Volume.FileSystem.GetJunctionPointTarget(APathName);
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.GetJunctionPointTarget(APathName);
    finally 
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetSymbolicLinkTarget(const ALinkName:String):String;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:='';
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.GetSymbolicLinkTarget LinkName = ' + ALinkName);
  {$ENDIF}
 
  Drive:=GetDriveFromPath(ALinkName,True,FILESYS_LOCK_READ);
  if Drive = nil then
   begin
    Volume:=GetVolumeFromPath(ALinkName,True,FILESYS_LOCK_READ);
    if Volume = nil then Exit;
    try
     if Volume.FileSystem = nil then Exit;
   
     Result:=Volume.FileSystem.GetSymbolicLinkTarget(ALinkName);
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.GetSymbolicLinkTarget(ALinkName);
    finally 
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.SetFileShortName(const AFileName,AShortName:String):Boolean;
{Note: ShortName must not include drive or path (Name only)}
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.SetFileShortName FileName = ' + AFileName + ' ShortName = ' + AShortName);
  {$ENDIF}
 
  Drive:=GetDriveFromPath(AFileName,True,FILESYS_LOCK_READ);
  if Drive = nil then
   begin
    Volume:=GetVolumeFromPath(AFileName,True,FILESYS_LOCK_READ);
    if Volume = nil then Exit;
    try
     if Volume.FileSystem = nil then Exit;
   
     Result:=Volume.FileSystem.SetFileShortName(AFileName,AShortName);
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.SetFileShortName(AFileName,AShortName);
    finally 
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.SetFileShortNameEx(AHandle:Integer;const AShortName:String):Boolean;
{Note: ShortName must not include drive or path (Name only)}
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.SetFileShortNameEx Handle = ' + IntToHex(AHandle,8) + ' ShortName = ' + AShortName);
  {$ENDIF}

  Drive:=GetDriveFromFile(AHandle,True,FILESYS_LOCK_READ);  
  if Drive <> nil then
   begin
    try
     if Drive.FileSystem = nil then Exit;
  
     Result:=Drive.FileSystem.SetFileShortNameEx(AHandle,AShortName);
    finally
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end
  else
   begin
    Volume:=GetVolumeFromFile(AHandle,True,FILESYS_LOCK_READ);  
    if Volume <> nil then
     begin
      try
       if Volume.FileSystem = nil then Exit;
  
       Result:=Volume.FileSystem.SetFileShortNameEx(AHandle,AShortName);
      finally
       {Unlock Volume}
       Volume.ReaderUnlock;
      end; 
     end;
   end;
 finally  
  ReaderUnlock;
 end; 
end;
  
{==============================================================================}

function TFileSysDriver.GetFileSecurity(const AFileName:String;ADescriptor:Pointer;var ASize:LongWord):Boolean;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.GetFileSecurity FileName = ' + AFileName);
  {$ENDIF}
 
  Drive:=GetDriveFromPath(AFileName,True,FILESYS_LOCK_READ);
  if Drive = nil then
   begin
    Volume:=GetVolumeFromPath(AFileName,True,FILESYS_LOCK_READ);
    if Volume = nil then Exit;
    try
     if Volume.FileSystem = nil then Exit;
   
     Result:=Volume.FileSystem.GetFileSecurity(AFileName,ADescriptor,ASize);
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.GetFileSecurity(AFileName,ADescriptor,ASize);
    finally 
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.SetFileSecurity(const AFileName:String;ADescriptor:Pointer):Boolean;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.SetFileSecurity FileName = ' + AFileName);
  {$ENDIF}
 
  Drive:=GetDriveFromPath(AFileName,True,FILESYS_LOCK_READ);
  if Drive = nil then
   begin
    Volume:=GetVolumeFromPath(AFileName,True,FILESYS_LOCK_READ);
    if Volume = nil then Exit;
    try
     if Volume.FileSystem = nil then Exit;
   
     Result:=Volume.FileSystem.SetFileSecurity(AFileName,ADescriptor);
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    try
     if Drive.FileSystem = nil then Exit;
    
     Result:=Drive.FileSystem.SetFileSecurity(AFileName,ADescriptor);
    finally 
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FileCopy(const ASourceFile,ADestFile:String;AFailIfExists:Boolean):Boolean;
var
 Exists:Boolean;
 Buffer:Pointer;
 BlockSize:Integer;
 BytesRemain:Int64;
 DestHandle:THandle; 
 SourceHandle:THandle;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FileCopy Source = ' + ASourceFile + ' Dest = ' + ADestFile);
  {$ENDIF}
 
  BlockSize:=262144;

  {Check for Source File}
  if not FileExists(ASourceFile) then
   begin
    Exit;
   end;
   
  {Check for Destination File}
  Exists:=False;
  if FileExists(ADestFile) then
   begin
    Exists:=True;
    if AFailIfExists then Exit;
    FileSetAttr(ADestFile,faArchive);
   end;
   
  {Open Source and Destination Files}
  SourceHandle:=FileOpen(ASourceFile,fmOpenRead or fmShareDenyNone);
  if SourceHandle = INVALID_HANDLE_VALUE then Exit;
  try
   if Exists then
    begin
     DestHandle:=FileOpen(ADestFile,fmOpenReadWrite or fmShareDenyWrite);
    end
   else
    begin
     DestHandle:=FileCreate(ADestFile);
    end;
   if DestHandle = INVALID_HANDLE_VALUE then Exit;
   try
    {Allocate the Buffer}
    Buffer:=GetMem(BlockSize);
    if Buffer = nil then Exit;
    try
     {Get the Size}
     BytesRemain:=FileSizeEx(SourceHandle); {Modified for 64bit}

     {Set the Size}
     FileSeekEx(DestHandle,BytesRemain,soFromBeginning);
     SetEndOfFile(DestHandle);
     FileSeekEx(DestHandle,0,soFromBeginning);
     if FileSizeEx(DestHandle) <> BytesRemain then Exit; {Modified for 64bit}
     
     {Copy the File}
     while BytesRemain > 0 do
      begin
       if BytesRemain >= BlockSize then 
        begin
         if FileRead(SourceHandle,Buffer^,BlockSize) <> BlockSize then Exit; 
         if FileWrite(DestHandle,Buffer^,BlockSize) <> BlockSize then Exit; 
         
         Dec(BytesRemain,BlockSize);
        end
       else
        begin
         if FileRead(SourceHandle,Buffer^,Int64Rec(BytesRemain).Lo) <> Int64Rec(BytesRemain).Lo then Exit; {Modified for 64bit}
         if FileWrite(DestHandle,Buffer^,Int64Rec(BytesRemain).Lo) <> Int64Rec(BytesRemain).Lo then Exit; {Modified for 64bit}
         
         BytesRemain:=0;
        end;
      end;
    finally
     FreeMem(Buffer);
    end;
    
    {Set the Destination DateTime}
    FileSetDate(DestHandle,FileGetDate(SourceHandle));
     
    Result:=True;
   finally
    FileClose(DestHandle);
   end;
  finally
   FileClose(SourceHandle);
  end;
  if Result then
   begin
    {Set the Destination Attributes}
    FileSetAttr(ADestFile,FileGetAttr(ASourceFile));
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FileCopyEx(const ASourceFile,ADestFile:String;AFailIfExists:Boolean;AUseSourceDate:Boolean;ADestDate:Integer;AUseSourceAttr:Boolean;ADestAttr:Integer):Boolean;
var
 Exists:Boolean;
 Buffer:Pointer;
 BlockSize:Integer;
 BytesRemain:Int64;
 DestHandle:THandle;
 SourceHandle:THandle;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FileCopyEx Source = ' + ASourceFile + ' Dest = ' + ADestFile);
  {$ENDIF}
 
  BlockSize:=262144;
  
  {Check for Source File}
  if not FileExists(ASourceFile) then
   begin
    Exit;
   end;
   
  {Check for Destination File}
  Exists:=False;
  if FileExists(ADestFile) then
   begin
    Exists:=True;
    if AFailIfExists then Exit;
    FileSetAttr(ADestFile,faArchive);
   end;
   
  {Open Source and Destination Files}
  SourceHandle:=FileOpen(ASourceFile,fmOpenRead or fmShareDenyNone);
  if SourceHandle = INVALID_HANDLE_VALUE then Exit;
  try
   if Exists then
    begin
     DestHandle:=FileOpen(ADestFile,fmOpenReadWrite or fmShareDenyWrite);
    end
   else
    begin
     DestHandle:=FileCreate(ADestFile);
    end;
   if DestHandle = INVALID_HANDLE_VALUE then Exit;
   try
    {Allocate the Buffer}
    Buffer:=GetMem(BlockSize);
    if Buffer = nil then Exit;
    try
     {Get the Size}
     BytesRemain:=FileSizeEx(SourceHandle); {Modified for 64bit}
    
     {Set the Size}
     FileSeekEx(DestHandle,BytesRemain,soFromBeginning);
     SetEndOfFile(DestHandle);
     FileSeekEx(DestHandle,0,soFromBeginning);
     if FileSizeEx(DestHandle) <> BytesRemain then Exit; {Modified for 64bit}
     
     {Copy the File}
     while BytesRemain > 0 do
      begin
       if BytesRemain >= BlockSize then
        begin
         if FileRead(SourceHandle,Buffer^,BlockSize) <> BlockSize then Exit; 
         if FileWrite(DestHandle,Buffer^,BlockSize) <> BlockSize then Exit; 
         
         Dec(BytesRemain,BlockSize);
        end
       else
        begin
         if FileRead(SourceHandle,Buffer^,Int64Rec(BytesRemain).Lo) <> Int64Rec(BytesRemain).Lo then Exit; {Modified for 64bit}
         if FileWrite(DestHandle,Buffer^,Int64Rec(BytesRemain).Lo) <> Int64Rec(BytesRemain).Lo then Exit; {Modified for 64bit}
         
         BytesRemain:=0;
        end;
      end;
    finally
     FreeMem(Buffer);
    end;
    
    {Set the Destination DateTime}
    if AUseSourceDate then
     begin
      FileSetDate(DestHandle,FileGetDate(SourceHandle));
     end
    else
     begin
      FileSetDate(DestHandle,ADestDate);
     end;
     
    Result:=True;
   finally
    FileClose(DestHandle);
   end;
  finally
   FileClose(SourceHandle);
  end;
  if Result then
   begin
    {Set the Destination Attributes}
    if AUseSourceAttr then
     begin
      FileSetAttr(ADestFile,FileGetAttr(ASourceFile));
     end
    else
     begin
      FileSetAttr(ADestFile,ADestAttr);
     end;
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FileMove(const ASourceFile,ADestFile:String;AFailIfExists:Boolean):Boolean;
begin
 {}
 Result:=False;
 
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FileMove Source = ' + ASourceFile + ' Dest = ' + ADestFile);
 {$ENDIF}
 
 if not FileCopy(ASourceFile,ADestFile,AFailIfExists) then Exit;
 
 if not DeleteFile(ASourceFile) then Exit;
 
 Result:=True;
end;

{==============================================================================}

function TFileSysDriver.FileMoveEx(const ASourceFile,ADestFile:String;AFailIfExists:Boolean;AUseSourceDate:Boolean;ADestDate:Integer;AUseSourceAttr:Boolean;ADestAttr:Integer):Boolean;
begin
 {}
 Result:=False;
 
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FileMoveEx Source = ' + ASourceFile + ' Dest = ' + ADestFile);
 {$ENDIF}
 
 if not FileCopyEx(ASourceFile,ADestFile,AFailIfExists,AUseSourceDate,ADestDate,AUseSourceAttr,ADestAttr) then Exit;
 
 if not DeleteFile(ASourceFile) then Exit;
 
 Result:=True;
end;

{==============================================================================}

function TFileSysDriver.GetPathName(const AFileName:String):String;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=AFileName;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.GetPathName FileName = ' + AFileName);
  {$ENDIF}
 
  Drive:=GetDriveFromPath(AFileName,True,FILESYS_LOCK_READ);
  if Drive = nil then
   begin
    Volume:=GetVolumeFromPath(AFileName,True,FILESYS_LOCK_READ);
    if Volume = nil then Exit;
    try
     if Volume.FileSystem = nil then Exit;
   
     Result:=Volume.FileSystem.GetPathName(AFileName);
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.GetPathName(AFileName);
    finally 
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetShortName(const AFileName:String):String;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=AFileName;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.GetShortName FileName = ' + AFileName);
  {$ENDIF}
 
  Drive:=GetDriveFromPath(AFileName,True,FILESYS_LOCK_READ);
  if Drive = nil then
   begin
    Volume:=GetVolumeFromPath(AFileName,True,FILESYS_LOCK_READ);
    if Volume = nil then Exit;
    try
     if Volume.FileSystem = nil then Exit;
    
     Result:=Volume.FileSystem.GetShortName(AFileName);
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    try
     if Drive.FileSystem = nil then Exit;
    
     Result:=Drive.FileSystem.GetShortName(AFileName);
    finally 
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetLongName(const AFileName:String):String;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=AFileName;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.GetLongName FileName = ' + AFileName);
  {$ENDIF}
 
  Drive:=GetDriveFromPath(AFileName,True,FILESYS_LOCK_READ);
  if Drive = nil then
   begin
    Volume:=GetVolumeFromPath(AFileName,True,FILESYS_LOCK_READ);
    if Volume = nil then Exit;
    try
     if Volume.FileSystem = nil then Exit;
    
     Result:=Volume.FileSystem.GetLongName(AFileName);
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.GetLongName(AFileName);
    finally 
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetTrueName(const AFileName:String):String;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=AFileName;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.GetTrueName FileName = ' + AFileName);
  {$ENDIF}
 
  Drive:=GetDriveFromPath(AFileName,True,FILESYS_LOCK_READ);
  if Drive = nil then
   begin
    Volume:=GetVolumeFromPath(AFileName,True,FILESYS_LOCK_READ);
    if Volume = nil then Exit;
    try
     if Volume.FileSystem = nil then Exit;
   
     Result:=Volume.FileSystem.GetTrueName(AFileName);
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    try
     if Drive.FileSystem = nil then Exit;
    
     Result:=Drive.FileSystem.GetTrueName(AFileName);
    finally 
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.AddSlash(const AFilePath:String;ALeading,ATrailing:Boolean):String;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=AFilePath;
 
 Drive:=GetDriveFromPath(AFilePath,True,FILESYS_LOCK_READ);
 if Drive = nil then
  begin
   Volume:=GetVolumeFromPath(AFilePath,True,FILESYS_LOCK_READ);
   if Volume = nil then Exit;
   try
    if Volume.FileSystem = nil then Exit;
   
    if ALeading then Result:=AddLeadingChar(Result,Volume.FileSystem.PathChar);
    if ATrailing then Result:=AddTrailingChar(Result,Volume.FileSystem.PathChar);
   finally 
    {Unlock Volume}
    Volume.ReaderUnlock;
   end; 
  end
 else
  begin
   try
    if Drive.FileSystem = nil then Exit;
   
    if ALeading then Result:=AddLeadingChar(Result,Drive.FileSystem.PathChar);
    if ATrailing then Result:=AddTrailingChar(Result,Drive.FileSystem.PathChar);
   finally 
    {Unlock Drive}
    Drive.ReaderUnlock;
   end; 
  end;
end;

{==============================================================================}

function TFileSysDriver.DeleteSlash(const AFilePath:String;ALeading,ATrailing:Boolean):String;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=AFilePath;
 
 Drive:=GetDriveFromPath(AFilePath,True,FILESYS_LOCK_READ);
 if Drive = nil then
  begin
   Volume:=GetVolumeFromPath(AFilePath,True,FILESYS_LOCK_READ);
   if Volume = nil then Exit;
   try
    if Volume.FileSystem = nil then Exit;
   
    if ALeading then Result:=StripLeadingChar(Result,Volume.FileSystem.PathChar);
    if ATrailing then Result:=StripTrailingChar(Result,Volume.FileSystem.PathChar);
   finally 
    {Unlock Volume}
    Volume.ReaderUnlock;
   end; 
  end
 else
  begin
   try
    if Drive.FileSystem = nil then Exit;
   
    if ALeading then Result:=StripLeadingChar(Result,Drive.FileSystem.PathChar);
    if ATrailing then Result:=StripTrailingChar(Result,Drive.FileSystem.PathChar);
   finally 
    {Unlock Drive}
    Drive.ReaderUnlock;
   end; 
  end;
end;

{==============================================================================}

function TFileSysDriver.FileCreateEx(const AFileName,AShortName:String;AMode:Integer = fmOpenReadWrite or fmShareExclusive):THandle;
{Note: ShortName must not include drive or path (Name only)}
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=INVALID_HANDLE_VALUE;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FileCreateEx FileName = ' + AFileName + ' ShortName = ' + AShortName + ' Mode = ' + IntToHex(AMode,4));
  {$ENDIF}
 
  Drive:=GetDriveFromPath(AFileName,True,FILESYS_LOCK_READ);
  if Drive = nil then
   begin
    Volume:=GetVolumeFromPath(AFileName,True,FILESYS_LOCK_READ);
    if Volume = nil then Exit;
    try
     if Volume.FileSystem = nil then Exit;
   
     Result:=Volume.FileSystem.FileCreateEx(AFileName,AShortName,AMode);
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.FileCreateEx(AFileName,AShortName,AMode);
    finally 
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.CreateDirEx(const ADirName,AShortName:String):Boolean;
{Note: ShortName must not include drive or path (Name only)}
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.CreateDirEx DirName = ' + ADirName + ' ShortName = ' + AShortName);
  {$ENDIF}
 
  Drive:=GetDriveFromPath(ADirName,True,FILESYS_LOCK_READ);
  if Drive = nil then
   begin
    Volume:=GetVolumeFromPath(ADirName,True,FILESYS_LOCK_READ);
    if Volume = nil then Exit;
    try
     if Volume.FileSystem = nil then Exit;
   
     Result:=Volume.FileSystem.CreateDirEx(ADirName,AShortName);
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.CreateDirEx(ADirName,AShortName);
    finally 
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FileSeekEx(AHandle:THandle;const AOffset:Int64;AOrigin:LongInt):Int64;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=-1;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FileSeekEx Handle = ' + IntToHex(AHandle,8) + ' Offset = ' + IntToStr(AOffset));
  {$ENDIF}
 
  Drive:=GetDriveFromFile(AHandle,True,FILESYS_LOCK_READ);  
  if Drive <> nil then
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.FileSeekEx(AHandle,AOffset,AOrigin);
    finally
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end
  else
   begin
    Volume:=GetVolumeFromFile(AHandle,True,FILESYS_LOCK_READ);  
    if Volume <> nil then
     begin
      try
       if Volume.FileSystem = nil then Exit;
     
       Result:=Volume.FileSystem.FileSeekEx(AHandle,AOffset,AOrigin);
      finally
       {Unlock Volume}
       Volume.ReaderUnlock;
      end; 
     end;
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.EndOfFileEx(AHandle:Integer):Boolean;
begin
 {}
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.EndOfFileEx Handle = ' + IntToHex(AHandle,8));
 {$ENDIF}
 
 Result:=FilePosEx(AHandle) >= FileSizeEx(AHandle);
end;

{==============================================================================}

function TFileSysDriver.FilePosEx(AHandle:THandle):Int64;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=-1;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FilePosEx Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}
  
  Drive:=GetDriveFromFile(AHandle,True,FILESYS_LOCK_READ);  
  if Drive <> nil then
   begin
    try
     if Drive.FileSystem = nil then Exit;
    
     Result:=Drive.FileSystem.FilePosEx(AHandle);
    finally
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end
  else
   begin
    Volume:=GetVolumeFromFile(AHandle,True,FILESYS_LOCK_READ);  
    if Volume <> nil then
     begin
      try
       if Volume.FileSystem = nil then Exit;
     
       Result:=Volume.FileSystem.FilePosEx(AHandle);
      finally
       {Unlock Volume}
       Volume.ReaderUnlock;
      end; 
     end;
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FileSizeEx(AHandle:THandle):Int64;
var
 Current:Int64;
begin
 {}
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FileSizeEx Handle = ' + IntToHex(AHandle,8));
 {$ENDIF}
 
 Current:=FilePosEx(AHandle);
 Result:=FileSeekEx(AHandle,0,soFromEnd);
 FileSeekEx(AHandle,Current,soFromBeginning);
end;

{==============================================================================}

function TFileSysDriver.FileAgeEx(const AFileName:String):TFileTime;
var
 Code:Integer;
 SearchRec:TFileSearchRec;
begin
 {}
 Int64(Result):=-1;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FileAgeEx FileName = ' + AFileName);
  {$ENDIF}
  
  Code:=FindFirstEx(AFileName,SearchRec);
  if Code = 0 then
   begin
    Result:=SearchRec.FindData.ftLastWriteTime; {64 Bit FileTime Format}
   end;
 
  FindCloseEx(SearchRec);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FileGetAttrEx(AHandle:Integer):Integer;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=-1;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FileGetAttrEx Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}
 
  Drive:=GetDriveFromFile(AHandle,True,FILESYS_LOCK_READ);  
  if Drive <> nil then
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.FileGetAttrEx(AHandle);
    finally
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end
  else
   begin
    Volume:=GetVolumeFromFile(AHandle,True,FILESYS_LOCK_READ);  
    if Volume <> nil then
     begin
      try
       if Volume.FileSystem = nil then Exit;
     
       Result:=Volume.FileSystem.FileGetAttrEx(AHandle);
      finally
       {Unlock Volume}
       Volume.ReaderUnlock;
      end; 
     end;
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FileGetDateEx(AHandle:Integer):TFileTime;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Int64(Result):=-1;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FileGetDateEx Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}
 
  Drive:=GetDriveFromFile(AHandle,True,FILESYS_LOCK_READ);  
  if Drive <> nil then
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.FileGetDateEx(AHandle);
    finally
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end
  else
   begin
    Volume:=GetVolumeFromFile(AHandle,True,FILESYS_LOCK_READ);  
    if Volume <> nil then
     begin
      try
       if Volume.FileSystem = nil then Exit;
     
       Result:=Volume.FileSystem.FileGetDateEx(AHandle);
      finally
       {Unlock Volume}
       Volume.ReaderUnlock;
      end; 
     end;
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FileSetDateEx(AHandle:Integer;AAge:TFileTime):Integer;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=-1;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FileSetDateEx Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}
 
  Drive:=GetDriveFromFile(AHandle,True,FILESYS_LOCK_READ);  
  if Drive <> nil then
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.FileSetDateEx(AHandle,AAge);
    finally
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end
  else
   begin
    Volume:=GetVolumeFromFile(AHandle,True,FILESYS_LOCK_READ);  
    if Volume <> nil then
     begin
      try
       if Volume.FileSystem = nil then Exit;
     
       Result:=Volume.FileSystem.FileSetDateEx(AHandle,AAge);
      finally
       {Unlock Volume}
       Volume.ReaderUnlock;
      end; 
     end;
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetFileTime(AHandle:Integer;ACreateTime,AAccessTime,AWriteTime:PFileTime):Boolean;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.GetFileTime Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}
 
  Drive:=GetDriveFromFile(AHandle,True,FILESYS_LOCK_READ);  
  if Drive <> nil then
   begin
    try
     if Drive.FileSystem = nil then Exit;
    
     Result:=Drive.FileSystem.GetFileTime(AHandle,ACreateTime,AAccessTime,AWriteTime);
    finally
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end
  else
   begin
    Volume:=GetVolumeFromFile(AHandle,True,FILESYS_LOCK_READ);  
    if Volume <> nil then
     begin
      try
       if Volume.FileSystem = nil then Exit;
     
       Result:=Volume.FileSystem.GetFileTime(AHandle,ACreateTime,AAccessTime,AWriteTime);
      finally
       {Unlock Volume}
       Volume.ReaderUnlock;
      end; 
     end;
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.SetFileTime(AHandle:Integer;ACreateTime,AAccessTime,AWriteTime:PFileTime):Boolean;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.SetFileTime Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}
 
  Drive:=GetDriveFromFile(AHandle,True,FILESYS_LOCK_READ);  
  if Drive <> nil then
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.SetFileTime(AHandle,ACreateTime,AAccessTime,AWriteTime);
    finally
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end
  else
   begin
    Volume:=GetVolumeFromFile(AHandle,True,FILESYS_LOCK_READ);  
    if Volume <> nil then
     begin
      try
       if Volume.FileSystem = nil then Exit;
     
       Result:=Volume.FileSystem.SetFileTime(AHandle,ACreateTime,AAccessTime,AWriteTime);
      finally
       {Unlock Volume}
       Volume.ReaderUnlock;
      end; 
     end;
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FindFirstEx(const APath:String;var ASearchRec:TFileSearchRec):Integer;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=-1;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FindFirstEx Path = ' + APath);
  {$ENDIF}
 
  Drive:=GetDriveFromPath(APath,True,FILESYS_LOCK_READ);
  if Drive = nil then
   begin
    Volume:=GetVolumeFromPath(APath,True,FILESYS_LOCK_READ);
    if Volume = nil then Exit;
    try
     {$IFDEF FILESYS_DEBUG}
     if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FindFirstEx Volume = ' + Volume.Name);
     {$ENDIF}
    
     if Volume.FileSystem = nil then Exit;
   
     Result:=Volume.FileSystem.FindFirstEx(APath,ASearchRec);
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    try
     {$IFDEF FILESYS_DEBUG}
     if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FindFirstEx Drive = ' + Drive.Name);
     {$ENDIF}
    
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.FindFirstEx(APath,ASearchRec);
    finally 
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FindNextEx(var ASearchRec:TFileSearchRec):Integer;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=-1;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FindNextEx Handle = ' + IntToHex(ASearchRec.FindHandle,8));
  {$ENDIF}
 
  Drive:=GetDriveFromFind(ASearchRec.FindHandle,True,FILESYS_LOCK_READ);  
  if Drive <> nil then
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     Result:=Drive.FileSystem.FindNextEx(ASearchRec);
    finally
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end
  else
   begin
    Volume:=GetVolumeFromFind(ASearchRec.FindHandle,True,FILESYS_LOCK_READ);  
    if Volume <> nil then
     begin
      try
       if Volume.FileSystem = nil then Exit;
     
       Result:=Volume.FileSystem.FindNextEx(ASearchRec);
      finally
       {Unlock Volume}
       Volume.ReaderUnlock;
      end; 
     end;
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

procedure TFileSysDriver.FindCloseEx(var ASearchRec:TFileSearchRec);
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FindCloseEx Handle = ' + IntToHex(ASearchRec.FindHandle,8));
  {$ENDIF}
 
  Drive:=GetDriveFromFind(ASearchRec.FindHandle,True,FILESYS_LOCK_READ);  
  if Drive <> nil then
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     Drive.FileSystem.FindCloseEx(ASearchRec);
    finally
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end
  else
   begin
    Volume:=GetVolumeFromFind(ASearchRec.FindHandle,True,FILESYS_LOCK_READ);  
    if Volume <> nil then
     begin
      try
       if Volume.FileSystem = nil then Exit;
     
       Volume.FileSystem.FindCloseEx(ASearchRec);
      finally
       {Unlock Volume}
       Volume.ReaderUnlock;
      end; 
     end;
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.DefineDosDevice(const ADeviceName,ATargetPath:String;AFlags:LongWord):Boolean;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.DefineDosDevice');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                DeviceName = ' + ADeviceName);
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                TargetPath = ' + ATargetPath);
  {$ENDIF}
  
  if (AFlags and DDD_REMOVE_DEFINITION) = 0 then
   begin
    {Add Device}
    Result:=CreateDrive(ADeviceName,ATargetPath);
   end
  else
   begin
    {Remove Device}
    Result:=DeleteDrive(ADeviceName);
   end;   
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetDiskType(const ARootPath:String):LongWord; {Equivalent to Win32 GetDriveType}
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=DRIVE_UNKNOWN;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.GetDiskType');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                RootPath = ' + ARootPath);
  {$ENDIF}
 
  Volume:=GetVolumeFromPath(ARootPath,True,FILESYS_LOCK_READ);  
  if Volume <> nil then
   begin
    {Check Drive Type}
    case Volume.DriveType of
     dtFIXED:Result:=DRIVE_FIXED;
     dtFLOPPY:Result:=DRIVE_REMOVABLE;
     dtREMOVABLE:Result:=DRIVE_REMOVABLE;
     dtNETWORK:Result:=DRIVE_REMOTE;
     dtRAMDRIVE:Result:=DRIVE_RAMDISK;
     dtCDROM:Result:=DRIVE_CDROM;
    end;

    {Unlock Volume}
    Volume.ReaderUnlock;
   end
  else
   begin
    Drive:=GetDriveFromPath(ARootPath,True,FILESYS_LOCK_READ);
    if Drive = nil then Exit;
 
    {Check Drive Type}
    case Drive.DriveType of
     dtFIXED:Result:=DRIVE_FIXED;
     dtFLOPPY:Result:=DRIVE_REMOVABLE;
     dtREMOVABLE:Result:=DRIVE_REMOVABLE;
     dtNETWORK:Result:=DRIVE_REMOTE;
     dtRAMDRIVE:Result:=DRIVE_RAMDISK;
     dtCDROM:Result:=DRIVE_CDROM;
    end;
    
    {Unlock Drive}
    Drive.ReaderUnlock;
   end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetDiskFreeSpace(const ARootPath:String;var ASectorsPerCluster,ABytesPerSector,ANumberOfFreeClusters,ATotalNumberOfClusters:LongWord):Boolean;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
 
 ClusterSize:LongWord;
 FreeClusterCount:Int64;
 TotalClusterCount:Int64;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.GetDiskFreeSpace');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                RootPath = ' + ARootPath);
  {$ENDIF}
 
  Volume:=GetVolumeFromPath(ARootPath,True,FILESYS_LOCK_READ);  
  if Volume <> nil then
   begin
    try
     if Volume.FileSystem = nil then Exit;
     
     {Get Drive Information}
     if Volume.FileSystem.GetDriveInformation(ClusterSize,TotalClusterCount,FreeClusterCount) then
      begin
       if Volume.FileSystem.SectorSize = 0 then Exit;
       
       {Get Values}
       ASectorsPerCluster:=ClusterSize div Volume.FileSystem.SectorSize;
       ABytesPerSector:=Volume.FileSystem.SectorSize;
       ANumberOfFreeClusters:=FreeClusterCount;
       ATotalNumberOfClusters:=TotalClusterCount; 
   
       Result:=True;
      end; 
    finally   
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    Drive:=GetDriveFromPath(ARootPath,True,FILESYS_LOCK_READ);
    if Drive = nil then Exit;
    try
     if Drive.FileSystem = nil then Exit;
     
     {Get Drive Information}
     if Drive.FileSystem.GetDriveInformation(ClusterSize,TotalClusterCount,FreeClusterCount) then
      begin
       if Drive.FileSystem.SectorSize = 0 then Exit;
       
       {Get Values}
       ASectorsPerCluster:=ClusterSize div Drive.FileSystem.SectorSize;
       ABytesPerSector:=Drive.FileSystem.SectorSize;
       ANumberOfFreeClusters:=FreeClusterCount;
       ATotalNumberOfClusters:=TotalClusterCount; 
   
       Result:=True;
      end; 
    finally
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetDiskFreeSpaceEx(const APathName:String;var AFreeBytesAvailableToCaller,ATotalNumberOfBytes,ATotalNumberOfFreeBytes:QWord):Boolean;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.GetDiskFreeSpaceEx');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                PathName = ' + APathName);
  {$ENDIF}
 
  Volume:=GetVolumeFromPath(APathName,True,FILESYS_LOCK_READ);  
  if Volume <> nil then
   begin
    try
     if Volume.FileSystem = nil then Exit;
     
     {Get Values}
     AFreeBytesAvailableToCaller:=Volume.FileSystem.GetDriveFreeSpaceEx;
     ATotalNumberOfBytes:=Volume.FileSystem.GetDriveTotalSpaceEx;
     ATotalNumberOfFreeBytes:=AFreeBytesAvailableToCaller;
   
     Result:=True;
    finally   
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    Drive:=GetDriveFromPath(APathName,True,FILESYS_LOCK_READ);
    if Drive = nil then Exit;
    try
     if Drive.FileSystem = nil then Exit;

     {Get Values}
     AFreeBytesAvailableToCaller:=Drive.FileSystem.GetDriveFreeSpaceEx;
     ATotalNumberOfBytes:=Drive.FileSystem.GetDriveTotalSpaceEx;
     ATotalNumberOfFreeBytes:=AFreeBytesAvailableToCaller;
     
     Result:=True;
    finally
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetLogicalDrives:LongWord;
begin
 {}
 Result:=GetValidDrives;
end;

{==============================================================================}

function TFileSysDriver.GetLogicalDriveStrings:String;
begin
 {}
 Result:=GetValidDriveStrings;
end;

{==============================================================================}

function TFileSysDriver.GetVolumeInformation(const ARootPath:String;var AVolumeName:String;var AVolumeSerialNumber,AMaximumComponentLength,AFileSystemFlags:LongWord;var ASystemName:String):Boolean; 
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.GetVolumeInformation');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                RootPath = ' + ARootPath);
  {$ENDIF}
 
  Volume:=GetVolumeFromPath(ARootPath,True,FILESYS_LOCK_READ);  
  if Volume <> nil then
   begin
    try
     if Volume.FileSystem = nil then Exit;
     
     {Get Values}
     AVolumeName:=Volume.VolumeName;
     AVolumeSerialNumber:=Volume.VolumeSerial;
     AMaximumComponentLength:=Volume.MaxPath;
     AFileSystemFlags:=Volume.Attributes;
     ASystemName:=Volume.SystemName;
   
     Result:=True;
    finally   
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    Drive:=GetDriveFromPath(ARootPath,True,FILESYS_LOCK_READ);
    if Drive = nil then Exit;
    try
     if Drive.FileSystem = nil then Exit;

     {Get Values}
     AVolumeName:=Drive.VolumeName;
     AVolumeSerialNumber:=Drive.VolumeSerial;
     AMaximumComponentLength:=Drive.MaxPath;
     AFileSystemFlags:=Drive.Attributes;
     ASystemName:=Drive.SystemName;
     
     Result:=True;
    finally
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.QueryDosDevice(const ARootPath:String):String;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:='';
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.QueryDosDevice');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                RootPath = ' + ARootPath);
  {$ENDIF}
  
  Volume:=GetVolumeFromPath(ARootPath,True,FILESYS_LOCK_READ);  
  if Volume <> nil then
   begin
    Result:=Volume.Parent;
    
    {Unlock Volume}
    Volume.ReaderUnlock;
   end
  else
   begin
    Drive:=GetDriveFromPath(ARootPath,True,FILESYS_LOCK_READ);
    if Drive = nil then Exit;
    
    Result:=Drive.Parent;

    {Unlock Drive}
    Drive.ReaderUnlock;
   end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.AreFileApisANSI:Boolean;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.AreFileApisANSI');
  {$ENDIF}
  
  Result:=FAT_OEM_CONVERT;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.CloseFile(AHandle:THandle):Boolean; {Equivalent to Win32 CloseHandle}
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.CloseFile');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}
  
  Drive:=GetDriveFromFile(AHandle,True,FILESYS_LOCK_READ);  
  if Drive <> nil then
   begin
    try
     if Drive.FileSystem = nil then Exit;
    
     Result:=Drive.FileSystem.CloseFile(AHandle);
    finally
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end
  else
   begin
    Volume:=GetVolumeFromFile(AHandle,True,FILESYS_LOCK_READ);  
    if Volume <> nil then
     begin
      try
       if Volume.FileSystem = nil then Exit;
     
       Result:=Volume.FileSystem.CloseFile(AHandle);
      finally
       {Unlock Volume}
       Volume.ReaderUnlock;
      end; 
     end;
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.CopyFile(const AExistingName,ANewName:String;AFailIfExists:Boolean):Boolean;
begin
 {}
 Result:=FileCopy(AExistingName,ANewName,AFailIfExists);
end;

{==============================================================================}

function TFileSysDriver.CreateFile(const AFileName:String;AAccessMode,AShareMode,ACreateFlags,AFileAttributes:LongWord):THandle;
var
 OpenMode:Integer;
 ShareMode:Integer;
begin
 {}
 Result:=INVALID_HANDLE_VALUE;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.CreateFile');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                FileName = ' + AFileName);
  {$ENDIF}
  
  {Get Open Mode}
  if (AAccessMode and GENERIC_ALL) = GENERIC_ALL then
   begin
    OpenMode:=fmOpenReadWrite;
    
    {$IFDEF FILESYS_DEBUG}
    if FILESYS_LOG_ENABLED then FileSysLogDebug('                OpenMode = fmOpenReadWrite');
    {$ENDIF}
   end
  else if (AAccessMode and (GENERIC_READ or GENERIC_WRITE)) = (GENERIC_READ or GENERIC_WRITE) then
   begin
    OpenMode:=fmOpenReadWrite;
    
    {$IFDEF FILESYS_DEBUG}
    if FILESYS_LOG_ENABLED then FileSysLogDebug('                OpenMode = fmOpenReadWrite');
    {$ENDIF}
   end
  else if (AAccessMode and GENERIC_WRITE) = GENERIC_WRITE then 
   begin
    OpenMode:=fmOpenWrite;
    
    {$IFDEF FILESYS_DEBUG}
    if FILESYS_LOG_ENABLED then FileSysLogDebug('                OpenMode = fmOpenWrite');
    {$ENDIF}
   end
  else
   begin
    OpenMode:=fmOpenRead;
    
    {$IFDEF FILESYS_DEBUG}
    if FILESYS_LOG_ENABLED then FileSysLogDebug('                OpenMode = fmOpenRead');
    {$ENDIF}
   end;   
  
  {Get Share Mode (FILE_SHARE_DELETE not supported)}
  if (AShareMode and (FILE_SHARE_READ or FILE_SHARE_WRITE)) = (FILE_SHARE_READ or FILE_SHARE_WRITE) then
   begin
    ShareMode:=fmShareDenyNone;

    {$IFDEF FILESYS_DEBUG}
    if FILESYS_LOG_ENABLED then FileSysLogDebug('                ShareMode = fmShareDenyNone');
    {$ENDIF}
   end
  else if (AShareMode and FILE_SHARE_WRITE) = FILE_SHARE_WRITE then 
   begin
    ShareMode:=fmShareDenyRead;

    {$IFDEF FILESYS_DEBUG}
    if FILESYS_LOG_ENABLED then FileSysLogDebug('                ShareMode = fmShareDenyRead');
    {$ENDIF}
   end
  else if (AShareMode and FILE_SHARE_READ) = FILE_SHARE_READ then 
   begin
    ShareMode:=fmShareDenyWrite;

    {$IFDEF FILESYS_DEBUG}
    if FILESYS_LOG_ENABLED then FileSysLogDebug('                ShareMode = fmShareDenyWrite');
    {$ENDIF}
   end
  else
   begin
    ShareMode:=fmShareExclusive;
    
    {$IFDEF FILESYS_DEBUG}
    if FILESYS_LOG_ENABLED then FileSysLogDebug('                ShareMode = fmShareExclusive');
    {$ENDIF}
   end;
  
  {Check Flags}
  case ACreateFlags of
   CREATE_NEW:begin
     {Check Directory}
     if DirectoryExists(AFileName) then Exit;
     
     {Check Exists}
     if FileExists(AFileName) then Exit;
     
     {Create File}
     Result:=FileCreate(AFileName,OpenMode or ShareMode);
    end;
   CREATE_ALWAYS:begin
     {Check Exists}
     if FileExists(AFileName) then
      begin
       {Open File}
       Result:=FileOpen(AFileName,OpenMode or ShareMode);
       
       {Truncate File}
       if Result <> INVALID_HANDLE_VALUE then
        begin
         FileSeekEx(Result,0,soFromBeginning);
         FileTruncate(Result);
        end; 
      end
     else
      begin
       {Check Directory}
       if DirectoryExists(AFileName) then Exit;
       
       {Create File}
       Result:=FileCreate(AFileName,OpenMode or ShareMode);
      end;     
    end;
   OPEN_EXISTING:begin
     {Open File}
     Result:=FileOpen(AFileName,OpenMode or ShareMode);
    end;
   OPEN_ALWAYS:begin
     {Check Exists}
     if FileExists(AFileName) then
      begin
       {Open File}
       Result:=FileOpen(AFileName,OpenMode or ShareMode);
      end
     else
      begin
       {Check Directory}
       if DirectoryExists(AFileName) then Exit;
       
       {Create File}
       Result:=FileCreate(AFileName,OpenMode or ShareMode);
      end;     
    end;
   TRUNCATE_EXISTING:begin
     {Check Directory}
     if DirectoryExists(AFileName) then Exit;
     
     {Check Exists}
     if FileExists(AFileName) then
      begin
       {Open File}
       Result:=FileOpen(AFileName,OpenMode or ShareMode);
     
       {Truncate File}
       if Result <> INVALID_HANDLE_VALUE then
        begin
         FileSeekEx(Result,0,soFromBeginning);
         FileTruncate(Result);
        end; 
      end;
    end;
  end;  
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FindCloseFile(AHandle:THandle):Boolean; {Equivalent to Win32 FindClose}
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
 FileSearchRec:TFileSearchRec;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FindCloseFile');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}
 
  Drive:=GetDriveFromFind(AHandle,True,FILESYS_LOCK_READ);  
  if Drive <> nil then
   begin
    try
     if Drive.FileSystem = nil then Exit;
 
     FileSearchRec.FindHandle:=AHandle;
   
     Drive.FileSystem.FindCloseEx(FileSearchRec);
     
     Result:=True;
    finally
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end
  else
   begin
    Volume:=GetVolumeFromFind(AHandle,True,FILESYS_LOCK_READ);  
    if Volume <> nil then
     begin
      try
       if Volume.FileSystem = nil then Exit;
      
       FileSearchRec.FindHandle:=AHandle;
     
       Volume.FileSystem.FindCloseEx(FileSearchRec);
       
       Result:=True;
      finally
       {Unlock Volume}
       Volume.ReaderUnlock;
      end; 
     end;
   end;
finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FindFirstFile(const AFileName:String;var AFindData:TWin32FindData):THandle;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
 FileSearchRec:TFileSearchRec;
begin
 {}
 Result:=INVALID_HANDLE_VALUE;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FindFirstFile');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                FileName = ' + AFileName);
  {$ENDIF}

  Drive:=GetDriveFromPath(AFileName,True,FILESYS_LOCK_READ);
  if Drive = nil then
   begin
    Volume:=GetVolumeFromPath(AFileName,True,FILESYS_LOCK_READ);
    if Volume = nil then Exit;
    try
     if Volume.FileSystem = nil then Exit;
   
     if Volume.FileSystem.FindFirstEx(AFileName,FileSearchRec) = 0 then
      begin
       Result:=FileSearchRec.FindHandle;
       AFindData:=FileSearchRec.FindData;
      end
     else
      begin
       SetLastError(ERROR_FILE_NOT_FOUND);
      end;      
    finally 
     {Unlock Volume}
     Volume.ReaderUnlock;
    end; 
   end
  else
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     if Drive.FileSystem.FindFirstEx(AFileName,FileSearchRec) = 0 then
      begin
       Result:=FileSearchRec.FindHandle;
       AFindData:=FileSearchRec.FindData;
      end
     else
      begin
       SetLastError(ERROR_FILE_NOT_FOUND);
      end;
    finally 
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FindNextFile(AHandle:THandle;var AFindData:TWin32FindData):Boolean;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
 FileSearchRec:TFileSearchRec;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.FindNextFile');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}

  Drive:=GetDriveFromFind(AHandle,True,FILESYS_LOCK_READ);  
  if Drive <> nil then
   begin
    try
     if Drive.FileSystem = nil then Exit;
   
     FileSearchRec.FindHandle:=AHandle;
     if Drive.FileSystem.FindNextEx(FileSearchRec) = 0 then
      begin
       Result:=True;
       AFindData:=FileSearchRec.FindData;
      end
     else
      begin
       SetLastError(ERROR_NO_MORE_FILES);
      end;      
    finally
     {Unlock Drive}
     Drive.ReaderUnlock;
    end; 
   end
  else
   begin
    Volume:=GetVolumeFromFind(AHandle,True,FILESYS_LOCK_READ);  
    if Volume <> nil then
     begin
      try
       if Volume.FileSystem = nil then Exit;
     
       FileSearchRec.FindHandle:=AHandle;
       if Volume.FileSystem.FindNextEx(FileSearchRec) = 0 then
        begin
         Result:=True;
         AFindData:=FileSearchRec.FindData;
        end
       else
        begin
         SetLastError(ERROR_NO_MORE_FILES);
        end;
      finally
       {Unlock Volume}
       Volume.ReaderUnlock;
      end; 
     end;
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.FlushFileBuffers(AHandle:THandle):Boolean;
begin
 {}
 Result:=FileFlush(AHandle);
end;

{==============================================================================}

function TFileSysDriver.GetFileAttributes(const AFileName:String):LongWord;
begin
 {}
 Result:=FileGetAttr(AFileName);
end;

{==============================================================================}

function TFileSysDriver.GetFileInformationByHandle(AHandle:THandle;var AFileInformation:TByHandleFileInformation):Boolean;
{Get the details of an existing entry with an open Handle}
{Note: Returned times are UTC}
var
 FileHandle:TFileHandle;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.GetFileInformationByHandle Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}
 
  {Get the Handle}
  FileHandle:=GetFileFromHandle(AHandle,True,FILESYS_LOCK_WRITE); //To Do //Reader
  if FileHandle = nil then Exit;
  try
   {Check the Mode}
   if FileHandle.OpenMode = fmOpenWrite then Exit;
   
   {Check the Handle}
   if FileHandle.HandleEntry = nil then Exit;
   
   {Get Information}
   AFileInformation.ftCreationTime:=FileHandle.HandleEntry.CreateTime;
   AFileInformation.ftLastAccessTime:=FileHandle.HandleEntry.AccessTime;
   AFileInformation.ftLastWriteTime:=FileHandle.HandleEntry.WriteTime;
   AFileInformation.nFileSizeHigh:=TULargeInteger(FileHandle.HandleEntry.Size).HighPart;
   AFileInformation.nFileSizeLow:=TULargeInteger(FileHandle.HandleEntry.Size).LowPart;
   AFileInformation.nNumberOfLinks:=1; //To Do //API
   AFileInformation.nFileIndexHigh:=0; //To Do //API
   AFileInformation.nFileIndexLow:=PtrUInt(FileHandle.HandleEntry);
  
   {Check Drive}
   if FileHandle.Drive <> nil then
    begin
     if FileHandle.Drive.FileSystem = nil then Exit;
     
     AFileInformation.dwFileAttributes:=(FileHandle.HandleEntry.Attributes and FileHandle.Drive.FileSystem.MaskAttributes);
     AFileInformation.dwVolumeSerialNumber:=FileHandle.Drive.VolumeSerial;
    end
   else if FileHandle.Volume <> nil then  
    begin
     if FileHandle.Volume.FileSystem = nil then Exit;
     
     AFileInformation.dwFileAttributes:=(FileHandle.HandleEntry.Attributes and FileHandle.Volume.FileSystem.MaskAttributes);
     AFileInformation.dwVolumeSerialNumber:=FileHandle.Volume.VolumeSerial;
    end;
  
   Result:=True;
  finally
   {Unlock Handle}
   FileHandle.WriterUnlock;
  end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetFileSize(AHandle:THandle;var AFileSizeHigh:LongWord):LongWord;
var
 Value:Int64;
begin
 {}
 Value:=FileSizeEx(AHandle);
 
 Result:=Int64Rec(Value).Lo;
 AFileSizeHigh:=Int64Rec(Value).Hi;
end;

{==============================================================================}

function TFileSysDriver.GetFullPathName(const AFileName:String):String;
begin
 {}
 Result:=GetLongName(AFileName);
end;

{==============================================================================}

function TFileSysDriver.GetShortPathName(const ALongPath:String):String;
begin
 {}
 Result:=GetShortName(ALongPath);
end;

{==============================================================================}

function TFileSysDriver.MoveFile(const AExistingName,ANewName:String):Boolean;
begin
 {}
 Result:=RenameFile(AExistingName,ANewName);
end;

{==============================================================================}

function TFileSysDriver.ReadFile(AHandle:THandle;var ABuffer;ABytesToRead:LongWord;var ABytesRead:LongWord):Boolean;
var
 Count:LongInt;
begin
 {}
 ABytesRead:=0;
 
 Count:=FileRead(AHandle,ABuffer,ABytesToRead);
 Result:=(Count <> -1);
 if Result then
  begin
   ABytesRead:=Count;
  end;
end;

{==============================================================================}

function TFileSysDriver.SetFileApisToANSI:Boolean;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.SetFileApisToANSI');
  {$ENDIF}

  FAT_OEM_CONVERT:=True;
  
  Result:=True;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.SetFileApisToOEM:Boolean;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSysDriver.SetFileApisToOEM');
  {$ENDIF}

  FAT_OEM_CONVERT:=False;
  
  Result:=True;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.SetFileAttributes(const AFileName:String;AFileAttributes:LongWord):Boolean;
begin
 {}
 Result:=(FileSetAttr(AFileName,AFileAttributes) <> -1);
end;

{==============================================================================}

function TFileSysDriver.SetFilePointer(AHandle:THandle;ADistanceToMove:LongInt;var ADistanceToMoveHigh:LongInt;AMoveMethod:LongWord):LongWord;
var
 Value:Int64;
begin
 {}
 Result:=INVALID_SET_FILE_POINTER;
 
 Int64Rec(Value).Lo:=ADistanceToMove;
 Int64Rec(Value).Hi:=ADistanceToMoveHigh;
 
 Value:=FileSeekEx(AHandle,Value,AMoveMethod);
 if Value <> -1 then
  begin
   Result:=Int64Rec(Value).Lo;
   ADistanceToMoveHigh:=Int64Rec(Value).Hi;
  end;
end;

{==============================================================================}

function TFileSysDriver.SetFilePointerEx(AHandle:THandle;const ADistanceToMove:Int64;var ANewFilePointer:Int64;AMoveMethod:LongWord):Boolean;
begin
 {}
 ANewFilePointer:=FileSeekEx(AHandle,ADistanceToMove,AMoveMethod);
 
 Result:=(ANewFilePointer <> -1);
end;

{==============================================================================}

function TFileSysDriver.WriteFile(AHandle:THandle;const ABuffer;ABytesToWrite:LongWord;var ABytesWritten:LongWord):Boolean;
var
 Count:LongInt;
begin
 {}
 ABytesWritten:=0;
 
 Count:=FileWrite(AHandle,ABuffer,ABytesToWrite);
 Result:=(Count <> -1);
 if Result then
  begin
   ABytesWritten:=Count;
  end; 
end;

{==============================================================================}

function TFileSysDriver.GetLongPathName(const AShortPath:String):String;
begin
 {}
 Result:=GetLongName(AShortPath);
end;

{==============================================================================}

function TFileSysDriver.CreateDirectory(const APathName:String):Boolean;
begin
 {}
 Result:=CreateDir(APathName);
end;

{==============================================================================}

function TFileSysDriver.GetCurrentDirectory:String;
begin
 {}
 Result:=GetCurrentDir;
end;

{==============================================================================}

function TFileSysDriver.RemoveDirectory(const APathName:String):Boolean;
begin
 {}
 Result:=RemoveDir(APathName);
end;

{==============================================================================}

function TFileSysDriver.SetCurrentDirectory(const APathName:String):Boolean;
begin
 {}
 Result:=SetCurrentDir(APathName);
end;

{==============================================================================}

function TFileSysDriver.GetDeviceFromRaw(AHandle:Integer;ALock:Boolean;AState:LongWord):TDiskDevice;
var
 Handle:TRawHandle;
begin
 {}
 Result:=nil;
 
 {Get the Handle}
 Handle:=GetRawFromHandle(AHandle,True,FILESYS_LOCK_READ);
 if Handle = nil then Exit;
 try
  {Get the Device}
  Result:=Handle.Device;
  
  {Check Device}
  if not CheckDevice(Result,ALock,AState) then Result:=nil;
 finally
  {Unlock Handle}
  Handle.ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetDeviceFromEnum(AHandle:Integer;ALock:Boolean;AState:LongWord):TDiskDevice;
var
 Handle:TEnumHandle;
begin
 {}
 Result:=nil;
 
 {Get the Handle}
 Handle:=GetEnumFromHandle(AHandle,True,FILESYS_LOCK_READ);
 if Handle = nil then Exit;
 try
  {Get the Device}
  Result:=Handle.CurrentDevice;

  {Check Device}
  if not CheckDevice(Result,ALock,AState) then Result:=nil;
 finally
  {Unlock Handle}
  Handle.ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetPartitionFromRaw(AHandle:Integer;ALock:Boolean;AState:LongWord):TDiskPartition;
var
 Handle:TRawHandle;
begin
 {}
 Result:=nil;
 
 {Get the Handle}
 Handle:=GetRawFromHandle(AHandle,True,FILESYS_LOCK_READ);
 if Handle = nil then Exit;
 try
  {Get the Partition}
  Result:=Handle.Partition;

  {Check Partition}
  if not CheckPartition(Result,ALock,AState) then Result:=nil;
 finally
  {Unlock Handle}
  Handle.ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetPartitionFromEnum(AHandle:Integer;ALock:Boolean;AState:LongWord):TDiskPartition;
var
 Handle:TEnumHandle;
begin
 {}
 Result:=nil;
 
 {Get the Handle}
 Handle:=GetEnumFromHandle(AHandle,True,FILESYS_LOCK_READ);
 if Handle = nil then Exit;
 try
  {Get the Partition}
  Result:=Handle.CurrentPartition;

  {Check Partition}
  if not CheckPartition(Result,ALock,AState) then Result:=nil;
 finally
  {Unlock Handle}
  Handle.ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetVolumeFromPath(const APath:String;ALock:Boolean;AState:LongWord):TDiskVolume;
var
 SlashPos:Integer;
 WorkBuffer:String;
 Device:TDiskDevice;
 FileSystem:TFileSystem;
 Partition:TDiskPartition;
begin
 {}
 Result:=nil;
 
 if Length(APath) > 1 then
  begin
   {Check for Drive Path}
   if APath[2] = FAT_DRIVE_CHAR then {:}
    begin
     {Check for Drive}
     if APath[1] in ['A'..'Z','a'..'z'] then {A:..Z:}
      begin
       Exit; {Return nil}
      end;
    end;
    
   {Check for Volume Path}
   if Copy(APath,1,Length(VOLUME_PATH_PREFIX)) = VOLUME_PATH_PREFIX then {\\?}
    begin
     {Check for Volume}
     if Uppercase(Copy(APath,Length(VOLUME_PATH_PREFIX) + 1,Length(VOLUME_PREFIX))) = Uppercase(VOLUME_PREFIX) then {\Volume}
      begin
       {Get Remainder}
       WorkBuffer:=Copy(APath,Length(VOLUME_PATH_PREFIX) + Length(VOLUME_PREFIX) + 1,Length(APath));
       
       {Check Slash}
       SlashPos:=Pos(FAT_PATH_CHAR,WorkBuffer);
       if SlashPos = 0 then SlashPos:=Pos(UNIX_PATH_CHAR,WorkBuffer);
       if SlashPos <> 0 then WorkBuffer:=Copy(WorkBuffer,1,SlashPos - 1);
       
       {Get Volume}
       Result:=GetVolumeByName(VOLUME_PREFIX + WorkBuffer,ALock,AState); {Previously VOLUME_PATH_PREFIX + VOLUME_PREFIX + WorkBuffer}
       if Result = nil then
        begin
         {Get FileSystem}
         FileSystem:=GetFileSystemByRootName(VOLUME_PATH_PREFIX + VOLUME_PREFIX + WorkBuffer,True,FILESYS_LOCK_READ);
         if FileSystem <> nil then
          begin
           Result:=FileSystem.Volume;
           //To Do //Lock
           //Dont need to do check volume, the lock on FileSystem prevents changes so can go ahead and lock the Volume ? (Search Result.WriterLock elsewhere)
           
           {Unlock FileSystem}
           FileSystem.ReaderUnlock;
          end; 
        end;
       Exit;
      end;
    end;
   
   {Check for Device Path}
   if Copy(APath,1,Length(DEVICE_PATH_PREFIX)) = DEVICE_PATH_PREFIX then {\\.}
    begin
     {Check for Device}
     if Uppercase(Copy(APath,Length(DEVICE_PATH_PREFIX) + 1,Length(FIXED_DEVICE_PREFIX))) = Uppercase(FIXED_DEVICE_PREFIX) then {\Harddisk}
      begin
       {Get Remainder}
       WorkBuffer:=Copy(APath,Length(DEVICE_PATH_PREFIX) + Length(FIXED_DEVICE_PREFIX) + 1,Length(APath));
       
       {Check Slash}
       SlashPos:=Pos(FAT_PATH_CHAR,WorkBuffer);
       if SlashPos = 0 then SlashPos:=Pos(UNIX_PATH_CHAR,WorkBuffer);
       if SlashPos <> 0 then WorkBuffer:=Copy(WorkBuffer,1,SlashPos - 1);
       
       {Get Device}
       Device:=GetDeviceByName(FIXED_DEVICE_PREFIX + WorkBuffer,True,FILESYS_LOCK_READ); {Previously DEVICE_PATH_PREFIX + FIXED_DEVICE_PREFIX + WorkBuffer}
       if Device <> nil then
        begin
         {Get Remainder}
         WorkBuffer:=Copy(APath,Length(DEVICE_PATH_PREFIX) + Length(FIXED_DEVICE_PREFIX) + Length(WorkBuffer) + 1,Length(APath));
         
         {Check for Partition}
         if Uppercase(Copy(WorkBuffer,1,Length(PARTITION_PREFIX))) = Uppercase(PARTITION_PREFIX) then {\Partition}
          begin
           {Get Remainder}
           WorkBuffer:=Copy(WorkBuffer,Length(PARTITION_PREFIX) + 1,Length(WorkBuffer));
           
           {Check Slash}
           SlashPos:=Pos(FAT_PATH_CHAR,WorkBuffer);
           if SlashPos = 0 then SlashPos:=Pos(UNIX_PATH_CHAR,WorkBuffer);
           if SlashPos <> 0 then WorkBuffer:=Copy(WorkBuffer,1,SlashPos - 1);
           
           {Get Partition}
           Partition:=GetPartitionByName(Device,PARTITION_PREFIX + WorkBuffer,True,FILESYS_LOCK_READ);
           if Partition <> nil then
            begin
             {Get Volume}
             Result:=GetVolumeByPartition(Partition,ALock,AState);
             
             {Unlock Partition}
             Partition.ReaderUnlock;
            end; 
           if Result = nil then
            begin
             {Get FileSystem}
             FileSystem:=GetFileSystemByRootPath(DEVICE_PATH_PREFIX + Device.Name + PARTITION_PREFIX + WorkBuffer,True,FILESYS_LOCK_READ);
             if FileSystem <> nil then
              begin
               Result:=FileSystem.Volume;
               //To Do //Lock
               //Dont need to do check volume, the lock on FileSystem prevents changes so can go ahead and lock the Volume ? (Search Result.WriterLock elsewhere)
               
               {Unlock FileSystem}
               FileSystem.ReaderUnlock;
              end; 
            end;
          end
         else
          begin
           {Get Volume}
           Result:=GetVolumeByDevice(Device,ALock,AState);
           if Result = nil then
            begin
             {Get FileSystem}
             FileSystem:=GetFileSystemByRootPath(DEVICE_PATH_PREFIX + FIXED_DEVICE_PREFIX + WorkBuffer,True,FILESYS_LOCK_READ);
             if FileSystem <> nil then
              begin
               Result:=FileSystem.Volume;
               //To Do //Lock
               //Dont need to do check volume, the lock on FileSystem prevents changes so can go ahead and lock the Volume ? (Search Result.WriterLock elsewhere)
               
               {Unlock FileSystem}
               FileSystem.ReaderUnlock;
              end; 
            end;
          end;
          
         {Unlock Device}
         Device.ReaderUnlock;
        end;
       Exit;
      end
     else if Uppercase(Copy(APath,Length(DEVICE_PATH_PREFIX) + 1,Length(CDROM_DEVICE_PREFIX))) = Uppercase(CDROM_DEVICE_PREFIX) then {\Cdrom}
      begin
       {Get Remainder}
       WorkBuffer:=Copy(APath,Length(DEVICE_PATH_PREFIX) + Length(CDROM_DEVICE_PREFIX) + 1,Length(APath));
       
       {Check Slash}
       SlashPos:=Pos(FAT_PATH_CHAR,WorkBuffer);
       if SlashPos = 0 then SlashPos:=Pos(UNIX_PATH_CHAR,WorkBuffer);
       if SlashPos <> 0 then WorkBuffer:=Copy(WorkBuffer,1,SlashPos - 1);
       
       {Get Device}
       Device:=GetDeviceByName(CDROM_DEVICE_PREFIX + WorkBuffer,True,FILESYS_LOCK_READ); {Previously DEVICE_PATH_PREFIX + CDROM_DEVICE_PREFIX + WorkBuffer}
       if Device <> nil then
        begin
         {Get Volume}
         Result:=GetVolumeByDevice(Device,ALock,AState);
        
         {Unlock Device}
         Device.ReaderUnlock;
        end;        
       if Result = nil then
        begin
         {Get FileSystem}
         FileSystem:=GetFileSystemByRootPath(DEVICE_PATH_PREFIX + CDROM_DEVICE_PREFIX + WorkBuffer,True,FILESYS_LOCK_READ);
         if FileSystem <> nil then
          begin
           Result:=FileSystem.Volume;
           //To Do //Lock
           //Dont need to do check volume, the lock on FileSystem prevents changes so can go ahead and lock the Volume ? (Search Result.WriterLock elsewhere)

           {Unlock FileSystem}
           FileSystem.ReaderUnlock;
          end; 
        end;
       Exit;
      end
     else if Uppercase(Copy(APath,Length(DEVICE_PATH_PREFIX) + 1,Length(FLOPPY_DEVICE_PREFIX))) = Uppercase(FLOPPY_DEVICE_PREFIX) then {\Floppy}
      begin
       {Get Remainder}
       WorkBuffer:=Copy(APath,Length(DEVICE_PATH_PREFIX) + Length(FLOPPY_DEVICE_PREFIX) + 1,Length(APath));
       
       {Check Slash}
       SlashPos:=Pos(FAT_PATH_CHAR,WorkBuffer);
       if SlashPos = 0 then SlashPos:=Pos(UNIX_PATH_CHAR,WorkBuffer);
       if SlashPos <> 0 then WorkBuffer:=Copy(WorkBuffer,1,SlashPos - 1);
       
       {Get Device}
       Device:=GetDeviceByName(FLOPPY_DEVICE_PREFIX + WorkBuffer,True,FILESYS_LOCK_READ); {Previously DEVICE_PATH_PREFIX + FLOPPY_DEVICE_PREFIX + WorkBuffer}
       if Device <> nil then
        begin
         {Get Volume}
         Result:=GetVolumeByDevice(Device,ALock,AState);
        
         {Unlock Device}
         Device.ReaderUnlock;
        end;        
       if Result = nil then
        begin
         {Get FileSystem}
         FileSystem:=GetFileSystemByRootPath(DEVICE_PATH_PREFIX + FLOPPY_DEVICE_PREFIX + WorkBuffer,True,FILESYS_LOCK_READ);
         if FileSystem <> nil then
          begin
           Result:=FileSystem.Volume;
           //To Do //Lock
           //Dont need to do check volume, the lock on FileSystem prevents changes so can go ahead and lock the Volume ? (Search Result.WriterLock elsewhere)
           
           {Unlock FileSystem}
           FileSystem.ReaderUnlock;
          end; 
        end;
       Exit;
      end
     else if Uppercase(Copy(APath,Length(DEVICE_PATH_PREFIX) + 1,Length(OTHER_DEVICE_PREFIX))) = Uppercase(OTHER_DEVICE_PREFIX) then {\Other}
      begin
       {Get Remainder}
       WorkBuffer:=Copy(APath,Length(DEVICE_PATH_PREFIX) + Length(OTHER_DEVICE_PREFIX) + 1,Length(APath));
       
       {Check Slash}
       SlashPos:=Pos(FAT_PATH_CHAR,WorkBuffer);
       if SlashPos = 0 then SlashPos:=Pos(UNIX_PATH_CHAR,WorkBuffer);
       if SlashPos <> 0 then WorkBuffer:=Copy(WorkBuffer,1,SlashPos - 1);
       
       {Get Device}
       Device:=GetDeviceByName(OTHER_DEVICE_PREFIX + WorkBuffer,True,FILESYS_LOCK_READ); {Previously DEVICE_PATH_PREFIX + OTHER_DEVICE_PREFIX + WorkBuffer}
       if Device <> nil then
        begin
         {Get Volume}
         Result:=GetVolumeByDevice(Device,ALock,AState);
         
         {Unlock Device}
         Device.ReaderUnlock;
        end;
       if Result = nil then
        begin
         {Get FileSystem}
         FileSystem:=GetFileSystemByRootPath(DEVICE_PATH_PREFIX + OTHER_DEVICE_PREFIX + WorkBuffer,True,FILESYS_LOCK_READ);
         if FileSystem <> nil then
          begin
           Result:=FileSystem.Volume;
           //To Do //Lock
           //Dont need to do check volume, the lock on FileSystem prevents changes so can go ahead and lock the Volume ? (Search Result.WriterLock elsewhere)
           
           {Unlock FileSystem}
           FileSystem.ReaderUnlock;
          end; 
        end;
       Exit;
      end;
    end;
    
   {Check for Unc Path}
   if (APath[1] = FAT_PATH_CHAR) and (APath[2] = FAT_PATH_CHAR) then {\\}
    begin
     Exit; {Return nil}
    end;
  end;
end;

{==============================================================================}

function TFileSysDriver.GetVolumeFromRaw(AHandle:Integer;ALock:Boolean;AState:LongWord):TDiskVolume;
var
 Handle:TRawHandle;
begin
 {}
 Result:=nil;
 
 {Get the Handle}
 Handle:=GetRawFromHandle(AHandle,True,FILESYS_LOCK_READ);
 if Handle = nil then Exit;
 try
  {Get the Volume}
  Result:=Handle.Volume;

  {Check Volume}
  if not CheckVolume(Result,ALock,AState) then Result:=nil;
 finally
  {Unlock Handle}
  Handle.ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetVolumeFromEnum(AHandle:Integer;ALock:Boolean;AState:LongWord):TDiskVolume;
var
 Handle:TEnumHandle;
begin
 {}
 Result:=nil;
 
 {Get the Handle}
 Handle:=GetEnumFromHandle(AHandle,True,FILESYS_LOCK_READ);
 if Handle = nil then Exit;
 try
  {Get the Volume}
  Result:=Handle.CurrentVolume;

  {Check Volume}
  if not CheckVolume(Result,ALock,AState) then Result:=nil;
 finally
  {Unlock Handle}
  Handle.ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetVolumeFromFile(AHandle:Integer;ALock:Boolean;AState:LongWord):TDiskVolume;
var
 Handle:TFileHandle;
begin
 {}
 Result:=nil;
 
 {Get the Handle}
 Handle:=GetFileFromHandle(AHandle,True,FILESYS_LOCK_READ);
 if Handle = nil then Exit;
 try
  {Get the Volume}
  Result:=Handle.Volume;

  {Check Volume}
  if not CheckVolume(Result,ALock,AState) then Result:=nil;
 finally
  {Unlock Handle}
  Handle.ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetVolumeFromFind(AHandle:Integer;ALock:Boolean;AState:LongWord):TDiskVolume;
var
 Handle:TFindHandle;
begin
 {}
 Result:=nil;
 
 {Get the Handle}
 Handle:=GetFindFromHandle(AHandle,True,FILESYS_LOCK_READ);
 if Handle = nil then Exit;
 try
  {Get the Volume}
  Result:=Handle.Volume;

  {Check Volume}
  if not CheckVolume(Result,ALock,AState) then Result:=nil;
 finally
  {Unlock Handle}
  Handle.ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetDriveFromPath(const APath:String;ALock:Boolean;AState:LongWord):TDiskDrive;
begin
 {}
 Result:=nil;
 
 if Length(APath) > 1 then {Previously - Length(APath) > 0}
  begin
   {Check for Drive Path}
   if APath[2] = FAT_DRIVE_CHAR then {:}
    begin
     {Check for Drive}
     if APath[1] in ['A'..'Z','a'..'z'] then {A:..Z:}
      begin
       {Get Drive}
       Result:=GetDriveByNo((Ord(UpCase(APath[1])) - Ord('A')) + 1,ALock,AState);
       Exit;
      end;
    end;
   
   {Check for Volume Path}
   if Copy(APath,1,Length(VOLUME_PATH_PREFIX)) = VOLUME_PATH_PREFIX then {\\?}
    begin
     {Check for Volume}
     if Uppercase(Copy(APath,Length(VOLUME_PATH_PREFIX) + 1,Length(VOLUME_PREFIX))) = Uppercase(VOLUME_PREFIX) then {\Volume}
      begin
       Exit; {Return nil}
      end;
    end;
   
   {Check for Device Path}
   if Copy(APath,1,Length(DEVICE_PATH_PREFIX)) = DEVICE_PATH_PREFIX then {\\.}
    begin
     {Check for Device}
     if Uppercase(Copy(APath,Length(DEVICE_PATH_PREFIX) + 1,Length(FIXED_DEVICE_PREFIX))) = Uppercase(FIXED_DEVICE_PREFIX) then {\Harddisk}
      begin
       Exit; {Return nil}
      end
     else if Uppercase(Copy(APath,Length(DEVICE_PATH_PREFIX) + 1,Length(CDROM_DEVICE_PREFIX))) = Uppercase(CDROM_DEVICE_PREFIX) then {\Cdrom}
      begin
       Exit; {Return nil}
      end
     else if Uppercase(Copy(APath,Length(DEVICE_PATH_PREFIX) + 1,Length(FLOPPY_DEVICE_PREFIX))) = Uppercase(FLOPPY_DEVICE_PREFIX) then {\Floppy}
      begin
       Exit; {Return nil}
      end;
    end;
   
   {Check for Unc Path}
   if (APath[1] = FAT_PATH_CHAR) and (APath[2] = FAT_PATH_CHAR) then {\\}
    begin
     {Get Drive}
     Result:=GetDriveByNo(NON_DRIVE,ALock,AState);
     Exit;
    end;
    
   {Default to Current Drive}
   Result:=GetDriveByNo(GetCurrentDrive,ALock,AState);
  end
 else if Length(APath) > 0 then
  begin
   {Default to Current Drive}
   Result:=GetDriveByNo(GetCurrentDrive,ALock,AState);
  end;  
end;

{==============================================================================}

function TFileSysDriver.GetDriveFromRaw(AHandle:Integer;ALock:Boolean;AState:LongWord):TDiskDrive;
var
 Handle:TRawHandle;
begin
 {}
 Result:=nil;
 
 {Get the Handle}
 Handle:=GetRawFromHandle(AHandle,True,FILESYS_LOCK_READ);
 if Handle = nil then Exit;
 try 
  {Get the Drive}
  Result:=Handle.Drive;

  {Check Drive}
  if not CheckDrive(Result,ALock,AState) then Result:=nil;
 finally
  {Unlock Handle}
  Handle.ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetDriveFromEnum(AHandle:Integer;ALock:Boolean;AState:LongWord):TDiskDrive;
var
 Handle:TEnumHandle;
begin
 {}
 Result:=nil;
 
 {Get the Handle}
 Handle:=GetEnumFromHandle(AHandle,True,FILESYS_LOCK_READ);
 if Handle = nil then Exit;
 try 
  {Get the Drive}
  Result:=Handle.CurrentDrive;

  {Check Drive}
  if not CheckDrive(Result,ALock,AState) then Result:=nil;
 finally
  {Unlock Handle}
  Handle.ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetDriveFromFile(AHandle:Integer;ALock:Boolean;AState:LongWord):TDiskDrive;
var
 Handle:TFileHandle;
begin
 {}
 Result:=nil;
 
 {Get the Handle}
 Handle:=GetFileFromHandle(AHandle,True,FILESYS_LOCK_READ);
 if Handle = nil then Exit;
 try 
  {Get the Drive}
  Result:=Handle.Drive;

  {Check Drive}
  if not CheckDrive(Result,ALock,AState) then Result:=nil;
 finally
  {Unlock Handle}
  Handle.ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetDriveFromFind(AHandle:Integer;ALock:Boolean;AState:LongWord):TDiskDrive;
var
 Handle:TFindHandle;
begin
 {}
 Result:=nil;
 
 {Get the Handle}
 Handle:=GetFindFromHandle(AHandle,True,FILESYS_LOCK_READ);
 if Handle = nil then Exit;
 try 
  {Get the Drive}
  Result:=Handle.Drive;

  {Check Drive}
  if not CheckDrive(Result,ALock,AState) then Result:=nil;
 finally
  {Unlock Handle}
  Handle.ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetImageFromEnum(AHandle:Integer;ALock:Boolean;AState:LongWord):TDiskImage;
var
 Handle:TEnumHandle;
begin
 {}
 Result:=nil;
 
 {Get the Handle}
 Handle:=GetEnumFromHandle(AHandle,True,FILESYS_LOCK_READ);
 if Handle = nil then Exit;
 try 
  {Get the Image}
  Result:=Handle.CurrentImage;

  {Check Image}
  if not CheckImage(Result,ALock,AState) then Result:=nil;
 finally
  {Unlock Handle}
  Handle.ReaderUnlock;
 end; 
end;
   
{==============================================================================}

function TFileSysDriver.GetCatalogFromEnum(AHandle:Integer;ALock:Boolean;AState:LongWord):TDiskCatalog;
var
 Handle:TEnumHandle;
 FileSystem:TFileSystem;
begin
 {}
 Result:=nil;
 
 {Get the Handle}
 Handle:=GetEnumFromHandle(AHandle,True,FILESYS_LOCK_READ);
 if Handle = nil then Exit;
 try 
  {Get the FileSystem}
  FileSystem:=GetFileSystemFromEnum(AHandle,True,FILESYS_LOCK_READ);  
  if FileSystem = nil then Exit;
  
  {Get the Catalog}
  Result:=Handle.CurrentCatalog;

  {Check Catalog}
  if not FileSystem.CheckCatalog(Result,ALock,AState) then Result:=nil;
  
  {Unlock FileSystem}
  FileSystem.ReaderUnlock;
 finally
  {Unlock Handle}
  Handle.ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetFileSystemFromPath(const APath:String;ALock:Boolean;AState:LongWord):TFileSystem;
var
 Drive:TDiskDrive;
 Volume:TDiskVolume;
begin
 {}
 Result:=nil;
 
 {Get the Drive}
 Drive:=GetDriveFromPath(APath,True,FILESYS_LOCK_READ);
 if Drive = nil then
  begin
   {Get the Volume}
   Volume:=GetVolumeFromPath(APath,True,FILESYS_LOCK_READ);
   if Volume = nil then Exit;
   try
    {Get the FileSystem}
    Result:=Volume.FileSystem;
    if Result = nil then Exit;
    
    {Lock FileSystem}
    if ALock then if AState = FILESYS_LOCK_READ then Result.ReaderLock else Result.WriterLock;
   finally 
    {Unlock Volume}
    Volume.ReaderUnlock;
   end; 
  end
 else
  begin
   try
    {Get the FileSystem}
    Result:=Drive.FileSystem;
    if Result = nil then Exit;
    
    {Lock FileSystem}
    if ALock then if AState = FILESYS_LOCK_READ then Result.ReaderLock else Result.WriterLock;
   finally 
    {Unlock Drive}
    Drive.ReaderUnlock;
   end; 
  end;
end;

{==============================================================================}

function TFileSysDriver.GetFileSystemFromEnum(AHandle:Integer;ALock:Boolean;AState:LongWord):TFileSystem;
var
 Handle:TEnumHandle;
begin
 {}
 Result:=nil;
 
 {Get the Handle}
 Handle:=GetEnumFromHandle(AHandle,True,FILESYS_LOCK_READ);
 if Handle = nil then Exit;
 try
  {Get the FileSystem}
  Result:=Handle.FileSystem;
  
  {Check FileSystem}
  if not CheckFileSystem(Result,ALock,AState) then Result:=nil;
 finally
  {Unlock Handle}
  Handle.ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetFileSystemFromFile(AHandle:Integer;ALock:Boolean;AState:LongWord):TFileSystem;
var
 Handle:TFileHandle;
begin
 {}
 Result:=nil;
 
 {Get the Handle}
 Handle:=GetFileFromHandle(AHandle,True,FILESYS_LOCK_READ); //To Do //Lock //GetDriveFromFile/GetVolumeFromFile etc ?
 if Handle = nil then Exit;
 try
  if Handle.Drive = nil then
   begin
    if Handle.Volume = nil then Exit;
   
    {Get the FileSystem}
    Result:=Handle.Volume.FileSystem;
    //To Do //Lock
    
   end
  else
   begin
    {Get the FileSystem}
    Result:=Handle.Drive.FileSystem;
    //To Do //Lock
    
   end;
 finally
  {Unlock Handle}
  Handle.ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetFileSystemFromFind(AHandle:Integer;ALock:Boolean;AState:LongWord):TFileSystem;
var
 Handle:TFindHandle;
begin
 {}
 Result:=nil;
 
 {Get the Handle}
 Handle:=GetFindFromHandle(AHandle,True,FILESYS_LOCK_READ);//To Do //Lock //GetDriveFromFind/GetVolumeFromFind etc ?
 if Handle = nil then Exit;
 try 
  if Handle.Drive = nil then
   begin
    if Handle.Volume = nil then Exit;
   
    {Get the FileSystem}
    Result:=Handle.Volume.FileSystem;
    //To Do //Lock
    
   end
  else
   begin
    {Get the FileSystem}
    Result:=Handle.Drive.FileSystem;
    //To Do //Lock
    
   end;
 finally
  {Unlock Handle}
  Handle.ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSysDriver.GetRawFromHandle(AHandle:Integer;ALock:Boolean;AState:LongWord):TRawHandle;
var
 Handle:TRawHandle;
begin
 {}
 Result:=nil;
 
 if not FRawHandles.ReaderLock then Exit;
 try
  if AHandle = -1 then Exit;
 
  {Find Matching Handle}
  Handle:=TRawHandle(FRawHandles.Last); {Search Backwards} 
  while Handle <> nil do
   begin
    if Handle.Handle = AHandle then
     begin
      {Lock Handle} 
      if ALock then if AState = FILESYS_LOCK_READ then Handle.ReaderLock else Handle.WriterLock;
      
      Result:=Handle;
      Exit;
     end;
    
    Handle:=TRawHandle(Handle.Prev);
   end;
 finally
  FRawHandles.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetEnumFromHandle(AHandle:Integer;ALock:Boolean;AState:LongWord):TEnumHandle;
var
 Handle:TEnumHandle;
begin
 {}
 Result:=nil;
 
 if not FEnumHandles.ReaderLock then Exit;
 try
  if AHandle = -1 then Exit;
 
  {Find Matching Handle}
  Handle:=TEnumHandle(FEnumHandles.Last); {Search Backwards} 
  while Handle <> nil do
   begin
    if Handle.Handle = AHandle then
     begin
      {Lock Handle} 
      if ALock then if AState = FILESYS_LOCK_READ then Handle.ReaderLock else Handle.WriterLock;
      
      Result:=Handle;
      Exit;
     end;
    
    Handle:=TEnumHandle(Handle.Prev);
   end;
 finally
  FEnumHandles.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetFileFromHandle(AHandle:Integer;ALock:Boolean;AState:LongWord):TFileHandle;
var
 Handle:TFileHandle;
begin
 {}
 Result:=nil;
 
 if not FFileHandles.ReaderLock then Exit;
 try
  if AHandle = -1 then Exit;
 
  {Find Matching Handle}
  Handle:=TFileHandle(FFileHandles.Last); {Search Backwards}
  while Handle <> nil do
   begin
    if Handle.Handle = AHandle then
     begin
      {Lock Handle} 
      if ALock then if AState = FILESYS_LOCK_READ then Handle.ReaderLock else Handle.WriterLock;
      
      Result:=Handle;
      Exit;
     end;
    
    Handle:=TFileHandle(Handle.Prev); 
   end;
 finally
  FFileHandles.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSysDriver.GetFindFromHandle(AHandle:Integer;ALock:Boolean;AState:LongWord):TFindHandle;
var
 Handle:TFindHandle;
begin
 {}
 Result:=nil;
 
 if not FFindHandles.ReaderLock then Exit;
 try
  if AHandle = -1 then Exit;
 
  {Find Matching Handle}
  Handle:=TFindHandle(FFindHandles.Last); {Search Backwards}
  while Handle <> nil do
   begin
    if Handle.Handle = AHandle then
     begin
      {Lock Handle} 
      if ALock then if AState = FILESYS_LOCK_READ then Handle.ReaderLock else Handle.WriterLock;
      
      Result:=Handle;
      Exit;
     end;
    
    Handle:=TFindHandle(Handle.Prev);
   end;
 finally
  FFindHandles.ReaderUnlock;
 end;   
end;

{==============================================================================}
{==============================================================================}
{TFileSysList}
constructor TFileSysList.Create;
begin
 {}
 inherited Create;
 FLock:=SynchronizerCreate;
end;

{==============================================================================}

destructor TFileSysList.Destroy;
begin
 {}
 WriterLock;
 try
  ClearList;
  inherited Destroy;
 finally
  {WriterUnlock;} {Can destroy Synchronizer while holding lock}
  SynchronizerDestroy(FLock);
 end;
end;

{==============================================================================}

procedure TFileSysList.ClearList;
var
 Next:TListObject;
 Current:TListObject;
begin
 {}
 WriterLock;
 try
  {Get Object}
  Next:=First;
  while Next <> nil do
   begin
    {Get Next}
    Current:=Next;
    Next:=Current.Next;
    
    {Free Object}
    Current.Free;
   end;
  
  {Reset Defaults}
  Clear;
 finally
  WriterUnlock;
 end;
end;

{==============================================================================}

function TFileSysList.ReaderLock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TFileSysList.ReaderUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TFileSysList.ReaderConvert:Boolean; 
{Convert a Reader lock to a Writer lock}
begin
 {}
 Result:=(SynchronizerReaderConvert(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TFileSysList.WriterLock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TFileSysList.WriterUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TFileSysList.WriterConvert:Boolean;
{Convert a Writer lock to a Reader lock}
begin
 {}
 Result:=(SynchronizerWriterConvert(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}
{==============================================================================}
{TFileSysListEx}
constructor TFileSysListEx.Create(ALock:TSynchronizerHandle);
begin
 {}
 inherited Create;
 FLock:=ALock;
end;

{==============================================================================}

destructor TFileSysListEx.Destroy;
begin
 {}
 WriterLock;
 try
  ClearList;
  inherited Destroy;
 finally
  WriterUnlock;
  FLock:=INVALID_HANDLE_VALUE;
 end;
end;

{==============================================================================}

procedure TFileSysListEx.ClearList;
var
 Next:TListObject;
 Current:TListObject;
begin
 {}
 WriterLock;
 try
  {Get Object}
  Next:=First;
  while Next <> nil do
   begin
    {Get Next}
    Current:=Next;
    Next:=Current.Next;
    
    {Free Object}
    Current.Free;
   end;
  
  {Reset Defaults}
  Clear;
 finally
  WriterUnlock;
 end;
end;

{==============================================================================}

function TFileSysListEx.ReaderLock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TFileSysListEx.ReaderUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TFileSysListEx.ReaderConvert:Boolean; 
{Convert a Reader lock to a Writer lock}
begin
 {}
 Result:=(SynchronizerReaderConvert(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TFileSysListEx.WriterLock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TFileSysListEx.WriterUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TFileSysListEx.WriterConvert:Boolean;
{Convert a Writer lock to a Reader lock}
begin
 {}
 Result:=(SynchronizerWriterConvert(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}
{==============================================================================}
{TFileSysTree}
constructor TFileSysTree.Create;
begin
 {}
 inherited Create;
 FLock:=SynchronizerCreate;
end;

{==============================================================================}

destructor TFileSysTree.Destroy;
begin
 {}
 WriterLock;
 try
  ClearList;
  inherited Destroy;
 finally
  {WriterUnlock;} {Can destroy Synchronizer while holding lock}
  SynchronizerDestroy(FLock);
 end;
end;

{==============================================================================}

procedure TFileSysTree.ClearList;
var
 Next:TTreeObject;
 Current:TTreeObject;
begin
 {}
 WriterLock;
 try
  {Get Object}
  Next:=First;
  while Next <> nil do
   begin
    {Get Next}
    Current:=Next;
    Next:=TTreeObject(Current.Next);
    
    {Clear Children}
    ClearListItems(Current);
    
    {Free Object}
    Current.Free;
   end;
   
  {Reset Defaults}
  Clear;
 finally
  WriterUnlock;
 end;
end;

{==============================================================================}

function TFileSysTree.ReaderLock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TFileSysTree.ReaderUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TFileSysTree.ReaderConvert:Boolean; 
{Convert a Reader lock to a Writer lock}
begin
 {}
 Result:=(SynchronizerReaderConvert(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TFileSysTree.WriterLock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TFileSysTree.WriterUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TFileSysTree.WriterConvert:Boolean;
{Convert a Writer lock to a Reader lock}
begin
 {}
 Result:=(SynchronizerWriterConvert(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}
{==============================================================================}
{TDiskDrive}
constructor TDiskDrive.Create(ADriver:TFileSysDriver;AVolume:TDiskVolume;ADriveNo:Integer);
begin
 {}
 inherited Create;
 FLock:=SynchronizerCreate;
 FLocalLock:=MutexCreate;

 FDriver:=ADriver;
 if FDriver <> nil then FDriver.AddDrive(Self);
 FVolume:=AVolume;
 
 FDriveNo:=ADriveNo;

 FDriveType:=dtUNKNOWN;

 FFileSystem:=nil;

 FRemovable:=False;
 FRecognizable:=True;
 FRecognized:=False;

 FSectorSize:=0;
 FStartSector:=0;
 FSectorCount:=0;
 FSectorShiftCount:=0;
end;

{==============================================================================}

destructor TDiskDrive.Destroy;
begin
 {}
 WriterLock;
 try
  FDriveNo:=0;
  FVolume:=nil;

  FDriveType:=dtUNKNOWN;

  FFileSystem:=nil;
  if FDriver <> nil then FDriver.RemoveDrive(Self);
  FDriver:=nil;
  
  MutexDestroy(FLocalLock);
  inherited Destroy;
 finally 
  {WriterUnlock;} {Can destroy Synchronizer while holding lock}
  SynchronizerDestroy(FLock);
 end;
end;

{==============================================================================}

function TDiskDrive.AcquireLock:Boolean;
begin
 {}
 Result:=(MutexLock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskDrive.ReleaseLock:Boolean;
begin
 {}
 Result:=(MutexUnlock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskDrive.GetName:String;
begin
 {}
 Result:='';

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if FDriveNo < MIN_DRIVE then Exit;
  if FDriveNo > NON_DRIVE then Exit;
  
  Result:=DRIVE_NAMES[FDriveNo];
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskDrive.GetRoot:String;
begin
 {}
 Result:='';

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if FDriveNo < MIN_DRIVE then Exit;
  if FDriveNo > NON_DRIVE then Exit;
  
  Result:=DRIVE_ROOTS[FDriveNo];
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskDrive.GetParent:String;
begin
 {}
 Result:='';

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if FVolume = nil then Exit;
  if FDriveNo < MIN_DRIVE then Exit;
  if FDriveNo > MAX_DRIVE then Exit;
  
  Result:=FVolume.Parent;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskDrive.GetMaxFile:Integer;
{Get MaxFile from FileSystem if Mounted}
begin
 {}
 Result:=0;

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if FFileSystem = nil then Exit;

  Result:=FFileSystem.MaxFile;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskDrive.GetMaxPath:Integer;
{Get MaxPath from FileSystem if Mounted}
begin
 {}
 Result:=0;

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if FFileSystem = nil then Exit;
  
  Result:=FFileSystem.MaxPath;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskDrive.GetAttributes:LongWord;
{Get Attributes from FileSystem if Mounted}
begin
 {}
 Result:=vaNone;

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if FFileSystem = nil then Exit;
  
  Result:=FFileSystem.Attributes;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskDrive.GetSystemName:String;
{Get SystemName from FileSystem if Mounted}
begin
 {}
 Result:='';

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if FFileSystem = nil then Exit;
  
  Result:=FFileSystem.SystemName;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskDrive.GetVolumeName:String;
{Get VolumeName from FileSystem if Mounted}
begin
 {}
 Result:='';

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if FFileSystem = nil then Exit;
  
  Result:=FFileSystem.VolumeName;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskDrive.GetVolumeGUID:String;
{Get VolumeGUID from FileSystem if Mounted}
begin
 {}
 Result:='';

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if FFileSystem = nil then Exit;
  
  Result:=FFileSystem.VolumeGUID;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskDrive.GetVolumeSerial:LongWord;
{Get VolumeSerial from FileSystem if Mounted}
begin
 {}
 Result:=0;

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if FFileSystem = nil then Exit;
  
  Result:=FFileSystem.VolumeSerial;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskDrive.GetDriveType:TDriveType;
{Get DriveType from Volume or Drive}
begin
 {}
 Result:=dtUNKNOWN;

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  
  if FVolume <> nil then
    begin
    Result:=FVolume.DriveType;
   end
  else
   begin
    Result:=FDriveType;
   end;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskDrive.GetFileSysType:TFileSysType;
{Get FileSysType from FileSystem if Mounted}
begin
 {}
 Result:=fsUNKNOWN;

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if FFileSystem = nil then Exit;
  
  Result:=FFileSystem.FileSysType;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

procedure TDiskDrive.SetFileSystem(AFileSystem:TFileSystem);
{Set the FileSystem and Reinitialize the Drive}
begin
 {}
 if not WriterLock then Exit;
 try
  if not AcquireLock then Exit;
  try
   if FDriver = nil then Exit;
   if FFileSystem = AFileSystem then Exit;
  
   FFileSystem:=AFileSystem;
  finally  
   ReleaseLock;
  end; 

  DriveInit;
 finally  
  WriterUnlock;
 end; 
end;

{==============================================================================}

function TDiskDrive.GetRemovable:Boolean;
{Get the Removable flag from Volume or Drive}
begin
 {}
 Result:=False;

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  
  if FVolume <> nil then
   begin
    Result:=FVolume.Removable;
   end
  else
   begin
    Result:=FRemovable;
   end;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskDrive.GetRecognizable:Boolean;
{Get the Recognizable flag from Volume or Drive}
begin
 {}
 Result:=False;

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  
  if FVolume <> nil then
   begin
    Result:=FVolume.Recognizable;
   end
  else
   begin
    Result:=FRecognizable;
   end;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskDrive.GetRecognized:Boolean;
{Get the Recognized flag from Volume or Drive}
begin
 {}
 Result:=False;

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  
  if FVolume <> nil then
   begin
    Result:=FVolume.Recognized;
   end
  else
   begin
    Result:=FRecognized;
   end;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskDrive.GetSectorSize:Word;
{Get SectorSize from FileSystem (Mounted) or Volume/Drive (Not Mounted)}
begin
 {}
 Result:=0;

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  
  if FFileSystem <> nil then
   begin
    Result:=FFileSystem.SectorSize;
   end
  else
   begin
    if FVolume <> nil then
     begin
      Result:=FVolume.SectorSize;
     end
    else
     begin
      Result:=FSectorSize;
     end;     
   end;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskDrive.GetStartSector:Int64;
{Get StartSector from FileSystem (Mounted) or Volume/Drive (Not Mounted)}
begin
 {}
 Result:=0;

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;

  if FFileSystem <> nil then
   begin
    Result:=FFileSystem.StartSector;
   end
  else
   begin
    if FVolume <> nil then
     begin
      Result:=FVolume.StartSector;
     end
    else
     begin
      Result:=FStartSector;
     end;
   end;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskDrive.GetSectorCount:LongWord;
{Get SectorCount from FileSystem (Mounted) or Volume/Drive (Not Mounted)}
begin
 {}
 Result:=0;

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  
  if FFileSystem <> nil then
   begin
    Result:=FFileSystem.SectorCount;
   end
  else
   begin
    if FVolume <> nil then
     begin
      Result:=FVolume.SectorCount;
     end
    else
     begin
      Result:=FSectorCount;
     end;     
   end;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskDrive.GetSectorShiftCount:Word;
begin
 {}
 Result:=FSectorShiftCount;
end;

{==============================================================================}

function TDiskDrive.GetDevice:TDiskDevice;
begin
 {}
 Result:=nil;

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if FVolume = nil then Exit;
  
  Result:=FVolume.Device;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskDrive.GetPartition:TDiskPartition;
begin
 {}
 Result:=nil;

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if FVolume = nil then Exit;
  
  Result:=FVolume.Partition;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskDrive.ReaderLock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskDrive.ReaderUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskDrive.WriterLock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskDrive.WriterUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskDrive.DriveInit:Boolean;
begin
 {}
 Result:=False;

 if not WriterLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskDrive.DriveInit');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('            Name = ' + Name);
  if FILESYS_LOG_ENABLED then FileSysLogDebug('            DriveNo = ' + IntToStr(DriveNo));
  {$ENDIF}
 
  if FDriver = nil then Exit;
  if FVolume = nil then Exit;
  if FDriveNo < MIN_DRIVE then Exit;
  if FDriveNo > MAX_DRIVE then Exit;

  FDriveType:=dtUNKNOWN;
  
  Result:=True;
 finally  
  WriterUnlock;
 end; 
end;

{==============================================================================}
{==============================================================================}
{TRawHandle}
constructor TRawHandle.Create;
begin
 {}
 inherited Create;
 FLock:=SynchronizerCreate;
 
 Device:=nil;
 Partition:=nil;
 Volume:=nil;
 Drive:=nil;

 OpenMode:=fmOpenRead;
 ShareMode:=fmShareCompat;

 Size:=0;
 Position:=0;
 Handle:=Integer(Self);
end;

{==============================================================================}

destructor TRawHandle.Destroy;
begin
 {}
 WriterLock;
 try
  inherited Destroy;
 finally
  {WriterUnlock;} {Can destroy Synchronizer while holding lock}
  SynchronizerDestroy(FLock);
 end;
end;

{==============================================================================}

function TRawHandle.ReaderLock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TRawHandle.ReaderUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TRawHandle.ReaderConvert:Boolean; 
{Convert a Reader lock to a Writer lock}
begin
 {}
 Result:=(SynchronizerReaderConvert(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TRawHandle.WriterLock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TRawHandle.WriterUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TRawHandle.WriterConvert:Boolean;
{Convert a Writer lock to a Reader lock}
begin
 {}
 Result:=(SynchronizerWriterConvert(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}
{==============================================================================}
{TEnumHandle}
constructor TEnumHandle.Create;
begin
 {}
 inherited Create;
 FLock:=SynchronizerCreate;
 
 FileSystem:=nil;

 Handle:=Integer(Self);

 CurrentDevice:=nil;
 CurrentPartition:=nil;
 CurrentDrive:=nil;
 CurrentVolume:=nil;
 CurrentImage:=nil;
 CurrentCatalog:=nil;
end;

{==============================================================================}

destructor TEnumHandle.Destroy;
begin
 {}
 WriterLock;
 try
  inherited Destroy;
 finally
  {WriterUnlock;} {Can destroy Synchronizer while holding lock}
  SynchronizerDestroy(FLock);
 end;
end;

{==============================================================================}

function TEnumHandle.ReaderLock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TEnumHandle.ReaderUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TEnumHandle.ReaderConvert:Boolean; 
{Convert a Reader lock to a Writer lock}
begin
 {}
 Result:=(SynchronizerReaderConvert(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TEnumHandle.WriterLock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TEnumHandle.WriterUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TEnumHandle.WriterConvert:Boolean;
{Convert a Writer lock to a Reader lock}
begin
 {}
 Result:=(SynchronizerWriterConvert(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}
{==============================================================================}
{TFileHandle}
constructor TFileHandle.Create;
begin
 {}
 inherited Create;
 FLock:=SynchronizerCreate;
 
 Volume:=nil;
 Drive:=nil;

 OpenMode:=fmOpenRead;
 ShareMode:=fmShareCompat;

 Position:=0;
 Handle:=Integer(Self);

 DataValue:=0;
 DataOffset:=0;

 ParentEntry:=nil;
 HandleEntry:=nil;
end;

{==============================================================================}

destructor TFileHandle.Destroy;
begin
 {}
 WriterLock;
 try
  inherited Destroy;
 finally
  {WriterUnlock;} {Can destroy Synchronizer while holding lock}
  SynchronizerDestroy(FLock);
 end;
end;

{==============================================================================}

function TFileHandle.ReaderLock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TFileHandle.ReaderUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TFileHandle.ReaderConvert:Boolean; 
{Convert a Reader lock to a Writer lock}
begin
 {}
 Result:=(SynchronizerReaderConvert(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TFileHandle.WriterLock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TFileHandle.WriterUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TFileHandle.WriterConvert:Boolean;
{Convert a Writer lock to a Reader lock}
begin
 {}
 Result:=(SynchronizerWriterConvert(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}
{==============================================================================}
{TFindHandle}
constructor TFindHandle.Create;
begin
 {}
 inherited Create;
 FLock:=SynchronizerCreate;
 
 Volume:=nil;
 Drive:=nil;

 Any:=False;
 Mask:='';
 Attr:=faNone;
 Flags:=FIND_FLAG_NONE;
 Handle:=Integer(Self);

 ParentEntry:=nil;
 CurrentEntry:=nil;
end;

{==============================================================================}

destructor TFindHandle.Destroy;
begin
 {}
 WriterLock;
 try
  inherited Destroy;
 finally
  {WriterUnlock;} {Can destroy Synchronizer while holding lock}
  SynchronizerDestroy(FLock);
 end;
end;

{==============================================================================}

function TFindHandle.ReaderLock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TFindHandle.ReaderUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TFindHandle.ReaderConvert:Boolean; 
{Convert a Reader lock to a Writer lock}
begin
 {}
 Result:=(SynchronizerReaderConvert(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TFindHandle.WriterLock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TFindHandle.WriterUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TFindHandle.WriterConvert:Boolean;
{Convert a Writer lock to a Reader lock}
begin
 {}
 Result:=(SynchronizerWriterConvert(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}
{==============================================================================}
{TDiskController}
constructor TDiskController.Create(ADriver:TFileSysDriver);
begin
 {}
 inherited Create;
 FLock:=SynchronizerCreate;
 FLocalLock:=MutexCreate;
 
 FDriver:=ADriver;
 if FDriver <> nil then FDriver.AddController(Self);
 
 FControllerNo:=-1;
 if FDriver <> nil then FControllerNo:=FDriver.GetNextControllerNo;
 FDescription:='';
end;

{==============================================================================}

destructor TDiskController.Destroy;
begin
 {}
 WriterLock;
 try
  FDescription:='';
  FControllerNo:=-1;
  
  if FDriver <> nil then FDriver.RemoveController(Self);
  FDriver:=nil;
  
  MutexDestroy(FLocalLock);
  inherited Destroy;
 finally 
  {WriterUnlock;} {Can destroy Synchronizer while holding lock}
  SynchronizerDestroy(FLock);
 end;
end;

{==============================================================================}

function TDiskController.AcquireLock:Boolean;
begin
 {}
 Result:=(MutexLock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskController.ReleaseLock:Boolean;
begin
 {}
 Result:=(MutexUnlock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskController.GetName:String;
begin
 {}
 Result:='';

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if FControllerNo = -1 then Exit;
  
  Result:=CONTROLLER_PREFIX + IntToStr(FControllerNo);
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskController.GetDescription:String;
begin
 {}
 Result:='';

 if not AcquireLock then Exit;

 Result:=FDescription;
 UniqueString(Result);

 ReleaseLock;
end;
 
{==============================================================================}

function TDiskController.GetFixedDiskCount:Integer;
begin
 {Virtual Base Method - No Function}
 Result:=0;
end;

{==============================================================================}

function TDiskController.GetFloppyDiskCount:Integer;
begin
 {Virtual Base Method - No Function}
 Result:=0;
end;

{==============================================================================}

function TDiskController.LCHStoLBA(ADevice:TDiskDevice;Cylinder,Head,Sector:Word;var LBA:LongWord):Boolean;
begin
 {}
 Result:=False;
 
 if ADevice = nil then Exit;
 
 {No need to cast to LongWord for result}
 LBA:=((Cylinder * ADevice.LogicalHeads + Head) * ADevice.LogicalSectors) + Sector - 1;
 
 Result:=True;
end;

{==============================================================================}

function TDiskController.PCHStoLBA(ADevice:TDiskDevice;Cylinder,Head,Sector:LongWord;var LBA:LongWord):Boolean;
begin
 {}
 Result:=False;
 
 if ADevice = nil then Exit;
 
 {No need to cast to LongWord for result}
 LBA:=((Cylinder * ADevice.PhysicalHeads + Head) * ADevice.PhysicalSectors) + Sector - 1;
 
 Result:=True;
end;

{==============================================================================}

function TDiskController.LBAtoLCHS(ADevice:TDiskDevice;LBA:LongWord;var Cylinder,Head,Sector:Word):Boolean;
var
 WorkLong:LongWord;
begin
 {}
 Result:=False;
 
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskController.LBAtoLCHS');
 if FILESYS_LOG_ENABLED then FileSysLogDebug('                 LBA = ' + IntToStr(LBA));
 {$ENDIF}
 
 if ADevice = nil then Exit;
 
 Cylinder:=LBA div (ADevice.LogicalHeads * ADevice.LogicalSectors);
 WorkLong:=LBA mod (ADevice.LogicalHeads * ADevice.LogicalSectors);
 Head:=WorkLong div ADevice.LogicalSectors;
 Sector:=WorkLong mod ADevice.LogicalSectors + 1;

 Result:=True;
end;

{==============================================================================}

function TDiskController.LBAtoPCHS(ADevice:TDiskDevice;LBA:LongWord;var Cylinder,Head,Sector:LongWord):Boolean;
var
 WorkLong:LongWord;
begin
 {}
 Result:=False;
 
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskController.LBAtoPCHS');
 if FILESYS_LOG_ENABLED then FileSysLogDebug('                 LBA = ' + IntToStr(LBA));
 {$ENDIF}
 
 if ADevice = nil then Exit;
 
 Cylinder:=LBA div (ADevice.PhysicalHeads * ADevice.PhysicalSectors);
 WorkLong:=LBA mod (ADevice.PhysicalHeads * ADevice.PhysicalSectors);
 Head:=WorkLong div ADevice.PhysicalSectors;
 Sector:=WorkLong mod ADevice.PhysicalSectors + 1;
 
 Result:=True;
end;

{==============================================================================}

function TDiskController.LCHStoPCHS(ADevice:TDiskDevice;LCylinder,LHead,LSector:Word;var PCylinder,PHead,PSector:LongWord):Boolean;
begin
 {}
 Result:=False;
 
 if ADevice = nil then Exit;
 
 //To Do //???
 //See HowItWorks CHS for algorithms
 
 Result:=True;
end;

{==============================================================================}

function TDiskController.PCHStoLCHS(ADevice:TDiskDevice;PCylinder,PHead,PSector:LongWord;var LCylinder,LHead,LSector:Word):Boolean;
begin
 {}
 Result:=False;
 
 if ADevice = nil then Exit;
 
 //To Do //???
 //See HowItWorks CHS for algorithms
 //Basically this:

  //Lcylinder = L-CHS cylinder being accessed
  //Lhead = L-CHS head being accessed
  //Lsector = L-CHS sector being accessed

  //Pcylinder = the P-CHS cylinder being accessed
  //Phead = the P-CHS head being accessed
  //Psector = P-CHS sector being accessed

  //NPH = is the number of heads in the P-CHS
  //N = 2, 4, 8, ..., the bit shift value

  //Pcylinder = ( Lcylinder * N ) + ( Lhead / NPH );
  //Phead = ( Lhead % NPH );
  //Psector = Lsector;

  //LCHStoPCHS is obviously done with the values reversed and the NPH is Logical (NLH) not Physical

 Result:=True;
end;

{==============================================================================}

function TDiskController.ReaderLock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskController.ReaderUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskController.ReaderConvert:Boolean; 
{Convert a Reader lock to a Writer lock}
begin
 {}
 Result:=(SynchronizerReaderConvert(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskController.WriterLock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskController.WriterUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskController.WriterConvert:Boolean;
{Convert a Writer lock to a Reader lock}
begin
 {}
 Result:=(SynchronizerWriterConvert(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskController.ControllerInit:Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=True; {Default to True}
end;

{==============================================================================}

function TDiskController.LocateDevices:Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=True; {Default to True}
end;

{==============================================================================}

function TDiskController.Read(ADevice:TDiskDevice;ASector:LongWord;ACount:Word;var ABuffer):Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskController.Write(ADevice:TDiskDevice;ASector:LongWord;ACount:Word;const ABuffer):Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskController.Erase(ADevice:TDiskDevice;ASector:LongWord;ACount:Word):Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskController.Reset(ADevice:TDiskDevice):Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskController.LockMedia(ADevice:TDiskDevice):Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskController.UnlockMedia(ADevice:TDiskDevice):Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskController.EjectMedia(ADevice:TDiskDevice):Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskController.MediaReady(ADevice:TDiskDevice):Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskController.MediaChanged(ADevice:TDiskDevice):Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskController.MediaLocked(ADevice:TDiskDevice):Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskController.Information(ADevice:TDiskDevice):String;
begin
 {Virtual Base Method - No Function}
 Result:='';
end;

{==============================================================================}

function TDiskController.VendorId(ADevice:TDiskDevice):Word; 
begin
 {Virtual Base Method - No Function}
 Result:=0;
end;

{==============================================================================}

function TDiskController.DeviceId(ADevice:TDiskDevice):Word; 
begin
 {Virtual Base Method - No Function}
 Result:=0;
end;

{==============================================================================}

function TDiskController.Manufacturer(ADevice:TDiskDevice):String; 
begin
 {Virtual Base Method - No Function}
 Result:='';
end;

{==============================================================================}

function TDiskController.Product(ADevice:TDiskDevice):String; 
begin
 {Virtual Base Method - No Function}
 Result:='';
end;

{==============================================================================}

function TDiskController.SerialNumber(ADevice:TDiskDevice):String; 
begin
 {Virtual Base Method - No Function}
 Result:='';
end;

{==============================================================================}

function TDiskController.HostBus(ADevice:TDiskDevice):String;
begin
 {Virtual Base Method - No Function}
 Result:='';
end;

{==============================================================================}

function TDiskController.BusNumber(ADevice:TDiskDevice):Word;
begin
 {Virtual Base Method - No Function}
 Result:=0;
end;

{==============================================================================}

function TDiskController.DeviceNumber(ADevice:TDiskDevice):Word;
begin
 {Virtual Base Method - No Function}
 Result:=0;
end;

{==============================================================================}

function TDiskController.FunctionNumber(ADevice:TDiskDevice):Word;
begin
 {Virtual Base Method - No Function}
 Result:=0;
end;

{==============================================================================}

function TDiskController.BaseAddress(ADevice:TDiskDevice):Word;
begin
 {Virtual Base Method - No Function}
 Result:=0;
end;

{==============================================================================}

function TDiskController.InterfaceType(ADevice:TDiskDevice):String;
begin
 {Virtual Base Method - No Function}
 Result:='';
end;

{==============================================================================}

function TDiskController.Slave(ADevice:TDiskDevice):Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskController.LogicalUnitNo(ADevice:TDiskDevice):LongWord;
begin
 {Virtual Base Method - No Function}
 Result:=0;
end;

{==============================================================================}

function TDiskController.FireWireGUID(ADevice:TDiskDevice):Int64;
begin
 {Virtual Base Method - No Function}
 Result:=0;
end;

{==============================================================================}

function TDiskController.WorldWideNo(ADevice:TDiskDevice):Int64;
begin
 {Virtual Base Method - No Function}
 Result:=0;
end;

{==============================================================================}

function TDiskController.PhysicalPort(ADevice:TDiskDevice):Word;
begin
 {Virtual Base Method - No Function}
 Result:=0;
end;

{==============================================================================}

function TDiskController.ControlPort(ADevice:TDiskDevice):Word;
begin
 {Virtual Base Method - No Function}
 Result:=0;
end;

{==============================================================================}

function TDiskController.IRQ(ADevice:TDiskDevice):LongWord;
begin
 {Virtual Base Method - No Function}
 Result:=0;
end;

{==============================================================================}

function TDiskController.PIO(ADevice:TDiskDevice):Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskController.DMA(ADevice:TDiskDevice):Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskController.LBA(ADevice:TDiskDevice):Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskController.Version(ADevice:TDiskDevice):LongWord;
begin
 {Virtual Base Method - No Function}
 Result:=0;
end;

{==============================================================================}

function TDiskController.MediaType(ADevice:TDiskDevice):TMediaType;
begin
 {Virtual Base Method - No Function}
 Result:=mtUNKNOWN;
end;

{==============================================================================}

function TDiskController.FloppyType(ADevice:TDiskDevice):TFloppyType;
begin
 {Virtual Base Method - No Function}
 Result:=ftUNKNOWN;
end;

{==============================================================================}

function TDiskController.Ready(ADevice:TDiskDevice):Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskController.Locked(ADevice:TDiskDevice):Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskController.Lockable(ADevice:TDiskDevice):Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskController.Ejectable(ADevice:TDiskDevice):Boolean; 
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskController.Readable(ADevice:TDiskDevice):Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=True; {Default to True}
end;

{==============================================================================}

function TDiskController.Writeable(ADevice:TDiskDevice):Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=True; {Default to True}
end;

{==============================================================================}

function TDiskController.Eraseable(ADevice:TDiskDevice):Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskController.Removable(ADevice:TDiskDevice):Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskController.ChangeLine(ADevice:TDiskDevice):Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskController.PhysicalCylinders(ADevice:TDiskDevice):LongWord;
begin
 {Virtual Base Method - No Function}
 Result:=0;
end;

{==============================================================================}

function TDiskController.PhysicalHeads(ADevice:TDiskDevice):LongWord;
begin
 {Virtual Base Method - No Function}
 Result:=0;
end;

{==============================================================================}

function TDiskController.PhysicalSectors(ADevice:TDiskDevice):LongWord;
begin
 {Virtual Base Method - No Function}
 Result:=0;
end;

{==============================================================================}

function TDiskController.LogicalCylinders(ADevice:TDiskDevice):LongWord;
begin
 {Virtual Base Method - No Function}
 Result:=0;
end;

{==============================================================================}

function TDiskController.LogicalHeads(ADevice:TDiskDevice):LongWord;
begin
 {Virtual Base Method - No Function}
 Result:=0;
end;

{==============================================================================}

function TDiskController.LogicalSectors(ADevice:TDiskDevice):LongWord;
begin
 {Virtual Base Method - No Function}
 Result:=0;
end;

{==============================================================================}

function TDiskController.SectorSize(ADevice:TDiskDevice):Word;
begin
 {Virtual Base Method - No Function}
 Result:=0;
end;

{==============================================================================}

function TDiskController.SectorCount(ADevice:TDiskDevice):Int64;
begin
 {Virtual Base Method - No Function}
 Result:=0;
end;

{==============================================================================}

function TDiskController.SectorShiftCount(ADevice:TDiskDevice):Word;
{Note: Caller must hold the device lock}
begin
 {Base Implementation}
 Result:=0;
 
 if ADevice = nil then Exit;
 if ADevice.SectorSize = 0 then Exit;
 
 while (ADevice.SectorSize shr Result) > 1 do
  begin
   Inc(Result);
  end;
end;

{==============================================================================}
{==============================================================================}
{TDiskDevice}
constructor TDiskDevice.Create(ADriver:TFileSysDriver;AController:TDiskController;AImage:TDiskImage;AStorage:PStorageDevice;ADeviceNo:Integer;const AIdentifier:String);
begin
 {}
 inherited Create;
 FLock:=SynchronizerCreate;
 FLocalLock:=MutexCreate;

 FDriver:=ADriver;
 if FDriver <> nil then FDriver.AddDevice(Self);
 FController:=AController;
 FImage:=AImage;
 {if FImage <> nil then FImage.Device:=Self;} {Done by DeviceInit}
 FStorage:=AStorage;
 
 FDeviceNo:=ADeviceNo;
 FIdentifier:=AIdentifier;
end;

{==============================================================================}

destructor TDiskDevice.Destroy;
begin
 {}
 WriterLock;
 try
  FDeviceNo:=-1;
  
  if FImage <> nil then FImage.Device:=nil;
  FStorage:=nil;
  FImage:=nil;
  FController:=nil;
  if FDriver <> nil then FDriver.RemoveDevice(Self);
  FDriver:=nil;
  
  MutexDestroy(FLocalLock);
  inherited Destroy;
 finally 
  {WriterUnlock;} {Can destroy Synchronizer while holding lock}
  SynchronizerDestroy(FLock);
 end;
end;

{==============================================================================}

function TDiskDevice.AcquireLock:Boolean;
begin
 {}
 Result:=(MutexLock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskDevice.ReleaseLock:Boolean;
begin
 {}
 Result:=(MutexUnlock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskDevice.GetName:String;
begin
 {}
 Result:='';

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if FDeviceNo = -1 then Exit;
  
  if FDeviceNo < MIN_FIXED_DEVICE then
   begin
    {Floppy Device}
    Result:=FLOPPY_DEVICE_PREFIX + IntToStr(FDeviceNo);
   end
  else
   begin
    {Fixed, Removable, CD, DVD Device}
    case FMediaType of
     mtFIXED,mtREMOVABLE:begin
       Result:=FIXED_DEVICE_PREFIX + IntToStr(FDeviceNo - MIN_FIXED_DEVICE);
      end;
     mtCDROM,mtDVD:begin
       Result:=CDROM_DEVICE_PREFIX + IntToStr(FDeviceNo - MIN_CDROM_DEVICE);
      end;
     mtOTHER:begin
       Result:=OTHER_DEVICE_PREFIX + IntToStr(FDeviceNo - MIN_OTHER_DEVICE);
      end;
    end;
   end;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskDevice.GetIdentifier:String;
begin
 {}
 Result:='';

 if not AcquireLock then Exit;

 Result:=FIdentifier;
 UniqueString(Result);

 ReleaseLock;
end;

{==============================================================================}

function TDiskDevice.GetInformation:String;
begin
 {}
 Result:='';

 if not AcquireLock then Exit;

 Result:=FInformation;
 UniqueString(Result);

 ReleaseLock;
end;

{==============================================================================}

function TDiskDevice.GetManufacturer:String;
begin
 {}
 Result:='';

 if not AcquireLock then Exit;

 Result:=FManufacturer;
 UniqueString(Result);

 ReleaseLock;
end;

{==============================================================================}

function TDiskDevice.GetProduct:String;
begin
 {}
 Result:='';

 if not AcquireLock then Exit;

 Result:=FProduct;
 UniqueString(Result);

 ReleaseLock;
end;

{==============================================================================}

function TDiskDevice.GetSerialNumber:String;
begin
 {}
 Result:='';

 if not AcquireLock then Exit;

 Result:=FSerialNumber;
 UniqueString(Result);

 ReleaseLock;
end;

{==============================================================================}

function TDiskDevice.GetHostBus:String;
begin
 {}
 Result:='';

 if not AcquireLock then Exit;

 Result:=FHostBus;
 UniqueString(Result);

 ReleaseLock;
end;

{==============================================================================}

function TDiskDevice.GetInterfaceType:String;
begin
 {}
 Result:='';

 if not AcquireLock then Exit;

 Result:=FInterfaceType;
 UniqueString(Result);

 ReleaseLock;
end;

{==============================================================================}

function TDiskDevice.GetFreeSectors:Int64;
{Get the total Count of Unused Sectors on the Device}
var
 Volume:TDiskVolume;
 Partition:TDiskPartition;
begin
 {}
 Result:=0;

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if FController = nil then Exit;
  if FDeviceNo = -1 then Exit;
  if FSectorCount = 0 then Exit;
  
  {If not a "Fixed Disk" or "Removable Disk" then nothing Free}
  if (FMediaType <> mtFIXED) and (FMediaType <> mtREMOVABLE) then Exit;
  
  {Check Partition}
  if FDriver.GetPartitionByDevice(Self,False,FILESYS_LOCK_NONE) = nil then {Do not lock}
   begin
    {Check Volume}
    Volume:=FDriver.GetVolumeByDevice(Self,True,FILESYS_LOCK_READ);
    if Volume <> nil then
     begin
      try
       {Check File System Type}
       if Volume.FileSysType <> fsUNKNOWN then
        begin
         {Subtract the amount used by the volume}
         Result:=FSectorCount - Volume.SectorCount;
         Exit;
        end;
      finally  
       Volume.ReaderUnlock;
      end; 
     end;
   end;
  
  {Get Sector Count}  
  Result:=(FSectorCount - 1); {Minus one to allow for Master Boot}
   
  {Check each Partition}                              
  Partition:=FDriver.GetPartitionByNext(nil,True,False,FILESYS_LOCK_READ); 
  while Partition <> nil do
   begin
    {Subtract the amount used by each first level Partition}
    if (Partition.Device = Self) and (Partition.Partition = nil) then
     begin
      Result:=Result - Partition.SectorCount;
     end;
       
    Partition:=FDriver.GetPartitionByNext(Partition,True,True,FILESYS_LOCK_READ);
   end;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskDevice.GetAvailableSectors:Int64;
{Get the largest Count of Unused Sectors on the Device}
var
 FreeStart:Int64;
 FreeCount:Int64;
begin
 {}
 Result:=0;
 
 if not GetAvailableBlock(FreeStart,FreeCount) then Exit;
 
 Result:=FreeCount;
end;

{==============================================================================}

function TDiskDevice.GetAvailableBlock(var AStart,ACount:Int64):Boolean;
{Get the Start and Count of largest Unused Sectors on the Device}
var
 EntryCount:Word;
 MinimumCount:LongWord;
 Volume:TDiskVolume;

 Count:Integer;
 Partitions:TList;
 Partition:TDiskPartition;
begin
 {}
 Result:=False;

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if FController = nil then Exit;
  if FDeviceNo = -1 then Exit;
  if FSectorCount = 0 then Exit;

  {If not a "Fixed Disk" or "Removable Disk" then nothing Available}
  if (FMediaType <> mtFIXED) and (FMediaType <> mtREMOVABLE) then Exit;
  
  {Check Partition}
  if FDriver.GetPartitionByDevice(Self,False,FILESYS_LOCK_NONE) = nil then {Do not lock}
   begin
    {Check Volume}
    Volume:=FDriver.GetVolumeByDevice(Self,True,FILESYS_LOCK_READ);
    if Volume <> nil then
     begin
      try
       {Check File System Type}
       if Volume.FileSysType <> fsUNKNOWN then Exit;
      finally  
       Volume.ReaderUnlock;
      end; 
     end;
   end;
  
  {Get the Minimum Block}
  MinimumCount:=(FPhysicalSectors * FPhysicalHeads);
  if (MinimumCount = 0) or (FPhysicalCylinders > 1024) then MinimumCount:=(FLogicalSectors * FLogicalHeads);
  
  {Get Start Block}
  AStart:=1;                {Start at one to allow for Master Boot}
  ACount:=(FSectorCount - 1);  {Minus one to allow for Master Boot}
  EntryCount:=0;
  
  {Get Partitions}
  Partitions:=FDriver.GetPartitionsByDevice(Self,True,FILESYS_LOCK_READ);
  try
   {Sort by Start}
   Partitions.Sort(ComparePartitions);

   {Check each Partition}
   for Count:=0 to Partitions.Count - 1 do
    begin
     if Partitions.Items[Count] <> nil then
      begin
       Partition:=TDiskPartition(Partitions.Items[Count]); {Locked by GetPartitionsByDevice}
       
       {Check for first level}
       if (Partition.Device = Self) and (Partition.Partition = nil) then
        begin
         Inc(EntryCount);
         
         {Check for maximum partitions already}
         if EntryCount > MAX_PARTITION then Exit;

         {Check Partition for overlap with Free}
         if (AStart >= Partition.StartSector) and ((AStart + ACount) <= (Partition.StartSector + Partition.SectorCount)) then
          begin
           {Partition overlaps whole of Free}
           ACount:=0;
           Break;
          end
         else if (AStart < Partition.StartSector) and ((AStart + ACount) > (Partition.StartSector + Partition.SectorCount)) then
          begin
           {Partition overlaps middle of Free}
           if (Partition.StartSector - AStart) >= ((AStart + ACount) - (Partition.StartSector + Partition.SectorCount)) then
            begin
             {Larger block on left side of Partition}
             ACount:=(Partition.StartSector - AStart);
            end
           else
            begin
             {Larger block on right side of Partition}
             ACount:=((AStart + ACount) - (Partition.StartSector + Partition.SectorCount));
             AStart:=(Partition.StartSector + Partition.SectorCount);
            end;
          end
         else if (AStart >= Partition.StartSector) and (AStart < (Partition.StartSector + Partition.SectorCount)) then {No <= due to no SectorCount - 1}
          begin
           {Partition overlaps left side of Free}
           ACount:=((AStart + ACount) - (Partition.StartSector + Partition.SectorCount));
           AStart:=(Partition.StartSector + Partition.SectorCount);
          end
         else if (AStart < Partition.StartSector) and ((AStart + ACount) > Partition.StartSector) then {No >= due to no Count - 1}
          begin
           {Partition overlaps right side of Free}
           ACount:=(Partition.StartSector - AStart);
          end;
        end;
      end;
    end;
    
   if ACount > MinimumCount then Result:=True;
  finally
   {Unlock each Partition}
   for Count:=0 to Partitions.Count - 1 do
    begin
     if Partitions.Items[Count] <> nil then
      begin
       Partition:=TDiskPartition(Partitions.Items[Count]); {Locked by GetPartitionsByDevice}
   
       {Unlock Partition}
       Partition.ReaderUnlock;
      end; 
    end;
   
   {Free Partitions}
   Partitions.Free;
  end;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskDevice.GetDiskSignature:LongWord;
var
 BootRecord:PExtMasterBootRecord;
begin
 {}
 Result:=0;

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if FController = nil then Exit;
  if FDeviceNo = -1 then Exit;
  if FSectorSize = 0 then Exit;
  if FSectorCount = 0 then Exit;

  {If not a "Fixed Disk" or "Removable Disk" then no Signature}
  if (FMediaType <> mtFIXED) and (FMediaType <> mtREMOVABLE) then Exit;
  
  {If not partitioned then no Signature}
  if FDriver.GetPartitionByDevice(Self,False,FILESYS_LOCK_NONE) = nil then Exit; {Do not lock}
  
  {Allocate Boot Record}
  BootRecord:=GetMem(FSectorSize);
  if BootRecord = nil then Exit;
  try
   {Read Boot Record}
   if not FDriver.Cache.DeviceRead(Self,0,1,BootRecord^) then Exit;
   
   {Check Boot Record}
   if BootRecord.Signature <> BOOT_RECORD_SIGNATURE then Exit;
   
   {Get Disk Signature}
   Result:=BootRecord.DiskSignature;
  finally
   FreeMem(BootRecord);
  end;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

procedure TDiskDevice.SetDiskSignature(ADiskSignature:LongWord);
var
 BootRecord:PExtMasterBootRecord;
begin
 {}
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if FController = nil then Exit;
  if FDeviceNo = -1 then Exit;
  if FSectorSize = 0 then Exit;
  if FSectorCount = 0 then Exit;

  {If not a "Fixed Disk" or "Removable Disk" then no Signature}
  if (FMediaType <> mtFIXED) and (FMediaType <> mtREMOVABLE) then Exit;
  
  {If not partitioned then no Signature}
  if FDriver.GetPartitionByDevice(Self,False,FILESYS_LOCK_NONE) = nil then Exit; {Do not lock}
  
  {Allocate Boot Record}
  BootRecord:=GetMem(FSectorSize);
  if BootRecord = nil then Exit;
  try
   {Read Boot Record}
   if not FDriver.Cache.DeviceRead(Self,0,1,BootRecord^) then Exit;
   
   {Check Boot Record}
   if BootRecord.Signature <> BOOT_RECORD_SIGNATURE then Exit;
   
   {Set Disk Signature}
   BootRecord.DiskSignature:=ADiskSignature;
   
   {Write Boot Record}
   if not FDriver.Cache.DeviceWrite(Self,0,1,BootRecord^) then Exit;
  finally
   FreeMem(BootRecord);
  end;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskDevice.ReaderLock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskDevice.ReaderUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskDevice.WriterLock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskDevice.WriterUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskDevice.DeviceInit:Boolean;
begin
 {}
 Result:=False;

 if not WriterLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskDevice.DeviceInit');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('             Name = ' + Name);
  {$ENDIF}

  if FDriver = nil then Exit;
  if FController = nil then Exit;
  if FDeviceNo = -1 then Exit;

  {Bind to Image}
  if FImage <> nil then FImage.Device:=Self;

  {Get Device Information from Controller}
  FLBA:=FController.LBA(Self);
  FVersion:=FController.Version(Self);

  {Note: Must get LBA and Version first}
  FMediaType:=FController.MediaType(Self);
  FFloppyType:=FController.FloppyType(Self);
  FReady:=FController.Ready(Self);
  FLocked:=FController.Locked(Self);
  FLockable:=FController.Lockable(Self);
  FEjectable:=FController.Ejectable(Self);
  FReadable:=FController.Readable(Self);
  FWriteable:=FController.Writeable(Self);
  FEraseable:=FController.Eraseable(Self);
  FRemovable:=FController.Removable(Self);
  FChangeLine:=FController.ChangeLine(Self); 

  FInformation:=FController.Information(Self);
 
  FVendorId:=FController.VendorId(Self);
  FDeviceId:=FController.DeviceId(Self);
 
  FManufacturer:=FController.Manufacturer(Self);
  FProduct:=FController.Product(Self);
  FSerialNumber:=FController.SerialNumber(Self);
  
  FHostBus:=FController.HostBus(Self);
  FBusNumber:=FController.BusNumber(Self);
  FDeviceNumber:=FController.DeviceNumber(Self);
  FFunctionNumber:=FController.FunctionNumber(Self);
  FBaseAddress:=FController.BaseAddress(Self);
  FInterfaceType:=FController.InterfaceType(Self);

  FSlave:=FController.Slave(Self);
  FLogicalUnitNo:=FController.LogicalUnitNo(Self);
  FFireWireGUID:=FController.FireWireGUID(Self);
  FWorldWideNo:=FController.WorldWideNo(Self);

  FPhysicalPort:=FController.PhysicalPort(Self);
  FControlPort:=FController.ControlPort(Self);
  FIRQ:=FController.IRQ(Self);

  FPIO:=FController.PIO(Self);
  FDMA:=FController.DMA(Self);

  FPhysicalCylinders:=FController.PhysicalCylinders(Self);
  FPhysicalHeads:=FController.PhysicalHeads(Self);
  FPhysicalSectors:=FController.PhysicalSectors(Self);

  FLogicalCylinders:=FController.LogicalCylinders(Self);
  FLogicalHeads:=FController.LogicalHeads(Self);
  FLogicalSectors:=FController.LogicalSectors(Self);

  FSectorSize:=FController.SectorSize(Self);
  FSectorCount:=FController.SectorCount(Self);
  FSectorShiftCount:=FController.SectorShiftCount(Self);
 
  Result:=True;
 finally  
  WriterUnlock;
 end; 
end;

{==============================================================================}

function TDiskDevice.LocatePartitions:Boolean;
var
 Count:Integer;
 Partition:TDiskPartition;
 BootRecord:PMasterBootRecord;
 PartitionEntry:TPartitionEntry;
begin
 {}
 Result:=False;
 
 if not WriterLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskDevice.LocatePartitions');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('             Name = ' + Name);
  if FILESYS_LOG_ENABLED then FileSysLogDebug('             DeviceNo = ' + IntToHex(DeviceNo,2));
  if FILESYS_LOG_ENABLED then FileSysLogDebug('             Identifier = ' + Identifier);
  if FILESYS_LOG_ENABLED then FileSysLogDebug('             Information = ' + Information);
  if FILESYS_LOG_ENABLED then FileSysLogDebug('             MediaType = ' + MediaTypeToString(MediaType));
  {$ENDIF}

  if FDriver = nil then Exit;
  if FController = nil then Exit;
  if FDeviceNo = -1 then Exit;
  if FSectorCount = 0 then Exit;

  case FMediaType of
   mtFIXED:begin
     {"Fixed Disk" Device}
     if FSectorSize = 0 then Exit;
     
     {Allocate Boot Record}
     BootRecord:=GetMem(FSectorSize);
     if BootRecord = nil then Exit;
     try
      {Check Media and Read Boot Record}
      if not FController.MediaReady(Self) then Exit; {was MediaReady}
      if not FDriver.Cache.DeviceRead(Self,0,1,BootRecord^) then Exit;
      
      {Check Boot Record}
      if BootRecord.Signature <> BOOT_RECORD_SIGNATURE then Exit;
      
      {Scan Partition Table}
      for Count:=MIN_PARTITION to MAX_PARTITION do
       begin
        PartitionEntry:=BootRecord.PartitionTable.PartitionEntry[Count];
        if (PartitionEntry.TypeIndicator <> pidUnused) and (PartitionEntry.SectorCount <> 0) then
         begin
          {Entry is not Unused so create a Partition object}
          Partition:=FDriver.GetPartitionByEntryNo(Self,nil,Count,False,FILESYS_LOCK_NONE); {Do not lock}
          if Partition = nil then
           begin
            {Partition does not already Exist}
            Partition:=TDiskPartition.Create(FDriver,Self,nil,FDriver.GetNextPartitionNo(Self,False));
            Partition.EntryNo:=Count;
            Partition.PartitionInit;
            
            {Get the Recognizer for this Partition}
            FDriver.GetRecognizerByPartition(Partition,False,FILESYS_LOCK_NONE); {Do not lock}
           end;
         end;
       end;
      
      {Check for Extended Partitions}
      for Count:=MIN_PARTITION to MAX_PARTITION do
       begin
        Partition:=FDriver.GetPartitionByEntryNo(Self,nil,Count,True,FILESYS_LOCK_WRITE);
        if Partition <> nil then
         begin
          Partition.LocatePartitions;
          
          {Unlock Partition}
          Partition.WriterUnlock;
         end;
       end;
      
      Result:=True;
     finally
      FreeMem(BootRecord);
     end;
    end;
   mtREMOVABLE:begin
     {"Removable Disk" Device}
     if FSectorSize = 0 then Exit;

     {Allocate Boot Record}
     BootRecord:=GetMem(FSectorSize);
     if BootRecord = nil then Exit;
     try
      {Check Media and Read Boot Record}
      if not FController.MediaReady(Self) then Exit; {was MediaReady}
      if not FDriver.Cache.DeviceRead(Self,0,1,BootRecord^) then Exit;
      
      {Check Boot Sector}
      if FDriver.GetRecognizerByBootSector(PBootSector(BootRecord),0,FSectorCount,False,FILESYS_LOCK_NONE) = nil then
       begin
        {Check Boot Record}
        if BootRecord.Signature <> BOOT_RECORD_SIGNATURE then Exit;
        
        {Scan Partition Table}
        for Count:=MIN_PARTITION to MAX_PARTITION do
         begin
          PartitionEntry:=BootRecord.PartitionTable.PartitionEntry[Count];
          if (PartitionEntry.TypeIndicator <> pidUnused) and (PartitionEntry.SectorCount <> 0) then
           begin
            {Entry is not Unused so create a Partition object}
            Partition:=FDriver.GetPartitionByEntryNo(Self,nil,Count,False,FILESYS_LOCK_NONE); {Do not lock}
            if Partition = nil then
             begin
              {Partition does not already Exist}
              Partition:=TDiskPartition.Create(FDriver,Self,nil,FDriver.GetNextPartitionNo(Self,False));
              Partition.EntryNo:=Count;
              Partition.PartitionInit;
              
              {Get the Recognizer for this Partition}
              FDriver.GetRecognizerByPartition(Partition,False,FILESYS_LOCK_NONE); {Do not lock}
             end;
           end;
         end;
        
        {Check for Extended Partitions}
        for Count:=MIN_PARTITION to MAX_PARTITION do
         begin
          Partition:=FDriver.GetPartitionByEntryNo(Self,nil,Count,True,FILESYS_LOCK_WRITE);
          if Partition <> nil then
           begin
            Partition.LocatePartitions;
            
            {Unlock Partition}
            Partition.WriterUnlock;
           end;
         end;
       end;  
      
      Result:=True;
     finally
      FreeMem(BootRecord);
     end;
    end;   
   else
    begin
     {"Floppy Disk" Device (including CDROM, DVD, Other)}
     Result:=True;
    end;
  end;
 finally  
  WriterUnlock;
 end; 
end;

{==============================================================================}

function TDiskDevice.LocateVolumes:Boolean;
var
 Volume:TDiskVolume;
begin
 {}
 Result:=False;

 if not WriterLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskDevice.LocateVolumes');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('             Name = ' + Name);
  if FILESYS_LOG_ENABLED then FileSysLogDebug('             DeviceNo = ' + IntToHex(DeviceNo,2));
  if FILESYS_LOG_ENABLED then FileSysLogDebug('             Identifier = ' + Identifier);
  if FILESYS_LOG_ENABLED then FileSysLogDebug('             Information = ' + Information);
  if FILESYS_LOG_ENABLED then FileSysLogDebug('             MediaType = ' + MediaTypeToString(MediaType));
  {$ENDIF}

  if FDriver = nil then Exit;
  if FController = nil then Exit;
  if FDeviceNo = -1 then Exit;
  {if FSectorCount = 0 then Exit;} {Zero is allowed}

  case FMediaType of
   mtFLOPPY,mtCDROM,mtDVD,mtOTHER:begin
     {"Floppy Disk" Device (including CDROM, DVD, Other)}
     {Create a Volume}
     Volume:=FDriver.GetVolumeByDevice(Self,False,FILESYS_LOCK_NONE); {Do not lock}
     if Volume = nil then
      begin
       {Check Media}
       if FController.MediaReady(Self) then
        begin
         Volume:=TDiskVolume.Create(FDriver,Self,nil,FDriver.GetNextVolumeNo);
         Volume.VolumeInit;
        end; 
      end;
     
     Result:=True;
    end;
   mtREMOVABLE:begin
     {"Removable Disk" Device}
     {Check Partition}
     if FDriver.GetPartitionByDevice(Self,False,FILESYS_LOCK_NONE) = nil then {Do not lock}
      begin
       {Create a Volume}
       Volume:=FDriver.GetVolumeByDevice(Self,False,FILESYS_LOCK_NONE); {Do not lock}
       if Volume = nil then
        begin
         {Check Media}
         if FController.MediaReady(Self) then
          begin
           Volume:=TDiskVolume.Create(FDriver,Self,nil,FDriver.GetNextVolumeNo);
           Volume.VolumeInit;
          end; 
        end;
     
       Result:=True;
      end
     else
      begin     
       Result:=True;
      end; 
    end;
   mtFIXED:begin
     {"Fixed Disk" Device}
     Result:=True;
    end;
  end;
 finally  
  WriterUnlock;
 end; 
end;

{==============================================================================}

function TDiskDevice.CreateVolume:TDiskVolume;
begin
 {Base Implementation}
 Result:=nil;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskDevice.CreateVolume (Name=' + Name + ')');
  {$ENDIF}

  if FDriver = nil then Exit;
 
  Result:=TDiskVolume.Create(FDriver,Self,nil,FDriver.GetNextVolumeNo);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TDiskDevice.DeleteVolume(AVolume:TDiskVolume):Boolean;
{Note: Caller must hold the volume writer lock}
begin
 {Base Implementation}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskDevice.DeleteVolume (Name=' + Name + ')');
  {$ENDIF}

  if AVolume = nil then Exit;
 
  AVolume.Free;
 
  Result:=True;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TDiskDevice.CreatePartition(AParent:TDiskPartition;APartitionId:Byte;ACount:LongWord;AActive:Boolean):Boolean;
{Note: Caller must hold the parent writer lock}
var
 Recognizer:TRecognizer;
begin
 {}
 Result:=False;
 
 if not WriterLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskDevice.CreatePartition (Name=' + Name + ')');
  {$ENDIF}

  if FDriver = nil then Exit;
  if FController = nil then Exit;
  if FDeviceNo = -1 then Exit;

  {Get the Recognizer}
  Recognizer:=FDriver.GetRecognizerByNext(nil,True,False,FILESYS_LOCK_READ);
  while Recognizer <> nil do
   begin
    {Check for Partitioner}
    if Recognizer.Partitioner <> nil then
     begin
      {Check Accepted} {Pass null for Partition}
      if Recognizer.Partitioner.AcceptPartition(Self,nil,AParent,APartitionId) then
       begin
        {Create Partition}
        Result:=Recognizer.Partitioner.CreatePartition(Self,AParent,APartitionId,ACount,AActive);
        
        {Unlock Recognizer}
        Recognizer.ReaderUnlock;
        Exit;
       end;
     end;
     
    Recognizer:=FDriver.GetRecognizerByNext(Recognizer,True,True,FILESYS_LOCK_READ); 
   end;
 finally  
  WriterUnlock;
 end; 
end;

{==============================================================================}

function TDiskDevice.DeletePartition(APartition:TDiskPartition):Boolean;
{Note: Caller must hold the partition writer lock}
var
 Recognizer:TRecognizer;
begin
 {}
 Result:=False;

 if not WriterLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskDevice.DeletePartition (Name=' + Name + ')');
  {$ENDIF}

  if FDriver = nil then Exit;
  if FController = nil then Exit;
  if FDeviceNo = -1 then Exit;
  if APartition = nil then Exit;
  
  {Get the Recognizer}
  Recognizer:=FDriver.GetRecognizerByPartition(APartition,True,FILESYS_LOCK_READ);
  if Recognizer <> nil then
   begin
    try
     {Check for Partitioner}
     if Recognizer.Partitioner = nil then Exit;
    
     {Check Accepted} {Pass Unused for Id}
     if not Recognizer.Partitioner.AcceptPartition(Self,APartition,APartition.Partition,pidUnused) then Exit;
    
     {Delete Partition}
     Result:=Recognizer.Partitioner.DeletePartition(APartition);
    finally
     {Unlock Recognizer}
     Recognizer.ReaderUnlock;
    end;   
   end;
 finally  
  WriterUnlock;
 end; 
end;

{==============================================================================}

function TDiskDevice.ModifyPartition(APartition:TDiskPartition;APartitionId:Byte):Boolean;
{Note: Caller must hold the partition writer lock}
var
 Recognizer:TRecognizer;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskDevice.ModifyPartition (Name=' + Name + ')');
  {$ENDIF}

  if FDriver = nil then Exit;
  if FController = nil then Exit;
  if FDeviceNo = -1 then Exit;
  if APartition = nil then Exit;
  
  {Get the Recognizer}
  Recognizer:=FDriver.GetRecognizerByPartition(APartition,True,FILESYS_LOCK_READ);
  if Recognizer <> nil then
   begin
    try
     {Check for Partitioner}
     if Recognizer.Partitioner = nil then Exit;
    
     {Check Accepted} {Pass new Id for Id}
     if not Recognizer.Partitioner.AcceptPartition(Self,APartition,APartition.Partition,APartitionId) then Exit;
    
     {Modify Partition}
     Result:=Recognizer.Partitioner.ModifyPartition(APartition,APartitionId,False);
    finally
     {Unlock Recognizer}
     Recognizer.ReaderUnlock;
    end;   
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TDiskDevice.ActivatePartition(APartition:TDiskPartition;AActive:Boolean):Boolean;
{Note: Caller must hold the partition writer lock}
var
 Recognizer:TRecognizer;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskDevice.ActivatePartition (Name=' + Name + ')');
  {$ENDIF}

  if FDriver = nil then Exit;
  if FController = nil then Exit;
  if FDeviceNo = -1 then Exit;
  if APartition = nil then Exit;
  
  {Get the Recognizer}
  Recognizer:=FDriver.GetRecognizerByPartition(APartition,True,FILESYS_LOCK_READ);
  if Recognizer <> nil then
   begin
    try
     {Check for Partitioner}
     if Recognizer.Partitioner = nil then Exit;
    
     {Check Accepted} {Pass current Id for Id}
     if not Recognizer.Partitioner.AcceptPartition(Self,APartition,APartition.Partition,APartition.PartitionId) then Exit;
    
     {Activate Partition}
     Result:=Recognizer.Partitioner.ActivatePartition(APartition,AActive);
    finally
     {Unlock Recognizer}
     Recognizer.ReaderUnlock;
    end;   
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TDiskDevice.ShrinkPartition(APartition:TDiskPartition;const AStart,ASize:Int64):Boolean;
{Note: Caller must hold the partition writer lock}
var
 Recognizer:TRecognizer;
begin
 {}
 //To Do //Event callback
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskDevice.ShrinkPartition (Name=' + Name + ')');
  {$ENDIF}

  if FDriver = nil then Exit;
  if FController = nil then Exit;
  if FDeviceNo = -1 then Exit;
  if APartition = nil then Exit;
  
  {Get the Recognizer}
  Recognizer:=FDriver.GetRecognizerByPartition(APartition,True,FILESYS_LOCK_READ);
  if Recognizer <> nil then
   begin
    try
     {Check for Resizer}
     if Recognizer.Resizer = nil then Exit;
    
     {Check Accepted}
     if not Recognizer.Resizer.AcceptPartition(APartition,AStart,ASize) then Exit;
    
     {Shrink Partition}
     Result:=Recognizer.Resizer.ShrinkPartition(APartition,AStart,ASize);
    finally
     {Unlock Recognizer}
     Recognizer.ReaderUnlock;
    end;   
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TDiskDevice.ExpandPartition(APartition:TDiskPartition;const AStart,ASize:Int64):Boolean;
{Note: Caller must hold the partition writer lock}
var
 Recognizer:TRecognizer;
begin
 {}
 //To Do //Event callback
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskDevice.ExpandPartition (Name=' + Name + ')');
  {$ENDIF}

  if FDriver = nil then Exit;
  if FController = nil then Exit;
  if FDeviceNo = -1 then Exit;
  if APartition = nil then Exit;
  
  {Get the Recognizer}
  Recognizer:=FDriver.GetRecognizerByPartition(APartition,True,FILESYS_LOCK_READ);
  if Recognizer <> nil then
   begin
    try
     {Check for Resizer}
     if Recognizer.Resizer = nil then Exit;
    
     {Check Accepted}
     if not Recognizer.Resizer.AcceptPartition(APartition,AStart,ASize) then Exit;
    
     {Expand Partition}
     Result:=Recognizer.Resizer.ExpandPartition(APartition,AStart,ASize);
    finally
     {Unlock Recognizer}
     Recognizer.ReaderUnlock;
    end;   
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TDiskDevice.Reset:Boolean;
begin
 {}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskDevice.Reset (Name=' + Name + ')');
  {$ENDIF}

  if FDriver = nil then Exit;
  if FController = nil then Exit;
  
  Result:=FController.Reset(Self);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TDiskDevice.LockMedia:Boolean;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskDevice.LockMedia (Name=' + Name + ')'); 
  {$ENDIF}

  if FDriver = nil then Exit;
  if FController = nil then Exit;
  
  Result:=FController.LockMedia(Self);
  if Result then FLocked:=FController.Locked(Self);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TDiskDevice.UnlockMedia:Boolean;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskDevice.UnlockMedia (Name=' + Name + ')'); 
  {$ENDIF}

  if FDriver = nil then Exit;
  if FController = nil then Exit;
  
  Result:=FController.UnlockMedia(Self);
  if Result then FLocked:=FController.Locked(Self);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TDiskDevice.EjectMedia:Boolean;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskDevice.EjectMedia (Name=' + Name + ')'); 
  {$ENDIF}

  if FDriver = nil then Exit;
  if FController = nil then Exit;
  
  Result:=FController.EjectMedia(Self);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TDiskDevice.MediaReady:Boolean;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskDevice.MediaReady (Name=' + Name + ')'); 
  {$ENDIF}

  if FDriver = nil then Exit;
  if FController = nil then Exit;
  
  FReady:=FController.MediaReady(Self);
  
  Result:=FReady;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TDiskDevice.MediaChanged:Boolean;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskDevice.MediaChanged (Name=' + Name + ')'); 
  {$ENDIF}

  if FDriver = nil then Exit;
  if FController = nil then Exit;
  
  Result:=FController.MediaChanged(Self);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TDiskDevice.MediaLocked:Boolean;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskDevice.MediaLocked (Name=' + Name + ')'); 
  {$ENDIF}

  if FDriver = nil then Exit;
  if FController = nil then Exit;
  
  FLocked:=FController.MediaLocked(Self);
  
  Result:=FLocked;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TDiskDevice.InsertDevice:Boolean; 
begin
 {}
 Result:=False;

 if not WriterLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskDevice.InsertDevice (Name=' + Name + ')'); 
  {$ENDIF}

  if FDriver = nil then Exit;

  {Init Device}
  DeviceInit;
  
  {Locate Partitions}
  LocatePartitions;
  
  {Locate Volumes and Drives}
  FDriver.LocateVolumes;
  FDriver.LocateDrives;

  Result:=True;  
 finally  
  WriterUnlock;
 end; 
end;
  
{==============================================================================}

function TDiskDevice.EjectDevice:Boolean; 
var
 Volume:TDiskVolume;
 Partition:TDiskPartition;
begin
 {}
 Result:=False;

 if not WriterLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskDevice.EjectDevice (Name=' + Name + ')'); 
  {$ENDIF}

  if FDriver = nil then Exit;

  {Release any Raw Handles on the Device}
  FDriver.ReleaseRawHandles(Self,nil,nil,nil);

  {Release any CachePages on the Device}
  FDriver.Cache.ReleaseDevicePages(Self);
  
  {Init Device}
  DeviceInit;
  
  {Remove any Volume on the Device}
  Volume:=FDriver.GetVolumeByDevice(Self,True,FILESYS_LOCK_WRITE);
  while Volume <> nil do
   begin
    Volume.Free;
    
    Volume:=FDriver.GetVolumeByDevice(Self,True,FILESYS_LOCK_WRITE);
   end;
  
  {Remove any Partition on the Device}
  Partition:=FDriver.GetPartitionByDevice(Self,True,FILESYS_LOCK_WRITE);
  while Partition <> nil do
   begin
    Partition.Free;
    
    Partition:=FDriver.GetPartitionByDevice(Self,True,FILESYS_LOCK_WRITE);
   end;
  
  Result:=True;  
 finally  
  WriterUnlock;
 end; 
end;
  
{==============================================================================}

function TDiskDevice.OpenDevice(AMode:Integer):Integer;
var
 Handle:TRawHandle;
begin
 {}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskDevice.OpenDevice (Name=' + Name + ')'); 
  {$ENDIF}

  if FDriver = nil then Exit;
  if SectorSize = 0 then Exit;
  
  {Open the Handle}
  Handle:=FDriver.OpenRawHandle(Self,nil,nil,nil,AMode,True,FILESYS_LOCK_WRITE);
  if Handle = nil then Exit;
  
  {Set the Handle properties}
  Handle.Size:=(SectorCount * SectorSize);  //To Do //shl SectorShiftCount
  Handle.Position:=0;
  
  {Return the Handle}
  Result:=Handle.Handle;

  {Unlock Handle}
  Handle.WriterUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

procedure TDiskDevice.CloseDevice(AHandle:Integer);
var
 Handle:TRawHandle;
begin
 {}
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskDevice.CloseDevice (Name=' + Name + ')'); 
  if FILESYS_LOG_ENABLED then FileSysLogDebug('             Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}

  if FDriver = nil then Exit;
  
  {Get the Handle}
  Handle:=FDriver.GetRawFromHandle(AHandle,True,FILESYS_LOCK_WRITE);
  if Handle = nil then Exit;
  
  {Close the Handle} {Do not unlock}
  FDriver.CloseRawHandle(Handle);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TDiskDevice.ReadDevice(AHandle:Integer;var ABuffer;ACount:Integer):Integer;
{Note: Raw Reads must be in Sector sized multiples}
var
 Start:Int64;
 Count:LongWord;
 Handle:TRawHandle;
begin
 {}
 Result:=0;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskDevice.ReadDevice (Name=' + Name + ')'); 
  if FILESYS_LOG_ENABLED then FileSysLogDebug('             Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}

  if FDriver = nil then Exit;
  if SectorSize = 0 then Exit;
  
  {Get the Handle}
  Handle:=FDriver.GetRawFromHandle(AHandle,True,FILESYS_LOCK_WRITE);
  if Handle = nil then Exit;
  try
   {Check the Mode}
   if Handle.OpenMode = fmOpenWrite then Exit;
  
   {Check for Sector Multiple}
   if (ACount mod SectorSize) <> 0 then Exit;
  
   {Determine how many Sectors to Read and Starting Sector}
   Start:=Handle.Position div SectorSize;              //To Do //shr SectorShiftCount
   Count:=LongWord(ACount) div SectorSize;             //To Do //shr SectorShiftCount
   if (Start + Count) > SectorCount then Exit;
  
   {Read to Buffer}
   if FDriver.Cache.DeviceRead(Self,Start,Count,ABuffer) then
    begin
     Handle.Position:=Handle.Position + ACount;
     Result:=ACount;
    end;
  finally
   {Unlock Handle}
   Handle.WriterUnlock;
  end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TDiskDevice.WriteDevice(AHandle:Integer;const ABuffer;ACount:Integer):Integer;
{Note: Raw Writes must be in Sector sized multiples}
var
 Start:Int64;
 Count:LongWord;
 Handle:TRawHandle;
begin
 {}
 Result:=0;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskDevice.WriteDevice (Name=' + Name + ')'); 
  if FILESYS_LOG_ENABLED then FileSysLogDebug('             Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}

  if FDriver = nil then Exit;
  if SectorSize = 0 then Exit;
  
  {Get the Handle}
  Handle:=FDriver.GetRawFromHandle(AHandle,True,FILESYS_LOCK_WRITE);
  if Handle = nil then Exit;
  try
   {Check the Mode}
   if Handle.OpenMode = fmOpenRead then Exit;
  
   {Check for Sector Multiple}
   if (ACount mod SectorSize) <> 0 then Exit;
  
   {Determine how many Sectors to Write and Starting Sector}
   Start:=Handle.Position div SectorSize;             //To Do //shr SectorShiftCount
   Count:=LongWord(ACount) div SectorSize;            //To Do //shr SectorShiftCount
   if (Start + Count) > SectorCount then Exit;
  
   {Write from Buffer}
   if FDriver.Cache.DeviceWrite(Self,Start,Count,ABuffer) then
    begin
     Handle.Position:=Handle.Position + ACount;
     Result:=ACount;
    end;
  finally
   {Unlock Handle}
   Handle.WriterUnlock;
  end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TDiskDevice.EraseDevice(AHandle:Integer;ACount:Integer):Integer; 
{Note: Raw Erases must be in Sector sized multiples}
var
 Start:Int64;
 Count:LongWord;
 Handle:TRawHandle;
begin
 {}
 Result:=0;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskDevice.EraseDevice (Name=' + Name + ')'); 
  if FILESYS_LOG_ENABLED then FileSysLogDebug('             Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}

  if FDriver = nil then Exit;
  if SectorSize = 0 then Exit;
 
  {Get the Handle}
  Handle:=FDriver.GetRawFromHandle(AHandle,True,FILESYS_LOCK_WRITE);
  if Handle = nil then Exit;
  try
   {Check the Mode}
   if Handle.OpenMode = fmOpenRead then Exit;
 
   {Check for Sector Multiple}
   if (ACount mod SectorSize) <> 0 then Exit;
 
   {Determine how many Sectors to Write and Starting Sector}
   Start:=Handle.Position div SectorSize;             //To Do //shr SectorShiftCount
   Count:=LongWord(ACount) div SectorSize;            //To Do //shr SectorShiftCount
   if (Start + Count) > SectorCount then Exit;
 
   {Erase Device}
   if FDriver.Cache.DeviceErase(Self,Start,Count) then
    begin
     Handle.Position:=Handle.Position + ACount;
     Result:=ACount;
    end;
  finally
   {Unlock Handle}
   Handle.WriterUnlock;
  end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TDiskDevice.SeekDevice(AHandle:Integer;const AOffset:Int64;AOrigin:Integer):Int64;
{Note: Raw Seeks must be in Sector sized multiples}
{Note: Raw Seeks cannot extend the size of the Device}
var
 Handle:TRawHandle;
begin
 {}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskDevice.SeekDevice (Name=' + Name + ')'); 
  if FILESYS_LOG_ENABLED then FileSysLogDebug('             Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}

  if FDriver = nil then Exit;
  if SectorSize = 0 then Exit;
  
  {Get the Handle}
  Handle:=FDriver.GetRawFromHandle(AHandle,True,FILESYS_LOCK_WRITE);
  if Handle = nil then Exit;
  try
   {Check for Sector Multiple}
   if (AOffset mod SectorSize) <> 0 then Exit;
  
   {Move Pointer}
   case AOrigin of
    soFromBeginning:begin
      {Check Offset}
      if AOffset < 0 then Exit;
      if AOffset > Handle.Size then Exit;
      Handle.Position:=AOffset;
      
      Result:=Handle.Position;
     end;
    soFromCurrent:begin
      {Check Offset}
      if (Handle.Position + AOffset) < 0 then Exit;
      if (Handle.Position + AOffset) > Handle.Size then Exit;
      Handle.Position:=(Handle.Position + AOffset);
      
      Result:=Handle.Position;
     end;
    soFromEnd:begin
      {Check Offset}
      if (Handle.Size + AOffset) < 0 then Exit;
      if (Handle.Size + AOffset) > Handle.Size then Exit;
      Handle.Position:=(Handle.Size + AOffset);
      
      Result:=Handle.Position;
     end;
   end;
  finally
   {Unlock Handle}
   Handle.WriterUnlock;
  end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}
{==============================================================================}
{TDiskPartition}
constructor TDiskPartition.Create(ADriver:TFileSysDriver;ADevice:TDiskDevice;APartition:TDiskPartition;APartitionNo:Integer);
begin
 {}
 inherited Create;
 FLock:=SynchronizerCreate;
 FLocalLock:=MutexCreateEx(False,MUTEX_DEFAULT_SPINCOUNT,MUTEX_FLAG_RECURSIVE);
 
 FDriver:=ADriver;
 if FDriver <> nil then FDriver.AddPartition(Self);
 FDevice:=ADevice;
 FPartition:=APartition;
 
 FPartitionNo:=APartitionNo;
 FEntryNo:=-1;

 FRecognizable:=True;
end;

{==============================================================================}

destructor TDiskPartition.Destroy;
begin
 {}
 WriterLock;
 try
  FPartitionNo:=0;
  
  FDevice:=nil;
  FPartition:=nil;
  if FDriver <> nil then FDriver.RemovePartition(Self);
  FDriver:=nil;
  
  MutexDestroy(FLocalLock);
  inherited Destroy;
 finally 
  {WriterUnlock;} {Can destroy Synchronizer while holding lock}
  SynchronizerDestroy(FLock);
 end;
end;

{==============================================================================}

function TDiskPartition.AcquireLock:Boolean;
begin
 {}
 Result:=(MutexLock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskPartition.ReleaseLock:Boolean;
begin
 {}
 Result:=(MutexUnlock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskPartition.GetName:String;
begin
 {}
 Result:='';

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if FPartitionNo = 0 then Exit;
  
  if FExtended then
   begin
    Result:=EXTENDED_PREFIX + IntToStr(FPartitionNo);
   end
  else
   begin
    Result:=PARTITION_PREFIX + IntToStr(FPartitionNo);
   end;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskPartition.GetPath:String;
begin
 {}
 Result:='';

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if FDevice = nil then Exit;
  if FPartitionNo = 0 then Exit;
  
  if FExtended then
   begin
    Result:=FDevice.Name + EXTENDED_PREFIX + IntToStr(FPartitionNo);
   end
  else
   begin
    Result:=FDevice.Name + PARTITION_PREFIX + IntToStr(FPartitionNo);
   end;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskPartition.GetParent:String;
begin
 {}
 Result:='';

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if FDevice = nil then Exit;
  if FPartitionNo = 0 then Exit;
  
  if FPartition <> nil then
   begin
    Result:=FDevice.Name + FPartition.Name;
   end
  else
   begin
    Result:=FDevice.Name;
   end;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskPartition.GetLogical:Boolean;
{Check for a non extended partition with a parent}
begin
 {}
 Result:=False;

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if FDevice = nil then Exit;
  if FExtended then Exit;
  if FPartition = nil then Exit;
  
  Result:=True;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskPartition.GetPrimary:Boolean;
{Check for a non extended partition with no parent}
begin
 {}
 Result:=False;

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if FDevice = nil then Exit;
  if FExtended then Exit;
  if FPartition <> nil then Exit;
  
  Result:=True;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

procedure TDiskPartition.SetExtended(AExtended:Boolean);
{Mark partition as extended, update no and recalculate start}
{Note: Once extended is enabled it cannot be turned off}
{Note: If already enabled then no action is taken}
begin
 {}
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if FDevice = nil then Exit;
  if not(AExtended) or (FExtended) then Exit;
  
  FPartitionNo:=FDriver.GetNextPartitionNo(FDevice,AExtended);
  FExtended:=AExtended; {Must be after GetNextPartitionNo}
  FStartSector:=GetParentStart + FSectorOffset;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskPartition.GetFreeSectors:LongWord;
{Get the total Count of Unused Sectors in the Partition}
var
 Partition:TDiskPartition;
begin
 {}
 Result:=0;

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if FDevice = nil then Exit;
  if FEntryNo < MIN_PARTITION then Exit;
  if FEntryNo > MAX_PARTITION then Exit;
  if FDevice.Controller = nil then Exit;
  if FSectorCount = 0 then Exit;
  
  {If not Extended then nothing Free}
  if not FExtended then Exit;
  
  {If not first level then nothing Free}
  if FPartition <> nil then Exit;
  
  {Get Sector Count}  
  Result:=(FSectorCount - 1); {Minus one to allow for Partition Record}
  
  {Check each Partition}
  Partition:=FDriver.GetPartitionByNext(nil,True,False,FILESYS_LOCK_READ);
  while Partition <> nil do
   begin
    {Subtract the amount used by each extended or direct child Partition}
    if (Partition.Partition = Self) or ((Partition.Extended) and (Partition.Root = Self)) then
     begin
      Result:=Result - Partition.SectorCount;
     end;
     
    Partition:=FDriver.GetPartitionByNext(Partition,True,True,FILESYS_LOCK_READ);
   end;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskPartition.GetAvailableSectors:LongWord;
{Get the largest Count of Unused Sectors in the Partition}
var
 FreeStart:LongWord;
 FreeCount:LongWord;
begin
 {}
 Result:=0;
 
 if not GetAvailableBlock(FreeStart,FreeCount) then Exit;
 
 Result:=FreeCount;
end;

{==============================================================================}

function TDiskPartition.GetAvailableBlock(var AStart,ACount:LongWord):Boolean;
{Get the Start and Count of largest Unused Sectors in the Partition}
var
 {EntryCount:Word;}
 MinimumCount:LongWord;

 Count:Integer;
 Partitions:TList;
 Partition:TDiskPartition;
begin
 {}
 Result:=False;

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if FDevice = nil then Exit;
  if FEntryNo < MIN_PARTITION then Exit;
  if FEntryNo > MAX_PARTITION then Exit;
  if FDevice.Controller = nil then Exit;
  if FSectorCount = 0 then Exit;

  {If not Extended then nothing Available}
  if not FExtended then Exit;
  
  {If not first level then nothing Available}
  if FPartition <> nil then Exit;
  
  {Get the Minimum Block}
  MinimumCount:=(FDevice.PhysicalSectors * FDevice.PhysicalHeads);
  if (MinimumCount = 0) or (FDevice.PhysicalCylinders > 1024) then MinimumCount:=(FDevice.LogicalSectors * FDevice.LogicalHeads);
  
  {Get Start Block}
  AStart:=FStartSector + 1;     {Plus one to allow for Partition Record}
  ACount:=(FSectorCount - 1);  {Minus one to allow for Partition Record}
  {EntryCount:=0;}
  
  {Get Partitions}
  Partitions:=FDriver.GetPartitionsByPartition(Self,True,FILESYS_LOCK_READ);
  try
   {Sort by Start}
   Partitions.Sort(ComparePartitions);
   
   {Check each Partition}
   for Count:=0 to Partitions.Count - 1 do
    begin
     if Partitions.Items[Count] <> nil then
      begin
       Partition:=TDiskPartition(Partitions.Items[Count]); {Locked by GetPartitionsByPartition}
       
       {Check for extended or direct child}
       if (Partition.Partition = Self) or ((Partition.Extended) and (Partition.Root = Self)) then
        begin
         {Inc(EntryCount);}
         
         {Check for maximum partitions already (Only 2 on Extended)}
         {if EntryCount > MAX_EXTENDED then Exit;} {Dont check can be many more than 2 child partitions}
         
         {Check Partition for overlap with Free}
         if (AStart >= Partition.StartSector) and ((AStart + ACount) <= (Partition.StartSector + Partition.SectorCount)) then
          begin
           {Partition overlaps whole of Free}
           ACount:=0;
           Break;
          end
         else if (AStart < Partition.StartSector) and ((AStart + ACount) > (Partition.StartSector + Partition.SectorCount)) then
          begin
           {Partition overlaps middle of Free}
           if (Partition.StartSector - AStart) >= ((AStart + ACount) - (Partition.StartSector + Partition.SectorCount)) then
            begin
             {Larger block on left side of Partition}
             ACount:=(Partition.StartSector - AStart);
            end
           else
            begin
             {Larger block on right side of Partition}
             ACount:=((AStart + ACount) - (Partition.StartSector + Partition.SectorCount));
             AStart:=(Partition.StartSector + Partition.SectorCount);
            end;
          end
         else if (AStart >= Partition.StartSector) and (AStart < (Partition.StartSector + Partition.SectorCount)) then {No <= due to no SectorCount - 1}
          begin
           {Partition overlaps left side of Free}
           ACount:=((AStart + ACount) - (Partition.StartSector + Partition.SectorCount));
           AStart:=(Partition.StartSector + Partition.SectorCount);
          end
         else if (AStart < Partition.StartSector) and ((AStart + ACount) > Partition.StartSector) then {No >= due to no Count - 1}
          begin
           {Partition overlaps right side of Free}
           ACount:=(Partition.StartSector - AStart);
          end;
        end;
      end;
    end;
    
   if ACount > MinimumCount then Result:=True;
  finally
   {Unlock each Partition}
   for Count:=0 to Partitions.Count - 1 do
    begin
     if Partitions.Items[Count] <> nil then
      begin
       Partition:=TDiskPartition(Partitions.Items[Count]); {Locked by GetPartitionsByPartition}
  
       {Unlock Partition}
       Partition.ReaderUnlock;
      end;
    end;
    
   {Free Partitions}  
   Partitions.Free;
  end;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskPartition.GetRoot:TDiskPartition;
{Returns the first level extended for a second level plus partition}
var
 Parent:TDiskPartition;
begin
 {}
 Result:=nil;

 if not AcquireLock then Exit;
 try
  Parent:=FPartition; //To Do //Lock //Use FDriver.CheckPartition(Lock) ?
  while Parent <> nil do
   begin
    Result:=Parent;
    
    Parent:=Parent.Partition; //To Do //Lock //Use FDriver.CheckPartition(Lock) ?
   end;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskPartition.GetParentStart:LongWord;
var
 Parent:TDiskPartition;
begin
 {}
 Result:=0;

 if not AcquireLock then Exit;
 try
  Parent:=FPartition; //To Do //Lock //Use FDriver.CheckPartition(Lock) ?
  
  if FExtended then
   begin
    {Extended Partitions Start at Root.StartSector + SectorOffset}
    {Partitions with no Parent Start at SectorOffset}
    while Parent <> nil do
     begin
      Result:=Parent.StartSector;
      
      Parent:=Parent.Partition; //To Do //Lock //Use FDriver.CheckPartition(Lock) ?
     end;
   end
  else
   begin
    {Non Extended Partitions Start at Parent.StartSector + SectorOffset}
    {Partitions with no Parent Start at SectorOffset}
    if Parent <> nil then
     begin
      Result:=Parent.StartSector;
     end;
   end;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskPartition.ReaderLock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskPartition.ReaderUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskPartition.ReaderConvert:Boolean; 
{Convert a Reader lock to a Writer lock}
begin
 {}
 Result:=(SynchronizerReaderConvert(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskPartition.WriterLock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskPartition.WriterUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskPartition.WriterConvert:Boolean;
{Convert a Writer lock to a Reader lock}
begin
 {}
 Result:=(SynchronizerWriterConvert(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskPartition.PartitionInit:Boolean;
var
 PartitionEntry:TPartitionEntry;
 PartitionRecord:PPartitionRecord;
begin
 {}
 Result:=False;

 if not WriterLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskPartition.PartitionInit');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Name = ' + Name);
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                EntryNo = ' + IntToStr(EntryNo));
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                PartitionId = ' + IntToStr(PartitionId));
  {$ENDIF}

  if FDriver = nil then Exit;
  if FDevice = nil then Exit;
  if FEntryNo < MIN_PARTITION then Exit;
  if FEntryNo > MAX_PARTITION then Exit;
  if FDevice.Controller = nil then Exit;

  if FPartition <> nil then
   begin
    {Allocate Partition Record}
    PartitionRecord:=GetMem(FDevice.SectorSize);
    if PartitionRecord = nil then Exit;
    try
     {Get the Partition Record from the parent Partition}
     if not FDriver.Cache.DeviceRead(FDevice,FPartition.StartSector,1,PartitionRecord^) then Exit;
     
     PartitionEntry:=PartitionRecord.PartitionTable.PartitionEntry[FEntryNo];
     
     {Fill the Fields for the Partition}
     FPartitionId:=PartitionEntry.TypeIndicator;
     FBeginHead:=PartitionEntry.StartHead;
     FBeginSector:=(PartitionEntry.StartSector and $3F);
     FBeginCylinder:=(PartitionEntry.StartSector and $C0);
     FBeginCylinder:=(FBeginCylinder shl 2) + PartitionEntry.StartCylinder;
     FEndHead:=PartitionEntry.EndHead;
     FEndSector:=(PartitionEntry.EndSector and $3F);
     FEndCylinder:=(PartitionEntry.EndSector and $C0);
     FEndCylinder:=(FEndCylinder shl 2) + PartitionEntry.EndCylinder;
     FSectorOffset:=PartitionEntry.SectorOffset;

     FActive:=((PartitionEntry.BootIndicator and $80) <> $00);

     {Note: For Extended Partitions within Extended Partitions
      this will miscalculate the StartSector until SetExtended
      is called by a Recognizer at which time StartSector will
      be recalculated}
     FStartSector:=GetParentStart + FSectorOffset;
     FSectorCount:=PartitionEntry.SectorCount;
     
     Result:=True;
    finally
     FreeMem(PartitionRecord);
    end;
   end
  else
   begin
    {Allocate Partition Record}
    PartitionRecord:=GetMem(FDevice.SectorSize);
    if PartitionRecord = nil then Exit;
    try
     {Get the Partition Record from the Device}
     if not FDriver.Cache.DeviceRead(FDevice,0,1,PartitionRecord^) then Exit;
    
     PartitionEntry:=PartitionRecord.PartitionTable.PartitionEntry[FEntryNo];
     
     {Fill the Fields for the Partition}
     FPartitionId:=PartitionEntry.TypeIndicator;
     FBeginHead:=PartitionEntry.StartHead;
     FBeginSector:=(PartitionEntry.StartSector and $3F);
     FBeginCylinder:=(PartitionEntry.StartSector and $C0);
     FBeginCylinder:=(FBeginCylinder shl 2) + PartitionEntry.StartCylinder;
     FEndHead:=PartitionEntry.EndHead;
     FEndSector:=(PartitionEntry.EndSector and $3F);
     FEndCylinder:=(PartitionEntry.EndSector and $C0);
     FEndCylinder:=(FEndCylinder shl 2) + PartitionEntry.EndCylinder;
     FSectorOffset:=PartitionEntry.SectorOffset;

     FActive:=((PartitionEntry.BootIndicator and $80) <> $00);

     FStartSector:=FSectorOffset;
     FSectorCount:=PartitionEntry.SectorCount;
     
     Result:=True;
    finally
     FreeMem(PartitionRecord);
    end;
   end;
 finally  
  WriterUnlock;
 end; 
end;

{==============================================================================}

function TDiskPartition.LocatePartitions:Boolean;
var
 Count:Integer;
 Partition:TDiskPartition;
 PartitionEntry:TPartitionEntry;
 PartitionRecord:PPartitionRecord;
begin
 {}
 Result:=False;
 
 if not WriterLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskPartition.LocatePartitions');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Name = ' + Name);
  {$ENDIF}

  if FDriver = nil then Exit;
  if FDevice = nil then Exit;
  if FEntryNo < MIN_PARTITION then Exit;
  if FEntryNo > MAX_PARTITION then Exit;
  if FDevice.Controller = nil then Exit;

  if FExtended then
   begin
    {Allocate Partition Record}
    PartitionRecord:=GetMem(FDevice.SectorSize);
    if PartitionRecord = nil then Exit;
    try
     {Check Media and Read Partition Record}
     if not FDevice.Controller.MediaReady(FDevice) then Exit; {was Device.MediaReady}
     if not FDriver.Cache.DeviceRead(FDevice,FStartSector,1,PartitionRecord^) then Exit;
     
     {Check Partition Record}
     if PartitionRecord.Signature <> PARTITION_RECORD_SIGNATURE then Exit;
     
     {Scan Partition Table}
     for Count:=MIN_PARTITION to MAX_PARTITION do {Should be MAX_EXTENDED}
      begin
       PartitionEntry:=PartitionRecord.PartitionTable.PartitionEntry[Count];
       if (PartitionEntry.TypeIndicator <> pidUnused) and (PartitionEntry.SectorCount <> 0) then
        begin
         {Entry is not Unused so create a Partition object}
         Partition:=FDriver.GetPartitionByEntryNo(FDevice,Self,Count,False,FILESYS_LOCK_NONE); {Do not lock}
         if Partition = nil then
          begin
           {Partition does not already Exist}
           Partition:=TDiskPartition.Create(FDriver,FDevice,Self,FDriver.GetNextPartitionNo(FDevice,False));
           Partition.EntryNo:=Count;
           Partition.PartitionInit;
           
           {Get the Recognizer for this Partition}
           FDriver.GetRecognizerByPartition(Partition,False,FILESYS_LOCK_NONE); {Do not lock}
          end;
        end;
      end;
     
     {Check for Extended Partitions}
     for Count:=MIN_PARTITION to MAX_PARTITION do {Should be MAX_EXTENDED}
      begin
       Partition:=FDriver.GetPartitionByEntryNo(FDevice,Self,Count,True,FILESYS_LOCK_WRITE);
       if Partition <> nil then
        begin
         Partition.LocatePartitions;
         
         {Unlock Partition}
         Partition.WriterUnlock;
        end;
      end;
      
     Result:=True;
    finally
     FreeMem(PartitionRecord);
    end;
   end
  else
   begin
    Result:=True;
   end;
 finally  
  WriterUnlock;
 end; 
end;

{==============================================================================}

function TDiskPartition.LocateVolumes:Boolean;
var
 Volume:TDiskVolume;
begin
 {}
 Result:=False;

 if not WriterLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskPartition.LocateVolumes');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Name = ' + Name);
  {$ENDIF}

  if FDriver = nil then Exit;
  if FDevice = nil then Exit;
  if FEntryNo < MIN_PARTITION then Exit;
  if FEntryNo > MAX_PARTITION then Exit;
  if FDevice.Controller = nil then Exit;

  {Check for Non Volume}
  if not FNonVolume then
   begin
    {Create a Volume}
    Volume:=FDriver.GetVolumeByPartition(Self,False,FILESYS_LOCK_NONE); {Do not lock}
    if Volume = nil then
     begin
      {No meed to check MediaReady}
      Volume:=TDiskVolume.Create(FDriver,FDevice,Self,FDriver.GetNextVolumeNo);
      Volume.VolumeInit;
     end;
     
    Result:=True;
   end
  else
   begin
    Result:=True;
   end;
 finally  
  WriterUnlock;
 end; 
end;

{==============================================================================}

function TDiskPartition.CreateVolume:TDiskVolume;
begin
 {Base Implementation}
 Result:=nil;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskPartition.CreateVolume (Name=' + Name + ')');
  {$ENDIF}

  if FDriver = nil then Exit;
  if FDevice = nil then Exit;
 
  Result:=TDiskVolume.Create(FDriver,FDevice,Self,FDriver.GetNextVolumeNo);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TDiskPartition.DeleteVolume(AVolume:TDiskVolume):Boolean;
{Note: Caller must hold the volume writer lock}
begin
 {Base Implementation}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskPartition.DeleteVolume (Name=' + Name + ')');
  {$ENDIF}

  if AVolume = nil then Exit;
  
  AVolume.Free;
  
  Result:=True;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TDiskPartition.OpenPartition(AMode:Integer):Integer;
var
 Count:Int64; {Temporary until SectorCount is Int64}
 Handle:TRawHandle;
begin
 {}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskPartition.OpenPartition (Name=' + Name + ')');
  {$ENDIF}

  if Device = nil then Exit;
  if FDriver = nil then Exit;
  if Device.SectorSize = 0 then Exit;
  
  {Open the Handle}
  Handle:=FDriver.OpenRawHandle(nil,Self,nil,nil,AMode,True,FILESYS_LOCK_WRITE);
  if Handle = nil then Exit;
  
  {Set the Handle properties}
  Count:=SectorCount; {Temporary until SectorCount is Int64}
  Handle.Size:=(Count * Device.SectorSize);   //To Do //shl Device.SectorShiftCount
  Handle.Position:=0;
  
  {Return the Handle}
  Result:=Handle.Handle;

  {Unlock Handle}
  Handle.WriterUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

procedure TDiskPartition.ClosePartition(AHandle:Integer);
var
 Handle:TRawHandle;
begin
 {}
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskPartition.ClosePartition (Name=' + Name + ')');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}
  if FDriver = nil then Exit;
  
  {Get the Handle}
  Handle:=FDriver.GetRawFromHandle(AHandle,True,FILESYS_LOCK_WRITE);
  if Handle = nil then Exit;
  
  {Close the Handle} {Do not unlock}
  FDriver.CloseRawHandle(Handle);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TDiskPartition.ReadPartition(AHandle:Integer;var ABuffer;ACount:Integer):Integer;
{Note: Raw Reads must be in Sector sized multiples}
var
 Start:Int64;
 Count:LongWord;
 Handle:TRawHandle;
begin
 {}
 Result:=0;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskPartition.ReadPartition (Name=' + Name + ')');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}

  if Device = nil then Exit;
  if FDriver = nil then Exit;
  if Device.SectorSize = 0 then Exit;
  
  {Get the Handle}
  Handle:=FDriver.GetRawFromHandle(AHandle,True,FILESYS_LOCK_WRITE);
  if Handle = nil then Exit;
  try
   {Check the Mode}
   if Handle.OpenMode = fmOpenWrite then Exit;
  
   {Check for Sector Multiple}
   if (ACount mod Device.SectorSize) <> 0 then Exit;
  
   {Determine how many Sectors to Read and Starting Sector}
   Start:=Handle.Position div Device.SectorSize;                               //To Do //shr Device.SectorShiftCount
   Count:=LongWord(ACount) div Device.SectorSize;                              //To Do //shr Device.SectorShiftCount
   if (StartSector + Start + Count) > Device.SectorCount then Exit;
  
   {Read to Buffer}
   if FDriver.Cache.DeviceRead(Device,StartSector + Start,Count,ABuffer) then
    begin
     Handle.Position:=Handle.Position + ACount;
     Result:=ACount;
    end;
  finally
   {Unlock Handle}
   Handle.WriterUnlock;
  end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TDiskPartition.WritePartition(AHandle:Integer;const ABuffer;ACount:Integer):Integer;
{Note: Raw Writes must be in Sector sized multiples}
var
 Start:Int64;
 Count:LongWord;
 Handle:TRawHandle;
begin
 {}
 Result:=0;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskPartition.WritePartition (Name=' + Name + ')');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}

  if Device = nil then Exit;
  if FDriver = nil then Exit;
  if Device.SectorSize = 0 then Exit;
  
  {Get the Handle}
  Handle:=FDriver.GetRawFromHandle(AHandle,True,FILESYS_LOCK_WRITE);
  if Handle = nil then Exit;
  try
   {Check the Mode}
   if Handle.OpenMode = fmOpenRead then Exit;
  
   {Check for Sector Multiple}
   if (ACount mod Device.SectorSize) <> 0 then Exit;
  
   {Determine how many Sectors to Write and Starting Sector}
   Start:=Handle.Position div Device.SectorSize;                                    //To Do //shr Device.SectorShiftCount
   Count:=LongWord(ACount) div Device.SectorSize;                                   //To Do //shr Device.SectorShiftCount
   if (StartSector + Start + Count) > Device.SectorCount then Exit;
  
   {Write from Buffer}
   if FDriver.Cache.DeviceWrite(Device,StartSector + Start,Count,ABuffer) then
    begin
     Handle.Position:=Handle.Position + ACount;
     Result:=ACount;
    end;
  finally
   {Unlock Handle}
   Handle.WriterUnlock;
  end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TDiskPartition.SeekPartition(AHandle:Integer;const AOffset:Int64;AOrigin:Integer):Int64;
{Note: Raw Seeks must be in Sector sized multiples}
{Note: Raw Seeks cannot extend the size of the Partition}
var
 Handle:TRawHandle;
begin
 {}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskPartition.SeekPartition (Name=' + Name + ')');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}

  if Device = nil then Exit;
  if FDriver = nil then Exit;
  if Device.SectorSize = 0 then Exit;
  
  {Get the Handle}
  Handle:=FDriver.GetRawFromHandle(AHandle,True,FILESYS_LOCK_WRITE);
  if Handle = nil then Exit;
  try
   {Check for Sector Multiple}
   if (AOffset mod Device.SectorSize) <> 0 then Exit;
  
   {Move Pointer}
   case AOrigin of
    soFromBeginning:begin
      {Check Offset}
      if AOffset < 0 then Exit;
      if AOffset > Handle.Size then Exit;
      Handle.Position:=AOffset;
      
      Result:=Handle.Position;
     end;
    soFromCurrent:begin
      {Check Offset}
      if (Handle.Position + AOffset) < 0 then Exit;
      if (Handle.Position + AOffset) > Handle.Size then Exit;
      Handle.Position:=(Handle.Position + AOffset);
      
      Result:=Handle.Position;
     end;
    soFromEnd:begin
      {Check Offset}
      if (Handle.Size + AOffset) < 0 then Exit;
      if (Handle.Size + AOffset) > Handle.Size then Exit;
      Handle.Position:=(Handle.Size + AOffset);
      
      Result:=Handle.Position;
     end;
   end;
  finally
   {Unlock Handle}
   Handle.WriterUnlock;
  end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}
{==============================================================================}
{TDiskVolume}
constructor TDiskVolume.Create(ADriver:TFileSysDriver;ADevice:TDiskDevice;APartition:TDiskPartition;AVolumeNo:Integer);
begin
 {}
 inherited Create;
 FLock:=SynchronizerCreate;
 FLocalLock:=MutexCreate;

 FDriver:=ADriver;
 if FDriver <> nil then FDriver.AddVolume(Self);
 FDevice:=ADevice;
 FPartition:=APartition;
 
 FVolumeNo:=AVolumeNo;
 FSegmentNo:=0;

 FDriveType:=dtUNKNOWN;

 FFileSystem:=nil;

 FRemovable:=False;
 FRecognizable:=True;
 FRecognized:=False;

 FSectorSize:=0;
 FStartSector:=0;
 FSectorCount:=0;
 FSectorShiftCount:=0;
end;

{==============================================================================}

destructor TDiskVolume.Destroy;
begin
 {}
 WriterLock;
 try
  FVolumeNo:=0;
  
  FDevice:=nil;
  FPartition:=nil;

  FDriveType:=dtUNKNOWN;

  FFileSystem:=nil;
  if FDriver <> nil then FDriver.RemoveVolume(Self);
  FDriver:=nil;
  
  MutexDestroy(FLocalLock);
  inherited Destroy;
 finally 
  {WriterUnlock;} {Can destroy Synchronizer while holding lock}
  SynchronizerDestroy(FLock);
 end;
end;

{==============================================================================}

function TDiskVolume.AcquireLock:Boolean;
begin
 {}
 Result:=(MutexLock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskVolume.ReleaseLock:Boolean;
begin
 {}
 Result:=(MutexUnlock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskVolume.GetName:String;
begin
 {}
 Result:='';
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if FVolumeNo = 0 then Exit;
 
  Result:=VOLUME_PREFIX + IntToStr(FVolumeNo);
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskVolume.GetParent:String;
begin
 {}
 Result:='';
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if FDevice = nil then Exit;
  if FVolumeNo = 0 then Exit;
 
  if FPartition <> nil then
   begin
    Result:=FDevice.Name + FPartition.Name;
   end
  else
   begin
    Result:=FDevice.Name;
   end;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskVolume.GetMaxFile:Integer;
{Get MaxFile from FileSystem if Mounted}
begin
 {}
 Result:=0;

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if FFileSystem = nil then Exit;
  
  Result:=FFileSystem.MaxFile;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskVolume.GetMaxPath:Integer;
{Get MaxPath from FileSystem if Mounted}
begin
 {}
 Result:=0;

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if FFileSystem = nil then Exit;
  
  Result:=FFileSystem.MaxPath;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskVolume.GetAttributes:LongWord;
{Get Attributes from FileSystem if Mounted}
begin
 {}
 Result:=vaNone;

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if FFileSystem = nil then Exit;
  
  Result:=FFileSystem.Attributes;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskVolume.GetSystemName:String;
{Get SystemName from FileSystem if Mounted}
begin
 {}
 Result:='';

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if FFileSystem = nil then Exit;
  
  Result:=FFileSystem.SystemName;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskVolume.GetVolumeName:String;
{Get VolumeName from FileSystem if Mounted}
begin
 {}
 Result:='';

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if FFileSystem = nil then Exit;
  
  Result:=FFileSystem.VolumeName;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskVolume.GetVolumeGUID:String;
{Get VolumeGUID from FileSystem if Mounted}
begin
 {}
 Result:='';

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if FFileSystem = nil then Exit;
  
  Result:=FFileSystem.VolumeGUID;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskVolume.GetVolumeSerial:LongWord;
{Get VolumeSerial from FileSystem if Mounted}
begin
 {}
 Result:=0;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if FFileSystem = nil then Exit;
  
  Result:=FFileSystem.VolumeSerial;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskVolume.GetFileSysType:TFileSysType;
{Get FileSysType from FileSystem if Mounted}
begin
 {}
 Result:=fsUNKNOWN;

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if FFileSystem = nil then Exit;
  
  Result:=FFileSystem.FileSysType;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

procedure TDiskVolume.SetFileSystem(AFileSystem:TFileSystem);
{Set the FileSystem and Reinitialize the Volume}
begin
 {}
 if not WriterLock then Exit;
 try
  if not AcquireLock then Exit;
  try
   if FDriver = nil then Exit;
   if FFileSystem = AFileSystem then Exit;
  
   FFileSystem:=AFileSystem;
  finally  
   ReleaseLock;
  end; 
  
  VolumeInit;
 finally  
  WriterUnlock;
 end; 
end;

{==============================================================================}

function TDiskVolume.GetSectorSize:Word;
{Get SectorSize from FileSystem (Mounted) or Volume (Not Mounted)}
begin
 {}
 Result:=0;

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  
  if FFileSystem <> nil then
   begin
    Result:=FFileSystem.SectorSize;
   end
  else
   begin
    Result:=FSectorSize;
   end;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskVolume.GetStartSector:Int64;
{Get StartSector from FileSystem (Mounted) or Volume (Not Mounted)}
begin
 {}
 Result:=0;

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  
  if FFileSystem <> nil then
   begin
    Result:=FFileSystem.StartSector;
   end
  else
   begin
    Result:=FStartSector;
   end;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskVolume.GetSectorCount:LongWord;
{Get SectorCount from FileSystem (Mounted) or Volume (Not Mounted)}
begin
 {}
 Result:=0;

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  
  if FFileSystem <> nil then
   begin
    Result:=FFileSystem.SectorCount;
   end
  else
   begin
    Result:=FSectorCount;
   end;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskVolume.GetSectorShiftCount:Word;
begin
 {}
 Result:=FSectorShiftCount;
end;

{==============================================================================}

function TDiskVolume.MediaTypeToDriveType(AMediaType:TMediaType):TDriveType;
begin
 {}
 Result:=dtUNKNOWN;
 
 case AMediaType of
  mtFLOPPY:Result:=dtFLOPPY;
  mtFIXED:Result:=dtFIXED;
  mtREMOVABLE,mtOTHER:Result:=dtREMOVABLE;
  mtCDROM,mtDVD:Result:=dtCDROM;
 end;
end;

{==============================================================================}

function TDiskVolume.ReaderLock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskVolume.ReaderUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskVolume.WriterLock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskVolume.WriterUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskVolume.VolumeInit:Boolean;
begin
 {}
 Result:=False;

 if not WriterLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskVolume.VolumeInit');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('             Name = ' + Name);
  if FILESYS_LOG_ENABLED then FileSysLogDebug('             VolumeNo = ' + IntToStr(VolumeNo));
  {$ENDIF}

  if FDriver = nil then Exit;
  if FDevice = nil then Exit;
  if FVolumeNo = 0 then Exit;

  {Setup Status and Sector Size}
  FDriveType:=MediaTypeToDriveType(FDevice.MediaType);
  FRemovable:=FDevice.Removable;
  FSectorSize:=FDevice.SectorSize;
  FSectorShiftCount:=FDevice.SectorShiftCount;

  {Check for Partition}
  if FPartition <> nil then
   begin
    {Setup Start Sector and Count from Partition}
    FStartSector:=FPartition.StartSector;
    FSectorCount:=FPartition.SectorCount;
    
    Result:=True;
   end
  else
   begin
    {Setup Start Sector and Count from Device}
    FStartSector:=0;
    FSectorCount:=FDevice.SectorCount;
    
    Result:=True;
   end;
 finally  
  WriterUnlock;
 end; 
end;

{==============================================================================}

function TDiskVolume.CreateDrive(ADriveNo:Integer):TDiskDrive;
begin
 {Base Implementation}
 Result:=nil;

 if not WriterLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskVolume.CreateDrive (Name= ' + Name + ')');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('             DriveNo = ' + IntToStr(ADriveNo));
  {$ENDIF}

  if FDriver = nil then Exit;
  if ADriveNo < MIN_DRIVE then Exit;
  if ADriveNo > MAX_DRIVE then Exit;
  
  Result:=TDiskDrive.Create(FDriver,Self,ADriveNo);
 finally  
  WriterUnlock;
 end; 
end;

{==============================================================================}

function TDiskVolume.DeleteDrive(ADrive:TDiskDrive):Boolean;
{Note: Caller must hold the drive writer lock}
begin
 {Base Implementation}
 Result:=False;
 
 if not WriterLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskVolume.DeleteDrive (Name= ' + Name + ')');
  {$ENDIF}

  if ADrive = nil then Exit;
  
  ADrive.Free;
  
  Result:=True;
 finally  
  WriterUnlock;
 end; 
end;

{==============================================================================}

function TDiskVolume.MountVolume(ADriveNo:Integer):Boolean;
var
 Drive:TDiskDrive;
 Recognizer:TRecognizer;
begin
 {}
 Result:=False;
 
 if not WriterLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskVolume.MountVolume (Name= ' + Name + ')');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('             DriveNo = ' + IntToStr(ADriveNo));
  {$ENDIF}

  if FDriver = nil then Exit;
  if FDevice = nil then Exit;
  if FVolumeNo = 0 then Exit;
  
  {Check for already Mounted}
  if FFileSystem <> nil then Exit;
  
  {Get the Recognizer}
  Recognizer:=FDriver.GetRecognizerByVolume(Self,True,FILESYS_LOCK_READ);
  if Recognizer <> nil then
   begin
    if (FDriver.AllowDrives) and (Recognizer.AllowDrive) and (ADriveNo <> INVALID_DRIVE) then
     begin
      if ADriveNo < MIN_DRIVE then Exit;
      if ADriveNo > MAX_DRIVE then Exit;
      
      {Check for Drive already used}
      if FDriver.GetDriveByNo(ADriveNo,False,FILESYS_LOCK_NONE) <> nil then Exit; {Do not lock}
      
      {Create Drive}
      Drive:=TDiskDrive.Create(FDriver,Self,ADriveNo);
      Drive.DriveInit;
      
      {Mount Volume}
      Result:=Recognizer.MountVolume(Self,Drive);
     end
    else
     begin
      {Mount Volume}
      Result:=Recognizer.MountVolume(Self,nil);
     end;
   
    {Unlock Recognizer}
    Recognizer.ReaderUnlock;
   end;
 finally  
  WriterUnlock;
 end; 
end;

{==============================================================================}

function TDiskVolume.DismountVolume:Boolean;
var
 Recognizer:TRecognizer;
begin
 {}
 Result:=False;

 if not WriterLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskVolume.DismountVolume (Name= ' + Name + ')');
  {$ENDIF}

  if FDriver = nil then Exit;
  if FDevice = nil then Exit;
  if FVolumeNo = 0 then Exit;
  
  {Check for not Mounted}
  if FFileSystem = nil then Exit;
  
  {Get the Recognizer}
  Recognizer:=FDriver.GetRecognizerByVolume(Self,True,FILESYS_LOCK_READ);
  if Recognizer <> nil then
   begin
    {Dismount Volume}
    Result:=Recognizer.DismountVolume(Self);

    {Unlock Recognizer}
    Recognizer.ReaderUnlock;
   end;
 finally  
  WriterUnlock;
 end; 
end;

{==============================================================================}

function TDiskVolume.FormatVolume(AFloppyType:TFloppyType;AFileSysType:TFileSysType):Boolean;
var
 Recognizer:TRecognizer;
begin
 {}
 //To Do //Event callback
 Result:=False;

 if not WriterLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskVolume.FormatVolume (Name= ' + Name + ')');
  {$ENDIF}

  if FDriver = nil then Exit;
  if FDevice = nil then Exit;
  if FVolumeNo = 0 then Exit;
  
  {Get the Recognizer}
  Recognizer:=FDriver.GetRecognizerByVolume(Self,True,FILESYS_LOCK_READ);
  if Recognizer <> nil then
   begin
    try
     {Check for Formatter}
     if Recognizer.Formatter = nil then Exit;
     if not Recognizer.Formatter.AcceptVolume(Self,AFloppyType,AFileSysType) then Exit;
    
     {Format Volume}
     Result:=Recognizer.Formatter.FormatVolume(Self,AFloppyType,AFileSysType);
    finally
     {Unlock Recognizer}
     Recognizer.ReaderUnlock;
    end;   
   end;
 finally  
  WriterUnlock;
 end; 
end;

{==============================================================================}

function TDiskVolume.DefragmentVolume:Boolean;
var
 Recognizer:TRecognizer;
begin
 {}
 //To Do //Event callback
 Result:=False;

 if not WriterLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskVolume.DefragmentVolume (Name= ' + Name + ')');
  {$ENDIF}

  if FDriver = nil then Exit;
  if FDevice = nil then Exit;
  if FVolumeNo = 0 then Exit;
  
  {Get the Recognizer}
  Recognizer:=FDriver.GetRecognizerByVolume(Self,True,FILESYS_LOCK_READ);
  if Recognizer <> nil then
   begin
    try
     {Check for Defragger}
     if Recognizer.Defragger = nil then Exit;
     if not Recognizer.Defragger.AcceptVolume(Self) then Exit;
    
     {Defragment Volume}
     Result:=Recognizer.Defragger.DefragmentVolume(Self);
    finally
     {Unlock Recognizer}
     Recognizer.ReaderUnlock;
    end;   
   end;
 finally  
  WriterUnlock;
 end; 
end;

{==============================================================================}

function TDiskVolume.ConvertVolume(AFileSysType:TFileSysType):Boolean;
var
 Recognizer:TRecognizer;
begin
 {}
 //To Do //Event callback
 Result:=False;

 if not WriterLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskVolume.ConvertVolume (Name= ' + Name + ')');
  {$ENDIF}

  if FDriver = nil then Exit;
  if FDevice = nil then Exit;
  if FVolumeNo = 0 then Exit;
  
  {Get the Recognizer}
  Recognizer:=FDriver.GetRecognizerByVolume(Self,True,FILESYS_LOCK_READ);
  if Recognizer <> nil then
   begin
    try
     {Check for Converter}
     if Recognizer.Converter = nil then Exit;
     if not Recognizer.Converter.AcceptVolume(Self,AFileSysType) then Exit;
    
     {Converter Volume}
     Result:=Recognizer.Converter.ConvertVolume(Self,AFileSysType);
    finally
     {Unlock Recognizer}
     Recognizer.ReaderUnlock;
    end;   
   end;
 finally  
  WriterUnlock;
 end; 
end;

{==============================================================================}

function TDiskVolume.RepairVolume:Boolean;
var
 Recognizer:TRecognizer;
begin
 {}
 //To Do //Event callback
 Result:=False;

 if not WriterLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskVolume.RepairVolume (Name= ' + Name + ')');
  {$ENDIF}

  if FDriver = nil then Exit;
  if FDevice = nil then Exit;
  if FVolumeNo = 0 then Exit;
  
  {Get the Recognizer}
  Recognizer:=FDriver.GetRecognizerByVolume(Self,True,FILESYS_LOCK_READ);
  if Recognizer <> nil then
   begin
    try
     {Check for Repairer}
     if Recognizer.Repairer = nil then Exit;
     if not Recognizer.Repairer.AcceptVolume(Self) then Exit;
    
     {Repair Volume}
     Result:=Recognizer.Repairer.RepairVolume(Self);
    finally
     {Unlock Recognizer}
     Recognizer.ReaderUnlock;
    end;   
   end;
 finally  
  WriterUnlock;
 end; 
end;

{==============================================================================}

function TDiskVolume.CopyVolume(ADest:TDiskVolume):Boolean;
{Note: Caller must hold the dest writer lock}
var
 Recognizer:TRecognizer;
begin
 {}
 //To Do //Event callback
 Result:=False;

 if not WriterLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskVolume.CopyVolume (Name= ' + Name + ')');
  {$ENDIF}

  if FDriver = nil then Exit;
  if FDevice = nil then Exit;
  if FVolumeNo = 0 then Exit;
  
  {Get the Recognizer}
  Recognizer:=FDriver.GetRecognizerByVolume(Self,True,FILESYS_LOCK_READ);
  if Recognizer <> nil then
   begin
    try
     {Check for Copier}
     if Recognizer.Copier = nil then Exit;
     if not Recognizer.Copier.AcceptVolume(Self,ADest) then Exit;
    
     {Copy Volume}
     Result:=Recognizer.Copier.CopyVolume(Self,ADest);
    finally
     {Unlock Recognizer}
     Recognizer.ReaderUnlock;
    end;   
   end;
 finally  
  WriterUnlock;
 end; 
end;

{==============================================================================}

function TDiskVolume.ShrinkVolume(const AStart,ASize:Int64):Boolean;
var
 Recognizer:TRecognizer;
begin
 {}
 //To Do //Event callback
 Result:=False;

 if not WriterLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskVolume.ShrinkVolume (Name= ' + Name + ')');
  {$ENDIF}

  if FDriver = nil then Exit;
  if FDevice = nil then Exit;
  if FVolumeNo = 0 then Exit;
  
  {Get the Recognizer}
  Recognizer:=FDriver.GetRecognizerByVolume(Self,True,FILESYS_LOCK_READ);
  if Recognizer <> nil then
   begin
    try
     {Check for Resizer}
     if Recognizer.Resizer = nil then Exit;
     if not Recognizer.Resizer.AcceptVolume(Self,AStart,ASize) then Exit;
    
     {Shrink Volume}
     Result:=Recognizer.Resizer.ShrinkVolume(Self,AStart,ASize);
    finally
     {Unlock Recognizer}
     Recognizer.ReaderUnlock;
    end;   
   end;
 finally  
  WriterUnlock;
 end; 
end;

{==============================================================================}

function TDiskVolume.ExpandVolume(const AStart,ASize:Int64):Boolean;
var
 Recognizer:TRecognizer;
begin
 {}
 //To Do //Event callback
 Result:=False;

 if not WriterLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskVolume.ExpandVolume (Name= ' + Name + ')');
  {$ENDIF}

  if FDriver = nil then Exit;
  if FDevice = nil then Exit;
  if FVolumeNo = 0 then Exit;
  
  {Get the Recognizer}
  Recognizer:=FDriver.GetRecognizerByVolume(Self,True,FILESYS_LOCK_READ);
  if Recognizer <> nil then
   begin
    try
     {Check for Resizer}
     if Recognizer.Resizer = nil then Exit;
     if not Recognizer.Resizer.AcceptVolume(Self,AStart,ASize) then Exit;
    
     {Expand Volume}
     Result:=Recognizer.Resizer.ExpandVolume(Self,AStart,ASize);
    finally
     {Unlock Recognizer}
     Recognizer.ReaderUnlock;
    end;   
   end;
 finally  
  WriterUnlock;
 end; 
end;

{==============================================================================}

function TDiskVolume.OpenVolume(AMode:Integer):Integer;
var
 Count:Int64; {Temporary until SectorCount is Int64}
 Handle:TRawHandle;
begin
 {}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskVolume.OpenVolume (Name= ' + Name + ')');
  {$ENDIF}

  if Device = nil then Exit;
  if FDriver = nil then Exit;
  if Device.SectorSize = 0 then Exit;
  
  {Open the Handle}
  Handle:=FDriver.OpenRawHandle(nil,nil,Self,nil,AMode,True,FILESYS_LOCK_WRITE);
  if Handle = nil then Exit;
  
  {Set the Handle properties}
  Count:=SectorCount; {Temporary until SectorCount is Int64}
  Handle.Size:=(Count * Device.SectorSize); //To Do //shl Device.SectorShiftCount
  Handle.Position:=0;
  
  {Return the Handle}
  Result:=Handle.Handle;

  {Unlock Handle}
  Handle.WriterUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

procedure TDiskVolume.CloseVolume(AHandle:Integer);
var
 Handle:TRawHandle;
begin
 {}
 if FDriver = nil then Exit;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskVolume.OpenVolume (Name= ' + Name + ')');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('             Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}

  {Get the Handle}
  Handle:=FDriver.GetRawFromHandle(AHandle,True,FILESYS_LOCK_WRITE);
  if Handle = nil then Exit;
  
  {Close the Handle} {Do not unlock}
  FDriver.CloseRawHandle(Handle);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TDiskVolume.ReadVolume(AHandle:Integer;var ABuffer;ACount:Integer):Integer;
{Note: Raw Reads must be in Sector sized multiples}
var
 Start:Int64;
 Count:LongWord;
 Handle:TRawHandle;
begin
 {}
 Result:=0;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskVolume.ReadVolume (Name= ' + Name + ')');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('             Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}

  if Device = nil then Exit;
  if FDriver = nil then Exit;
  if Device.SectorSize = 0 then Exit;
  
  {Get the Handle}
  Handle:=FDriver.GetRawFromHandle(AHandle,True,FILESYS_LOCK_WRITE);
  if Handle = nil then Exit;
  try
   {Check the Mode}
   if Handle.OpenMode = fmOpenWrite then Exit;
  
   {Check for Sector Multiple}
   if (ACount mod Device.SectorSize) <> 0 then Exit;
  
   {Determine how many Sectors to Read and Starting Sector}
   Start:=Handle.Position div Device.SectorSize;                                 //To Do //shr Device.SectorShiftCount
   Count:=LongWord(ACount) div Device.SectorSize;                                //To Do //shr Device.SectorShiftCount
   if (StartSector + Start + Count) > Device.SectorCount then Exit;
  
   {Read to Buffer}
   if FDriver.Cache.DeviceRead(Device,StartSector + Start,Count,ABuffer) then
    begin
     Handle.Position:=Handle.Position + ACount;
     Result:=ACount;
    end;
  finally
   {Unlock Handle}
   Handle.WriterUnlock;
  end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TDiskVolume.WriteVolume(AHandle:Integer;const ABuffer;ACount:Integer):Integer;
{Note: Raw Writes must be in Sector sized multiples}
var
 Start:Int64;
 Count:LongWord;
 Handle:TRawHandle;
begin
 {}
 Result:=0;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskVolume.WriteVolume (Name= ' + Name + ')');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('             Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}

  if Device = nil then Exit;
  if FDriver = nil then Exit;
  if Device.SectorSize = 0 then Exit;
  
  {Get the Handle}
  Handle:=FDriver.GetRawFromHandle(AHandle,True,FILESYS_LOCK_WRITE);
  if Handle = nil then Exit;
  try
   {Check the Mode}
   if Handle.OpenMode = fmOpenRead then Exit;
  
   {Check for Sector Multiple}
   if (ACount mod Device.SectorSize) <> 0 then Exit;

   {Determine how many Sectors to Write and Starting Sector}
   Start:=Handle.Position div Device.SectorSize;                                 //To Do //shr Device.SectorShiftCount
   Count:=LongWord(ACount) div Device.SectorSize;                                //To Do //shr Device.SectorShiftCount
   if (StartSector + Start + Count) > Device.SectorCount then Exit;

   {Write from Buffer}
   if FDriver.Cache.DeviceWrite(Device,StartSector + Start,Count,ABuffer) then
    begin
     Handle.Position:=Handle.Position + ACount;
     Result:=ACount;
    end;
  finally
   {Unlock Handle}
   Handle.WriterUnlock;
  end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TDiskVolume.SeekVolume(AHandle:Integer;const AOffset:Int64;AOrigin:Integer):Int64;
{Note: Raw Seeks must be in Sector sized multiples}
{Note: Raw Seeks cannot extend the size of the Volume}
var
 Handle:TRawHandle;
begin
 {}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskVolume.SeekVolume (Name= ' + Name + ')');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('             Handle = ' + IntToHex(AHandle,8));
  {$ENDIF}

  if Device = nil then Exit;
  if FDriver = nil then Exit;
  if Device.SectorSize = 0 then Exit;
  
  {Get the Handle}
  Handle:=FDriver.GetRawFromHandle(AHandle,True,FILESYS_LOCK_WRITE);
  if Handle = nil then Exit;
  try
   {Check for Sector Multiple}
   if (AOffset mod Device.SectorSize) <> 0 then Exit;
  
   {Move Pointer}
   case AOrigin of
    soFromBeginning:begin
      {Check Offset}
      if AOffset < 0 then Exit;
      if AOffset > Handle.Size then Exit;
      Handle.Position:=AOffset;
      
      Result:=Handle.Position;
     end;
    soFromCurrent:begin
      {Check Offset}
      if (Handle.Position + AOffset) < 0 then Exit;
      if (Handle.Position + AOffset) > Handle.Size then Exit;
      Handle.Position:=(Handle.Position + AOffset);
      
      Result:=Handle.Position;
     end;
    soFromEnd:begin
      {Check Offset}
      if (Handle.Size + AOffset) < 0 then Exit;
      if (Handle.Size + AOffset) > Handle.Size then Exit;
      Handle.Position:=(Handle.Size + AOffset);
      
      Result:=Handle.Position;
     end;
   end;
  finally
   {Unlock Handle}
   Handle.WriterUnlock;
  end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}
{==============================================================================}
{TDiskImage}
constructor TDiskImage.Create(ADriver:TFileSysDriver;AController:TDiskController;const AName:String;AImageNo:Integer);
begin
 {}
 inherited Create;
 FLock:=SynchronizerCreate;
 FLocalLock:=MutexCreateEx(False,MUTEX_DEFAULT_SPINCOUNT,MUTEX_FLAG_RECURSIVE);
 
 FDriver:=ADriver;
 if FDriver <> nil then FDriver.AddImage(Self);
 FController:=AController;
 
 FName:=AName;
 UniqueString(FName);
 FImageNo:=AImageNo;

 FLocked:=False;
 FChanged:=False;
 FAttributes:=iaNone;

 FImageType:=itUNKNOWN;
 FMediaType:=mtUNKNOWN;
 FFloppyType:=ftUNKNOWN;

 FCylinders:=0;
 FHeads:=0;
 FSectors:=0;
 FLogicalShiftCount:=0;

 FSectorSize:=0;
 FSectorCount:=0;
 FSectorShiftCount:=0;

 FPartitionId:=pidUnused;
 FFileSysType:=fsUNKNOWN;

 FDevice:=nil;
end;

{==============================================================================}

destructor TDiskImage.Destroy;
begin
 {}
 WriterLock;
 try
  FDevice:=nil;
  
  FController:=nil;
  if FDriver <> nil then FDriver.RemoveImage(Self);
  FDriver:=nil;
  
  MutexDestroy(FLocalLock);
  inherited Destroy;
 finally 
  {WriterUnlock;} {Can destroy Synchronizer while holding lock}
  SynchronizerDestroy(FLock);
 end;
end;

{==============================================================================}

function TDiskImage.AcquireLock:Boolean;
begin
 {}
 Result:=(MutexLock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskImage.ReleaseLock:Boolean;
begin
 {}
 Result:=(MutexUnlock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskImage.GetReady:Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskImage.GetReadable:Boolean;
begin
 {}
 Result:=((FAttributes and iaReadable) = iaReadable);
end;

{==============================================================================}

function TDiskImage.GetWriteable:Boolean;
begin
 {}
 Result:=((FAttributes and iaWriteable) = iaWriteable);
end;

{==============================================================================}

function TDiskImage.GetEraseable:Boolean;
begin
 {}
 Result:=((FAttributes and iaEraseable) = iaEraseable);
end;

{==============================================================================}

function TDiskImage.GetCylinders:LongWord;
begin
 {Virtual Base Method - No Function}
 Result:=FCylinders;
end;

{==============================================================================}

function TDiskImage.GetHeads:LongWord;
begin
 {Virtual Base Method - No Function}
 Result:=FHeads;
end;

{==============================================================================}

function TDiskImage.GetSectors:LongWord;
begin
 {Virtual Base Method - No Function}
 Result:=FSectors;
end;

{==============================================================================}

function TDiskImage.GetLogicalShiftCount:Word;
begin
 {}
 Result:=0;
 
 if not AcquireLock then Exit;
 try
  if FCylinders = 0 then Exit;
 
  while (FCylinders shr Result) > 1024 do
   begin
    Inc(Result);
   end;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskImage.GetSectorSize:Word;
begin
 {Virtual Base Method - No Function}
 Result:=FSectorSize;
end;

{==============================================================================}

function TDiskImage.GetSectorCount:Int64;
begin
 {Virtual Base Method - No Function}
 Result:=FSectorCount;
end;

{==============================================================================}

function TDiskImage.GetSectorShiftCount:Word;
begin
 {}
 Result:=0;
 
 if not AcquireLock then Exit;
 try
  if FSectorSize = 0 then Exit;
 
  while (FSectorSize shr Result) > 1 do
   begin
    Inc(Result);
   end;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskImage.GetPartitionId:Byte;
begin
 {Virtual Base Method - No Function}
 Result:=FPartitionId;
end;

{==============================================================================}

function TDiskImage.GetName:String; 
begin
 {}
 Result:='';
 
 if not AcquireLock then Exit;
 
 Result:=FName;
 UniqueString(Result);
 
 ReleaseLock;
end;

{==============================================================================}

procedure TDiskImage.SetName(const AName:String);
begin
 {}
 if not AcquireLock then Exit;
 try
  if GetReady then Exit;
 
  FName:=AName;
  UniqueString(FName);
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

procedure TDiskImage.SetDevice(ADevice:TDiskDevice);
{Set the Device and Reinitialize the Device}
begin
 {}
 if not AcquireLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskImage.SetDevice');
  {$ENDIF}

  if FDriver = nil then Exit;
  if FDevice = ADevice then Exit;
 
  FDevice:=ADevice;
  if FDevice <> nil then FDevice.DeviceInit;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TDiskImage.ReaderLock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskImage.ReaderUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskImage.ReaderConvert:Boolean; 
{Convert a Reader lock to a Writer lock}
begin
 {}
 Result:=(SynchronizerReaderConvert(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskImage.WriterLock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskImage.WriterUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskImage.WriterConvert:Boolean;
{Convert a Writer lock to a Reader lock}
begin
 {}
 Result:=(SynchronizerWriterConvert(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskImage.WriterOwner:Boolean;
{Return True if the current thread is the writer owner}
begin
 {}
 Result:=(SynchronizerWriterOwner(FLock) = GetCurrentThreadID);
end;

{==============================================================================}

function TDiskImage.ImageInit:Boolean;
begin
 {Virtual Base Method}
 Result:=False;
 
 if not WriterLock then Exit;
 try
  if FDriver = nil then Exit;
  if FController = nil then Exit;
  if FImageNo = 0 then Exit;

  if not Ready then
   begin
    FLocked:=False;
    FChanged:=False;
    {FAttributes:=iaNone;}   {Do not Reset}

    {FImageType:=itUNKNOWN;} {Do not Reset}
    {FMediaType:=mtUNKNOWN;} {Do not Reset}
    FFloppyType:=ftUNKNOWN;

    FSectorSize:=0;
    FSectorCount:=0;
    FSectorShiftCount:=0;

    FCylinders:=0;
    FHeads:=0;
    FSectors:=0;
    FLogicalShiftCount:=0;

    FPartitionId:=pidUnused;
    FFileSysType:=fsUNKNOWN;
    
    Result:=True;
   end
  else
   begin
    {FLocked:=False;}        {Do not Reset}
    {FChanged:=False;}       {Do not Reset}
    {FAttributes:=iaNone;}   {Do not Reset}

    {FImageType:=itUNKNOWN;} {Do not Reset}
    {FMediaType:=mtUNKNOWN;} {Do not Reset}
    {FFloppyType:=ftUNKNOWN;}{Do not Reset}
 
    FSectorSize:=GetSectorSize;
    FSectorCount:=GetSectorCount;
    FSectorShiftCount:=GetSectorShiftCount;

    FSectors:=GetSectors;    {Must be SHC not CHS}
    FHeads:=GetHeads;
    FCylinders:=GetCylinders;
    FLogicalShiftCount:=GetLogicalShiftCount;

    FPartitionId:=GetPartitionId;
    FFileSysType:=fsUNKNOWN;
    
    Result:=True;
   end;
 finally  
  WriterUnlock;
 end; 
end;

{==============================================================================}

function TDiskImage.LockMedia:Boolean;
begin
 {}
 Result:=False;
 
 if FLocked then Exit;
 
 FLocked:=True;
 
 Result:=True;
end;

{==============================================================================}

function TDiskImage.UnlockMedia:Boolean;
begin
 {}
 Result:=False;
 
 if not FLocked then Exit;
 
 FLocked:=False;
 
 Result:=True;
end;

{==============================================================================}

function TDiskImage.EjectMedia:Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskImage.MediaReady:Boolean;
begin
 {}
 Result:=GetReady;
end;

{==============================================================================}

function TDiskImage.MediaChanged:Boolean;
begin
 {}
 Result:=FChanged;
end;

{==============================================================================}

function TDiskImage.MediaLocked:Boolean;
begin
 {}
 Result:=FLocked;
end;

{==============================================================================}

function TDiskImage.Read(ASector:LongWord;ACount:Word;var ABuffer):Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskImage.Write(ASector:LongWord;ACount:Word;const ABuffer):Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskImage.Allocated(ASector:LongWord;ACount:Word):Word;
{Used by Copier to determine allocated Sectors}
begin
 {Virtual Base Method}
 Result:=ACount; {Default to all Allocated}
end;

{==============================================================================}

function TDiskImage.MountImage:Boolean;
var
 Recognizer:TRecognizer;
begin
 {}
 Result:=False;
 
 if not WriterLock then Exit;
 try
  if FDriver = nil then Exit;
  if FImageNo = 0 then Exit;
 
  {Check for already Mounted}
  if FDevice = nil then
   begin
    {Get the Recognizer}
    Recognizer:=FDriver.GetRecognizerByImage(Self,True,FILESYS_LOCK_READ);
    if Recognizer <> nil then
     begin
      {Mount Image}
      Result:=Recognizer.MountImage(Self);
      
      {Unlock Recognizer}
      Recognizer.ReaderUnlock;
     end;
   end
  else
   begin
    Result:=True;
   end; 
 finally  
  WriterUnlock;
 end; 
end;

{==============================================================================}

function TDiskImage.DismountImage:Boolean;
var
 Recognizer:TRecognizer;
begin
 {}
 Result:=False;

 if not WriterLock then Exit;
 try
  if FDriver = nil then Exit;
  if FImageNo = 0 then Exit;
  
  {Check for not Mounted}
  if FDevice = nil then Exit;
  
  {Get the Recognizer}
  Recognizer:=FDriver.GetRecognizerByImage(Self,True,FILESYS_LOCK_READ);
  if Recognizer <> nil then
   begin
    {Dismount Image}
    Result:=Recognizer.DismountImage(Self);

    {Unlock Recognizer}
    Recognizer.ReaderUnlock;
   end;
 finally  
  WriterUnlock;
 end; 
end;

{==============================================================================}

function TDiskImage.InsertImage:Boolean;
var
 Recognizer:TRecognizer;
begin
 {}
 Result:=False;

 if not WriterLock then Exit;
 try
  if FDriver = nil then Exit;
  if FImageNo = 0 then Exit;
  
  {Check for not Mounted}
  if FDevice = nil then Exit;
  
  {Get the Recognizer}
  Recognizer:=FDriver.GetRecognizerByImage(Self,True,FILESYS_LOCK_READ);
  if Recognizer <> nil then
   begin
    {Insert Image}
    Result:=Recognizer.InsertImage(Self);

    {Unlock Recognizer}
    Recognizer.ReaderUnlock;
   end;
 finally  
  WriterUnlock;
 end; 
end;

{==============================================================================}

function TDiskImage.EjectImage:Boolean;
var
 Recognizer:TRecognizer;
begin
 {}
 Result:=False;

 if not WriterLock then Exit;
 try
  if FDriver = nil then Exit;
  if FImageNo = 0 then Exit;
  
  {Check for not Mounted}
  if FDevice = nil then Exit;
  
  {Get the Recognizer}
  Recognizer:=FDriver.GetRecognizerByImage(Self,True,FILESYS_LOCK_READ);
  if Recognizer <> nil then
   begin
    {Dismount Image}
    Result:=Recognizer.EjectImage(Self);

    {Unlock Recognizer}
    Recognizer.ReaderUnlock;
   end;
 finally  
  WriterUnlock;
 end; 
end;

{==============================================================================}

function TDiskImage.ConvertImage(AImageType:TImageType):Boolean;
var
 Recognizer:TRecognizer;
begin
 {}
 //To Do //Event callback
 Result:=False;

 if not WriterLock then Exit;
 try
  if FDriver = nil then Exit;
  if FImageNo = 0 then Exit;
  
  {Get the Recognizer}
  Recognizer:=FDriver.GetRecognizerByImage(Self,True,FILESYS_LOCK_READ);
  if Recognizer <> nil then
   begin
    try
     {Check for Converter}
     if Recognizer.Converter = nil then Exit;
     if not Recognizer.Converter.AcceptImage(Self,AImageType) then Exit;
    
     {Convert Image}
     Result:=Recognizer.Converter.ConvertImage(Self,AImageType);
    finally
     {Unlock Recognizer}
     Recognizer.ReaderUnlock;
    end;   
   end;
 finally  
  WriterUnlock;
 end; 
end;

{==============================================================================}

function TDiskImage.CopyImage(ADest:TDiskImage):Boolean;
{Note: Caller must hold the dest writer lock}
var
 Recognizer:TRecognizer;
begin
 {}
 //To Do //Event callback
 Result:=False;

 if not WriterLock then Exit;
 try
  if FDriver = nil then Exit;
  if FImageNo = 0 then Exit;
  
  {Get the Recognizer}
  Recognizer:=FDriver.GetRecognizerByImage(Self,True,FILESYS_LOCK_READ);
  if Recognizer <> nil then
   begin
    try
     {Check for Copier}
     if Recognizer.Copier = nil then Exit;
     if not Recognizer.Copier.AcceptImage(Self,ADest) then Exit;
    
     {Convert Image}
     Result:=Recognizer.Copier.CopyImage(Self,ADest);
    finally
     {Unlock Recognizer}
     Recognizer.ReaderUnlock;
    end;   
   end;
 finally  
  WriterUnlock;
 end; 
end;

{==============================================================================}

function TDiskImage.ShrinkImage(const ASize:Int64):Boolean;
var
 Recognizer:TRecognizer;
begin
 {}
 //To Do //Event callback
 Result:=False;

 if not WriterLock then Exit;
 try
  if FDriver = nil then Exit;
  if FImageNo = 0 then Exit;
  
  {Get the Recognizer}
  Recognizer:=FDriver.GetRecognizerByImage(Self,True,FILESYS_LOCK_READ); 
  if Recognizer <> nil then
   begin
    try
     {Check for Resizer}
     if Recognizer.Resizer = nil then Exit;
     if not Recognizer.Resizer.AcceptImage(Self,ASize) then Exit;
    
     {Shrink Image}
     Result:=Recognizer.Resizer.ShrinkImage(Self,ASize);
    finally
     {Unlock Recognizer}
     Recognizer.ReaderUnlock;
    end;   
   end;
 finally  
  WriterUnlock;
 end; 
end;

{==============================================================================}

function TDiskImage.ExpandImage(const ASize:Int64):Boolean;
var
 Recognizer:TRecognizer;
begin
 {}
 //To Do //Event callback
 Result:=False;
 
 if not WriterLock then Exit;
 try
  if FDriver = nil then Exit;
  if FImageNo = 0 then Exit;
  
  {Get the Recognizer}
  Recognizer:=FDriver.GetRecognizerByImage(Self,True,FILESYS_LOCK_READ); 
  if Recognizer <> nil then
   begin
    try
     {Check for Resizer}
     if Recognizer.Resizer = nil then Exit;
     if not Recognizer.Resizer.AcceptImage(Self,ASize) then Exit;
    
     {Expand Image}
     Result:=Recognizer.Resizer.ExpandImage(Self,ASize);
    finally
     {Unlock Recognizer}
     Recognizer.ReaderUnlock;
    end;   
   end;
 finally  
  WriterUnlock;
 end; 
end;

{==============================================================================}

function TDiskImage.CreateImage(AMediaType:TMediaType;AFloppyType:TFloppyType;AAttributes:LongWord;ASectorSize:Word;const ASectorCount:Int64;ACylinders,AHeads,ASectors:LongWord;APartitionId:Byte):Integer;
{Used by Imager to perform Create Image}
begin
 {Virtual Base Method - No Function}
 Result:=0; {Return is an ImageNo}
end;

{==============================================================================}

function TDiskImage.OpenImage(AMediaType:TMediaType;AFloppyType:TFloppyType;AAttributes:LongWord;ASectorSize:Word;const ASectorCount:Int64;ACylinders,AHeads,ASectors:LongWord;APartitionId:Byte):Integer;
{Used by Imager to perform Open Image}
begin
 {Virtual Base Method - No Function}
 Result:=0; {Return is an ImageNo}
end;

{==============================================================================}

function TDiskImage.CloseImage:Boolean;
{Used by Imager to perform Close Image}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskImage.ResizeImage(const ASectorCount:Int64):Boolean;
{Used by Resizer to perform Shrink or Expand Image}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskImage.CreateSnapshot:Boolean;
{Used by Imager to perform Create Snapshot}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskImage.DeleteSnapshot:Boolean;
{Used by Imager to perform Delete Snapshot}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskImage.MergeSnapshot:Boolean;
{Used by Imager to perform Merge Snapshot}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}
{==============================================================================}
{TRecognizer}
constructor TRecognizer.Create(ADriver:TFileSysDriver);
begin
 {}
 inherited Create;
 FLock:=SynchronizerCreate;
 FLocalLock:=MutexCreate;
 
 FAllowDrive:=True;
 FAllowDefault:=False;
 FDirtyCheck:=True;
 FQuickCheck:=True;
 FDriver:=ADriver;
 if FDriver <> nil then FDriver.AddRecognizer(Self);
 FPartitioner:=nil;
 FFormatter:=nil;
 FDefragger:=nil;
 FConverter:=nil;
 FRepairer:=nil;
 FResizer:=nil;
 FCopier:=nil;
 FImager:=nil;
end;

{==============================================================================}

destructor TRecognizer.Destroy;
begin
 {}
 WriterLock;
 try
  if FPartitioner <> nil then FPartitioner.Free;
  if FFormatter <> nil then FFormatter.Free;
  if FDefragger <> nil then FDefragger.Free;
  if FConverter <> nil then FConverter.Free;
  if FRepairer <> nil then FRepairer.Free;
  if FResizer <> nil then FResizer.Free;
  if FCopier <> nil then FCopier.Free;
  if FImager <> nil then FImager.Free;
  if FDriver <> nil then FDriver.RemoveRecognizer(Self);
  FDriver:=nil;
  
  MutexDestroy(FLocalLock);
  inherited Destroy;
 finally 
  {WriterUnlock;} {Can destroy Synchronizer while holding lock}
  SynchronizerDestroy(FLock);
 end;
end;

{==============================================================================}

function TRecognizer.AcquireLock:Boolean;
begin
 {}
 Result:=(MutexLock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TRecognizer.ReleaseLock:Boolean;
begin
 {}
 Result:=(MutexUnlock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TRecognizer.GetName:String;
begin
 {Virtual Base Method - No Function}
 Result:='Unknown';
end;

{==============================================================================}

function TRecognizer.ReaderLock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TRecognizer.ReaderUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TRecognizer.ReaderConvert:Boolean; 
{Convert a Reader lock to a Writer lock}
begin
 {}
 Result:=(SynchronizerReaderConvert(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TRecognizer.WriterLock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TRecognizer.WriterUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TRecognizer.WriterConvert:Boolean;
{Convert a Writer lock to a Reader lock}
begin
 {}
 Result:=(SynchronizerWriterConvert(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TRecognizer.RecognizePartitionId(APartitionId:Byte):Boolean; 
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TRecognizer.RecognizeBootSector(ABootSector:PBootSector;const AStartSector,ASectorCount:Int64):Boolean; 
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TRecognizer.RecognizePartition(APartition:TDiskPartition):Boolean;
{Note: Caller must hold the partition lock}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TRecognizer.RecognizeVolume(AVolume:TDiskVolume):Boolean;
{Note: Caller must hold the volume lock}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TRecognizer.MountVolume(AVolume:TDiskVolume;ADrive:TDiskDrive):Boolean;
{Note: Caller must hold the volume and drive locks}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TRecognizer.DismountVolume(AVolume:TDiskVolume):Boolean;
{Note: Dismount does not free the Volume only the FileSystem and Drive(s)}
{Note: Caller must hold the volume writer lock}
var
 Drive:TDiskDrive;
 FileSystem:TFileSystem;
begin
 {Base Implementation}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;
  if AVolume = nil then Exit;

  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TRecognizer.DismountVolume - Volume = ' + AVolume.Name);
  {$ENDIF}
  
  {Remove any FileSystem using the Volume}
  FileSystem:=FDriver.GetFileSystemByVolume(AVolume,True,FILESYS_LOCK_WRITE);
  while FileSystem <> nil do
   begin
    {Note: The FileSystem will automatically unbind from any volume/drive when Destroyed}
    FileSystem.DismountFileSystem;
    FileSystem.Free;
    
    FileSystem:=FDriver.GetFileSystemByVolume(AVolume,True,FILESYS_LOCK_WRITE);
   end;
  
  {Remove any Drive using the Volume}
  Drive:=FDriver.GetDriveByVolume(AVolume,True,FILESYS_LOCK_WRITE);
  while Drive <> nil do
   begin
    Drive.Free;
    
    Drive:=FDriver.GetDriveByVolume(AVolume,True,FILESYS_LOCK_WRITE);
   end;
   
  Result:=True;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TRecognizer.RecognizeImage(AImage:TDiskImage):Boolean;
{Note: Caller must hold the image lock}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TRecognizer.MountImage(AImage:TDiskImage):Boolean;
{Note: Caller must hold the image lock}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TRecognizer.DismountImage(AImage:TDiskImage):Boolean;
{Note: Dismount closes the Image and frees Device, Partitions, Volumes, Drives}
{Note: Caller must hold the image lock}
var
 Device:TDiskDevice;
begin
 {Base Implementation}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;
  if AImage = nil then Exit;
  if FImager = nil then Exit;

  {Check Ready}
  if not AImage.Ready then Exit;

  {Remove any Device using the Image}
  Device:=FDriver.GetDeviceByImage(AImage,True,FILESYS_LOCK_WRITE);
  while Device <> nil do
   begin
    Device.Free;
    
    Device:=FDriver.GetDeviceByImage(AImage,True,FILESYS_LOCK_WRITE);
   end;
   
  {Close the Image}
  Result:=FImager.CloseImage(AImage);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TRecognizer.InsertImage(AImage:TDiskImage):Boolean;
{Note: Caller must hold the image lock}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TRecognizer.EjectImage(AImage:TDiskImage):Boolean;
{Note: Eject closes the Image but does not free Device, Partitions, Volumes, Drives}
{Note: Caller must hold the image writer lock}
var
 Device:TDiskDevice;
 Volume:TDiskVolume;
 Drive:TDiskDrive;
 FileSystem:TFileSystem;
begin
 {Base Implementation}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;
  if AImage = nil then Exit;
  if FImager = nil then Exit;

  {Check Ready}
  if not AImage.Ready then Exit;
 
  {Get the Device}
  Device:=FDriver.GetDeviceByImage(AImage,True,FILESYS_LOCK_WRITE);
  if Device = nil then Exit;
  try
   {Check for Removable}
   if not Device.Removable then Exit;
   if Device.MediaLocked then Exit;

   {Release any CachePages on the Device}
   FDriver.Cache.ReleaseDevicePages(Device);

   {Close the Image}
   FImager.CloseImage(AImage);

   {Initialize the Device}
   Device.DeviceInit;

   {Get the Volume}
   Volume:=FDriver.GetVolumeByDevice(Device,True,FILESYS_LOCK_WRITE);
   if Volume = nil then Exit;
   try
    Volume.VolumeInit;
   
    {Get the FileSystem}
    FileSystem:=FDriver.GetFileSystemByVolume(Volume,True,FILESYS_LOCK_WRITE);
    if FileSystem = nil then Exit;
    FileSystem.DismountFileSystem;
    FileSystem.Free; {Note: The FileSystem will automatically unbind from any volume/drive when Destroyed}

    {Get the Drive}
    Drive:=FDriver.GetDriveByDevice(Device,True,FILESYS_LOCK_WRITE);
    if Drive <> nil then
     begin
      Drive.DriveInit;

      {Unlock Drive}
      Drive.WriterUnlock;
     end; 

    Result:=True;
   finally 
    {Unlock Volume}
    Volume.WriterUnlock;
   end; 
  finally
   {Unlock Device}
   Device.WriterUnlock;
  end;  
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}
{==============================================================================}
{TRedirector}
constructor TRedirector.Create(ADriver:TFileSysDriver);
begin
 {}
 inherited Create;
 FLock:=SynchronizerCreate;
 FLocalLock:=MutexCreate;

 FDriver:=ADriver;
 if FDriver <> nil then FDriver.AddRedirector(Self);
end;

{==============================================================================}

destructor TRedirector.Destroy;
begin
 {}
 WriterLock;
 try
  if FDriver <> nil then FDriver.RemoveRedirector(Self);
  FDriver:=nil;
  
  MutexDestroy(FLocalLock);
  inherited Destroy;
 finally 
  {WriterUnlock;} {Can destroy Synchronizer while holding lock}
  SynchronizerDestroy(FLock);
 end;
end;

{==============================================================================}

function TRedirector.AcquireLock:Boolean;
begin
 {}
 Result:=(MutexLock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TRedirector.ReleaseLock:Boolean;
begin
 {}
 Result:=(MutexUnlock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TRedirector.ReaderLock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TRedirector.ReaderUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TRedirector.WriterLock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TRedirector.WriterUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TRedirector.LocateDrives:Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TRedirector.RedirectPath(const APath:String):Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TRedirector.RedirectDrive(ADrive:TDiskDrive):Boolean;
{Note: Caller must hold the drive lock}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TRedirector.AttachPath(const APath:String;ADrive:TDiskDrive):Boolean;
{Note: Caller must hold the drive lock}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TRedirector.DetachDrive(ADrive:TDiskDrive):Boolean;
{Note: Detach does not free the Drive only the FileSystem}
{Note: Caller must hold the drive writer lock}
var
 FileSystem:TFileSystem;
begin
 {Base Implementation}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;
  if ADrive = nil then Exit;

  {Remove any FileSystem using the Drive}
  FileSystem:=FDriver.GetFileSystemByDrive(ADrive,True,FILESYS_LOCK_WRITE);
  while FileSystem <> nil do
   begin
    {Note: The FileSystem will automatically unbind from the volume/drive when Destroyed}
    FileSystem.DismountFileSystem;
    FileSystem.Free;
    
    FileSystem:=FDriver.GetFileSystemByDrive(ADrive,True,FILESYS_LOCK_WRITE);
   end;
 
  Result:=True;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}
{==============================================================================}
{TDiskPartitioner}
constructor TDiskPartitioner.Create(ADriver:TFileSysDriver;ARecognizer:TRecognizer);
begin
 {}
 inherited Create;
 FLock:=SynchronizerCreate;
 FLocalLock:=MutexCreate;
 
 FDriver:=ADriver;
 FRecognizer:=ARecognizer;
 
 FInitChar:=0;
end;

{==============================================================================}

destructor TDiskPartitioner.Destroy;
begin
 {}
 WriterLock;
 try
  FRecognizer:=nil;
  FDriver:=nil;
  
  MutexDestroy(FLocalLock);
  inherited Destroy;
 finally 
  {WriterUnlock;} {Can destroy Synchronizer while holding lock}
  SynchronizerDestroy(FLock);
 end;
end;

{==============================================================================}

function TDiskPartitioner.AcquireLock:Boolean;
begin
 {}
 Result:=(MutexLock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskPartitioner.ReleaseLock:Boolean;
begin
 {}
 Result:=(MutexUnlock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskPartitioner.CheckLogical(ADevice:TDiskDevice;AParent:TDiskPartition;APartitionId:Byte):Boolean;
{Check if the Partition is of a Logical type}
{Note: Caller must hold the device and partition lock}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskPartitioner.CheckExtended(ADevice:TDiskDevice;AParent:TDiskPartition;APartitionId:Byte):Boolean;
{Check if the Partition is of an Extended type}
{Note: Caller must hold the device and partition lock}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskPartitioner.GetLogicalChild(ADevice:TDiskDevice;APartition:TDiskPartition;ALock:Boolean;AState:LongWord):TDiskPartition;
{Get the logical Child for an extended partition based on Parent}
{Note: Used to find the logical child of a Partition being deleted}
{Note: Caller must hold the device and partition lock}
var
 Count:Integer;
 Partition:TDiskPartition;
begin
 {}
 Result:=nil;
 
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskPartitioner.GetLogicalChild');
 {$ENDIF}
 
 if ADevice = nil then Exit;
 if APartition = nil then Exit;

 {Check Partition}
 if not APartition.Extended then Exit;
 
 {Get Child}
 for Count:=MIN_PARTITION to MAX_EXTENDED do {Only 2 on Extended}
  begin
   Partition:=FDriver.GetPartitionByEntryNo(ADevice,APartition,Count,True,FILESYS_LOCK_READ);
   if Partition <> nil then
    begin
     {Check for Logical}
     if Partition.Logical then
      begin
       {Lock Partition} 
       if ALock then
        begin
         {Convert Partition}
         if AState = FILESYS_LOCK_WRITE then Partition.ReaderConvert;
        end
       else
        begin
         {Unlock Partition}
         Partition.ReaderUnlock;
        end;        
       
       Result:=Partition;
       Exit;
      end
     else
      begin
       {Unlock Partition}
       Partition.ReaderUnlock;
      end;      
    end;
  end;
end;

{==============================================================================}

function TDiskPartitioner.GetExtendedSibling(ADevice:TDiskDevice;AParent:TDiskPartition;ALock:Boolean;AState:LongWord):TDiskPartition;
{Get the next Sibling for an extended partition based on Parent}
{Note: Passed Parent should be the actual Parent}
{Note: Also used to find the next sibling of a Partition being deleted}
{Note: Caller must hold the device and partition lock}
var
 Count:Integer;
 Partition:TDiskPartition;
begin
 {}
 Result:=nil;
 
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskPartitioner.GetExtendedSibling');
 {$ENDIF}
 
 if ADevice = nil then Exit;
 if AParent = nil then Exit;

 {Check Parent}
 if not AParent.Extended then Exit;
 
 {Get Sibling}
 for Count:=MIN_PARTITION to MAX_EXTENDED do {Only 2 on Extended}
  begin
   Partition:=FDriver.GetPartitionByEntryNo(ADevice,AParent,Count,True,FILESYS_LOCK_READ);
   if Partition <> nil then
    begin
     {Check for Extended}
     if Partition.Extended then
      begin
       {Lock Partition} 
       if ALock then
        begin
         {Convert Partition}
         if AState = FILESYS_LOCK_WRITE then Partition.ReaderConvert;
        end
       else
        begin
         {Unlock Partition}
         Partition.ReaderUnlock;
        end;        
       
       Result:=Partition;
       Exit;
      end
     else
      begin
       {Unlock Partition}
       Partition.ReaderUnlock;
      end;      
    end;
  end;
end;

{==============================================================================}

function TDiskPartitioner.GetExtendedParent(ADevice:TDiskDevice;AParent:TDiskPartition;AStart:LongWord;ALock:Boolean;AState:LongWord):TDiskPartition;
{Get the actual Parent for an extended partition based on Start sector}
{Note: Passed Parent should be the Root extended}
{Note: Caller must hold the device and partition lock}
var
 Count:Integer;
 Partitions:TList;
 Current:TDiskPartition;
 Partition:TDiskPartition;
begin
 {}
 Result:=nil;
 
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskPartitioner.GetExtendedParent');
 {$ENDIF}
 
 if ADevice = nil then Exit;
 if AParent = nil then Exit;

 {Check Parent}
 if not AParent.Extended then Exit;
 
 {Default to Parent}
 Result:=AParent;
 
 {Set Default}
 Current:=nil;
 
 {Get Partitions}
 Partitions:=FDriver.GetPartitionsByPartition(AParent,True,FILESYS_LOCK_READ);
 try
  {Sort by Start}
  Partitions.Sort(ComparePartitions);
  
  {Check each Partition} {in Reverse Order}
  for Count:=Partitions.Count - 1 downto 0 do
   begin
    if Partitions.Items[Count] <> nil then
     begin
      Partition:=TDiskPartition(Partitions.Items[Count]); {Locked by GetPartitionsByPartition}
      
      {Check for Extended}
      if (Partition.Extended) and (Partition.StartSector <= AStart) then
       begin
        {Lock Partition} 
        if ALock then
         begin
          {Convert Partition}
          if AState = FILESYS_LOCK_WRITE then Partition.ReaderConvert;
         end
        else
         begin
          {Unlock Partition}
          Partition.ReaderUnlock;
         end;        
        
        {Save Result}
        Current:=Partition;
        
        Result:=Partition;
        Exit;
       end;
     end;
   end;
 finally
  {Unlock each Partition}
  for Count:=0 to Partitions.Count - 1 do
   begin
    if Partitions.Items[Count] <> nil then
     begin
      Partition:=TDiskPartition(Partitions.Items[Count]); {Locked by GetPartitionsByPartition}
 
      {Unlock Partition}
      if Partition <> Current then Partition.ReaderUnlock;
     end;
   end;

  {Free Partitions}   
  Partitions.Free;
 end;
end;

{==============================================================================}

function TDiskPartitioner.GetEndCHS(ADevice:TDiskDevice;AStart,ACount:LongWord;var ACylinder,AHead,ASector:Word):Boolean;
{Get the End CHS values or dummy values if larger than 8GB}
{Start and Count must be Cylinder aligned when passed}
{Note: Caller must hold the device lock}
var
 Head:LongWord;
 Heads:LongWord;
 Sector:LongWord;
 Sectors:LongWord;
 Cylinder:LongWord;
 Cylinders:LongWord;
begin
 {Base Implementation}
 Result:=False;
 
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskPartitioner.GetEndCHS');
 if FILESYS_LOG_ENABLED then FileSysLogDebug('                  Start = ' + IntToStr(AStart));
 if FILESYS_LOG_ENABLED then FileSysLogDebug('                  Count = ' + IntToStr(ACount));
 {$ENDIF}
 
 if ACount = 0 then Exit;
 if ADevice = nil then Exit;
 if ADevice.Controller = nil then Exit;

 {Get CHS Values}
 Heads:=ADevice.PhysicalHeads;
 Sectors:=ADevice.PhysicalSectors;
 Cylinders:=ADevice.PhysicalCylinders;
 if (Heads = 0) or (Sectors = 0) or (Cylinders = 0) or (Cylinders > 1024) then
  begin
   {Use Logical Values}
   Heads:=ADevice.LogicalHeads;
   Sectors:=ADevice.LogicalSectors;
   Cylinders:=ADevice.LogicalCylinders;
   if (Heads = 0) or (Sectors = 0) or (Cylinders = 0) then Exit;
   
   {Check Alignment}
   if ((AStart + ACount) mod Sectors) <> 0 then Exit; {Not minus one}
   
   {Get End LCHS}
   Result:=ADevice.Controller.LBAtoLCHS(ADevice,AStart + ACount - 1,ACylinder,AHead,ASector);
  end
 else
  begin
   {Use Physical Values}
   {Check Alignment}
   if ((AStart + ACount) mod Sectors) <> 0 then Exit;
   
   {Get End PCHS}
   if not ADevice.Controller.LBAtoPCHS(ADevice,AStart + ACount - 1,Cylinder,Head,Sector) then Exit;
   AHead:=Head;
   ASector:=Sector;
   ACylinder:=Cylinder;
   
   Result:=True;
  end;
end;

{==============================================================================}

function TDiskPartitioner.GetStartCHS(ADevice:TDiskDevice;AStart,ACount:LongWord;var ACylinder,AHead,ASector:Word):Boolean;
{Get the Start CHS values or dummy values if larger than 8GB}
{Start and Count must be Cylinder aligned when passed}
{Note: Caller must hold the device lock}
var
 Head:LongWord;
 Heads:LongWord;
 Sector:LongWord;
 Sectors:LongWord;
 Cylinder:LongWord;
 Cylinders:LongWord;
begin
 {Base Implementation}
 Result:=False;
 
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskPartitioner.GetStartCHS');
 if FILESYS_LOG_ENABLED then FileSysLogDebug('                  Start = ' + IntToStr(AStart));
 if FILESYS_LOG_ENABLED then FileSysLogDebug('                  Count = ' + IntToStr(ACount));
 {$ENDIF}
 
 if ACount = 0 then Exit;
 if ADevice = nil then Exit;
 if ADevice.Controller = nil then Exit;

 {Get CHS Values}
 Heads:=ADevice.PhysicalHeads;
 Sectors:=ADevice.PhysicalSectors;
 Cylinders:=ADevice.PhysicalCylinders;
 if (Heads = 0) or (Sectors = 0) or (Cylinders = 0) or (Cylinders > 1024) then
  begin
   {Use Logical Values}
   Heads:=ADevice.LogicalHeads;
   Sectors:=ADevice.LogicalSectors;
   Cylinders:=ADevice.LogicalCylinders;
   if (Heads = 0) or (Sectors = 0) or (Cylinders = 0) then Exit;
   
   {Check Alignment}
   if (AStart mod Sectors) <> 0 then Exit;
   
   {Get Start LCHS}
   Result:=ADevice.Controller.LBAtoLCHS(ADevice,AStart,ACylinder,AHead,ASector);
  end
 else
  begin
   {Use Physical Values}
   {Check Alignment}
   if (AStart mod Sectors) <> 0 then Exit;
   
   {Get Start PCHS}
   if not ADevice.Controller.LBAtoPCHS(ADevice,AStart,Cylinder,Head,Sector) then Exit;
   AHead:=Head;
   ASector:=Sector;
   ACylinder:=Cylinder;
   
   Result:=True;
  end;
end;

{==============================================================================}

function TDiskPartitioner.GetSectorCount(ADevice:TDiskDevice;AStart,ACount:LongWord):LongWord;
{Determine the actual sector Count given an actual Start sector and nominal sector Count}
{The actual result will be a Count that is aligned to a Cylinder boundary}
{Start must be Cylinder aligned when passed}
{Note: Caller must hold the device lock}
var
 Count:LongWord;
 Heads:LongWord;
 Sectors:LongWord;
 WorkInt:LongWord;
begin
 {Base Implementation}
 Result:=0;
 
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskPartitioner.GetSectorCount');
 if FILESYS_LOG_ENABLED then FileSysLogDebug('                  Start = ' + IntToStr(AStart));
 if FILESYS_LOG_ENABLED then FileSysLogDebug('                  Count = ' + IntToStr(ACount));
 {$ENDIF}
 
 if ACount = 0 then Exit;
 if ADevice = nil then Exit;

 {Get Physical Values}
 Heads:=ADevice.PhysicalHeads;
 Sectors:=ADevice.PhysicalSectors;
 if (Heads = 0) or (Sectors = 0) or (ADevice.PhysicalCylinders > 1024) then
  begin
   {Get Logical Values}
   Heads:=ADevice.LogicalHeads;
   Sectors:=ADevice.LogicalSectors;
   if (Heads = 0) or (Sectors = 0) then Exit;
  end;
 
 {Check Count}
 if ACount < (Heads * Sectors) then Exit;
 
 {Get Count}
 Count:=AStart + ACount;
 
 {Align Count to Head}
 if (Count mod Sectors) <> 0 then
  begin
   {Move back}
   Count:=Count - (Count mod Sectors);
  end;
 
 {Align Count to Cylinder}
 WorkInt:=(Count div Sectors);
 if (WorkInt mod Heads) <> 0 then
  begin
   {Move back}
   Count:=Count - ((WorkInt mod Heads) * Sectors);
  end;
 
 {Return Count}
 Result:=Count - AStart;
 
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('                  Result = ' + IntToStr(Result));
 {$ENDIF}
end;

{==============================================================================}

function TDiskPartitioner.GetStartSector(ADevice:TDiskDevice;AExtended,ALogical:Boolean;AStart:LongWord;var ACount:LongWord):LongWord;
{Determine the actual Start sector given a nominal Start sector}
{The actual result will be a Start that is aligned to a Cylinder boundary}
{Note: For first Partition (not Extended) and Logical the Start is aligned to a Head boundary}
{Note: Caller must hold the device lock}
var
 Start:LongWord;
 Heads:LongWord;
 Sectors:LongWord;
 WorkInt:LongWord;
begin
 {Base Implementation}
 Result:=0;
 
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskPartitioner.GetStartSector');
 if FILESYS_LOG_ENABLED then FileSysLogDebug('                  Start = ' + IntToStr(AStart));
 if FILESYS_LOG_ENABLED then FileSysLogDebug('                  Count = ' + IntToStr(ACount));
 {$ENDIF}
 
 if ACount = 0 then Exit;
 if ADevice = nil then Exit;

 {Get Physical Values}
 Heads:=ADevice.PhysicalHeads;
 Sectors:=ADevice.PhysicalSectors;
 if (Heads = 0) or (Sectors = 0) or (ADevice.PhysicalCylinders > 1024) then
  begin
   {Get Logical Values}
   Heads:=ADevice.LogicalHeads;
   Sectors:=ADevice.LogicalSectors;
   if (Heads = 0) or (Sectors = 0) then Exit;
  end;
 
 {Check Count}
 if ACount < (Heads * Sectors) then Exit;
 
 {Get Start}
 Start:=AStart;
 
 {Align Start to Head}
 if (Start mod Sectors) <> 0 then
  begin
   {Adjust Count}
   ACount:=ACount - (Sectors - (Start mod Sectors));
   
   {Move forward}
   Start:=Start + (Sectors - (Start mod Sectors));
  end;
 
 {Allow for First/Extended/Logical}
 if ((Start >= (Heads * Sectors)) or (AExtended)) and not(ALogical) then
  begin
   {Align Start to Cylinder}
   WorkInt:=(Start div Sectors);
   if (WorkInt mod Heads) <> 0 then
    begin
     {Adjust Count}
     ACount:=ACount - ((Heads - (WorkInt mod Heads)) * Sectors);
     
     {Move forward}
     Start:=Start + ((Heads - (WorkInt mod Heads)) * Sectors);
    end;
  end;
 
 {Return Start}
 Result:=Start;
 
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('                  Result = ' + IntToStr(Result));
 {$ENDIF}
end;

{==============================================================================}

function TDiskPartitioner.GetSectorOffset(ADevice:TDiskDevice;AParent:TDiskPartition;AExtended:Boolean;AStart:LongWord):LongWord;
{Determine the actual sector Offset given an actual Start sector}
{Accounts for Offset behaviour of second level extended and logical partitions}
{Start must be Cylinder aligned when passed}
{Note: Caller must hold the device and partition lock}
begin
 {Base Implementation}
 Result:=0;
 
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskPartitioner.GetSectorOffset');
 if FILESYS_LOG_ENABLED then FileSysLogDebug('                  Start = ' + IntToStr(AStart));
 {$ENDIF}
 
 if ADevice = nil then Exit;

 if AParent = nil then
  begin
   {First Level - Offset equals Start}
   Result:=AStart;
  end
 else
  begin
   {Second Level}
   if AExtended then
    begin
     {Extended - Offset is from Root}
     Result:=AStart - AParent.StartSector;
     if AParent.Root <> nil then
      begin
       Result:=AStart - AParent.Root.StartSector;
      end;
    end
   else
    begin
     {Logical - Offset is from Parent}
     Result:=AStart - AParent.StartSector;
    end;
  end;
  
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('                  Result = ' + IntToStr(Result));
 {$ENDIF}
end;

{==============================================================================}

function TDiskPartitioner.GetPartitionId(ADevice:TDiskDevice;AParent:TDiskPartition;AStart,ACount:LongWord;APartitionId:Byte):Byte;
{Determine the actual partition Type given a Start, Count and nominal Type}
{Note: Caller must hold the device and partition lock}
begin
 {Base Implementation} {Will be overridden by most Partitioners}
 Result:=APartitionId;
end;

{==============================================================================}

function TDiskPartitioner.InitPartition(ADevice:TDiskDevice;AParent:TDiskPartition;AStart,ACount:LongWord;APartitionId:Byte):Boolean;
{Perform any initialization of a new partition such as filling the boot sector etc}
{Note: Start is the absolute start sector on the device}
{Note: Caller must hold the device and partition lock}
begin
 {Base Implementation} {Will be overridden by most Partitioners}
 Result:=False;
 
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskPartitioner.InitPartition');
 if FILESYS_LOG_ENABLED then FileSysLogDebug('                  Start = ' + IntToStr(AStart));
 if FILESYS_LOG_ENABLED then FileSysLogDebug('                  Count = ' + IntToStr(ACount));
 if FILESYS_LOG_ENABLED then FileSysLogDebug('                  PartitionId = ' + PartitionIdToString(APartitionId));
 {$ENDIF}
 
 if ACount = 0 then Exit;
 if ADevice = nil then Exit;
 
 Result:=FillSectors(ADevice,nil,AStart,1,FInitChar);
end;

{==============================================================================}

function TDiskPartitioner.CreatePartitionRecord(ADevice:TDiskDevice;ARecord:PPartitionRecord):Boolean;
{Check for a valid Partition record (or Master Boot Record)}
{Create an empty Partition record (or Master Boot Record) if not valid}
{Note: Caller must hold the device lock}
begin
 {}
 Result:=False;
 
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskPartitioner.CreatePartitionRecord');
 {$ENDIF}
 
 if ARecord = nil then Exit;

 {Check Signature}
 if ARecord.Signature <> PARTITION_RECORD_SIGNATURE then
  begin
   {Check Device}
   if ADevice = nil then Exit;
   if ADevice.SectorSize = 0 then Exit;
   
   {Initialize Partition Record (or Master Boot Record)}
   FillChar(ARecord^,ADevice.SectorSize,0);
   PMasterBootRecord(ARecord).BootCode:=MasterBootCode;
   ARecord.Signature:=PARTITION_RECORD_SIGNATURE;
  end;
 
 Result:=True;
end;

{==============================================================================}

function TDiskPartitioner.CreatePartitionEntry(ADevice:TDiskDevice;AStart,ACount,AOffset:LongWord;APartitionId:Byte;AActive:Boolean;var AEntry:TPartitionEntry):Boolean;
{Fill the Partitition entry with the supplied values}
{Note: Caller must hold the device lock}
var
 Head:Word;
 Sector:Word;
 Cylinder:Word;
begin
 {}
 Result:=False;
 
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskPartitioner.CreatePartitionEntry');
 if FILESYS_LOG_ENABLED then FileSysLogDebug('                  Start = ' + IntToStr(AStart));
 if FILESYS_LOG_ENABLED then FileSysLogDebug('                  Count = ' + IntToStr(ACount));
 if FILESYS_LOG_ENABLED then FileSysLogDebug('                  Offset = ' + IntToStr(AOffset));
 if FILESYS_LOG_ENABLED then FileSysLogDebug('                  PartitionId = ' + PartitionIdToString(APartitionId));
 {$ENDIF}
 
 if ADevice = nil then Exit;

 {Create Entry}
 FillChar(AEntry,SizeOf(TPartitionEntry),0);
 AEntry.BootIndicator:=$00;
 if AActive then AEntry.BootIndicator:=$80;
 AEntry.TypeIndicator:=APartitionId;
 AEntry.SectorOffset:=AOffset;
 AEntry.SectorCount:=ACount;
 
 {Set Start CHS}
 if not GetStartCHS(ADevice,AStart,ACount,Cylinder,Head,Sector) then Exit;
 AEntry.StartHead:=Head;
 AEntry.StartCylinder:=(Cylinder and $FF);
 AEntry.StartSector:=(Cylinder and $300) shr 2;
 AEntry.StartSector:=AEntry.StartSector + (Sector and $3F);
 
 {Set End CHS}
 if not GetEndCHS(ADevice,AStart,ACount,Cylinder,Head,Sector) then Exit;
 AEntry.EndHead:=Head;
 AEntry.EndCylinder:=(Cylinder and $FF);
 AEntry.EndSector:=(Cylinder and $300) shr 2;
 AEntry.EndSector:=AEntry.EndSector + (Sector and $3F);
 
 Result:=True;
end;

{==============================================================================}

function TDiskPartitioner.FillSectors(ADevice:TDiskDevice;APartition:TDiskPartition;ASector,ACount:LongWord;AValue:Byte):Boolean;
{Fill specified number of sectors with the supplied value}
{Note: Sector is relative to the StartSector of the Partition}
{Note: Caller must hold the device and partition lock}
var
 Buffer:Pointer;
begin
 {Base Implementation}
 Result:=False;
 
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskPartitioner.FillSectors');
 if FILESYS_LOG_ENABLED then FileSysLogDebug('                  Sector = ' + IntToStr(ASector));
 if FILESYS_LOG_ENABLED then FileSysLogDebug('                  Count = ' + IntToStr(ACount));
 if FILESYS_LOG_ENABLED then FileSysLogDebug('                  Value = ' + IntToStr(AValue));
 {$ENDIF}
 
 if ADevice = nil then Exit;
 if ADevice.SectorSize = 0 then Exit;

 {Allocate Buffer}
 Buffer:=GetMem(ADevice.SectorSize);
 if Buffer = nil then Exit;
 try
  {Fill Sectors}
  while ACount > 0 do
   begin
    {Read Sector} {Dont need to read first}
    {if not ReadSectors(ADevice,APartition,ASector,1,Buffer^) then Exit;}
    
    {Fill Sector}
    FillChar(Buffer^,ADevice.SectorSize,AValue);
    
    {Write Sector}
    if not WriteSectors(ADevice,APartition,ASector,1,Buffer^) then Exit;
    
    Inc(ASector);
    Dec(ACount);
   end;
  
  Result:=True;
 finally
  FreeMem(Buffer);
 end;
end;

{==============================================================================}

function TDiskPartitioner.ReadSectors(ADevice:TDiskDevice;APartition:TDiskPartition;ASector,ACount:LongWord;var ABuffer):Boolean;
{Read Sectors from the Device or Partition using Cache}
{Note: Sector is relative to the StartSector of the Device or Partition}
{Note: Caller must hold the device and partition lock, cache will serialize access to device}
begin
 {Base Implementation}
 Result:=False;
 
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskPartitioner.ReadSectors');
 if FILESYS_LOG_ENABLED then FileSysLogDebug('                  Sector = ' + IntToStr(ASector));
 if FILESYS_LOG_ENABLED then FileSysLogDebug('                  Count = ' + IntToStr(ACount));
 {$ENDIF}
 
 if FDriver = nil then Exit;
 if ADevice = nil then Exit;
 if ADevice.SectorCount = 0 then Exit;
 
 if APartition = nil then
  begin
   {Device Read}
   Result:=FDriver.Cache.DeviceRead(ADevice,ASector,ACount,ABuffer);
  end
 else
  begin
   {Partition Read}
   if APartition.SectorCount = 0 then Exit;
   if APartition.Device <> ADevice then Exit;
   
   Result:=FDriver.Cache.DeviceRead(ADevice,APartition.StartSector + ASector,ACount,ABuffer);
  end;
end;

{==============================================================================}

function TDiskPartitioner.WriteSectors(ADevice:TDiskDevice;APartition:TDiskPartition;ASector,ACount:LongWord;const ABuffer):Boolean;
{Write Sectors to the Device or Partition using Cache}
{Note: Sector is relative to the StartSector of the Device or Partition}
{Note: Caller must hold the device and partition lock, cache will serialize access to device}
begin
 {Base Implementation}
 Result:=False;
 
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskPartitioner.WriteSectors');
 if FILESYS_LOG_ENABLED then FileSysLogDebug('                  Sector = ' + IntToStr(ASector));
 if FILESYS_LOG_ENABLED then FileSysLogDebug('                  Count = ' + IntToStr(ACount));
 {$ENDIF}
 
 if FDriver = nil then Exit;
 if ADevice = nil then Exit;
 if ADevice.SectorCount = 0 then Exit;
 
 if APartition = nil then
  begin
   {Device Write}
   Result:=FDriver.Cache.DeviceWrite(ADevice,ASector,ACount,ABuffer);
  end
 else
  begin
   {Partition Write}
   if APartition.SectorCount = 0 then Exit;
   if APartition.Device <> ADevice then Exit;
   
   Result:=FDriver.Cache.DeviceWrite(ADevice,APartition.StartSector + ASector,ACount,ABuffer);
  end;
end;

{==============================================================================}

function TDiskPartitioner.ReaderLock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskPartitioner.ReaderUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskPartitioner.WriterLock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskPartitioner.WriterUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskPartitioner.AcceptPartition(ADevice:TDiskDevice;APartition,AParent:TDiskPartition;APartitionId:Byte):Boolean;
{Check if the Partition can be accepted for Create, Delete, Modify, Activate}
{Note: Caller must hold the device and partition and parent lock}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskPartitioner.CreatePartition(ADevice:TDiskDevice;AParent:TDiskPartition;APartitionId:Byte;ACount:LongWord;AActive:Boolean):Boolean;
{Create a new Partition on the specified Device with the specified Parent (Optional)}
{Note: When creating Logical partitions the passed Parent must be the Root Extended}
{Note: Caller must hold the device and parent writer locks}
var
 Start:LongWord;
 Count:LongWord;
 Offset:LongWord;
 EntryNo:Integer;
 LargeStart:Int64;
 LargeCount:Int64;
 PartitionId:Byte;
 SiblingNo:Integer;
 Volume:TDiskVolume;
 Parent:TDiskPartition;
 Sibling:TDiskPartition;
 SiblingEntry:TPartitionEntry;
 PartitionEntry:TPartitionEntry;
 PartitionRecord:PPartitionRecord; {Always use Partition Record}
begin
 {Base Implementation}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TDiskPartitioner.CreatePartition');
  {$ENDIF}

  if FDriver = nil then Exit;
  if FRecognizer = nil then Exit;
  if ADevice = nil then Exit;

  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                 Device = ' + ADevice.Name);
  {$ENDIF}
  
  {Check Accepted} {Pass null for Partition}
  if not AcceptPartition(ADevice,nil,AParent,APartitionId) then Exit;

  {Allocate Buffer}
  if ADevice.SectorSize = 0 then Exit;
  PartitionRecord:=GetMem(ADevice.SectorSize);
  if PartitionRecord = nil then Exit;
  try
   {Check Level}
   if AParent = nil then
    begin
     {First Level}
     {Check Partitions}
     if FDriver.GetPartitionByDevice(ADevice,False,FILESYS_LOCK_NONE) = nil then {Do not lock}
      begin
       {Check Volume}
       Volume:=FDriver.GetVolumeByDevice(ADevice,True,FILESYS_LOCK_WRITE);
       if Volume <> nil then
        begin
         {Check File System Type}
         if Volume.FileSysType = fsUNKNOWN then
          begin
           {Remove Volume}
           Volume.Free;
          end
         else
          begin
           {Unlock Volume}
           Volume.WriterUnlock;
           
           {Error, should have failed AcceptPartition}
           Exit;
          end;          
        end;    
      end;

     {Read Partition Record}
     if not ReadSectors(ADevice,nil,0,1,PartitionRecord^) then Exit;
     
     {Check Partition Record}
     if not CreatePartitionRecord(ADevice,PartitionRecord) then Exit;
     
     {Get Start and Count}
     if not ADevice.GetAvailableBlock(LargeStart,LargeCount) then Exit;
     if (LargeStart > $FFFFFFFF) or (LargeCount < ACount) then Exit;
     
     {Adjust Start and Count}
     Start:=LargeStart;
     Count:=ACount;
     Start:=GetStartSector(ADevice,CheckExtended(ADevice,nil,APartitionId),False,Start,Count);
     if Start = 0 then Exit;
     Count:=GetSectorCount(ADevice,Start,Count);
     if Count = 0 then Exit;
     
     {Get Offset}
     Offset:=GetSectorOffset(ADevice,nil,False,Start);
     if Offset = 0 then Exit;
     
     {Get Entry No}
     EntryNo:=0;
     while FDriver.GetPartitionByEntryNo(ADevice,nil,EntryNo,False,FILESYS_LOCK_NONE) <> nil do {Do not lock}
      begin
       Inc(EntryNo);
       if EntryNo > MAX_PARTITION then Exit;
      end;
     
     {Get PartitionId}
     PartitionId:=GetPartitionId(ADevice,nil,Start,Count,APartitionId);
     if PartitionId = pidUnused then Exit;
     
     {Get Active}
     AActive:=(AActive) and not(CheckExtended(ADevice,nil,PartitionId));
     
     {Create Entry}
     if not CreatePartitionEntry(ADevice,Start,Count,Offset,PartitionId,AActive,PartitionEntry) then Exit;
     
     {Set Entry}
     PartitionRecord.PartitionTable.PartitionEntry[EntryNo]:=PartitionEntry;
     
     {Initialize Partition}
     if not InitPartition(ADevice,nil,Start,Count,PartitionId) then Exit;
     
     {Write Partition Record}
     if not WriteSectors(ADevice,nil,0,1,PartitionRecord^) then Exit;
     
     {Locate Partitions, Volumes and Drives}
     ADevice.LocatePartitions; {Device only}
     FDriver.LocateVolumes;
     FDriver.LocateDrives;
    end
   else
    begin
     {$IFDEF FILESYS_DEBUG}
     if FILESYS_LOG_ENABLED then FileSysLogDebug('                 Parent = ' + AParent.Name);
     {$ENDIF}
    
     {Note: Accept forces Parent to be Root extended and Id to be non extended}
     if AParent.EntryNo = -1 then Exit;
     
     {Second Level}
     {Get Start and Count}
     if not AParent.GetAvailableBlock(Start,Count) then Exit;
     if Count < ACount then Exit;
     Count:=ACount;
     
     {Get Actual Parent}
     Parent:=GetExtendedParent(ADevice,AParent,Start,True,FILESYS_LOCK_WRITE);
     if Parent = nil then Exit;
     //To Do //Critical //Unlock //Actual instead of Parent?

     {$IFDEF FILESYS_DEBUG}
     if FILESYS_LOG_ENABLED then FileSysLogDebug('                 Parent = ' + Parent.Name);
     {$ENDIF}
     
     {Get Sibling} {of Actual Parent}
     Sibling:=GetExtendedSibling(ADevice,Parent,True,FILESYS_LOCK_WRITE);
     try
      {Create Extended} {if not First Logical}
      if (Parent <> AParent) or ((Parent = AParent) and (GetLogicalChild(ADevice,AParent,False,FILESYS_LOCK_NONE) <> nil)) then {Do not lock}
       begin
        {Read Partition Record} {of Actual Parent}
        if not ReadSectors(ADevice,Parent,0,1,PartitionRecord^) then Exit;
        
        {Check Partition Record}
        if not CreatePartitionRecord(ADevice,PartitionRecord) then Exit;
       
        {Adjust Start and Count}
        Start:=GetStartSector(ADevice,True,False,Start,Count);
        if Start = 0 then Exit;
        Count:=GetSectorCount(ADevice,Start,Count);
        if Count = 0 then Exit;
       
        {Get Offset}
        Offset:=GetSectorOffset(ADevice,Parent,True,Start);
        if Offset = 0 then Exit;
       
        {Check Sibling}
        if Sibling = nil then
         begin
          SiblingNo:=-1;
         
          {Get Entry No}
          EntryNo:=1; {Extended always goes in EntryNo 1}
          if FDriver.GetPartitionByEntryNo(ADevice,Parent,EntryNo,False,FILESYS_LOCK_NONE) <> nil then Exit; {Do not lock}
         end
        else
         begin
          {$IFDEF FILESYS_DEBUG}
          if FILESYS_LOG_ENABLED then FileSysLogDebug('                 Sibling = ' + Sibling.Name);
          {$ENDIF}
          
          if Sibling.EntryNo = -1 then Exit;
          
          {Get Entry No}
          EntryNo:=Sibling.EntryNo;  {Reuse the Sibling EntryNo}
         
          {Get Sibling Entry}
          SiblingEntry:=PartitionRecord.PartitionTable.PartitionEntry[Sibling.EntryNo];
         
          {Unlink Sibling}
          SiblingNo:=Sibling.EntryNo;
          Sibling.EntryNo:=-1;
         end;
        
        {Get PartitionId} {for Extended Partition}
        PartitionId:=GetPartitionId(ADevice,Parent,Start,Count,pidExtended);
        if PartitionId = pidUnused then Exit;
       
        {Create Entry}
        if not CreatePartitionEntry(ADevice,Start,Count,Offset,PartitionId,False,PartitionEntry) then Exit;
        
        {Set Entry}
        PartitionRecord.PartitionTable.PartitionEntry[EntryNo]:=PartitionEntry;
       
        {Initialize Partition}
        if not InitPartition(ADevice,Parent,Start,Count,PartitionId) then Exit;
       
        {Write Partition Record} {of Actual Parent}
        if not WriteSectors(ADevice,Parent,0,1,PartitionRecord^) then Exit;
       
        {Locate Partitions} {on Actual Parent}
        Parent.LocatePartitions;
       
        {Get Created Parent}
        Parent:=FDriver.GetPartitionByEntryNo(ADevice,Parent,EntryNo,True,FILESYS_LOCK_WRITE);
        if Parent = nil then Exit;
        //To Do //Critical //Unlock  //Created instead of Parent?
        
        {Get Start and Count}
        Start:=Parent.StartSector + 1;
        Count:=Parent.SectorCount - 1;
       
        {Check Sibling}
        if Sibling <> nil then
         begin
          {Read Partition Record} {of Created Parent}
          if not ReadSectors(ADevice,Parent,0,1,PartitionRecord^) then Exit;
         
          {Check Partition Record}
          if not CreatePartitionRecord(ADevice,PartitionRecord) then Exit;
         
          {Relink Sibling}
          Sibling.EntryNo:=SiblingNo;
          
          {Set Sibling Entry}
          PartitionRecord.PartitionTable.PartitionEntry[Sibling.EntryNo]:=SiblingEntry;
          Sibling.FPartition:=Parent;
         
          {Write Partition Record} {of Created Parent}
          if not WriteSectors(ADevice,Parent,0,1,PartitionRecord^) then Exit;
         end;
       end;
     finally
      {Unlock Sibling}
      if Sibling <> nil then Sibling.WriterUnlock;
     end;
     
     {Create Logical}
     {Read Partition Record} {of Actual Parent}
     if not ReadSectors(ADevice,Parent,0,1,PartitionRecord^) then Exit;
     
     {Check Partition Record}
     if not CreatePartitionRecord(ADevice,PartitionRecord) then Exit;
     
     {Adjust Start and Count}
     Start:=GetStartSector(ADevice,False,True,Start,Count);
     if Start = 0 then Exit;
     Count:=GetSectorCount(ADevice,Start,Count);
     if Count = 0 then Exit;
     
     {Get Offset}
     Offset:=GetSectorOffset(ADevice,Parent,False,Start);
     if Offset = 0 then Exit;
     
     {Get Entry No}
     EntryNo:=0;
     while FDriver.GetPartitionByEntryNo(ADevice,Parent,EntryNo,False,FILESYS_LOCK_NONE) <> nil do {Do not lock}
      begin
       Inc(EntryNo);
       if EntryNo > MAX_EXTENDED then Exit; {Only 2 on Extended}
      end;
     
     {Get PartitionId}
     PartitionId:=GetPartitionId(ADevice,Parent,Start,Count,APartitionId);
     if PartitionId = pidUnused then Exit;
     
     {Create Entry}
     if not CreatePartitionEntry(ADevice,Start,Count,Offset,PartitionId,False,PartitionEntry) then Exit;
     
     {Set Entry}
     PartitionRecord.PartitionTable.PartitionEntry[EntryNo]:=PartitionEntry;
     
     {Initialize Partition}
     if not InitPartition(ADevice,Parent,Start,Count,PartitionId) then Exit;
     
     {Write Partition Record} {of Actual Parent}
     if not WriteSectors(ADevice,Parent,0,1,PartitionRecord^) then Exit;
     
     {Locate Partitions, Volumes and Drives}
     Parent.LocatePartitions; {Parent only}
     FDriver.LocateVolumes;
     FDriver.LocateDrives;
    end;
   
   Result:=True;
  finally
   FreeMem(PartitionRecord);
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TDiskPartitioner.DeletePartition(APartition:TDiskPartition):Boolean;
{Delete the specified Partition from the specified Device}
{Note: Caller must hold the device and partition writer locks}
var
 Device:TDiskDevice;
 Volume:TDiskVolume;
 Root:TDiskPartition;
 Child:TDiskPartition;
 Parent:TDiskPartition;
 Sibling:TDiskPartition;
 PartitionEntry:TPartitionEntry;
 PartitionRecord:PPartitionRecord; {Always use Partition Record}
begin
 {Base Implementation}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;
  if FRecognizer = nil then Exit;
  if APartition = nil then Exit;
  if APartition.EntryNo = -1 then Exit;

  {Check Accepted} {Pass Unused for Id}
  if not AcceptPartition(APartition.Device,APartition,APartition.Partition,pidUnused) then Exit;

  {Dismount Volume}
  Volume:=FDriver.GetVolumeByPartition(APartition,True,FILESYS_LOCK_WRITE);
  if Volume <> nil then
   begin
    Volume.DismountVolume; 
   
    {Unlock Volume}
    Volume.WriterUnlock;
   end;   

  {Allocate Buffer}
  if APartition.Device = nil then Exit;
  if APartition.Device.SectorSize = 0 then Exit;
  PartitionRecord:=GetMem(APartition.Device.SectorSize);
  if PartitionRecord = nil then Exit;
  try
   {Check Level}
   if APartition.Partition = nil then
    begin
     {First Level}
     {Read Partition Record}
     if not ReadSectors(APartition.Device,nil,0,1,PartitionRecord^) then Exit;
     
     {Check Signature}
     if PartitionRecord.Signature <> PARTITION_RECORD_SIGNATURE then Exit;
     
     {Get Entry}
     PartitionEntry:=PartitionRecord.PartitionTable.PartitionEntry[APartition.EntryNo];
     
     {Clear Entry}
     FillChar(PartitionEntry,SizeOf(TPartitionEntry),0);
     
     {Set Entry}
     PartitionRecord.PartitionTable.PartitionEntry[APartition.EntryNo]:=PartitionEntry;
     
     {Write Partition Record}
     if not WriteSectors(APartition.Device,nil,0,1,PartitionRecord^) then Exit;
     
     {Get Device}
     Device:=APartition.Device;
     
     {Delete Partition}
     APartition.Free;
     
     {Check Partitions}
     if FDriver.GetPartitionByDevice(Device,False,FILESYS_LOCK_NONE) = nil then {Do not lock}
      begin
       {Locate Volumes and Drives}
       FDriver.LocateVolumes;
       FDriver.LocateDrives;
      end;
    end
   else
    begin
     if APartition.Partition.EntryNo = -1 then Exit;
     
     {Second Level}
     {Get Root and Parent}
     Root:=APartition.Root; //To Do //Lock //Use CheckPartition ?
     Parent:=APartition.Partition; //To Do //Lock //Use CheckPartition ?
     
     {Read Partition Record}
     if not ReadSectors(APartition.Device,Parent,0,1,PartitionRecord^) then Exit;
     
     {Check Signature}
     if PartitionRecord.Signature <> PARTITION_RECORD_SIGNATURE then Exit;
     
     {Get Entry}
     PartitionEntry:=PartitionRecord.PartitionTable.PartitionEntry[APartition.EntryNo];
     
     {Check Extended}
     if APartition.Extended then
      begin
       {Get Child} {of Partition not Parent}
       Child:=GetLogicalChild(APartition.Device,APartition,True,FILESYS_LOCK_WRITE);
       if Child = nil then
        begin
         {Delete Extended}
         {Get Sibling} {of Partition not Parent}
         Sibling:=GetExtendedSibling(APartition.Device,APartition,True,FILESYS_LOCK_WRITE);
         if Sibling = nil then
          begin
           {Delete Partition}
           {Clear Entry}
           FillChar(PartitionEntry,SizeOf(TPartitionEntry),0);
           
           {Set Entry}
           PartitionRecord.PartitionTable.PartitionEntry[APartition.EntryNo]:=PartitionEntry;
           
           {Write Partition Record}
           if not WriteSectors(APartition.Device,Parent,0,1,PartitionRecord^) then Exit;
           
           {Delete Partition}
           APartition.Free;
          end
         else
          begin
           try
            if Sibling.EntryNo = -1 then Exit;
           
            {Move Sibling}
            {Read Partition Record} {from Partition not Parent}
            if not ReadSectors(APartition.Device,APartition,0,1,PartitionRecord^) then Exit;
           
            {Check Signature}
            if PartitionRecord.Signature <> PARTITION_RECORD_SIGNATURE then Exit;
            
            {Get Sibling Entry}
            PartitionEntry:=PartitionRecord.PartitionTable.PartitionEntry[Sibling.EntryNo];
            
            {Read Partition Record} {from Parent}
            if not ReadSectors(APartition.Device,Parent,0,1,PartitionRecord^) then Exit;
           
            {Set Sibling Entry}
            PartitionRecord.PartitionTable.PartitionEntry[APartition.EntryNo]:=PartitionEntry;
            Sibling.FPartition:=Parent;
           
            {Write Partition Record}
            if not WriteSectors(APartition.Device,Parent,0,1,PartitionRecord^) then Exit;
           
            {Delete Partition}
            APartition.Free;
           finally
            {Unlock Sibling}
            Sibling.WriterUnlock;
           end;           
          end;
        end
       else
        begin
         {Delete Child} {Do not unlock}
         if not DeletePartition(Child) then Exit;
        end;
      end
     else
      begin
       {Delete Logical}
       {Clear Entry}
       FillChar(PartitionEntry,SizeOf(TPartitionEntry),0);
       
       {Set Entry}
       PartitionRecord.PartitionTable.PartitionEntry[APartition.EntryNo]:=PartitionEntry;
       
       {Write Partition Record}
       if not WriteSectors(APartition.Device,Parent,0,1,PartitionRecord^) then Exit;
       
       {Delete Partition}
       APartition.Free;
       
       {Delete Parent if not Root}
       if Parent <> Root then if not DeletePartition(Parent) then Exit; //To Do //Lock //see above
      end;
    end;
   
   Result:=True;
  finally
   FreeMem(PartitionRecord);
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TDiskPartitioner.ModifyPartition(APartition:TDiskPartition;APartitionId:Byte;AOverride:Boolean):Boolean;
{Modify the type of the specified Partition}
{Note: Override disables the normalisation of PartitionId to suit size and type}
{      and also disables dismount and remount of any volumes and drives etc}
{Note: Caller must hold the partition writer lock}
var
 PartitionId:Byte;
 Volume:TDiskVolume;
 PartitionEntry:TPartitionEntry;
 PartitionRecord:PPartitionRecord; {Always use Partition Record}
begin
 {Base Implementation}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;
  if FRecognizer = nil then Exit;
  if APartition = nil then Exit;
  if APartition.EntryNo = -1 then Exit;

  {Check Accepted} {Pass new Id for Id}
  if not AcceptPartition(APartition.Device,APartition,APartition.Partition,APartitionId) then Exit;

  {Dismount Volume}
  Volume:=nil;
  if not AOverride then Volume:=FDriver.GetVolumeByPartition(APartition,True,FILESYS_LOCK_WRITE);
  if Volume <> nil then
   begin
    Volume.DismountVolume;

    {Unlock Volume}
    Volume.WriterUnlock;
   end; 

  {Allocate Buffer} 
  if APartition.Device = nil then Exit;
  if APartition.Device.SectorSize = 0 then Exit;
  PartitionRecord:=GetMem(APartition.Device.SectorSize);
  if PartitionRecord = nil then Exit;
  try
   {Read Partition Record}
   if not ReadSectors(APartition.Device,APartition.Partition,0,1,PartitionRecord^) then Exit;
   
   {Check Signature}
   if PartitionRecord.Signature <> PARTITION_RECORD_SIGNATURE then Exit;
   
   {Get Entry}
   PartitionEntry:=PartitionRecord.PartitionTable.PartitionEntry[APartition.EntryNo];
   
   {Get PartitionId}
   PartitionId:=GetPartitionId(APartition.Device,APartition.Partition,APartition.StartSector,APartition.SectorCount,APartitionId);
   if AOverride then PartitionId:=APartitionId;
   if PartitionId = pidUnused then Exit;
   
   {Check PartitionId}
   if PartitionEntry.TypeIndicator <> PartitionId then
    begin
     {Set PartitionId}
     PartitionEntry.TypeIndicator:=PartitionId;
     PartitionRecord.PartitionTable.PartitionEntry[APartition.EntryNo]:=PartitionEntry;
     APartition.FPartitionId:=PartitionId;
     
     {Write Partition Record}
     if not WriteSectors(APartition.Device,APartition.Partition,0,1,PartitionRecord^) then Exit;
    end;
  
   {Locate Volumes and Drives}
   if not AOverride then FDriver.LocateVolumes;
   if not AOverride then FDriver.LocateDrives;
   
   Result:=True;
  finally
   FreeMem(PartitionRecord);
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TDiskPartitioner.ActivatePartition(APartition:TDiskPartition;AActive:Boolean):Boolean;
{Make the specified Partition active and all siblings inactive}
{Also allows making the specified Partition inactive}
{Note: No need to check for Extended as AcceptPartition does}
{Note: Caller must hold the partition writer lock}
var
 Sibling:TDiskPartition;
 PartitionEntry:TPartitionEntry;
 PartitionRecord:PPartitionRecord; {Always use Partition Record}
begin
 {Base Implementation}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;
  if FRecognizer = nil then Exit;
  if APartition = nil then Exit;
  if APartition.EntryNo = -1 then Exit;

  {Check Accepted} {Pass current Id for Id}
  if not AcceptPartition(APartition.Device,APartition,APartition.Partition,APartition.PartitionId) then Exit;

  {Allocate Buffer}
  if APartition.Device = nil then Exit;
  if APartition.Device.SectorSize = 0 then Exit;
  PartitionRecord:=GetMem(APartition.Device.SectorSize);
  if PartitionRecord = nil then Exit;
  try
   {Read Partition Record}
   if not ReadSectors(APartition.Device,APartition.Partition,0,1,PartitionRecord^) then Exit;
   
   {Check Signature}
   if PartitionRecord.Signature <> PARTITION_RECORD_SIGNATURE then Exit;
   
   {Get Entry}
   PartitionEntry:=PartitionRecord.PartitionTable.PartitionEntry[APartition.EntryNo];
   
   {Check Active}
   if ((PartitionEntry.BootIndicator and $80) = $80) <> AActive then
    begin
     {Check Active}
     if AActive then
      begin
       {Set Active}
       PartitionEntry.BootIndicator:=(PartitionEntry.BootIndicator or $80);
       PartitionRecord.PartitionTable.PartitionEntry[APartition.EntryNo]:=PartitionEntry;
       
       APartition.FActive:=True;
       
       {Get Siblings}
       Sibling:=FDriver.GetPartitionByNext(nil,True,False,FILESYS_LOCK_READ); //To Do //If we have a WriterLock on the passed partition this will deadlock ?
       while Sibling <> nil do
        begin
         {Check for Partition on same Device with same Parent and not current Partition}
         if (Sibling <> APartition) and (Sibling.Device = APartition.Device) and (Sibling.Partition = APartition.Partition) and (Sibling.EntryNo <> -1) then
          begin
           {Get Entry}
           PartitionEntry:=PartitionRecord.PartitionTable.PartitionEntry[Sibling.EntryNo];
           
           {Remove Active}
           PartitionEntry.BootIndicator:=(PartitionEntry.BootIndicator and not($80));
           PartitionRecord.PartitionTable.PartitionEntry[Sibling.EntryNo]:=PartitionEntry;
           
           Sibling.FActive:=False;
          end;
          
         Sibling:=FDriver.GetPartitionByNext(Sibling,True,True,FILESYS_LOCK_READ); //To Do //If we have a WriterLock on the passed partition this will deadlock ?
        end;
      end
     else
      begin
       {Set Inactive}
       PartitionEntry.BootIndicator:=$00;
       PartitionRecord.PartitionTable.PartitionEntry[APartition.EntryNo]:=PartitionEntry;
       
       APartition.FActive:=False;
      end;
     
     {Write Partition Record}
     if not WriteSectors(APartition.Device,APartition.Partition,0,1,PartitionRecord^) then Exit;
    end;
   
   Result:=True;
  finally
   FreeMem(PartitionRecord);
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}
{==============================================================================}
{TDiskFormatter}
constructor TDiskFormatter.Create(ADriver:TFileSysDriver;ARecognizer:TRecognizer);
begin
 {}
 inherited Create;
 FLock:=SynchronizerCreate;
 FLocalLock:=MutexCreate;
 
 FDriver:=ADriver;
 FRecognizer:=ARecognizer;
end;

{==============================================================================}

destructor TDiskFormatter.Destroy;
begin
 {}
 WriterLock;
 try
  FRecognizer:=nil;
  FDriver:=nil;
 
  MutexDestroy(FLocalLock);
  inherited Destroy;
 finally 
  {WriterUnlock;} {Can destroy Synchronizer while holding lock}
  SynchronizerDestroy(FLock);
 end;
end;

{==============================================================================}

function TDiskFormatter.AcquireLock:Boolean;
begin
 {}
 Result:=(MutexLock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskFormatter.ReleaseLock:Boolean;
begin
 {}
 Result:=(MutexUnlock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskFormatter.FillSectors(AVolume:TDiskVolume;ADrive:TDiskDrive;ASector,ACount:LongWord;AValue:Byte):Boolean;
{Fill specified number of sectors with the supplied value}
{Note: Sector is relative to the StartSector of the Volume}
var
 Buffer:Pointer;
 SectorSize:Word;
begin
 {Base Implementation}
 Result:=False;
 
 if AVolume = nil then Exit;

 {Get Sector Size}
 SectorSize:=AVolume.SectorSize;
 if SectorSize = 0 then Exit;

 {Allocate Buffer}
 Buffer:=GetMem(SectorSize);
 if Buffer = nil then Exit;
 try
  {Fill Sectors}
  while ACount > 0 do
   begin
    {Read Sector} {Dont need to read first}
    {if not ReadSectors(AVolume,ADrive,ASector,1,Buffer^) then Exit;}
    
    {Fill Sector}
    FillChar(Buffer^,SectorSize,AValue);
    
    {Write Sector}
    if not WriteSectors(AVolume,ADrive,ASector,1,Buffer^) then Exit;
    
    Inc(ASector);
    Dec(ACount);
   end;
   
  Result:=True;
 finally
  FreeMem(Buffer);
 end;
end;

{==============================================================================}

function TDiskFormatter.ReadSectors(AVolume:TDiskVolume;ADrive:TDiskDrive;ASector,ACount:LongWord;var ABuffer):Boolean;
{Read Sectors from the Volume using Cache}
{Note: Sector is relative to the StartSector of the Volume}
{Note: Caller must hold the volume and drive lock, cache will serialize access to device}
begin
 {Base Implementation}
 Result:=False;
 if FDriver = nil then Exit;
 if AVolume = nil then Exit;
 if AVolume.Device = nil then Exit;
 if AVolume.SectorCount = 0 then Exit;

 Result:=FDriver.Cache.DeviceRead(AVolume.Device,AVolume.StartSector + ASector,ACount,ABuffer);
end;

{==============================================================================}

function TDiskFormatter.WriteSectors(AVolume:TDiskVolume;ADrive:TDiskDrive;ASector,ACount:LongWord;const ABuffer):Boolean;
{Write Sectors to the Volume using Cache}
{Note: Sector is relative to the StartSector of the Volume}
{Note: Caller must hold the volume and drive lock, cache will serialize access to device}
begin
 {Base Implementation}
 Result:=False;
 if FDriver = nil then Exit;
 if AVolume = nil then Exit;
 if AVolume.Device = nil then Exit;
 if AVolume.SectorCount = 0 then Exit;

 Result:=FDriver.Cache.DeviceWrite(AVolume.Device,AVolume.StartSector + ASector,ACount,ABuffer);
end;

{==============================================================================}

function TDiskFormatter.ReaderLock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskFormatter.ReaderUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskFormatter.WriterLock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskFormatter.WriterUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskFormatter.AcceptVolume(AVolume:TDiskVolume;AFloppyType:TFloppyType;AFileSysType:TFileSysType):Boolean;
{Check if the Volume can be accepted for Format}
{Note: Caller must hold the volume lock}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskFormatter.FormatVolume(AVolume:TDiskVolume;AFloppyType:TFloppyType;AFileSysType:TFileSysType):Boolean;
{Format the specified Volume}
{Note: Caller must hold the volume writer lock}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}
{==============================================================================}
{TDiskDefragger}
constructor TDiskDefragger.Create(ADriver:TFileSysDriver;ARecognizer:TRecognizer);
begin
 {}
 inherited Create;
 FLock:=SynchronizerCreate;
 FLocalLock:=MutexCreate;

 FDriver:=ADriver;
 FRecognizer:=ARecognizer;
end;

{==============================================================================}

destructor TDiskDefragger.Destroy;
begin
 {}
 WriterLock;
 try
  FRecognizer:=nil;
  FDriver:=nil;
  
  MutexDestroy(FLocalLock);
  inherited Destroy;
 finally 
  {WriterUnlock;} {Can destroy Synchronizer while holding lock}
  SynchronizerDestroy(FLock);
 end;
end;

{==============================================================================}

function TDiskDefragger.AcquireLock:Boolean;
begin
 {}
 Result:=(MutexLock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskDefragger.ReleaseLock:Boolean;
begin
 {}
 Result:=(MutexUnlock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskDefragger.ReaderLock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskDefragger.ReaderUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskDefragger.WriterLock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskDefragger.WriterUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskDefragger.AcceptVolume(AVolume:TDiskVolume):Boolean;
{Note: Caller must hold the volume lock}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskDefragger.DefragmentVolume(AVolume:TDiskVolume):Boolean;
{Note: Caller must hold the volume lock}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}
{==============================================================================}
{TDiskConverter}
constructor TDiskConverter.Create(ADriver:TFileSysDriver;ARecognizer:TRecognizer);
begin
 {}
 inherited Create;
 FLock:=SynchronizerCreate;
 FLocalLock:=MutexCreate;

 FDriver:=ADriver;
 FRecognizer:=ARecognizer;
end;

{==============================================================================}

destructor TDiskConverter.Destroy;
begin
 {}
 WriterLock;
 try
  FRecognizer:=nil;
  FDriver:=nil;
  
  MutexDestroy(FLocalLock);
  inherited Destroy;
 finally 
  {WriterUnlock;} {Can destroy Synchronizer while holding lock}
  SynchronizerDestroy(FLock);
 end;
end;

{==============================================================================}

function TDiskConverter.AcquireLock:Boolean;
begin
 {}
 Result:=(MutexLock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskConverter.ReleaseLock:Boolean;
begin
 {}
 Result:=(MutexUnlock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskConverter.ReaderLock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskConverter.ReaderUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskConverter.WriterLock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskConverter.WriterUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskConverter.AcceptVolume(AVolume:TDiskVolume;AFileSysType:TFileSysType):Boolean;
{Note: Caller must hold the volume lock}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskConverter.ConvertVolume(AVolume:TDiskVolume;AFileSysType:TFileSysType):Boolean;
{Note: Caller must hold the volume lock}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskConverter.AcceptImage(AImage:TDiskImage;AImageType:TImageType):Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskConverter.ConvertImage(AImage:TDiskImage;AImageType:TImageType):Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}
{==============================================================================}
{TDiskRepairer}
constructor TDiskRepairer.Create(ADriver:TFileSysDriver;ARecognizer:TRecognizer);
begin
 {}
 inherited Create;
 FLock:=SynchronizerCreate;
 FLocalLock:=MutexCreate;
 
 FDriver:=ADriver;
 FRecognizer:=ARecognizer;
end;

{==============================================================================}

destructor TDiskRepairer.Destroy;
begin
 {}
 WriterLock;
 try
  FRecognizer:=nil;
  FDriver:=nil;
  
  MutexDestroy(FLocalLock);
  inherited Destroy;
 finally 
  {WriterUnlock;} {Can destroy Synchronizer while holding lock}
  SynchronizerDestroy(FLock);
 end;
end;

{==============================================================================}

function TDiskRepairer.AcquireLock:Boolean;
begin
 {}
 Result:=(MutexLock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskRepairer.ReleaseLock:Boolean;
begin
 {}
 Result:=(MutexUnlock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskRepairer.ReaderLock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskRepairer.ReaderUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskRepairer.WriterLock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskRepairer.WriterUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskRepairer.AcceptVolume(AVolume:TDiskVolume):Boolean;
{Note: Caller must hold the volume lock}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskRepairer.RepairVolume(AVolume:TDiskVolume):Boolean;
{Note: Caller must hold the volume lock}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}
{==============================================================================}
{TDiskResizer}
constructor TDiskResizer.Create(ADriver:TFileSysDriver;ARecognizer:TRecognizer);
begin
 {}
 inherited Create;
 FLock:=SynchronizerCreate;
 FLocalLock:=MutexCreate;
 
 FDriver:=ADriver;
 FRecognizer:=ARecognizer;
end;

{==============================================================================}

destructor TDiskResizer.Destroy;
begin
 {}
 WriterLock;
 try
  FRecognizer:=nil;
  FDriver:=nil;
  
  MutexDestroy(FLocalLock);
  inherited Destroy;
 finally 
  {WriterUnlock;} {Can destroy Synchronizer while holding lock}
  SynchronizerDestroy(FLock);
 end;
end;

{==============================================================================}

function TDiskResizer.AcquireLock:Boolean;
begin
 {}
 Result:=(MutexLock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskResizer.ReleaseLock:Boolean;
begin
 {}
 Result:=(MutexUnlock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskResizer.ReaderLock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskResizer.ReaderUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskResizer.WriterLock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskResizer.WriterUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskResizer.AcceptVolume(AVolume:TDiskVolume;const AStart,ASize:Int64):Boolean;
{Note: Caller must hold the volume lock}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskResizer.ShrinkVolume(AVolume:TDiskVolume;const AStart,ASize:Int64):Boolean;
{Note: Caller must hold the volume writer lock}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskResizer.ExpandVolume(AVolume:TDiskVolume;const AStart,ASize:Int64):Boolean;
{Note: Caller must hold the volume writer lock}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskResizer.AcceptPartition(APartition:TDiskPartition;const AStart,ASize:Int64):Boolean;
{Note: Caller must hold the partition lock}
begin
 {Virtual Base Method - No Function}
 Result:=False; //To Do //Build Resize of MBR type partitions into TDiskResizer (Base Class) override for LVM/GUID
end;

{==============================================================================}

function TDiskResizer.ShrinkPartition(APartition:TDiskPartition;const AStart,ASize:Int64):Boolean;
{Note: Caller must hold the partition writer lock}
begin
 {Virtual Base Method - No Function}
 Result:=False; //To Do //Build Resize of MBR type partitions into TDiskResizer (Base Class) override for LVM/GUID
end;

{==============================================================================}

function TDiskResizer.ExpandPartition(APartition:TDiskPartition;const AStart,ASize:Int64):Boolean;
{Note: Caller must hold the partition writer lock}
begin
 {Virtual Base Method - No Function}
 Result:=False; //To Do //Build Resize of MBR type partitions into TDiskResizer (Base Class) override for LVM/GUID
end;

{==============================================================================}

function TDiskResizer.AcceptImage(AImage:TDiskImage;const ASize:Int64):Boolean;
{Note: Caller must hold the image lock}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskResizer.ShrinkImage(AImage:TDiskImage;const ASize:Int64):Boolean;
{Note: Caller must hold the image writer lock}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskResizer.ExpandImage(AImage:TDiskImage;const ASize:Int64):Boolean;
{Note: Caller must hold the image writer lock}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}
{==============================================================================}
{TDiskCopier}
constructor TDiskCopier.Create(ADriver:TFileSysDriver;ARecognizer:TRecognizer);
begin
 {}
 inherited Create;
 FLock:=SynchronizerCreate;
 FLocalLock:=MutexCreate;

 FDriver:=ADriver;
 FRecognizer:=ARecognizer;
end;

{==============================================================================}

destructor TDiskCopier.Destroy;
begin
 {}
 WriterLock;
 try
  FRecognizer:=nil;
  FDriver:=nil;
  
  MutexDestroy(FLocalLock);
  inherited Destroy;
 finally 
  {WriterUnlock;} {Can destroy Synchronizer while holding lock}
  SynchronizerDestroy(FLock);
 end;
end;

{==============================================================================}

function TDiskCopier.AcquireLock:Boolean;
begin
 {}
 Result:=(MutexLock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskCopier.ReleaseLock:Boolean;
begin
 {}
 Result:=(MutexUnlock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskCopier.ReaderLock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskCopier.ReaderUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskCopier.WriterLock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskCopier.WriterUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskCopier.AcceptVolume(AVolume,ADest:TDiskVolume):Boolean;
{Note: Caller must hold the volume lock}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskCopier.CopyVolume(AVolume,ADest:TDiskVolume):Boolean;
{Note: Caller must hold the volume writer lock}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskCopier.AcceptImage(AImage,ADest:TDiskImage):Boolean;
{Note: Caller must hold the image lock}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskCopier.CopyImage(AImage,ADest:TDiskImage):Boolean;
{Note: Caller must hold the image writer lock}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}
{==============================================================================}
{TDiskImager}
constructor TDiskImager.Create(ADriver:TFileSysDriver;ARecognizer:TRecognizer);
begin
 {}
 inherited Create;
 FLock:=SynchronizerCreate;
 FLocalLock:=MutexCreate;
 
 FDriver:=ADriver;
 FRecognizer:=ARecognizer;
end;

{==============================================================================}

destructor TDiskImager.Destroy;
begin
 {}
 WriterLock;
 try
  FRecognizer:=nil;
  FDriver:=nil;
  
  MutexDestroy(FLocalLock);
  inherited Destroy;
 finally 
  {WriterUnlock;} {Can destroy Synchronizer while holding lock}
  SynchronizerDestroy(FLock);
 end;
end;

{==============================================================================}

function TDiskImager.AcquireLock:Boolean;
begin
 {}
 Result:=(MutexLock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskImager.ReleaseLock:Boolean;
begin
 {}
 Result:=(MutexUnlock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskImager.ReaderLock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskImager.ReaderUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskImager.WriterLock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskImager.WriterUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskImager.AcceptImage(AImage:TDiskImage;const AName:String;AImageType:TImageType;AMediaType:TMediaType;AFloppyType:TFloppyType;AAttributes:LongWord;ASectorSize:Word;const ASectorCount:Int64):Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskImager.CreateImage(AImage:TDiskImage;const AName:String;AImageType:TImageType;AMediaType:TMediaType;AFloppyType:TFloppyType;AAttributes:LongWord;ASectorSize:Word;const ASectorCount:Int64;ACylinders,AHeads,ASectors:LongWord;APartitionId:Byte):Integer;
begin
 {Virtual Base Method - No Function}
 Result:=0; {Return is an ImageNo}
end;

{==============================================================================}

function TDiskImager.OpenImage(AImage:TDiskImage;const AName:String;AImageType:TImageType;AMediaType:TMediaType;AFloppyType:TFloppyType;AAttributes:LongWord;ASectorSize:Word;const ASectorCount:Int64;ACylinders,AHeads,ASectors:LongWord;APartitionId:Byte):Integer;
begin
 {Virtual Base Method - No Function}
 Result:=0; {Return is an ImageNo}
end;

{==============================================================================}

function TDiskImager.CloseImage(AImage:TDiskImage):Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskImager.AcceptSnapshot(AImage:TDiskImage):Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskImager.CreateSnapshot(AImage:TDiskImage):Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskImager.DeleteSnapshot(AImage:TDiskImage):Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskImager.MergeSnapshot(AImage:TDiskImage):Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}
{==============================================================================}
{TFileSystem}
constructor TFileSystem.Create(ADriver:TFileSysDriver;AVolume:TDiskVolume;ADrive:TDiskDrive);
begin
 {}
 inherited Create;
 FLock:=SynchronizerCreate;
 FLocalLock:=MutexCreate;
 
 FDriver:=ADriver;
 if FDriver <> nil then FDriver.AddFileSystem(Self);
 FVolume:=AVolume;
 {if FVolume <> nil then FVolume.FileSystem:=Self;} {Done by FileSystemInit}
 FDrive:=ADrive;
 {if FDrive <> nil then FDrive.FileSystem:=Self;} {Done by FileSystemInit}

 FPathChar:='';
 FNameChar:='';
 FFileChar:='';
 FRootChar:='';
 FRootName:='';
 FRootPath:='';
 FMaxFile:=0;
 FMaxPath:=0;
 FMaxAltFile:=0;
 FMaxAltPath:=0;
 FAttributes:=vaNone;
 FMaxAttributes:=faNone;
 FMaskAttributes:=faNone;
 FSystemName:='';
 FVolumeName:='';
 FVolumeGUID:='';
 FVolumeSerial:=0;
 FFileSysType:=fsUNKNOWN;

 FSectorSize:=0;
 FStartSector:=0;
 FSectorCount:=0;

 FRoot:=nil;
 
 FCurrentIndex:=TlsAlloc;
 FCurrentEntry:=nil;
 
 FChunks:=TFileSysList.Create;
 FTables:=TFileSysList.Create;
 FBlocks:=TFileSysList.Create;
 FEntries:=TFileSysTree.Create;
 FCatalogs:=TFileSysList.Create;
 FAcls:=TFileSysList.Create;

 FChunkLocal:=MutexCreate;
 FTableLocal:=MutexCreate;
 FBlockLocal:=MutexCreate;
 FEntryLocal:=MutexCreateEx(False,MUTEX_DEFAULT_SPINCOUNT,MUTEX_FLAG_RECURSIVE);
 FCatalogLocal:=MutexCreate;
 FSecurityLocal:=MutexCreate;
 FAclLocal:=MutexCreate;
 FAceLocal:=MutexCreate;
 
 FMarkDirty:=False;
 FMarkClean:=False;
 FMarkError:=False;
 FLogDirty:=False;
 FMountDirty:=False;

 FOemConvert:=True;
 FNumericTail:=True;

 FReadOnly:=False;
 FLongNames:=True;
 FDataStreams:=False;
 FReparsePoints:=False;
 FCaseSensitive:=False;
 FCasePreserved:=False;
 FUnicodeNames:=False;
 FPersistentAcls:=False;
 FFileCompression:=False;
 FVolumeQuotas:=False;
 FSparseFiles:=False;
 FRemoteStorage:=False;
 FVolumeCompressed:=False;
 FObjectIds:=False;
 FEncryption:=False;

 FBootCatalog:=False;
 FVirtualVolume:=False;
 FFolderEncryption:=False;
 FFolderCompression:=False;

 FBootSector:=0;
 FBootBackup:=0;

 FSectorBuffer:=nil;
 FSectorLock:=MutexCreate;
 if (FVolume <> nil) then FSectorBuffer:=GetMem(FVolume.SectorSize);
 if (FVolume = nil) and (FDrive <> nil) then FSectorBuffer:=GetMem(FDrive.SectorSize);
end;

{==============================================================================}

destructor TFileSystem.Destroy;
begin
 {}
 WriterLock;
 try
  if FSectorBuffer <> nil then FreeMem(FSectorBuffer);
  FSectorBuffer:=nil;
  MutexDestroy(FSectorLock);
  
  FAcls.Free;
  FCatalogs.Free;
  FEntries.Free;
  FBlocks.Free;
  FTables.Free;
  FChunks.Free;
  
  MutexDestroy(FAceLocal);
  MutexDestroy(FAclLocal);
  MutexDestroy(FSecurityLocal);
  MutexDestroy(FCatalogLocal);
  MutexDestroy(FEntryLocal);
  MutexDestroy(FBlockLocal);
  MutexDestroy(FTableLocal);
  MutexDestroy(FChunkLocal);
  
  TlsFree(FCurrentIndex);
  
  FRoot:=nil;
  
  if FDrive <> nil then FDrive.FileSystem:=nil;
  FDrive:=nil;
  if FVolume <> nil then FVolume.FileSystem:=nil;
  FVolume:=nil;
  if FDriver <> nil then FDriver.RemoveFileSystem(Self);
  FDriver:=nil;
  
  MutexDestroy(FLocalLock);
  inherited Destroy;
 finally 
  {WriterUnlock;} {Can destroy Synchronizer while holding lock}
  SynchronizerDestroy(FLock);
 end;
end;

{==============================================================================}

function TFileSystem.AcquireLock:Boolean;
begin
 {}
 Result:=(MutexLock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TFileSystem.ReleaseLock:Boolean;
begin
 {}
 Result:=(MutexUnlock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TFileSystem.SectorLock:Boolean;
begin
 {}
 Result:=(MutexLock(FSectorLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TFileSystem.SectorUnlock:Boolean;
begin
 {}
 Result:=(MutexUnlock(FSectorLock) = ERROR_SUCCESS);
end;

{==============================================================================}

procedure TFileSystem.SetDrive(ADrive:TDiskDrive);
begin
 {Base Implementation}
 if not WriterLock then Exit;
 try
  if FDriver = nil then Exit;
  if FDrive = ADrive then Exit;
  
  {Check Drive}
  if FDrive = nil then
   begin
    {Bind}
    if ADrive = nil then Exit;
    
    {Set Drive}
    FDrive:=ADrive;
    
    {Setup Defaults}
    FRootChar:=LoadRootChar;
    FRootName:=LoadRootName;
    FRootPath:=LoadRootPath;
    
    {Bind to Drive}
    FDrive.FileSystem:=Self;
    
    {Check Root}
    if FRoot <> nil then
     begin
      {Setup Defaults}
      FRoot.Name:=FRootName;
      FRoot.AltName:=FRootPath;
     end;
   end
  else
   begin
    {Unbind}
    if ADrive <> nil then Exit;
    
    {Unbind from Drive}
    FDrive.FileSystem:=nil;
    
    {Set Drive}
    FDrive:=nil;
    
    {Setup Defaults}
    FRootChar:=LoadRootChar;
    FRootName:=LoadRootName;
    FRootPath:=LoadRootPath;
    
    {Check Root}
    if FRoot <> nil then
     begin
      {Setup Defaults}
      FRoot.Name:=FRootName;
      FRoot.AltName:=FRootPath;
     end;
   end;
 finally  
  WriterUnlock;
 end; 
end;

{==============================================================================}

procedure TFileSystem.SetVolume(AVolume:TDiskVolume);
begin
 {Virtual Base Method - No Function}
 if not WriterLock then Exit;
 try
  {Nothing}
 finally  
  WriterUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.GetPathChar:String; 
begin
 {}
 Result:='';

 if not AcquireLock then Exit;

 Result:=FPathChar;
 UniqueString(Result);

 ReleaseLock;
end;

{==============================================================================}

function TFileSystem.GetNameChar:String; 
begin
 {}
 Result:='';

 if not AcquireLock then Exit;

 Result:=FNameChar;
 UniqueString(Result);

 ReleaseLock;
end;

{==============================================================================}

function TFileSystem.GetFileChar:String; 
begin
 {}
 Result:='';

 if not AcquireLock then Exit;

 Result:=FFileChar;
 UniqueString(Result);

 ReleaseLock;
end;

{==============================================================================}

function TFileSystem.GetRootChar:String; 
begin
 {}
 Result:='';

 if not AcquireLock then Exit;

 Result:=FRootChar;
 UniqueString(Result);

 ReleaseLock;
end;

{==============================================================================}

function TFileSystem.GetRootName:String; 
begin
 {}
 Result:='';

 if not AcquireLock then Exit;

 Result:=FRootName;
 UniqueString(Result);

 ReleaseLock;
end;

{==============================================================================}

function TFileSystem.GetRootPath:String; 
begin
 {}
 Result:='';

 if not AcquireLock then Exit;

 Result:=FRootPath;
 UniqueString(Result);

 ReleaseLock;
end;

{==============================================================================}

function TFileSystem.GetSystemName:String; 
begin
 {}
 Result:='';

 if not AcquireLock then Exit;

 Result:=FSystemName;
 UniqueString(Result);

 ReleaseLock;
end;

{==============================================================================}

function TFileSystem.GetVolumeName:String; 
begin
 {}
 Result:='';

 if not AcquireLock then Exit;

 Result:=FVolumeName;
 UniqueString(Result);

 ReleaseLock;
end;

{==============================================================================}

function TFileSystem.GetVolumeGUID:String; 
begin
 {}
 Result:='';

 if not AcquireLock then Exit;

 Result:=FVolumeGUID;
 UniqueString(Result);

 ReleaseLock;
end;

{==============================================================================}

function TFileSystem.LoadPathChar:String;
{Load the Path separator character}
begin
 {Base Implementation}
 Result:=FAT_PATH_CHAR;
end;

{==============================================================================}

function TFileSystem.LoadNameChar:String;
{Load the Name separator character}
begin
 {Base Implementation}
 Result:=FAT_NAME_CHAR;
end;

{==============================================================================}

function TFileSystem.LoadFileChar:String;
{Load the File separator character}
begin
 {Base Implementation}
 Result:=FAT_FILE_CHAR;
end;

{==============================================================================}

function TFileSystem.LoadRootChar:String;
{Load the Root specifier character (eg C:)}
begin
 {Base Implementation}
 Result:='';

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  
  if FDrive <> nil then
   begin
    Result:=FDrive.Root;
   end;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TFileSystem.LoadRootName:String;
{Load Root Name from Drive or Volume (eg C:\ or \\?\Volume1)}
begin
 {Base Implementation}
 Result:='';

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  
  if FDrive <> nil then
   begin
    Result:=FDrive.Name;
   end
  else
   begin
    if FVolume = nil then Exit;
    
    Result:=VOLUME_PATH_PREFIX + FVolume.Name;
   end;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TFileSystem.LoadRootPath:String;
{Load Root Path from Volume or Drive (eg \\.\Harddisk0\Partition1 or C:\)}
begin
 {Base Implementation}
 Result:='';

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  
  if FVolume <> nil then
   begin
    Result:=DEVICE_PATH_PREFIX + FVolume.Parent;
   end
  else
   begin
    if FDrive = nil then Exit;
    
    Result:=FDrive.Name;
   end;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TFileSystem.LoadMaxFile:Integer;
{Load the maximum File name length}
begin
 {Base Implementation}
 Result:=MAX_FAT_FILE;
end;

{==============================================================================}

function TFileSystem.LoadMaxPath:Integer;
{Load the maximum Path name length}
begin
 {Base Implementation}
 Result:=MAX_FAT_PATH;
end;

{==============================================================================}

function TFileSystem.LoadMaxAltFile:Integer;
{Load the maximum Alt File name length}
begin
 {Base Implementation}
 Result:=MAX_FAT_FILE;
end;

{==============================================================================}

function TFileSystem.LoadMaxAltPath:Integer;
{Load the maximum Alt Path name length}
begin
 {Base Implementation}
 Result:=MAX_FAT_PATH;
end;

{==============================================================================}

function TFileSystem.LoadAttributes:LongWord;
{Load the File System (Volume) Attributes}
begin
 {Base Implementation}
 Result:=vaNone;

 if FReadOnly then Result:=(Result or vaReadOnly);
 if FLongNames then Result:=(Result or vaLongNamesApi);
 if FDataStreams then Result:=(Result or vaNamedStreams);
 if FReparsePoints then Result:=(Result or vaReparsePoints);
 if FCaseSensitive then Result:=(Result or vaCaseSensitive);
 if FCasePreserved then Result:=(Result or vaCasePreserved);
 if FUnicodeNames then Result:=(Result or vaUnicode);
 if FPersistentAcls then Result:=(Result or vaPersistentAcls);
 if FFileCompression then Result:=(Result or vaFileCompression);
 if FVolumeQuotas then Result:=(Result or vaVolumeQuotas);
 if FSparseFiles then Result:=(Result or vaSparseFiles);
 if FRemoteStorage then Result:=(Result or vaRemoteStorage);
 if FVolumeCompressed then Result:=(Result or vaVolumeCompressed);
 if FObjectIds then Result:=(Result or vaObjectIds);
 if FEncryption then Result:=(Result or vaEncryption);

 if FBootCatalog then Result:=(Result or vaBootCatalog);
 if FVirtualVolume then Result:=(Result or vaVirtualVolume);
 if FFolderEncryption then Result:=(Result or vaFolderEncryption);
 if FFolderCompression then Result:=(Result or vaFolderCompression);
end;

{==============================================================================}

function TFileSystem.LoadMaxAttributes:LongWord;
{Load the Maximum File Attributes (FileSetAttr)}
begin
 {Base Implementation}
 Result:=faFindMask;
end;

{==============================================================================}

function TFileSystem.LoadMaskAttributes:LongWord;
{Load the File Attributes Mask (FileGetAttr/FindFirstEx/FindNextEx)}
begin
 {Base Implementation}
 Result:=faFindMask;
end;

{==============================================================================}

function TFileSystem.LoadMountPointTag:LongWord;
begin
 {Base Implementation}
 Result:=0;
end;

{==============================================================================}

function TFileSystem.LoadSymbolicLinkTag:LongWord;
begin
 {Base Implementation}
 Result:=0;
end;

{==============================================================================}

function TFileSystem.LoadSystemName:String;
begin
 {Virtual Base Method - No Function}
 Result:='';
end;

{==============================================================================}

function TFileSystem.LoadVolumeName:String;
begin
 {Virtual Base Method - No Function}
 Result:='';
end;

{==============================================================================}

function TFileSystem.LoadVolumeGUID:String;
begin
 {Virtual Base Method - No Function}
 Result:='';
end;

{==============================================================================}

function TFileSystem.LoadVolumeSerial:LongWord;
begin
 {Virtual Base Method - No Function}
 Result:=0;
end;

{==============================================================================}

function TFileSystem.LoadFileSysType:TFileSysType;
begin
 {Virtual Base Method - No Function}
 Result:=fsUNKNOWN;
end;

{==============================================================================}

function TFileSystem.LoadSectorSize:Word;
{Load Sector Size from Volume}
begin
 {Base Implementation}
 Result:=0;

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if FVolume = nil then Exit;
  
  Result:=FVolume.SectorSize;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TFileSystem.LoadStartSector:Int64;
{Load Start Sector from Volume }
begin
 {Base Implementation}
 Result:=0;

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if FVolume = nil then Exit;

  Result:=FVolume.StartSector;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TFileSystem.LoadSectorCount:LongWord;
{Load Sector Count from Volume}
//To Do //This is called by FileSystemInit and would be
//the ideal place to do DeviceInit if SectorCount is 0.
//That way FileSystem can check for FSectorCount 0 and do
//FileSystemInit to try again to access the device etc
begin
 {Base Implementation}
 Result:=0;

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if FVolume = nil then Exit;

  Result:=FVolume.SectorCount;
 finally  
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TFileSystem.GetCurrent:TDiskEntry; 
begin
 {}
 if FILESYS_GLOBAL_CURRENTDIR then
  begin
   Result:=FCurrentEntry;
   if Result = nil then
    begin
     FCurrentEntry:=FRoot;
     
     Result:=FCurrentEntry;
     if Result <> nil then Result.AddReference;
    end;
  end
 else
  begin 
   Result:=TlsGetValue(FCurrentIndex);
   if Result = nil then
    begin
     if not TlsSetValue(FCurrentIndex,FRoot) then Exit;
     
     Result:=TlsGetValue(FCurrentIndex);
     if Result <> nil then Result.AddReference;
    end;
  end;  
end;

{==============================================================================}

function TFileSystem.SetCurrent(ACurrent:TDiskEntry):Boolean;
begin
 {}
 if FILESYS_GLOBAL_CURRENTDIR then
  begin
   FCurrentEntry:=ACurrent;
   
   Result:=(FCurrentEntry <> nil);
  end
 else
  begin 
   Result:=TlsSetValue(FCurrentIndex,ACurrent)
  end; 
end;

{==============================================================================}

function TFileSystem.FillSectors(ASector,ACount:LongWord;AValue:Byte):Boolean;
{Fill specified number of sectors with the supplied value}
{Note: Sector is relative to the StartSector of the FileSystem}
begin
 {Base Implementation}
 Result:=False;
 
 if not SectorLock then Exit;
 try
  if FSectorBuffer = nil then Exit;

  {Fill Sectors}
  while ACount > 0 do
   begin
    {Read Sector} {Dont need to read first}
    {if not ReadSectors(ASector,1,FSectorBuffer^) then Exit;}
   
    {Fill Sector}
    FillChar(FSectorBuffer^,FSectorSize,AValue);
   
    {Write Sector}
    if not WriteSectors(ASector,1,FSectorBuffer^) then Exit;
   
    Inc(ASector);
    Dec(ACount);
   end;
  
  Result:=True;
 finally
  SectorUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.ReadSectors(ASector,ACount:LongWord;var ABuffer):Boolean;
{Read Sectors from the Volume using Cache}
{Note: Sector is relative to the StartSector of the FileSystem}
{Note: Caller must hold the filesystem lock, cache will serialize access to device}
begin
 {Base Implementation}
 Result:=False;
 
 if FDriver = nil then Exit;
 if FSectorCount = 0 then Exit;
 
 if FVolume = nil then Exit;
 if FVolume.Device = nil then Exit;
   
 Result:=FDriver.Cache.DeviceRead(FVolume.Device,FStartSector + ASector,ACount,ABuffer);
end;

{==============================================================================}

function TFileSystem.WriteSectors(ASector,ACount:LongWord;const ABuffer):Boolean;
{Write Sectors to the Volume using Cache}
{Note: Sector is relative to the StartSector of the FileSystem}
{Note: Caller must hold the filesystem lock, cache will serialize access to device}
begin
 {Base Implementation}
 Result:=False;
 
 if FDriver = nil then Exit;
 if FSectorCount = 0 then Exit;
 
 if FVolume = nil then Exit;
 if FVolume.Device = nil then Exit;
   
 Result:=FDriver.Cache.DeviceWrite(FVolume.Device,FStartSector + ASector,ACount,ABuffer);
end;

{==============================================================================}

function TFileSystem.ReadEntry(AParent,AEntry:TDiskEntry;var ABuffer;const AStart:Int64;ACount:LongWord;var AOffset,AValue:LongWord):Integer;
{Note: Start, Count and Size have already been checked}
{Note: Offset and Value are private to the filesystem}
begin
 {Virtual Base Method - No Function}
 Result:=0;
end;

{==============================================================================}

function TFileSystem.WriteEntry(AParent,AEntry:TDiskEntry;const ABuffer;const AStart:Int64;ACount:LongWord;var AOffset,AValue:LongWord):Integer;
{Note: Start, Count and Size have already been checked}
{Note: Offset and Value are private to the filesystem}
begin
 {Virtual Base Method - No Function}
 Result:=0;
end;

{==============================================================================}

function TFileSystem.LoadTables:Boolean;
{Load all Disk Tables}
{Note: Descendant method must use WriterLock on Tables}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TFileSystem.LoadBlocks:Boolean;
{Load all Disk Blocks}
{Note: Descendant method must use WriterLock on Blocks}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TFileSystem.LoadEntries(AParent:TDiskEntry):Boolean;
{Note: Parent must be supplied}
{Note: Descendant method must use WriterLock on Entries}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TFileSystem.LoadCatalogs:Boolean;
{Note: Descendant method must use WriterLock on Catalogs}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TFileSystem.LoadTable(ATableNo:LongWord):Boolean;
{Note: TableNo is zero based}
{Note: Descendant method must use WriterLock on Tables}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TFileSystem.LoadBlock(ABlockNo:LongWord):Boolean;
{Note: BlockNo is zero based}
{Note: Descendant method must use WriterLock on Blocks}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TFileSystem.UnloadEntries(AParent:TDiskEntry):Boolean; 
{Note: Parent must be supplied}
{Note: Descendant method must use WriterLock on Entries}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TFileSystem.AddEntry(AParent:TDiskEntry;const AName:String;AAttributes:LongWord;AReference:Boolean):TDiskEntry;
{Reference: Add a reference on the returned entry if True}
{Note: Parent must be supplied, Name has already been checked}

{Note: Descendant method must use WriterLock on Entries}
begin
 {Virtual Base Method - No Function}
 Result:=nil;
end;

{==============================================================================}

function TFileSystem.AddEntryEx(AParent:TDiskEntry;const AName,AAltName:String;AAttributes:LongWord;AReference:Boolean):TDiskEntry;
{Reference: Add a reference on the returned entry if True}
{Note: Parent must be supplied, Name and AltName have already been checked}
{If AltName already exists then a generated one will be provided, will not fail due to AltName}

{Note: Descendant method must use WriterLock on Entries}
begin
 {Virtual Base Method - No Function}
 Result:=nil;
end;

{==============================================================================}

function TFileSystem.RemoveEntry(AParent,AEntry:TDiskEntry):Boolean;
{Note: Files and Folders have been checked, Handles have been checked}
{Note: Parent must be supplied}

{Note: Descendant method must use WriterLock on Entries}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TFileSystem.RenameEntry(AParent,AEntry:TDiskEntry;const AName:String):Boolean;
{Note: Parent must be supplied, Name has already been checked}

{Note: Descendant method must use WriterLock on Entries}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TFileSystem.RenameEntryEx(AParent,AEntry:TDiskEntry;const AAltName:String):Boolean;
{Note: Parent must be supplied, Name has already been checked}

{Note: Descendant method must use WriterLock on Entries}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TFileSystem.MoveEntry(ASource,ADest,AEntry:TDiskEntry):Boolean;
{Note: Source and Dest must be supplied, Name has already been checked}

{Note: Descendant method must use WriterLock on Entries}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TFileSystem.AddCatalog(AEntry:TDiskEntry;AMediaType:TMediaType;AFloppyType:TFloppyType;AAttributes:LongWord;ASectorSize:Word;const ASectorCount:Int64):TDiskCatalog;
{Note: Descendant method must use WriterLock on Catalogs}
begin
 {Virtual Base Method - No Function}
 Result:=nil;
end;

{==============================================================================}

function TFileSystem.RemoveCatalog(ACatalog:TDiskCatalog):Boolean;
{Note: Descendant method must use WriterLock on Catalogs}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TFileSystem.CheckCatalog(ACatalog:TDiskCatalog;ALock:Boolean;AState:LongWord):Boolean; 
var
 Catalog:TDiskCatalog;
begin
 {Base Implementation}
 Result:=False;

 if not FCatalogs.ReaderLock then Exit;
 try
  if ACatalog = nil then Exit;
  
  Catalog:=TDiskCatalog(FCatalogs.First);
  while Catalog <> nil do
   begin
    if Catalog = ACatalog then
     begin
      {Lock Catalog} 
      if ALock then if AState = FILESYS_LOCK_READ then Catalog.ReaderLock else Catalog.WriterLock;
      
      Result:=True;
      Exit;
     end;
     
    Catalog:=TDiskCatalog(Catalog.Next);
   end;
 finally
  FCatalogs.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSystem.GetCatalogByNo(ACatalogNo:LongWord;ALock:Boolean;AState:LongWord):TDiskCatalog;
{Note: CatalogNo is one based}
var
 Next:TDiskCatalog;
begin
 {Base Implementation}
 Result:=nil;
 
 if FDriver = nil then Exit;
 if ACatalogNo = 0 then Exit;
 
 {Load Catalogs}
 if LoadCatalogs then
  begin
   if not FCatalogs.ReaderLock then Exit;
   try
    {Check Catalogs}
    Next:=TDiskCatalog(FCatalogs.First);
    while Next <> nil do
     begin
      if Next.CatalogNo = ACatalogNo then
       begin
        {Lock Catalog} 
        if ALock then if AState = FILESYS_LOCK_READ then Next.ReaderLock else Next.WriterLock;
      
        Result:=Next;
        Exit;
       end;
      
      Next:=TDiskCatalog(Next.Next);
     end;
   finally
    FCatalogs.ReaderUnlock;
   end;   
  end;
end;

{==============================================================================}

function TFileSystem.GetCatalogByName(const AName:String;ALock:Boolean;AState:LongWord):TDiskCatalog;
var
 Next:TDiskCatalog;
begin
 {Base Implementation}
 Result:=nil;
 
 if FDriver = nil then Exit;
 if Trim(AName) = '' then Exit;
 
 {Load Catalogs}
 if LoadCatalogs then
  begin
   if not FCatalogs.ReaderLock then Exit;
   try
    {Check Catalogs}
    Next:=TDiskCatalog(FCatalogs.First);
    while Next <> nil do
     begin
      if Uppercase(Next.Name) = Uppercase(AName) then
       begin
        {Lock Catalog} 
        if ALock then if AState = FILESYS_LOCK_READ then Next.ReaderLock else Next.WriterLock;
        
        Result:=Next;
        Exit;
       end;
       
      Next:=TDiskCatalog(Next.Next);
     end;
   finally
    FCatalogs.ReaderUnlock;
   end;   
  end;
end;

{==============================================================================}

function TFileSystem.GetCatalogByNext(APrevious:TDiskCatalog;ALock,AUnlock:Boolean;AState:LongWord):TDiskCatalog; 
var
 Catalog:TDiskCatalog;
begin
 {}
 Result:=nil;
 
 if not FCatalogs.ReaderLock then Exit;
 try
  {Check Previous}
  if APrevious = nil then
   begin
    {Get First}
    Catalog:=TDiskCatalog(FCatalogs.First);
    if Catalog <> nil then
     begin
      {Lock Catalog}
      if ALock then if AState = FILESYS_LOCK_READ then Catalog.ReaderLock else Catalog.WriterLock;
      
      {Return Result}
      Result:=Catalog;
     end;
   end
  else
   begin
    {Get Next}
    Catalog:=TDiskCatalog(APrevious.Next);
    if Catalog <> nil then
     begin
      {Lock Catalog}
      if ALock then if AState = FILESYS_LOCK_READ then Catalog.ReaderLock else Catalog.WriterLock;
      
      {Return Result}
      Result:=Catalog;
     end;

    {Unlock Previous}
    if AUnlock then if AState = FILESYS_LOCK_READ then APrevious.ReaderUnlock else APrevious.WriterUnlock;
   end;   
 finally
  FCatalogs.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSystem.GetNextCatalogNo:LongWord;
begin
 {Base Implementation}
 Result:=1;
 
 while GetCatalogByNo(Result,False,FILESYS_LOCK_NONE) <> nil do {Do not lock}
  begin
   Inc(Result);
  end;
end;

{==============================================================================}

function TFileSystem.GetMaxCatalogNo:LongWord;
var
 Catalog:TDiskCatalog;
begin
 {Base Implementation}
 Result:=0;

 if not FCatalogs.ReaderLock then Exit;
 try
  Catalog:=TDiskCatalog(FCatalogs.First);
  while Catalog <> nil do
   begin
    if Catalog.CatalogNo > Result then
     begin
      Result:=Catalog.CatalogNo;
     end;
     
    Catalog:=TDiskCatalog(Catalog.Next);
   end;
 finally
  FCatalogs.ReaderUnlock;
 end;   
end;

{==============================================================================}

function TFileSystem.AddHardlink(AEntry,AParent:TDiskEntry;const AName:String;AReference:Boolean):TDiskEntry;
{Reference: Add a reference on the returned entry if True}
{Note: Entry and Parent must be supplied, Name has already been checked}

{Note: Descendant method must use WriterLock on Entries}
begin
 {Virtual Base Method - No Function}
 Result:=nil;
end;

{==============================================================================}

function TFileSystem.RemoveHardlink(AParent,AEntry:TDiskEntry):Boolean;
{Note: Entry and Parent must be supplied, Entry will be deleted}

{Note: Descendant method must use WriterLock on Entries}
begin
 {Base Implementation}
 Result:=RemoveEntry(AParent,AEntry);
end;

{==============================================================================}

function TFileSystem.AddMountPoint(AEntry:TDiskEntry;const ATarget:String):Boolean;
{Note: Entry must be supplied}

{Note: Descendant method must use WriterLock on Entries}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TFileSystem.RemoveMountPoint(AEntry:TDiskEntry):Boolean;
{Note: Entry must be supplied, Entry will not be deleted}

{Note: Descendant method must use WriterLock on Entries}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TFileSystem.AddJunctionPoint(AEntry:TDiskEntry;const ATarget:String):Boolean;
{Note: Entry must be supplied}

{Note: Descendant method must use WriterLock on Entries}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TFileSystem.RemoveJunctionPoint(AEntry:TDiskEntry):Boolean;
{Note: Entry must be supplied, Entry will not be deleted}

{Note: Descendant method must use WriterLock on Entries}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TFileSystem.AddSymbolicLink(AParent:TDiskEntry;const AName,ATarget:String;AFolder,AReference:Boolean):TDiskEntry;
{Reference: Add a reference on the returned entry if True}
{Note: Parent must be supplied, Name has already been checked}

{Note: Descendant method must use WriterLock on Entries}
begin
 {Virtual Base Method - No Function}
 Result:=nil;
end;

{==============================================================================}

function TFileSystem.AddSymbolicLinkEx(AParent:TDiskEntry;const AName,AAltName,ATarget:String;AFolder,AReference:Boolean):TDiskEntry;
{Reference: Add a reference on the returned entry if True}
{Note: Parent must be supplied, Name has already been checked}

{Note: Descendant method must use WriterLock on Entries}
begin
 {Virtual Base Method - No Function}
 Result:=nil;
end;

{==============================================================================}

function TFileSystem.RemoveSymbolicLink(AParent,AEntry:TDiskEntry):Boolean;
{Note: Entry and Parent must be supplied, Entry will be deleted}

{Note: Descendant method must use WriterLock on Entries}
begin
 {Base Implementation}
 Result:=RemoveEntry(AParent,AEntry);
end;

{==============================================================================}

function TFileSystem.SetTable(ATable:TDiskTable):Boolean;
{Note: Descendant method must use WriterLock on Tables}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TFileSystem.SetBlock(ABlock:TDiskBlock):Boolean;
{Note: Descendant method must use WriterLock on Blocks}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TFileSystem.SetEntry(AParent,AEntry:TDiskEntry):Boolean;
{Note: Parent must be supplied}
{Note: Descendant method must use WriterLock on Entries}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TFileSystem.SetCatalog(ACatalog:TDiskCatalog):Boolean;
{Note: Descendant method must use WriterLock on Catalogs}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TFileSystem.SetReparse(AParent,AEntry:TDiskEntry;AReparse:TDiskReparse):Boolean;
{Note: Descendant method must use WriterLock on Entries}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TFileSystem.SetSecurity(AParent,AEntry:TDiskEntry;ASecurity:TDiskSecurity):Boolean; 
{Note: Descendant method must use WriterLock on Entries}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TFileSystem.SizeEntry(AParent,AEntry:TDiskEntry;const ASize:Int64):Boolean;
{Note: Parent must be supplied}
{Note: Descendant method must use WriterLock on Entries}
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TFileSystem.GetTable(ATableNo:LongWord):TDiskTable;
{Note: TableNo is zero based} {Descendants may override if required}
var
 Next:TDiskTable;
begin
 {Base Implementation}
 Result:=nil;

 if not FTables.ReaderLock then Exit;
 try
  if FDriver = nil then Exit;
  
  {Check Tables}
  Next:=TDiskTable(FTables.First);
  while Next <> nil do
   begin
    if Next.TableNo = ATableNo then
     begin
      Result:=Next;
      Exit;
     end;
    Next:=TDiskTable(Next.Next);
   end;
 finally
  FTables.ReaderUnlock;
 end; 

 {Load Table}
 if LoadTable(ATableNo) then
  begin
   {Table Loaded call GetTable}
   Result:=GetTable(ATableNo);
  end;
end;

{==============================================================================}

function TFileSystem.GetTableEx(ATableNo:LongWord;AWrite:Boolean):TDiskTable; 
{Note: TableNo is zero based} {Descendants may override if required}
{Write: Use the writer lock on the blocks instead of the reader lock if True}
var
 Next:TDiskTable;
begin
 {Base Implementation}
 Result:=nil;

 if AWrite then
  begin
   if not FTables.WriterLock then Exit;
  end
 else
  begin   
   if not FTables.ReaderLock then Exit;
  end; 
 try
  if FDriver = nil then Exit;
  
  {Check Tables}
  Next:=TDiskTable(FTables.First);
  while Next <> nil do
   begin
    if Next.TableNo = ATableNo then
     begin
      Result:=Next;
      Exit;
     end;
    Next:=TDiskTable(Next.Next);
   end;
 finally
  if AWrite then
   begin
    FTables.WriterUnlock;
   end
  else
   begin
    FTables.ReaderUnlock;
   end;
 end; 

 {Load Table}
 if LoadTable(ATableNo) then
  begin
   {Table Loaded call GetTableEx}
   Result:=GetTableEx(ATableNo,AWrite);
  end;
end;

{==============================================================================}

function TFileSystem.GetBlock(ABlockNo:LongWord):TDiskBlock;
{Note: BlockNo is zero based} {Descendants may override if required}
var
 Next:TDiskBlock;
begin
 {Base Implementation}
 Result:=nil;

 if not FBlocks.ReaderLock then Exit;
 try
  if FDriver = nil then Exit;
  
  {Check Blocks}
  Next:=TDiskBlock(FBlocks.First);
  while Next <> nil do
   begin
    if Next.BlockNo = ABlockNo then
     begin
      Result:=Next;
      Exit;
     end;
    Next:=TDiskBlock(Next.Next);
   end;
 finally
  FBlocks.ReaderUnlock;
 end; 

 {Load Block}
 if LoadBlock(ABlockNo) then
  begin
   {Block Loaded call GetBlock}
   Result:=GetBlock(ABlockNo);
  end;
end;

{==============================================================================}

function TFileSystem.GetBlockEx(ABlockNo:LongWord;AWrite:Boolean):TDiskBlock; 
{Note: BlockNo is zero based} {Descendants may override if required}
{Write: Use the writer lock on the blocks instead of the reader lock if True}
var
 Next:TDiskBlock;
begin
 {Base Implementation}
 Result:=nil;

 if AWrite then
  begin
   if not FBlocks.WriterLock then Exit;
  end
 else
  begin   
   if not FBlocks.ReaderLock then Exit;
  end; 
 try
  if FDriver = nil then Exit;
  
  {Check Blocks}
  Next:=TDiskBlock(FBlocks.First);
  while Next <> nil do
   begin
    if Next.BlockNo = ABlockNo then
     begin
      Result:=Next;
      Exit;
     end;
    Next:=TDiskBlock(Next.Next);
   end;
 finally
  if AWrite then
   begin
    FBlocks.WriterUnlock;
   end
  else
   begin
    FBlocks.ReaderUnlock;
   end;
 end; 

 {Load Block}
 if LoadBlock(ABlockNo) then
  begin
   {Block Loaded call GetBlockEx}
   Result:=GetBlockEx(ABlockNo,AWrite);
  end;
end;

{==============================================================================}

function TFileSystem.GetEntry(AParent:TDiskEntry;const AName:String;AAttributes:LongWord):TDiskEntry;
{Note: If Parent is not supplied Root is assumed}
{Attributes is the match attributes to be checked}
var
 Hash:LongWord; 
 Next:TDiskEntry;
 Start:TDiskEntry;
 Parent:TDiskEntry;
 WorkBuffer:String;
begin
 {Base Implementation}
 Result:=nil;
 
 if FDriver = nil then Exit;
 
 {Get Parent}
 Parent:=AParent;
 if AParent = nil then Parent:=FRoot;
 
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSystem.GetEntry Name = ' + AName + ' Parent = ' + Parent.Name);
 {$ENDIF}
 
 {Get Name}
 WorkBuffer:=Uppercase(AName);
 
 {Load Entries}
 if LoadEntries(Parent) then
  begin
   if not FEntries.ReaderLock then Exit;
   try
    if (Length(AName) = 0) and (Parent = FRoot) then {Special case for root}
     begin
      Result:=Parent;
     end
    else 
     begin
      Hash:=GenerateNameHash(AName,NAME_HASH_SIZE); 
  
      Start:=Parent.Recent;
      if (Start <> nil) and (Start.Parent <> Parent) then Start:=nil; {Safety check for entry move}
      Next:=Start; {Parent.Recent;} {Start at Previous not Next} {Only read Recent once in case of change}
      if Next = nil then Next:=TDiskEntry(Parent.FirstChild);
      while Next <> nil do
       begin
        {Check Attributes (All entries will have only one match attribute)}
        if (Next.Attributes and faMatchMask) = (Next.Attributes and AAttributes) then
         begin
          if Next.Hash = Hash then
           begin
            if Uppercase(Next.Name) = WorkBuffer then
             begin
              {Check for Relative}
              if (Next.Attributes and faDot) = faDot then
               begin
                Result:=TDiskEntry(Next.Parent);
                Exit;
               end
              else if (Next.Attributes and faDotDot) = faDotDot then
               begin
                if Next.Parent = nil then Exit;
                
                Result:=TDiskEntry(Next.Parent.Parent);
                Exit;
               end
              else
               begin
                Parent.Recent:=Next;
                
                Result:=Next;
                Exit;
               end;
             end;
           end;
          if Next.AltHash = Hash then
           begin
            if Uppercase(Next.AltName) = WorkBuffer then
             begin
              {Check for Relative}
              if (Next.Attributes and faDot) = faDot then
               begin
                Result:=TDiskEntry(Next.Parent);
                Exit;
               end
              else if (Next.Attributes and faDotDot) = faDotDot then
               begin
                if Next.Parent = nil then Exit;
               
                Result:=TDiskEntry(Next.Parent.Parent);
                Exit;
               end
              else
               begin
                Parent.Recent:=Next;
                
                Result:=Next;
                Exit;
               end;
             end;
           end;
         end;
        
        Next:=TDiskEntry(Next.Next);
        
        if (Start <> nil) and (Next = nil) then Next:=TDiskEntry(Parent.FirstChild); {Start again from First}
        if (Start <> nil) and (Next = Start) then Break; {Break if returned to Start}
       end;
     end;
   finally
    FEntries.ReaderUnlock;
   end; 
  end;
end;

{==============================================================================}

function TFileSystem.GetEntryEx(AParent:TDiskEntry;const AName:String;AAttributes:LongWord;AAdd,ARemove,AWrite:Boolean):TDiskEntry; 
{Note: If Parent is not supplied Root is assumed}
{Attributes is the match attributes to be checked}
{Add: Add a reference on the returned entry if True}
{Remove: Remove a reference from the parent entry if True (If supplied)}
{Write: Use the writer lock on the entries instead of the reader lock if True}
var
 Hash:LongWord; 
 Next:TDiskEntry;
 Start:TDiskEntry;
 Parent:TDiskEntry;
 WorkBuffer:String;
begin
 {Base Implementation}
 Result:=nil;
 
 if FDriver = nil then Exit;
 
 {Get Parent}
 Parent:=AParent;
 if AParent = nil then Parent:=FRoot;
 
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSystem.GetEntryEx Name = ' + AName + ' Parent = ' + Parent.Name);
 {$ENDIF}
 
 {Get Name}
 WorkBuffer:=Uppercase(AName);
 
 {Load Entries}
 if LoadEntries(Parent) then
  begin
   if AWrite then
    begin
     if not FEntries.WriterLock then Exit;
    end
   else
    begin   
     if not FEntries.ReaderLock then Exit;
    end; 
   try
    try
     if (Length(AName) = 0) and (Parent = FRoot) then {Special case for root}
      begin
       Result:=Parent;
       if AAdd then Result.AddReference;
      end
     else 
      begin
       Hash:=GenerateNameHash(AName,NAME_HASH_SIZE); 
  
       Start:=Parent.Recent;
       if (Start <> nil) and (Start.Parent <> Parent) then Start:=nil; {Safety check for entry move}
       Next:=Start; {Parent.Recent;} {Start at Previous not Next} {Only read Recent once in case of change}
       if Next = nil then Next:=TDiskEntry(Parent.FirstChild);
       while Next <> nil do
        begin
         {Check Attributes (All entries will have only one match attribute)}
         if (Next.Attributes and faMatchMask) = (Next.Attributes and AAttributes) then
          begin
           if Next.Hash = Hash then
            begin
             if Uppercase(Next.Name) = WorkBuffer then
              begin
               {Check for Relative}
               if (Next.Attributes and faDot) = faDot then
                begin
                 Result:=TDiskEntry(Next.Parent);
                 if AAdd and (Result <> nil) then Result.AddReference;
                 Exit;
                end
               else if (Next.Attributes and faDotDot) = faDotDot then
                begin
                 if Next.Parent = nil then Exit;
                 
                 Result:=TDiskEntry(Next.Parent.Parent);
                 if AAdd and (Result <> nil) then Result.AddReference;
                 Exit;
                end
               else
                begin
                 Parent.Recent:=Next;
                 
                 Result:=Next;
                 if AAdd then Result.AddReference;
                 Exit;
                end;
              end;
            end;
           if Next.AltHash = Hash then
            begin
             if Uppercase(Next.AltName) = WorkBuffer then
              begin
               {Check for Relative}
               if (Next.Attributes and faDot) = faDot then
                begin
                 Result:=TDiskEntry(Next.Parent);
                 if AAdd and (Result <> nil) then Result.AddReference;
                 Exit;
                end
               else if (Next.Attributes and faDotDot) = faDotDot then
                begin
                 if Next.Parent = nil then Exit;
                
                 Result:=TDiskEntry(Next.Parent.Parent);
                 if AAdd and (Result <> nil) then Result.AddReference;
                 Exit;
                end
               else
                begin
                 Parent.Recent:=Next;
                 
                 Result:=Next;
                 if AAdd then Result.AddReference;
                 Exit;
                end;
              end;
            end;
          end;
         
         Next:=TDiskEntry(Next.Next);
         
         if (Start <> nil) and (Next = nil) then Next:=TDiskEntry(Parent.FirstChild); {Start again from First}
         if (Start <> nil) and (Next = Start) then Break; {Break if returned to Start}
        end;
      end;
    finally
     if ARemove and (AParent <> nil) then AParent.RemoveReference;
    end;
   finally
    if AWrite then
     begin
      FEntries.WriterUnlock;
     end
    else
     begin
      FEntries.ReaderUnlock;
     end;
   end; 
  end;
end;
 
{==============================================================================}

function TFileSystem.GetCatalog(ACatalogNo:LongWord):TDiskCatalog;
{Note: CatalogNo is one based}
var
 Next:TDiskCatalog;
begin
 {Base Implementation}
 Result:=nil;

 if FDriver = nil then Exit;
 if ACatalogNo = 0 then Exit;

 {Load Catalogs}
 if LoadCatalogs then
  begin
   if not FCatalogs.ReaderLock then Exit;
   try
    {Check Catalogs}
    Next:=TDiskCatalog(FCatalogs.First);
    while Next <> nil do
     begin
      if Next.CatalogNo = ACatalogNo then
       begin
        Result:=Next;
        Exit;
       end;
       
      Next:=TDiskCatalog(Next.Next);
     end;
   finally
    FCatalogs.ReaderUnlock;
   end;   
  end;
end;

{==============================================================================}

function TFileSystem.GetCatalogEx(ACatalogNo:LongWord;AWrite:Boolean):TDiskCatalog; 
{Note: CatalogNo is one based}
var
 Next:TDiskCatalog;
begin
 {Base Implementation}
 Result:=nil;

 if FDriver = nil then Exit;
 if ACatalogNo = 0 then Exit;

 {Load Catalogs}
 if LoadCatalogs then
  begin
   if AWrite then
    begin
     if not FCatalogs.WriterLock then Exit;
    end
   else
    begin   
     if not FCatalogs.ReaderLock then Exit;
    end; 
   try
    {Check Catalogs}
    Next:=TDiskCatalog(FCatalogs.First);
    while Next <> nil do
     begin
      if Next.CatalogNo = ACatalogNo then
       begin
        Result:=Next;
        Exit;
       end;
       
      Next:=TDiskCatalog(Next.Next);
     end;
   finally
    if AWrite then
     begin
      FCatalogs.WriterUnlock;
     end
    else
     begin
      FCatalogs.ReaderUnlock;
     end;
   end;   
  end;
end;

{==============================================================================}

function TFileSystem.GetReparse(AEntry:TDiskEntry):TDiskReparse;
begin
 {Virtual Base Method - No Function}
 Result:=nil;
end;

{==============================================================================}

function TFileSystem.GetSecurity(AEntry:TDiskEntry):TDiskSecurity;
begin
 {Virtual Base Method - No Function}
 Result:=nil;
end;

{==============================================================================}

function TFileSystem.MatchEntry(AParent,APrevious:TDiskEntry;const AName:String;AAttributes:LongWord;AAny:Boolean):TDiskEntry;
{Note: If Parent is not supplied Root is assumed}
{Attributes is the match attributes to be checked}
var
 Next:TDiskEntry;
 Parent:TDiskEntry;
begin
 {Base Implementation}
 Result:=nil;
 
 if FDriver = nil then Exit;
 
 {Get Parent}
 Parent:=AParent;
 if AParent = nil then Parent:=FRoot;
 
 {Load Entries}
 if LoadEntries(Parent) then
  begin
   if not FEntries.ReaderLock then Exit;
   try
    {Get Next}
    Next:=nil;
    if APrevious = nil then Next:=TDiskEntry(Parent.FirstChild);
    if APrevious <> nil then Next:=TDiskEntry(APrevious.Next); {Start at Next not Previous} 
    while Next <> nil do
     begin
      {Check Attributes (All entries will have only one match attribute)}
      if (Next.Attributes and faMatchMask) = (Next.Attributes and AAttributes) then
       begin
        {Note: No check for Dot and DotDot on match}
        if AAny then
         begin
          Result:=Next;
          Exit;
         end
        else
         begin
          if WildcardFileMatch(Next.Name,AName,FCaseSensitive) then
           begin
            Result:=Next;
            Exit;
           end
          else if WildcardFileMatch(Next.AltName,AName,FCaseSensitive) then
           begin
            Result:=Next;
            Exit;
           end;
         end;
       end;
      
      Next:=TDiskEntry(Next.Next);
     end;
   finally
    FEntries.ReaderUnlock;
   end; 
  end;
end;

{==============================================================================}

function TFileSystem.MatchEntryEx(AParent,APrevious:TDiskEntry;const AName:String;AAttributes:LongWord;AAny,AAdd,ARemove,AWrite:Boolean):TDiskEntry; 
{Note: If Parent is not supplied Root is assumed}
{Attributes is the match attributes to be checked}
{Add: Add a reference on the returned entry if True}
{Remove: Remove a reference from the previous entry if True (If supplied)}
{Write: Use the writer lock on the entries instead of the reader lock if True}
var
 Next:TDiskEntry;
 Parent:TDiskEntry;
begin
 {Base Implementation}
 Result:=nil;
 
 if FDriver = nil then Exit;
 
 {Get Parent}
 Parent:=AParent;
 if AParent = nil then Parent:=FRoot;
 
 {Load Entries}
 if LoadEntries(Parent) then
  begin
   if AWrite then
    begin
     if not FEntries.WriterLock then Exit;
    end
   else
    begin   
     if not FEntries.ReaderLock then Exit;
    end; 
   try
    try
     {Get Next}
     Next:=nil;
     if APrevious = nil then Next:=TDiskEntry(Parent.FirstChild);
     if APrevious <> nil then Next:=TDiskEntry(APrevious.Next); {Start at Next not Previous} 
     while Next <> nil do
      begin
       {Check Attributes (All entries will have only one match attribute)}
       if (Next.Attributes and faMatchMask) = (Next.Attributes and AAttributes) then
        begin
         {Note: No check for Dot and DotDot on match}
         if AAny then
          begin
           Result:=Next;
           if AAdd then Result.AddReference;
           Exit;
          end
         else
          begin
           if WildcardFileMatch(Next.Name,AName,FCaseSensitive) then
            begin
             Result:=Next;
             if AAdd then Result.AddReference;
             Exit;
            end
           else if WildcardFileMatch(Next.AltName,AName,FCaseSensitive) then
            begin
             Result:=Next;
             if AAdd then Result.AddReference;
             Exit;
            end;
          end;
        end;
      
       Next:=TDiskEntry(Next.Next);
      end;
    finally
     if ARemove and (APrevious <> nil) then APrevious.RemoveReference;
    end;
   finally
    if AWrite then
     begin
      FEntries.WriterUnlock;
     end
    else
     begin
      FEntries.ReaderUnlock;
     end;
   end; 
  end;
end;

{==============================================================================}

function TFileSystem.GetEntryPath(AEntry:TDiskEntry;AAltName:Boolean):String;
{Get the Full Path of an Entry (Not including Entry itself)}
{Note: Path ends with a trailing slash of PathChar unless Entry is a stream}
var
 WorkChar:String;
 Parent:TDiskEntry;
begin
 {}
 Result:='';
 
 if FDriver = nil then Exit;
 if AEntry = nil then Exit;
 
 {Get Path Char}
 WorkChar:=GetPathChar;
 
 if not FEntries.ReaderLock then Exit;
 try
  {Check Type}
  case (AEntry.Attributes and faMatchMask) of
   faDirectory,faFile,faVolumeID:begin
     {File, Folder, Label}
     Parent:=TDiskEntry(AEntry.Parent);
     while Parent <> nil do
      begin
       if Parent = FRoot then
        begin
         {Root Entry}
         Result:=AddTrailingChar(FRoot.Name,WorkChar) + Result;
        end
       else
        begin
         {Folder or File Entry}
         if (AAltName) and (Length(Parent.AltName) <> 0) then
          begin
           Result:=AddTrailingChar(Parent.AltName,WorkChar) + Result;
          end
         else
          begin
           Result:=AddTrailingChar(Parent.Name,WorkChar) + Result;
          end;
        end;
        
       Parent:=TDiskEntry(Parent.Parent);
      end;
    end;
   faStream:begin
     {Stream}
     Parent:=TDiskEntry(AEntry.Parent);
     
     Result:=GetEntryName(Parent,AAltName);
    end;
  end;
 finally
  FEntries.ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.GetEntryName(AEntry:TDiskEntry;AAltName:Boolean):String;
{Get the Full Name of an Entry (Including Entry itself)}
begin
 {}
 Result:='';
 
 if FDriver = nil then Exit;
 if AEntry = nil then Exit;
 
 if not FEntries.ReaderLock then Exit;
 try
  {Check Type}
  case (AEntry.Attributes and faMatchMask) of
   faDirectory,faFile,faVolumeID:begin
     {File, Folder, Label}
     if AEntry = FRoot then
      begin
       Result:=FRoot.Name;
      end
     else
      begin
       if (AAltName) and (Length(AEntry.AltName) <> 0) then
        begin
         Result:=AEntry.AltName;
        end
       else
        begin
         Result:=AEntry.Name;
        end;
      end;
    end;
   faStream:begin
     {Stream}
     Result:=AEntry.Name;
    end;
  end;
 
  {Get Entry Path}
  Result:=GetEntryPath(AEntry,AAltName) + Result;
 finally
  FEntries.ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.SplitPath(const APath:String;var ARelative:Boolean;AFolders:TStrings;var AName:String):Boolean;
{Split a Path into the component parts}
{Relative returns True if path is relative to current folder}
var
 PosIdx:Integer;
 WorkRoot:String;
 WorkPath:String;
 WorkBuffer:String;
begin
 {Base Implementation}
 Result:=False;
 
 if FDriver = nil then Exit;
 if FRoot = nil then Exit;
 if Length(APath) = 0 then Exit;
 if AFolders = nil then Exit;

 {$IFDEF FILESYS_DEBUG}
 {if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSystem.SplitPath Path = ' + APath);}
 {$ENDIF}
 
 {Get Root Char}
 WorkRoot:=GetRootChar;
 
 {Get Path Char}
 WorkPath:=GetPathChar;
 
 {Check for Relative}
 ARelative:=True;
 WorkBuffer:=APath;
 if (Length(FRoot.Name) <> 0) and (Uppercase(Copy(WorkBuffer,1,Length(FRoot.Name))) = Uppercase(FRoot.Name)) then
  begin
   {Path starts at Root Name (eg C:\ or \\?\Volume1)}
   ARelative:=False;
   Delete(WorkBuffer,1,Length(FRoot.Name));
  end
 else if (Length(FRoot.AltName) <> 0) and (Uppercase(Copy(WorkBuffer,1,Length(FRoot.AltName))) = Uppercase(FRoot.AltName)) then
  begin
   {Path starts at Root Alt Name (eg \\.\Harddisk0\Partition1)}
   ARelative:=False;
   Delete(WorkBuffer,1,Length(FRoot.AltName));
  end
 else if (Length(WorkRoot) <> 0) and (Uppercase(Copy(WorkBuffer,1,Length(WorkRoot))) = Uppercase(WorkRoot)) then
  begin
   {Path starts at Root Drive (eg C:)}
   ARelative:=True;
   Delete(WorkBuffer,1,Length(WorkRoot));
  end
 else if (Length(WorkPath) <> 0) and (Uppercase(Copy(WorkBuffer,1,Length(WorkPath))) = Uppercase(WorkPath)) then
  begin
   {Path starts at Root (eg \)}
   ARelative:=False;
   {No need to Delete due to StripLeadingChar below}
  end;
 
 {Get Folders}
 AFolders.Clear;
 WorkBuffer:=StripLeadingChar(StripTrailingChar(WorkBuffer,WorkPath),WorkPath);
 if Length(WorkBuffer) <> 0 then
  begin
   PosIdx:=Pos(WorkPath,WorkBuffer);
   while PosIdx <> 0 do
    begin
     AFolders.Add(Copy(WorkBuffer,1,PosIdx - 1));
     Delete(WorkBuffer,1,PosIdx);
     
     PosIdx:=Pos(WorkPath,WorkBuffer);
    end;
  end;
  
 {Get Name}
 AName:='';
 if Length(WorkBuffer) <> 0 then
  begin
   AName:=WorkBuffer;
  end;
  
 Result:=True;
end;

{==============================================================================}

function TFileSystem.SplitName(const AName:String;var AFile,AStream:String):Boolean;
{Split a Name into the component parts (File and Stream)}
{Name must not contain drive or path components}
{Returns False if name does not contain a stream component}
var
 PosIdx:Integer;
begin
 {Base Implementation}
 Result:=False;
 
 if FDriver = nil then Exit;
 if Length(AName) = 0 then Exit;
 if not FDataStreams then Exit;

 {Check Separator}
 PosIdx:=Pos(GetNameChar,AName);
 if PosIdx <> 0 then
  begin
   {Get File}
   AFile:=Copy(AName,1,PosIdx - 1);
   
   {Get Stream} {Include the Separator}
   AStream:=Copy(AName,PosIdx,Length(AName));
   
   Result:=True;
  end;
end;

{==============================================================================}

function TFileSystem.SplitFile(const AFile:String;var AName,AExt:String):Boolean;
{Split a File into the component parts (Name and Ext)}
{File must not contain drive or path components}
var
 PosIdx:Integer;
begin
 {Base Implementation}
 Result:=False;
 
 if FDriver = nil then Exit;
 if Length(AFile) = 0 then Exit;

 {Check Separator}
 PosIdx:=Pos(GetFileChar,AFile);
 if PosIdx <> 0 then
  begin
   {Get Name}
   AName:=Copy(AFile,1,PosIdx - 1);
   
   {Get Ext} {Remove the Separator}
   AExt:=Copy(AFile,PosIdx + 1,Length(AFile));
  end
 else
  begin
   {Get Name}
   AName:=AFile;
   
   {Get Ext}
   AExt:='';
  end;
  
 Result:=True;
end;

{==============================================================================}

function TFileSystem.SplitStream(const AStream:String;var AName,AType:String):Boolean;
{Split a Stream into the component parts (Name and Type)}
{Stream must not contain drive, path or file components}
var
 PosIdx:Integer;
 WorkChar:String;
 WorkBuffer:String;
begin
 {Base Implementation}
 Result:=False;
 
 if FDriver = nil then Exit;
 if Length(AStream) = 0 then Exit;

 {Get Name Char}
 WorkChar:=GetNameChar;
 
 {Check Separator}
 WorkBuffer:=AStream;
 if WorkBuffer[1] = WorkChar then
  begin
   Delete(WorkBuffer,1,1);
  end;
  
 {Check Separator}
 PosIdx:=Pos(WorkChar,WorkBuffer);
 if PosIdx <> 0 then
  begin
   {Get Name}
   AName:=Copy(WorkBuffer,1,PosIdx - 1);
   
   {Get Type} {Remove the Separator}
   AType:=Copy(WorkBuffer,PosIdx + 1,Length(WorkBuffer));
  end
 else
  begin
   {Get Name}
   AName:=WorkBuffer;
   
   {Get Type}
   AType:='';
  end;
  
 Result:=True;
end;

{==============================================================================}

function TFileSystem.BuildPath(ARelative:Boolean;AFolders:TLinkedStringList;const AName:String):String;
{Build Path from the component parts}
{If Relative is True then path is relative to current folder}
var
 WorkChar:String;
 Folder:TStringObject;
begin
 {Base Implementation}
 Result:='';
 
 if FDriver = nil then Exit;
 if FRoot = nil then Exit;
 if AFolders = nil then Exit;
 {if Length(AName) = 0 then Exit;} {Name may be blank}

 {Get Path Char}
 WorkChar:=GetPathChar;
 
 {Get Root}
 Result:=StripTrailingChar(FRoot.Name,WorkChar);
 if ARelative then Result:=StripTrailingChar(GetCurrentDir,WorkChar);
 
 {Get Folders}
 Folder:=TStringObject(AFolders.First);
 while Folder <> nil do
  begin
   Result:=Result + WorkChar + Folder.Value;
   Folder:=TStringObject(Folder.Next);
  end;
 
 {Get Name}
 if Length(AName) <> 0 then
  begin
   Result:=Result + WorkChar + AName;
  end;
end;

{==============================================================================}

function TFileSystem.BuildName(const AFile,AStream:String):String;
{Build a Name from the component parts (File and Stream)}
var
 WorkChar:String;
begin
 {Base Implementation}
 Result:='';
 
 if FDriver = nil then Exit;
 if Length(AFile) = 0 then Exit;
 {if Length(AStream) = 0 then Exit;} {Stream may be blank}

 Result:=AFile;
 if Length(AStream) <> 0 then
  begin
   {Get Name Char}
   WorkChar:=GetNameChar;
   
   if AStream[1] = WorkChar then
    begin
     Result:=Result + AStream;
    end
   else
    begin
     Result:=Result + WorkChar + AStream;
    end;
  end;
end;

{==============================================================================}

function TFileSystem.BuildFile(const AName,AExt:String):String;
{Build a File from the component parts (Name and Ext)}
begin
 {Base Implementation}
 Result:='';
 
 if FDriver = nil then Exit;
 if Length(AName) = 0 then Exit;
 {if Length(AExt) = 0 then Exit;} {Ext may be blank}

 Result:=AName;
 if Length(AExt) <> 0 then
  begin
   Result:=Result + GetFileChar + AExt;
  end;
end;

{==============================================================================}

function TFileSystem.BuildStream(const AName,AType:String):String;
{Build a Stream from the component parts (Name and Type)}
begin
 {Base Implementation}
 Result:='';
 
 if FDriver = nil then Exit;
 if Length(AName) = 0 then Exit;
 {if Length(AType) = 0 then Exit;} {Type may be blank}

 Result:=GetNameChar + AName;
 if Length(AType) <> 0 then
  begin
   Result:=Result + GetNameChar + AType;
  end;
end;

{==============================================================================}

function TFileSystem.CheckName(const AName:String):Boolean;
{Performs Name validation based on File System rules}
//To Do //CheckName should have Attributes to allow
//varying behaviour based on type (eg Label/Stream etc) //Yes, To Do
//Should also check for Name Char when it is a file or folder (not a stream)
begin
 {Base Implementation}
 Result:=False;
 
 if FDriver = nil then Exit;
 
 {Check for Length}
 if Length(AName) = 0 then Exit;
 if Length(AName) > FMaxFile then Exit;
 
 {Check for PathChar}
 if Pos(AName,GetPathChar) <> 0 then Exit;
 
 Result:=True;
end;

{==============================================================================}

function TFileSystem.CompareName(const AName,AMatch:String;AWildcard:Boolean):Boolean;
{Perform Name matching based on File System rules for Case-sensitivity etc}
{Also provides Wildcard matching based on File System rules}
begin
 {Base Implementation}
 Result:=False;
 
 if FDriver = nil then Exit;
 if Length(AName) = 0 then Exit;
 if Length(AMatch) = 0 then Exit;
 
 {Check Wildcard}
 if not AWildcard then
  begin
   {Check CaseSensitive}
   if FCaseSensitive then
    begin
     //To Do //To be used by Get/MatchFolder/File/Stream
    end
   else
    begin
     //To Do
    end;
  end
 else
  begin
   //To Do
  end;
end;

{==============================================================================}

function TFileSystem.CheckAltName(const AAltName:String):Boolean;
{Performs Name validation based on File System rules}
//To Do //CheckName should have Attributes to allow
//varying behaviour based on type (eg Label/Stream etc) //Yes, To Do
//Should also check for Name Char when it is a file or folder (not a stream)
begin
 {Base Implementation}
 Result:=False;
 
 if FDriver = nil then Exit;
 
 {Check for Length}
 if Length(AAltName) = 0 then Exit;
 if Length(AAltName) > FMaxAltFile then Exit;
 
 {Check for PathChar}
 if Pos(AAltName,GetPathChar) <> 0 then Exit;
 
 Result:=True;
end;

{==============================================================================}

function TFileSystem.CompareAltName(const AAltName,AMatch:String;AWildcard:Boolean):Boolean;
begin
 {Base Implementation}
 Result:=CompareName(AAltName,AMatch,AWildcard);
end;

{==============================================================================}

function TFileSystem.CheckLinkName(const AName:String):Boolean;
begin
 {Base Implementation}
 Result:=CheckName(AName);
end;

{==============================================================================}

function TFileSystem.GetSecurityFromDescriptor(ADescriptor:Pointer):TDiskSecurity;
begin
 {Virtual Base Method - No Function}
 Result:=nil;
end;

{==============================================================================}

function TFileSystem.GetDescriptorFromSecurity(ASecurity:TDiskSecurity;ADescriptor:Pointer;var ASize:LongWord):Boolean;
begin
 {Base Implementation}
 Result:=False;
 
 if FDriver = nil then Exit;
 if ASecurity = nil then Exit;
 {if ADescriptor = nil then Exit;} {Descriptor may be nil on first call to get Size}

 {Check Size}
 if ASize < ASecurity.SecuritySize then
  begin
   {Get Size}
   ASize:=ASecurity.SecuritySize;
  end
 else
  begin
   if ADescriptor = nil then Exit;
   
   {Get Descriptor}
   Result:=ASecurity.CopyToDescriptorEx(ADescriptor,ASize,False); {Return in API Format}
  end;
end;

{==============================================================================}

function TFileSystem.ReaderLock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TFileSystem.ReaderUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TFileSystem.ReaderConvert:Boolean; 
{Convert a Reader lock to a Writer lock}
begin
 {}
 Result:=(SynchronizerReaderConvert(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TFileSystem.WriterLock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TFileSystem.WriterUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TFileSystem.WriterConvert:Boolean;
{Convert a Writer lock to a Reader lock}
begin
 {}
 Result:=(SynchronizerWriterConvert(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TFileSystem.FileSystemInit:Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TFileSystem.MountFileSystem:Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TFileSystem.DismountFileSystem:Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TFileSystem.InitializeFileSystem(ASectorsPerCluster:LongWord;AFileSysType:TFileSysType):Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TFileSystem.CreateCatalog(const AName:String;AMediaType:TMediaType;AFloppyType:TFloppyType;AAttributes:LongWord;ASectorSize:Word;const ASectorCount:Int64):LongWord;
var
 Name:String;
 Relative:Boolean;
 ParentName:String;
 StreamName:String;
 StreamType:String;
 Folder:TStringObject;
 Folders:TLinkedStringList;

 Parent:TDiskEntry;
 Current:TDiskEntry;
 Catalog:TDiskCatalog;
begin
 {}
 Result:=0; {Return is a CatalogNo}

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Load Catalogs}
  if not LoadCatalogs then Exit;
  
  {Split the Path}
  Folders:=TLinkedStringList.Create;
  try
   if SplitPath(AName,Relative,Folders,Name) then
    begin
     {Get Parent}
     Parent:=FRoot;
     if Relative then Parent:=GetCurrent;
     if Parent = nil then Exit;
     
     {Add Reference}
     Parent.AddReference; 
     
     {Get Folders}
     Folder:=TStringObject(Folders.First);
     while Folder <> nil do
      begin
       Parent:=GetEntryEx(Parent,Folder.Value,faDirectory,True,True,False);
       if Parent = nil then Exit;
       
       Folder:=TStringObject(Folder.Next);
      end;
     
     {Split the Name}
     if SplitName(Name,ParentName,StreamName) then
      begin
       {Get File or Folder}
       Parent:=GetEntryEx(Parent,ParentName,faDirectory or faFile,True,True,False);
       if Parent = nil then Exit;
       
       {Get Stream}
       Current:=GetEntryEx(Parent,StreamName,faStream,True,False,False);
       if Current = nil then
        begin
         {Split the Stream}
         if SplitStream(StreamName,StreamName,StreamType) then
          begin
           {Get Stream}
           Current:=GetEntryEx(Parent,StreamName,faStream,True,False,False);
          end;
        end;
       if Current = nil then
        begin
         {Remove Reference}
         Parent.RemoveReference;
         Exit;
        end; 
      end
     else
      begin
       {Get File or Folder}
       Current:=GetEntryEx(Parent,Name,faDirectory or faFile,True,False,False);
       if Current = nil then
        begin
         {Remove Reference}
         Parent.RemoveReference;
         Exit;
        end; 
      end;
      
     {Add Catalog}
     Catalog:=AddCatalog(Current,AMediaType,AFloppyType,AAttributes,ASectorSize,ASectorCount);
     if Catalog <> nil then Result:=Catalog.CatalogNo;
     
     {Remove Reference}
     Current.RemoveReference;
     Parent.RemoveReference;
    end;
  finally
   Folders.Free;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.DeleteCatalog(ACatalogNo:LongWord):Boolean;
var
 Catalog:TDiskCatalog;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Load Catalogs}
  if not LoadCatalogs then Exit;
  
  {Get Catalog}
  Catalog:=GetCatalog(ACatalogNo);
  if Catalog = nil then Exit;
  
  {Remove Catalog}
  Result:=RemoveCatalog(Catalog);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.FindFirstCatalog(var ASearchRec:TCatalogSearchRec):Integer;
var
 Handle:TEnumHandle;
 Current:TDiskCatalog;
begin
 {Base Implementation}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  ASearchRec.FindHandle:=INVALID_HANDLE_VALUE;
  
  if FDriver = nil then Exit;

  {Load Catalogs}
  if not LoadCatalogs then Exit;
  
  {Find First Catalog}
  Current:=GetCatalogByNext(nil,True,False,FILESYS_LOCK_READ); 
  if Current = nil then Exit;
  try
   {Open Handle}
   Handle:=FDriver.OpenEnumHandle(Self,True,FILESYS_LOCK_WRITE);
   if Handle = nil then Exit;
  
   {Set the Handle properties}
   Handle.CurrentCatalog:=Current;
  
   {Return Catalog}
   ASearchRec.FindHandle:=Handle.Handle;
   ASearchRec.Name:=Current.Name;
   ASearchRec.Path:=Current.Path;
   ASearchRec.CatalogNo:=Current.CatalogNo;
   ASearchRec.MediaType:=Current.MediaType;
   ASearchRec.FloppyType:=Current.FloppyType;
   ASearchRec.Attributes:=Current.Attributes;
   ASearchRec.SectorSize:=Current.SectorSize;
   ASearchRec.SectorCount:=Current.SectorCount;
  
   Result:=0;
   
   {Unlock Handle}
   Handle.WriterUnlock;
  finally
   {Unlock Catalog}
   Current.ReaderUnlock;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.FindNextCatalog(var ASearchRec:TCatalogSearchRec):Integer;
var
 Handle:TEnumHandle;
 Current:TDiskCatalog;
begin
 {Base Implementation}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Get the Handle}
  Handle:=FDriver.GetEnumFromHandle(ASearchRec.FindHandle,True,FILESYS_LOCK_WRITE);
  if Handle = nil then Exit;
  try
   {Check Catalog}
   if not CheckCatalog(Handle.CurrentCatalog,True,FILESYS_LOCK_READ) then Exit;
  
   {Find Next Catalog}
   Current:=GetCatalogByNext(Handle.CurrentCatalog,True,True,FILESYS_LOCK_READ);
   if Current = nil then Exit;
  
   {Update Handle}
   Handle.CurrentCatalog:=Current;
  
   {Return Catalog}
   ASearchRec.FindHandle:=Handle.Handle;
   ASearchRec.Name:=Current.Name;
   ASearchRec.Path:=Current.Path;
   ASearchRec.CatalogNo:=Current.CatalogNo;
   ASearchRec.MediaType:=Current.MediaType;
   ASearchRec.FloppyType:=Current.FloppyType;
   ASearchRec.Attributes:=Current.Attributes;
   ASearchRec.SectorSize:=Current.SectorSize;
   ASearchRec.SectorCount:=Current.SectorCount;
   
   {Unlock Catalog}
   Current.ReaderUnlock;
   
   Result:=0;
  finally
   {Unlock Handle}
   Handle.WriterUnlock;
  end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

procedure TFileSystem.FindCatalogClose(var ASearchRec:TCatalogSearchRec);
{Close an open find Handle}
var
 Handle:TEnumHandle;
begin
 {Base Implementation}
 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Get the Handle}
  Handle:=FDriver.GetEnumFromHandle(ASearchRec.FindHandle,True,FILESYS_LOCK_WRITE);
  if Handle = nil then Exit;
  
  {Close the Handle} {Do not unlock}
  FDriver.CloseEnumHandle(Handle);
  
  ASearchRec.FindHandle:=INVALID_HANDLE_VALUE;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.GetDriveLabel:String;
begin
 {Base Implementation}
 Result:=GetVolumeName;
end;

{==============================================================================}

function TFileSystem.SetDriveLabel(const ALabel:String):Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TFileSystem.GetDriveSerial:LongWord;
begin
 {Base Implementation}
 Result:=FVolumeSerial;
end;

{==============================================================================}

function TFileSystem.SetDriveSerial(ASerial:LongWord):Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TFileSystem.GetDriveFreeSpace:LongWord;
{Return the Free space on Drive up to 2GB}
var
 WorkInt:Int64;
begin
 {Base Implementation}
 WorkInt:=GetDriveFreeSpaceEx;
 
 Result:=TULargeInteger(WorkInt).LowPart;
 if TULargeInteger(WorkInt).HighPart > 0 then Result:=LongWord(-1);
end;

{==============================================================================}

function TFileSystem.GetDriveFreeSpaceEx:Int64;
begin
 {Virtual Base Method - No Function}
 Result:=0;
end;

{==============================================================================}

function TFileSystem.GetDriveTotalSpace:LongWord;
{Return the Total space on Drive up to 2GB}
var
 WorkInt:Int64;
begin
 {Base Implementation}
 WorkInt:=GetDriveTotalSpaceEx;
 
 Result:=TULargeInteger(WorkInt).LowPart;
 if TULargeInteger(WorkInt).HighPart > 0 then Result:=LongWord(-1);
end;

{==============================================================================}

function TFileSystem.GetDriveTotalSpaceEx:Int64;
{Return the Total space on Drive up to 4TB}
begin
 {Base Implementation}
 Result:=0;
 
 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;
 
  Result:=FSectorCount;
  Result:=(Result * FSectorSize);
 
  {Modified to ensure Int64 mutliply}
  {Result:=(FSectorCount * FSectorSize);}
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.GetDriveInformation(var AClusterSize:LongWord;var ATotalClusterCount,AFreeClusterCount:Int64):Boolean; 
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TFileSystem.FileOpen(const FileName:String;Mode:Integer):THandle;
{Open existing entry and return Handle}
{Note: FileOpen can also open Folders but the handle can only be used for Get/SetFileTime}
{Note: Cannot create with FileOpen}
var
 Name:String;
 Relative:Boolean;
 ParentName:String;
 StreamName:String;
 StreamType:String;
 Folder:TStringObject;
 FileHandle:TFileHandle;
 Folders:TLinkedStringList;

 Parent:TDiskEntry;
 Current:TDiskEntry;
begin
 {Base Implementation}
 Result:=INVALID_HANDLE_VALUE;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Check Open Mode}
  if Mode = fmCreate then Exit;
  
  {Split the Path}
  Folders:=TLinkedStringList.Create;
  try
   if SplitPath(FileName,Relative,Folders,Name) then
    begin
     {Get Parent}
     Parent:=FRoot;
     if Relative then Parent:=GetCurrent;
     if Parent = nil then Exit;
     
     {Add Reference}
     Parent.AddReference; 
     
     {Get Folders}
     Folder:=TStringObject(Folders.First);
     while Folder <> nil do
      begin
       Parent:=GetEntryEx(Parent,Folder.Value,faDirectory,True,True,False);
       if Parent = nil then Exit;
       
       Folder:=TStringObject(Folder.Next);
      end;
     
     {Split the Name}
     if SplitName(Name,ParentName,StreamName) then
      begin
       {Get File or Folder}
       Parent:=GetEntryEx(Parent,ParentName,faDirectory or faFile,True,True,False);
       if Parent = nil then Exit;
       
       {Get Stream}
       Current:=GetEntryEx(Parent,StreamName,faStream,True,False,False);
       if Current = nil then
        begin
         {Split the Stream}
         if SplitStream(StreamName,StreamName,StreamType) then
          begin
           {Get Stream}
           Current:=GetEntryEx(Parent,StreamName,faStream,True,False,False);
          end;
        end;
       if Current = nil then
        begin
         {Remove Reference}
         Parent.RemoveReference;
         Exit;
        end; 
      end
     else
      begin
       {Get File or Folder}
       Current:=GetEntryEx(Parent,Name,faDirectory or faFile,True,False,False);
       if Current = nil then
        begin
         {Remove Reference}
         Parent.RemoveReference;
         Exit;
        end; 
      end;
     try
      {Check Attributes}
      if (Mode and fmOpenMask) <> fmOpenRead then if (Current.Attributes and faReadOnly) <> faNone then Exit;
     
      {Open Handle}
      FileHandle:=FDriver.OpenFileHandle(FVolume,FDrive,Parent,Current,Mode,True,FILESYS_LOCK_WRITE);
      if FileHandle = nil then Exit;
     
      {Check Update}
      if FILESYS_UPDATE_ACCESSTIME then
       begin
        {Set Time}
        Current.AccessTime:=Ultibo.DateTimeToFileTime(Now); {Converted to UTC}
       
        {Update Entry} {Dont check return}
        {SetEntry(Parent,Current);} {Modified 13/10/2009 (Update if opened for read only)}
        if FileHandle.OpenMode = fmOpenRead then SetEntry(Parent,Current);
       end; 
     
      {Return the Handle}
      Result:=FileHandle.Handle;
     
      {Unlock Handle}
      FileHandle.WriterUnlock;
     finally
      {Remove Reference}
      Current.RemoveReference;
      Parent.RemoveReference;
     end;     
    end;
  finally
   Folders.Free;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.FileCreate(const FileName:String;Mode:Integer = fmOpenReadWrite or fmShareExclusive):THandle;
{Create new entry or truncate existing entry and return Handle}
{Note: Cannot create Folders with FileCreate}
var
 Name:String;
 Relative:Boolean;
 ParentName:String;
 StreamName:String;
 StreamType:String;
 Folder:TStringObject;
 FileHandle:TFileHandle;
 Folders:TLinkedStringList;

 Parent:TDiskEntry;
 Current:TDiskEntry;
begin
 {Base Implementation}
 Result:=INVALID_HANDLE_VALUE;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Split the Path}
  Folders:=TLinkedStringList.Create;
  try
   if SplitPath(FileName,Relative,Folders,Name) then
    begin
     {Get Parent}
     Parent:=FRoot;
     if Relative then Parent:=GetCurrent;
     if Parent = nil then Exit;
     
     {Add Reference}
     Parent.AddReference; 
     
     {Get Folders}
     Folder:=TStringObject(Folders.First);
     while Folder <> nil do
      begin
       Parent:=GetEntryEx(Parent,Folder.Value,faDirectory,True,True,False);
       if Parent = nil then Exit;
       
       Folder:=TStringObject(Folder.Next);
      end;
     
     {Split the Name}
     if SplitName(Name,ParentName,StreamName) then
      begin
       {Get File or Folder}
       Parent:=GetEntryEx(Parent,ParentName,faDirectory or faFile,True,True,False);
       if Parent = nil then Exit;
       
       {Get Stream}
       Current:=GetEntryEx(Parent,StreamName,faStream,True,False,False);
       if Current = nil then
        begin
         {Split the Stream}
         if SplitStream(StreamName,StreamName,StreamType) then
          begin
           {Get Stream}
           Current:=GetEntryEx(Parent,StreamName,faStream,True,False,False);
          end;
        end;  
       if Current = nil then
        begin
         {Check Name}
         if not CheckName(StreamName) then
          begin
           {Remove Reference}
           Parent.RemoveReference;
           Exit;
          end; 
         
         {Add Stream}
         Current:=AddEntry(Parent,StreamName,faStream,True); 
         if Current = nil then
          begin
           {Remove Reference}
           Parent.RemoveReference;
           Exit;
          end;
        end;
      end
     else
      begin
       {Get File or Folder}
       Current:=GetEntryEx(Parent,Name,faDirectory or faFile,True,False,False);
       if Current = nil then
        begin
         {Check Name}
         if not CheckName(Name) then
          begin
           {Remove Reference}
           Parent.RemoveReference;
           Exit;
          end; 
         
         {Add File}
         Current:=AddEntry(Parent,Name,faFile,True);
         if Current = nil then
          begin
           {Remove Reference}
           Parent.RemoveReference;
           Exit;
          end; 
         
         {Check Encryption}
         if (FFolderEncryption) and ((Parent.Attributes and faEncrypted) = faEncrypted) then
          begin
           {Set Encrypted}
           Current.Attributes:=(Current.Attributes or faEncrypted);
           if not SetEntry(Parent,Current) then
            begin
             {Remove Reference}
             Current.RemoveReference;
             Parent.RemoveReference;
             Exit;
            end; 
          end;
         
         {Check Compression}
         if (FFolderCompression) and ((Parent.Attributes and faCompressed) = faCompressed) then
          begin
           {Set Compressed}
           Current.Attributes:=(Current.Attributes or faCompressed);
           if not SetEntry(Parent,Current) then
            begin
             {Remove Reference}
             Current.RemoveReference;
             Parent.RemoveReference;
             Exit;
            end; 
          end;
        end; 
      end;
     try
      {Open Handle}
      FileHandle:=FDriver.OpenFileHandle(FVolume,FDrive,Parent,Current,Mode,True,FILESYS_LOCK_WRITE);
      if FileHandle = nil then Exit;
     
      {Set the Size} {In case of existing file}
      if Current.Size <> 0 then if not SizeEntry(FileHandle.ParentEntry,FileHandle.HandleEntry,0) then Exit;
     
      {Set Attributes} {Entry will be updated by FileClose}
      Current.Attributes:=(Current.Attributes or faArchive);
     
      {Return the Handle}
      Result:=FileHandle.Handle;
   
      {Unlock Handle}
      FileHandle.WriterUnlock;
     finally
      {Remove Reference}
      Current.RemoveReference;
      Parent.RemoveReference;
     end;     
    end;
  finally
   Folders.Free;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.DeleteFile(const FileName:String):Boolean;
{Delete existing entry}
var
 Name:String;
 Relative:Boolean;
 ParentName:String;
 StreamName:String;
 StreamType:String;
 Folder:TStringObject;
 Folders:TLinkedStringList;

 Next:TDiskEntry;
 Parent:TDiskEntry;
 Current:TDiskEntry;
begin
 {Base Implementation}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Split the Path}
  Folders:=TLinkedStringList.Create;
  try
   if SplitPath(FileName,Relative,Folders,Name) then
    begin
     {Get Parent}
     Parent:=FRoot;
     if Relative then Parent:=GetCurrent;
     if Parent = nil then Exit;
    
     {Add Reference}
     Parent.AddReference; 
    
     {Get Folders}
     Folder:=TStringObject(Folders.First);
     while Folder <> nil do
      begin
       Parent:=GetEntryEx(Parent,Folder.Value,faDirectory,True,True,False);
       if Parent = nil then Exit;
       
       Folder:=TStringObject(Folder.Next);
      end;
    
     {Split the Name}
     if SplitName(Name,ParentName,StreamName) then
      begin
       {Get File or Folder}
       Parent:=GetEntryEx(Parent,ParentName,faDirectory or faFile,True,True,False);
       if Parent = nil then Exit;
      
       {Get Stream}
       Current:=GetEntryEx(Parent,StreamName,faStream,True,False,False);
       if Current = nil then
        begin
         {Split the Stream}
         if SplitStream(StreamName,StreamName,StreamType) then
          begin
           {Get Stream}
           Current:=GetEntryEx(Parent,StreamName,faStream,True,False,False);
          end;
        end;
       if Current = nil then
        begin
         {Remove Reference}
         Parent.RemoveReference;
         Exit;
        end; 
      end
     else
      begin
       {Get File or Folder}
       Current:=GetEntryEx(Parent,Name,faDirectory or faFile,True,False,False);
       if Current = nil then
        begin
         {Remove Reference}
         Parent.RemoveReference;
         Exit;
        end; 
      
       {Load Entries}
       if not LoadEntries(Current) then
        begin
         {Remove Reference}
         Current.RemoveReference;
         Parent.RemoveReference;
         Exit;
        end; 
      
       {Check Entries}
       if not FEntries.ReaderLock then
        begin
         {Remove Reference}
         Current.RemoveReference;
         Parent.RemoveReference;
         Exit;
        end; 
       try
        Next:=TDiskEntry(Current.FirstChild);
        while Next <> nil do
         begin
          {Allow delete if only Dot, DotDot or Streams remain}
          if (Next.Attributes and (faDot or faDotDot or faStream)) = faNone then
           begin
            {Remove Reference}
            Current.RemoveReference;
            Parent.RemoveReference;
            Exit;
           end; 
          
          //To Do //Should we do CheckFileHandles/UpdateFindHandles on each of these ? //Probably on Streams Yes - See also RemoveDir/DeleteHardlink
                                                                                       //How to protect ? (see notes)
        
          Next:=TDiskEntry(Next.Next);
         end;
       finally
        FEntries.ReaderUnlock;
       end; 
      end;
     try
      {Check Handles}
      if not FDriver.CheckFileHandles(Current) then Exit;
    
      {Update Handles}
      if not FDriver.UpdateFindHandles(Current) then Exit;
    
      {Remove Entry}
      Result:=RemoveEntry(Parent,Current);
      if Result and (Parent.Recent = Current) then Parent.Recent:=nil;
     finally
      {Remove Reference}
      Current.RemoveReference;
      Parent.RemoveReference;
     end;     
    end;
  finally
   Folders.Free;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

procedure TFileSystem.FileClose(Handle:Integer);
{Close open handle}
var
 FileHandle:TFileHandle;
begin
 {Base Implementation}
 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Get the Handle}
  FileHandle:=FDriver.GetFileFromHandle(Handle,True,FILESYS_LOCK_WRITE);
  if FileHandle = nil then Exit;
 
  {Update Entry} {Dont check return}
  if FileHandle.OpenMode <> fmOpenRead then SetEntry(FileHandle.ParentEntry,FileHandle.HandleEntry);

  {Close the Handle} {Do not unlock}
  FDriver.CloseFileHandle(FileHandle);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.RenameFile(const OldName,NewName:String):Boolean;
{Rename existing entry}
{If 8.3 then modify entry if Long then create new entry, delete existing}
var
 DestName:String;
 SourceName:String;
 Relative:Boolean;
 MoveOnly:Boolean;
 ParentName:String;
 StreamName:String;
 StreamType:String;
 Folder:TStringObject;
 Folders:TLinkedStringList;

 Dest:TDiskEntry;
 Source:TDiskEntry;
 Current:TDiskEntry;
begin
 {Base Implementation}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Split the Source Path}
  Folders:=TLinkedStringList.Create;
  try
   if SplitPath(OldName,Relative,Folders,SourceName) then
    begin
     {Get Source Parent}
     Source:=FRoot;
     if Relative then Source:=GetCurrent;
     if Source = nil then Exit;
     
     MoveOnly:=False;
     
     {Add Reference}
     Source.AddReference; 
     
     {Get Source Folders}
     Folder:=TStringObject(Folders.First);
     while Folder <> nil do
      begin
       Source:=GetEntryEx(Source,Folder.Value,faDirectory,True,True,False);
       if Source = nil then Exit;
       
       Folder:=TStringObject(Folder.Next);
      end;
    
     {Split the Dest Path}
     if SplitPath(NewName,Relative,Folders,DestName) then
      begin
       {Get Dest Parent}
       Dest:=FRoot;
       if Relative then Dest:=GetCurrent;
       if Dest = nil then
        begin
         {Remove Reference}
         Source.RemoveReference;
         Exit;
        end; 
      
       {Add Reference}
       Dest.AddReference; 
       
       {Get Dest Folders}
       Folder:=TStringObject(Folders.First);
       while Folder <> nil do
        begin
         Dest:=GetEntryEx(Dest,Folder.Value,faDirectory,True,True,False);
         if Dest = nil then
          begin
           {Remove Reference}
           Source.RemoveReference;
           Exit;
          end; 
         
         Folder:=TStringObject(Folder.Next);
        end;
       
       {Split the Source Name}
       if SplitName(SourceName,ParentName,StreamName) then
        begin
         {Get Source File or Folder}
         Source:=GetEntryEx(Source,ParentName,faDirectory or faFile,True,True,False);
         if Source = nil then
          begin
           {Remove Reference}
           Dest.RemoveReference;
           Exit;
          end; 
         
         {Get Source Stream}
         Current:=GetEntryEx(Source,StreamName,faStream,True,False,False);
         if Current = nil then
          begin
           {Split the Source Stream}
           if SplitStream(StreamName,StreamName,StreamType) then
            begin
             {Get Source Stream}
             Current:=GetEntryEx(Source,StreamName,faStream,True,False,False);
            end;
          end;
         if Current = nil then
          begin
           {Remove Reference}
           Dest.RemoveReference;
           Source.RemoveReference;
           Exit;
          end; 
         
         {Split the Dest Name}
         if not SplitName(DestName,ParentName,StreamName) then
          begin
           {Remove Reference}
           Current.RemoveReference;
           Dest.RemoveReference;
           Source.RemoveReference;
           Exit;
          end; 
         
         {Get Dest File or Folder}
         Dest:=GetEntryEx(Dest,ParentName,faDirectory or faFile,True,True,False);
         if Dest = nil then
          begin
           {Remove Reference}
           Current.RemoveReference;
           Source.RemoveReference;
           Exit;
          end; 
         try
          {Split the Dest Stream}
          SplitStream(StreamName,StreamName,StreamType);
          
          {Check Dest Name}
          if not CheckName(StreamName) then Exit;
          
          {Check Source Handles}
          if not FDriver.CheckFileHandles(Current) then Exit;
          
          {Check for Move}
          if Source <> Dest then
           begin
            {Check Dest Stream}
            if GetEntry(Dest,StreamName,faStream) <> nil then Exit;
            
            {Check Source Stream} {Allow for Current}
            if GetEntry(Source,StreamName,faStream) = Current then MoveOnly:=True;
            
            {Update Source Handles}
            if not FDriver.UpdateFindHandles(Current) then Exit;
            
            {Move Source Stream}
            Result:=MoveEntry(Source,Dest,Current);
            if Result and (Source.Recent = Current) then Source.Recent:=nil; 
            if not Result then Exit; 
             
            {Check Rename}
            if not MoveOnly then
             begin
              {Rename Dest Stream} 
              Result:=RenameEntry(Dest,Current,StreamName);
              if Result and (Dest.Recent = Current) then Dest.Recent:=nil; 
             end; 
           end
          else
           begin
            {Check Source Stream}
            if GetEntry(Source,StreamName,faStream) <> nil then Exit;
             
            {Rename Source Stream}
            Result:=RenameEntry(Source,Current,StreamName);
            if Result and (Source.Recent = Current) then Source.Recent:=nil; 
           end;
         finally
          {Remove Reference}
          Current.RemoveReference;
          Dest.RemoveReference;
          Source.RemoveReference;
         end;         
        end
       else
        begin
         {Get Source File or Folder}
         Current:=GetEntryEx(Source,SourceName,faDirectory or faFile,True,False,False);
         if Current = nil then
          begin
           {Remove Reference}
           Dest.RemoveReference;
           Source.RemoveReference;
           Exit;
          end;
         try 
          {Split the Dest Name}
          if SplitName(DestName,ParentName,StreamName) then Exit;
          
          {Check Dest Name}
          if not CheckName(DestName) then Exit;
          
          {Check Source Handles}
          if not FDriver.CheckFileHandles(Current) then Exit;
          
          {Check for Move}
          if Source <> Dest then
           begin
            {Check Dest File or Folder}
            if GetEntry(Dest,DestName,faDirectory or faFile) <> nil then Exit;
             
            {Check Source File or Folder} {Allow for Current}
            if GetEntry(Source,DestName,faDirectory or faFile) = Current then MoveOnly:=True;
             
            {Load Entries} {For Folder move update DotDot}
            if not LoadEntries(Current) then Exit;
            
            {Update Source Handles}
            if not FDriver.UpdateFindHandles(Current) then Exit;
            
            {Move Source File or Folder}
            Result:=MoveEntry(Source,Dest,Current);
            if Result and (Source.Recent = Current) then Source.Recent:=nil; 
            if not Result then Exit;
            
            {Check Rename}
            if not MoveOnly then
             begin
              {Rename Dest File or Folder} 
              Result:=RenameEntry(Dest,Current,DestName);
              if Result and (Dest.Recent = Current) then Dest.Recent:=nil; 
             end; 
           end
          else
           begin
            {Check Source File or Folder}
            if GetEntry(Source,DestName,faDirectory or faFile) <> nil then Exit;
             
            {Rename Source File or Folder}
            Result:=RenameEntry(Source,Current,DestName);
            if Result and (Source.Recent = Current) then Source.Recent:=nil; 
           end;
         finally
          {Remove Reference}
          Current.RemoveReference;
          Dest.RemoveReference;
          Source.RemoveReference;
         end;         
        end;
      end
     else
      begin
       {Remove Reference}
       Source.RemoveReference;
      end;      
    end;
  finally
   Folders.Free;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.FileSeek(Handle:THandle;Offset,Origin:LongInt):LongInt;
{Move the position of an open handle}
begin
 {Base Implementation}
 Result:=FileSeekEx(Handle,Offset,Origin);
end;

{==============================================================================}

function TFileSystem.FileSeekEx(Handle:THandle;const Offset:Int64;Origin:LongInt):Int64;
{Move the position of an open handle}
{Note: File Seeks can extend the size if OpenMode is Write or ReadWrite}
var
 FileHandle:TFileHandle;
begin
 {Base Implementation}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Get the Handle}
  FileHandle:=FDriver.GetFileFromHandle(Handle,True,FILESYS_LOCK_WRITE);
  if FileHandle = nil then Exit;
  try
   {Check the Handle}
   if FileHandle.HandleEntry = nil then Exit;
 
   {Move Pointer}
   case Origin of
    soFromBeginning:begin
      {Check Offset}
      if Offset < 0 then Exit;
      if Offset > FileHandle.HandleEntry.Size then if FileHandle.OpenMode = fmOpenRead then Exit;
      FileHandle.Position:=Offset;
      
      Result:=FileHandle.Position;
     end;
    soFromCurrent:begin
      {Check Offset}
      if (FileHandle.Position + Offset) < 0 then Exit;
      if (FileHandle.Position + Offset) > FileHandle.HandleEntry.Size then if FileHandle.OpenMode = fmOpenRead then Exit;
      FileHandle.Position:=(FileHandle.Position + Offset);
      
      Result:=FileHandle.Position;
     end;
    soFromEnd:begin
      {Check Offset}
      if (FileHandle.HandleEntry.Size + Offset) < 0 then Exit;
      if (FileHandle.HandleEntry.Size + Offset) > FileHandle.HandleEntry.Size then if FileHandle.OpenMode = fmOpenRead then Exit;
      FileHandle.Position:=(FileHandle.HandleEntry.Size + Offset);
      
      Result:=FileHandle.Position;
     end;
   end;
  finally
   {Unlock Handle}
   FileHandle.WriterUnlock;
  end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.FileFlush(Handle:Integer):Boolean;
{Flush an open handle from Cache}
{Note: Currently just flushes the Cache}
var
 FileHandle:TFileHandle;
begin
 {Base Implementation}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Get the Handle}
  FileHandle:=FDriver.GetFileFromHandle(Handle,True,FILESYS_LOCK_WRITE); //To Do //Reader
  if FileHandle = nil then Exit;
 
  {Flush the Cache}
  Result:=FDriver.Cache.FlushCache(False,True);

  {Unlock Handle}
  FileHandle.WriterUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.FileTruncate(Handle:Integer):Boolean;
{Truncate an open file at the current position}
{Note: Can extend a file as well as truncate}
var
 FileHandle:TFileHandle;
begin
 {Base Implementation}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Get the Handle}
  FileHandle:=FDriver.GetFileFromHandle(Handle,True,FILESYS_LOCK_WRITE); //To Do //Reader
  if FileHandle = nil then Exit;
 
  {Set the Size at Current Position}
  Result:=(FileSetSizeEx(Handle,FileHandle.Position) = 0);
 
  {Unlock Handle}
  FileHandle.WriterUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.FilePos(Handle:THandle):LongInt;
{Return the position of an open Handle}
begin
 {Base Implementation}
 Result:=FilePosEx(Handle);
end;

{==============================================================================}

function TFileSystem.FilePosEx(Handle:THandle):Int64;
{Return the position of an open Handle}
var
 FileHandle:TFileHandle;
begin
 {Base Implementation}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Get the Handle}
  FileHandle:=FDriver.GetFileFromHandle(Handle,True,FILESYS_LOCK_WRITE); //To Do //Reader   
  if FileHandle = nil then Exit;
 
  {Get the Position}
  Result:=FileHandle.Position;
 
  {Unlock Handle}
  FileHandle.WriterUnlock;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.FileGetAttr(const FileName:String):Integer;
{Get the attributes of an existing entry}
var
 Name:String;
 Relative:Boolean;
 ParentName:String;
 StreamName:String;
 StreamType:String;
 Folder:TStringObject;
 Folders:TLinkedStringList;

 Parent:TDiskEntry;
 Current:TDiskEntry;
begin
 {Base Implementation}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Split the Path}
  Folders:=TLinkedStringList.Create;
  try
   if SplitPath(FileName,Relative,Folders,Name) then
    begin
     {Get Parent}
     Parent:=FRoot;
     if Relative then Parent:=GetCurrent;
     if Parent = nil then Exit;
     
     {Add Reference}
     Parent.AddReference; 
     
     {Get Folders}
     Folder:=TStringObject(Folders.First);
     while Folder <> nil do
      begin
       Parent:=GetEntryEx(Parent,Folder.Value,faDirectory,True,True,False);
       if Parent = nil then Exit;
       
       Folder:=TStringObject(Folder.Next);
      end;
     
     {Split the Name}
     if SplitName(Name,ParentName,StreamName) then
      begin
       {Get File or Folder}
       Parent:=GetEntryEx(Parent,ParentName,faDirectory or faFile,True,True,False);
       if Parent = nil then Exit;
       
       {Get Stream}
       Current:=GetEntryEx(Parent,StreamName,faStream,True,False,False);
       if Current = nil then
        begin
         {Split the Stream}
         if SplitStream(StreamName,StreamName,StreamType) then
          begin
           {Get Stream}
           Current:=GetEntryEx(Parent,StreamName,faStream,True,False,False);
          end;
        end;
       if Current = nil then
        begin
         {Remove Reference}
         Parent.RemoveReference;
         Exit;
        end; 
      end
     else
      begin
       {Get File or Folder}
       Current:=GetEntryEx(Parent,Name,faDirectory or faFile,True,False,False);
       if Current = nil then
        begin
         {Remove Reference}
         Parent.RemoveReference;
         Exit;
        end; 
      end;
     
     {Get Attributes} {Hide internal Attributes}
     Result:=(Current.Attributes and FMaskAttributes); {faFindMask}

     {Remove Reference}
     Current.RemoveReference;
     Parent.RemoveReference;
    end;
  finally
   Folders.Free;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.FileGetDate(Handle:Integer):Integer;
{Get the date/time of an existing entry with an open Handle}
{Note: Returned time is converted to Local}
var
 FileTime:TFileTime;
 LocalTime:TFileTime;
begin
 {Base Implementation}
 Result:=-1;

 {Get File Time}
 if not GetFileTime(Handle,nil,nil,@FileTime) then Exit;
 
 {Get Local Time}
 if not Ultibo.FileTimeToLocalFileTime(FileTime,LocalTime) then Exit;
 
 {Convert Time}
 Ultibo.FileTimeToDosDateTime(LocalTime,LongRec(Result).Hi,LongRec(Result).Lo);
end;

{==============================================================================}

function TFileSystem.FileGetSize(Handle:THandle):LongInt;
{Get the size of an existing entry with an open Handle}
begin
 {Base Implementation}
 Result:=FileGetSizeEx(Handle);
end;

{==============================================================================}

function TFileSystem.FileGetSizeEx(Handle:THandle):Int64;
{Get the size of an existing entry with an open Handle}
var
 FileHandle:TFileHandle;
begin
 {Base Implementation}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Get the Handle}
  FileHandle:=FDriver.GetFileFromHandle(Handle,True,FILESYS_LOCK_WRITE); //To Do //Reader   
  if FileHandle = nil then Exit;
  try
   {Check the Mode}
   if FileHandle.OpenMode = fmOpenWrite then Exit;
 
   {Check the Handle}
   if FileHandle.HandleEntry = nil then Exit;
 
   {Get the Size}
   Result:=FileHandle.HandleEntry.Size;
  finally
   {Unlock Handle}
   FileHandle.WriterUnlock;
  end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.FileSetAttr(const FileName:String;Attr:Integer):Integer;
{Set the attributes of an existing entry}
{Note: File attributes can be set regardless of existing Handles}
var
 Name:String;
 Relative:Boolean;
 ParentName:String;
 StreamName:String;
 StreamType:String;
 Folder:TStringObject;
 Folders:TLinkedStringList;

 Parent:TDiskEntry;
 Current:TDiskEntry;
begin
 {Base Implementation}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Split the Path}
  Folders:=TLinkedStringList.Create;
  try
   if SplitPath(FileName,Relative,Folders,Name) then
    begin
     {Get Parent}
     Parent:=FRoot;
     if Relative then Parent:=GetCurrent;
     if Parent = nil then Exit;
     
     {Add Reference}
     Parent.AddReference; 
     
     {Get Folders}
     Folder:=TStringObject(Folders.First);
     while Folder <> nil do
      begin
       Parent:=GetEntryEx(Parent,Folder.Value,faDirectory,True,True,False);
       if Parent = nil then Exit;
       
       Folder:=TStringObject(Folder.Next);
      end;
     
     {Split the Name}
     if SplitName(Name,ParentName,StreamName) then
      begin
       {Get File or Folder}
       Parent:=GetEntryEx(Parent,ParentName,faDirectory or faFile,True,True,False);
       if Parent = nil then Exit;
       
       {Get Stream}
       Current:=GetEntryEx(Parent,StreamName,faStream,True,False,False);
       if Current = nil then
        begin
         {Split the Stream}
         if SplitStream(StreamName,StreamName,StreamType) then
          begin
           {Get Stream}
           Current:=GetEntryEx(Parent,StreamName,faStream,True,False,False);
          end;
        end;
       if Current = nil then Exit;
      end
     else
      begin
       {Get File or Folder}
       Current:=GetEntryEx(Parent,Name,faDirectory or faFile,True,False,False);
       if Current = nil then Exit;
      end;
     try
      {Set Attributes} {Preserve internal Attributes}
      Current.Attributes:=(Current.Attributes and (faFlagMask or faMatchMask)) or (LongWord(Attr) and FMaxAttributes); {faFindMask}
      if not SetEntry(Parent,Current) then Exit;
     
      Result:=0;
     finally
      {Remove Reference}
      Current.RemoveReference;
      Parent.RemoveReference;
     end;     
    end;
  finally
   Folders.Free;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.FileSetDate(Handle:Integer;Age:Integer):Integer;
{Set the date/time of an existing entry with an open Handle}
{Note: Passed time is assumed to be Local and is converted to UTC}
var
 FileTime:TFileTime;
 LocalTime:TFileTime;
begin
 {Base Implementation}
 Result:=-1;

 {Convert Time}
 if not Ultibo.DosDateTimeToFileTime(LongRec(Age).Hi,LongRec(Age).Lo,LocalTime) then Exit;
 
 {Get UTC Time}
 if not Ultibo.LocalFileTimeToFileTime(LocalTime,FileTime) then Exit;
 
 {Set File Time}
 if not SetFileTime(Handle,nil,nil,@FileTime) then Exit;
 
 Result:=0;
end;

{==============================================================================}

function TFileSystem.FileSetSize(Handle:THandle;Size:LongInt):LongInt;
{Set the size of an existing entry with an open Handle}
begin
 {Base Implementation}
 Result:=FileSetSizeEx(Handle,Size);
end;

{==============================================================================}

function TFileSystem.FileSetSizeEx(Handle:THandle;const Size:Int64):LongInt;
{Set the size of an existing entry with Open handle}
var
 FileHandle:TFileHandle;
begin
 {Base Implementation}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Check the Size}
  if Size < 0 then Exit;
 
  {Get the Handle}
  FileHandle:=FDriver.GetFileFromHandle(Handle,True,FILESYS_LOCK_WRITE); //To Do //Reader   
  if FileHandle = nil then Exit;
  try
   {Check the Mode}
   if FileHandle.OpenMode = fmOpenRead then Exit;
 
   {Check the Handle}
   if FileHandle.HandleEntry = nil then Exit;
 
   {Set the Size}
   if not SizeEntry(FileHandle.ParentEntry,FileHandle.HandleEntry,Size) then Exit;
   {FileHandle.HandleEntry.Size:=Size;} {Done by File System}
 
   Result:=0;
  finally
   {Unlock Handle}
   FileHandle.WriterUnlock;
  end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.FileRead(Handle:THandle;var Buffer;Count:LongInt):LongInt;
{Read data from an existing entry with an open Handle}
{Position may be beyond the end of the file}
{A read from beyond the end of the file will return 0 bytes}
var
 FileHandle:TFileHandle;
begin
 {Base Implementation}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;
 
  {Check Count (Negative byte read fails)}
  if Count < 0 then Exit;
  
  {Get the Handle}
  FileHandle:=FDriver.GetFileFromHandle(Handle,True,FILESYS_LOCK_WRITE);
  if FileHandle = nil then Exit;
  try
   {Check the Mode}
   if FileHandle.OpenMode = fmOpenWrite then Exit;
  
   {Check the Handle}
   if FileHandle.HandleEntry = nil then Exit;
  
   {Return Success}
   Result:=0;
   
   {Check the Count (Zero byte read successful)}
   if Count < 1 then Exit;
  
   {Check Size}
   if (FileHandle.Position + Count) > FileHandle.HandleEntry.Size then
    begin
     {Check Position}
     if FileHandle.Position > FileHandle.HandleEntry.Size then Exit;
     
     {Adjust Size}
     Count:=FileHandle.HandleEntry.Size - FileHandle.Position;
     
     {Check the Count (Zero byte read successful)}
     if Count < 1 then Exit;
    end;
    
   {Read Data}
   Result:=ReadEntry(FileHandle.ParentEntry,FileHandle.HandleEntry,Buffer,FileHandle.Position,Count,FileHandle.DataOffset,FileHandle.DataValue);
   if Result = Count then
    begin
     {Set Position}
     FileHandle.Position:=FileHandle.Position + Count;
    end
   else
    begin
     {Return Error}
     Result:=-1;
    end;    
  finally
   {Unlock Handle}
   FileHandle.WriterUnlock;
  end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.FileWrite(Handle:THandle;const Buffer;Count:LongInt):LongInt;
{Write data to an existing entry with an open Handle}
{Position may be beyond the end of the file}
{A write to beyond the end of the file will succeed and Size will be Position plus Count}
var
 FileHandle:TFileHandle;
begin
 {Base Implementation}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Check Count (Negative byte write fails)}
  if Count < 0 then Exit;
 
  {Get the Handle}
  FileHandle:=FDriver.GetFileFromHandle(Handle,True,FILESYS_LOCK_WRITE);
  if FileHandle = nil then Exit;
  try
   {Check the Mode}
   if FileHandle.OpenMode = fmOpenRead then Exit;
 
   {Check Handle}
   if FileHandle.HandleEntry = nil then Exit;
  
   {Check Size}
   if (FileHandle.Position + Count) > FileHandle.HandleEntry.Size then
    begin
     {Set Size}
     if not SizeEntry(FileHandle.ParentEntry,FileHandle.HandleEntry,FileHandle.Position + Count) then Exit;
     {FileHandle.HandleEntry.Size:=FileHandle.Position + Count;} {Done by File System}
    end;
  
   {Return Success}
   Result:=0;
  
   {Check the Count (Zero byte write successful, does not truncate the file)}
   if Count < 1 then Exit;
  
   {Write Data}
   Result:=WriteEntry(FileHandle.ParentEntry,FileHandle.HandleEntry,Buffer,FileHandle.Position,Count,FileHandle.DataOffset,FileHandle.DataValue);
   if Result = Count then
    begin
     {Set Time and Attributes} {Entry will be updated by FileClose}
     FileHandle.HandleEntry.WriteTime:=Ultibo.DateTimeToFileTime(Now); {Converted to UTC}
     FileHandle.HandleEntry.Attributes:=(FileHandle.HandleEntry.Attributes or faArchive);
    
     {Set Position}
     FileHandle.Position:=FileHandle.Position + Count;
    end
   else
    begin
     {Return Error}
     Result:=-1;
    end;
  finally
   {Unlock Handle}
   FileHandle.WriterUnlock;
  end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.CreateDir(const DirName:String):Boolean;
{Create a new entry}{No File or Stream support}
var
 Name:String;
 Relative:Boolean;
 Folder:TStringObject;
 Folders:TLinkedStringList;

 Parent:TDiskEntry;
 Current:TDiskEntry;
begin
 {Base Implementation}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSystem.CreateDir DirName = ' + DirName);
  {$ENDIF}
  
  {Split the Path}
  Folders:=TLinkedStringList.Create;
  try
   if SplitPath(DirName,Relative,Folders,Name) then
    begin
     {$IFDEF FILESYS_DEBUG}
     if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSystem.CreateDir Name = ' + Name);
     {$ENDIF}
     
     {Get Parent}
     Parent:=FRoot;
     if Relative then Parent:=GetCurrent;
     if Parent = nil then Exit;
     
     {Add Reference}
     Parent.AddReference; 
     
     {Get Folders}
     Folder:=TStringObject(Folders.First);
     while Folder <> nil do
      begin
       Parent:=GetEntryEx(Parent,Folder.Value,faDirectory,True,True,False);
       if Parent = nil then Exit;
       
       Folder:=TStringObject(Folder.Next);
      end;
     try
      {$IFDEF FILESYS_DEBUG}
      if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSystem.CreateDir Parent = ' + Parent.Name);
      {$ENDIF}
     
      {Check File or Folder}
      if GetEntry(Parent,Name,faDirectory or faFile) <> nil then Exit;
     
      {Check Name}
      if not CheckName(Name) then Exit;
     
      {Add Folder}
      Current:=AddEntry(Parent,Name,faDirectory,True); 
      if Current = nil then Exit;
      try
       {Check Encryption}
       if (FFolderEncryption) and ((Parent.Attributes and faEncrypted) = faEncrypted) then
        begin
         {Set Encrypted}
         Current.Attributes:=(Current.Attributes or faEncrypted);
         if not SetEntry(Parent,Current) then Exit;
        end;
     
       {Check Compression}
       if (FFolderCompression) and ((Parent.Attributes and faCompressed) = faCompressed) then
        begin
         {Set Compressed}
         Current.Attributes:=(Current.Attributes or faCompressed);
         if not SetEntry(Parent,Current) then Exit;
        end;
     
       Result:=True;
      finally
       {Remove Reference}
       Current.RemoveReference;
      end;      
     finally
      {Remove Reference}
      Parent.RemoveReference;
     end;     
    end;
  finally
   Folders.Free;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.RemoveDir(const DirName:String):Boolean;
{Delete an existing entry}{No File or Stream support}
var
 Name:String;
 Relative:Boolean;
 Folder:TStringObject;
 Folders:TLinkedStringList;

 Next:TDiskEntry;
 Parent:TDiskEntry;
 Current:TDiskEntry;
begin
 {Base Implementation}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Split the Path}
  Folders:=TLinkedStringList.Create;
  try
   if SplitPath(DirName,Relative,Folders,Name) then
    begin
     {Get Parent}
     Parent:=FRoot;
     if Relative then Parent:=GetCurrent;
     if Parent = nil then Exit;
     
     {Add Reference}
     Parent.AddReference; 
     
     {Get Folders}
     Folder:=TStringObject(Folders.First);
     while Folder <> nil do
      begin
       Parent:=GetEntryEx(Parent,Folder.Value,faDirectory,True,True,False);
       if Parent = nil then Exit;
       
       Folder:=TStringObject(Folder.Next);
      end;
     try
      {Get Folder}
      Current:=GetEntryEx(Parent,Name,faDirectory,True,False,False);
      if Current = nil then Exit;
      try
       {Load Entries}
       if not LoadEntries(Current) then Exit;
     
       {Check Entries}
       if not FEntries.ReaderLock then Exit;
       try
        Next:=TDiskEntry(Current.FirstChild);
        while Next <> nil do
         begin
          {Allow delete if only Dot, DotDot or Streams remain}
          if (Next.Attributes and (faDot or faDotDot or faStream)) = faNone then Exit;
          //To Do //Should we do CheckFileHandles/UpdateFindHandles on each of these ? //Probably on Streams Yes - See also DeleteFile/DeleteHardlink
       
          Next:=TDiskEntry(Next.Next);
         end;
       finally
        FEntries.ReaderUnlock;
       end; 
      
       {Check Handles}
       if not FDriver.CheckFileHandles(Current) then Exit;
     
       {Update Handles}
       if not FDriver.UpdateFindHandles(Current) then Exit;
      
       {Remove Folder}
       Result:=RemoveEntry(Parent,Current);
       if Result and (Parent.Recent = Current) then Parent.Recent:=nil;
      finally
       {Remove Reference}
       Current.RemoveReference;
      end;      
     finally
      {Remove Reference}
      Parent.RemoveReference;
     end;     
    end;
  finally
   Folders.Free;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.GetCurrentDir:String;
{Return the current directory}{No File or Stream support}
var
 Current:TDiskEntry;
begin
 {Base Implementation}
 Result:='';
 
 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;
  
  Current:=GetCurrent;
  if Current = nil then Exit;
 
  Result:=GetEntryName(Current,False);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.SetCurrentDir(const DirName:String):Boolean;
{Set the current directory to an existing entry}{No File or Stream support}
var
 Name:String;
 Relative:Boolean;
 Folder:TStringObject;
 Folders:TLinkedStringList;

 Parent:TDiskEntry;
 Current:TDiskEntry;
 Previous:TDiskEntry;
begin
 {Base Implementation}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Split the Path}
  Folders:=TLinkedStringList.Create;
  try
   if SplitPath(DirName,Relative,Folders,Name) then
    begin
     {Get Parent}
     Parent:=FRoot;
     if Relative then Parent:=GetCurrent;
     if Parent = nil then Exit;
     
     {Add Reference}
     Parent.AddReference; 
     
     {Get Folders}
     Folder:=TStringObject(Folders.First);
     while Folder <> nil do
      begin
       Parent:=GetEntryEx(Parent,Folder.Value,faDirectory,True,True,False);
       if Parent = nil then Exit;
       
       Folder:=TStringObject(Folder.Next);
      end;
     try
      {Get Folder}
      Current:=GetEntryEx(Parent,Name,faDirectory,True,False,False);
      if Current = nil then Exit;
       
      {Remove Reference}
      Previous:=GetCurrent;
      if Previous <> nil then Previous.RemoveReference;
     
      {Set Current}
      Result:=SetCurrent(Current);
      
      {Do not remove reference on current}
     finally
      {Remove Reference}
      Parent.RemoveReference;
     end;
    end;
  finally
   Folders.Free;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.FindFirstEx(const Path:String;var SearchRec:TFileSearchRec):Integer;
{Find existing entries matching the specifications}
var
 Any:Boolean;
 Name:String;
 Relative:Boolean;
 ParentName:String;
 StreamName:String;
 StreamType:String;
 Folder:TStringObject;
 FindHandle:TFindHandle;
 Folders:TLinkedStringList;

 Parent:TDiskEntry;
 Current:TDiskEntry;
begin
 {Base Implementation}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  SearchRec.FindHandle:=INVALID_HANDLE_VALUE;
  if FDriver = nil then Exit;

  {Split the Path}
  Folders:=TLinkedStringList.Create;
  try
   if SplitPath(Path,Relative,Folders,Name) then
    begin
     {Get Parent}
     Parent:=FRoot;
     if Relative then Parent:=GetCurrent;
     if Parent = nil then Exit;
     
     {Add Reference}
     Parent.AddReference;
     
     {Get Folders}
     Folder:=TStringObject(Folders.First);
     while Folder <> nil do
      begin
       Parent:=GetEntryEx(Parent,Folder.Value,faDirectory,True,True,False); 
       if Parent = nil then Exit;
       
       Folder:=TStringObject(Folder.Next);
      end;
     
     {Split the Name}
     if SplitName(Name,ParentName,StreamName) then
      begin
       {Get File or Folder}
       Parent:=GetEntryEx(Parent,ParentName,faDirectory or faFile,True,True,False); 
       if Parent = nil then Exit;
       
       {Find First Stream}
       Any:=(StreamName = FIND_WILDCARD_STREAM);
       Current:=MatchEntryEx(Parent,nil,StreamName,faStream,Any,True,False,False); 
       if Current = nil then
        begin
         {Split the Stream}
         if SplitStream(StreamName,StreamName,StreamType) then
          begin
           {Find First Stream}
           Any:=(StreamName = FIND_WILDCARD_STREAM);
           Current:=MatchEntryEx(Parent,nil,StreamName,faStream,Any,True,False,False);
          end;
        end;
       if Current = nil then
        begin
         {Remove Reference}
         Parent.RemoveReference;
         Exit;
        end;
       
       {Open Handle}
       FindHandle:=FDriver.OpenFindHandle(FVolume,FDrive,Parent,StreamName,faStream,FIND_FLAG_NONE,True,FILESYS_LOCK_WRITE);
       if FindHandle = nil then
        begin
         {Remove Reference}
         Current.RemoveReference;
         Parent.RemoveReference;
         Exit;
        end; 
      end
     else
      begin
       {Find First File or Folder}
       Any:=(Name = FIND_WILDCARD_NAME);
       Current:=MatchEntryEx(Parent,nil,Name,faDirectory or faFile,Any,True,False,False);
       if Current = nil then
        begin
         {Remove Reference}
         Parent.RemoveReference;
         Exit;
        end;
       
       {Open Handle}
       FindHandle:=FDriver.OpenFindHandle(FVolume,FDrive,Parent,Name,faDirectory or faFile,FIND_FLAG_NONE,True,FILESYS_LOCK_WRITE);
       if FindHandle = nil then
        begin
         {Remove Reference}
         Current.RemoveReference;
         Parent.RemoveReference;
         Exit;
        end; 
      end;
     
     {Set the Handle properties}
     FindHandle.Any:=Any;
     FindHandle.CurrentEntry:=Current;
     
     {Return Entry}
     SearchRec.FindHandle:=FindHandle.Handle;
     SearchRec.FindData.dwFileAttributes:=(Current.Attributes and FMaskAttributes); {faFindMask}
     SearchRec.FindData.ftCreationTime:=Current.CreateTime;
     SearchRec.FindData.ftLastAccessTime:=Current.AccessTime;
     SearchRec.FindData.ftLastWriteTime:=Current.WriteTime;
     SearchRec.FindData.nFileSizeHigh:=TULargeInteger(Current.Size).HighPart;
     SearchRec.FindData.nFileSizeLow:=TULargeInteger(Current.Size).LowPart;
     SearchRec.FindData.dwReserved0:=Current.ReparseTag;
     StrLCopy(SearchRec.FindData.cFileName,PChar(Current.Name),MAX_PATH);
     StrLCopy(SearchRec.FindData.cAlternateFileName,PChar(Current.AltName),14);
     
     Result:=0;
     
     {Unlock Handle}
     FindHandle.WriterUnlock;

     {Remove Reference}
     Current.RemoveReference;
     Parent.RemoveReference;
    end;
  finally
   Folders.Free;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.FindNextEx(var SearchRec:TFileSearchRec):Integer;
{Continue Finding existing entries matching the specifications}
var
 FindHandle:TFindHandle;

 Current:TDiskEntry;
begin
 {Base Implementation}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Get the Handle}
  FindHandle:=FDriver.GetFindFromHandle(SearchRec.FindHandle,True,FILESYS_LOCK_WRITE);
  if FindHandle = nil then Exit;
  try
   {Check Parent}
   if FindHandle.ParentEntry = nil then Exit;
  
   {Find Next Entry}
   Current:=MatchEntryEx(FindHandle.ParentEntry,FindHandle.CurrentEntry,FindHandle.Mask,FindHandle.Attr,FindHandle.Any,True,False,False);
   if Current = nil then Exit;
  
   {Update Handle}
   FindHandle.CurrentEntry:=Current;
  
   {Return Entry}
   SearchRec.FindHandle:=FindHandle.Handle;
   SearchRec.FindData.dwFileAttributes:=(Current.Attributes and FMaskAttributes); {faFindMask}
   SearchRec.FindData.ftCreationTime:=Current.CreateTime;
   SearchRec.FindData.ftLastAccessTime:=Current.AccessTime;
   SearchRec.FindData.ftLastWriteTime:=Current.WriteTime;
   SearchRec.FindData.nFileSizeHigh:=TULargeInteger(Current.Size).HighPart;
   SearchRec.FindData.nFileSizeLow:=TULargeInteger(Current.Size).LowPart;
   SearchRec.FindData.dwReserved0:=Current.ReparseTag;
   StrLCopy(SearchRec.FindData.cFileName,PChar(Current.Name),MAX_PATH);
   StrLCopy(SearchRec.FindData.cAlternateFileName,PChar(Current.AltName),14);
  
   Result:=0;
   
   {Remove Reference}
   Current.RemoveReference;
  finally
   {Unlock Handle}
   FindHandle.WriterUnlock;
  end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

procedure TFileSystem.FindCloseEx(var SearchRec:TFileSearchRec);
{Close an open find Handle}
var
 FindHandle:TFindHandle;
begin
 {Base Implementation}
 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Get the Handle}
  FindHandle:=FDriver.GetFindFromHandle(SearchRec.FindHandle,True,FILESYS_LOCK_WRITE);
  if FindHandle = nil then Exit;
 
  {Close the Handle} {Do not unlock}
  FDriver.CloseFindHandle(FindHandle);
 
  SearchRec.FindHandle:=INVALID_HANDLE_VALUE;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.FindFirstStream(const FileName:String;var SearchRec:TStreamSearchRec):Integer;
{Find existing streams matching the specifications}
{Note: This does not return the default data stream for files}
var
 Name:String;
 Relative:Boolean;
 ParentName:String;
 StreamName:String;
 Folder:TStringObject;
 FindHandle:TFindHandle;
 Folders:TLinkedStringList;

 Parent:TDiskEntry;
 Current:TDiskEntry;
begin
 {Base Implementation}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  SearchRec.FindHandle:=INVALID_HANDLE_VALUE;
  if FDriver = nil then Exit;

  {Split the Path}
  Folders:=TLinkedStringList.Create;
  try
   if SplitPath(FileName,Relative,Folders,Name) then
    begin
     {Get Parent}
     Parent:=FRoot;
     if Relative then Parent:=GetCurrent;
     if Parent = nil then Exit;
     
     {Add Reference}
     Parent.AddReference;
     
     {Get Folders}
     Folder:=TStringObject(Folders.First);
     while Folder <> nil do
      begin
       Parent:=GetEntryEx(Parent,Folder.Value,faDirectory,True,True,False);
       if Parent = nil then Exit;
       
       Folder:=TStringObject(Folder.Next);
      end;
     
     {Split the Name}
     if SplitName(Name,ParentName,StreamName) then Exit;
     
     {Get File or Folder} {Allow for Root}
     if Length(Name) <> 0 then Parent:=GetEntryEx(Parent,Name,faDirectory or faFile,True,True,False);
     if Parent = nil then Exit;
     
     {Find First Stream}
     Current:=MatchEntryEx(Parent,nil,'*',faStream,True,True,False,False);
     if Current = nil then
      begin
       {Remove Reference}
       Parent.RemoveReference;
       Exit;
      end; 

     {Open Handle}
     FindHandle:=FDriver.OpenFindHandle(FVolume,FDrive,Parent,'*',faStream,FIND_FLAG_NONE,True,FILESYS_LOCK_WRITE);
     if FindHandle = nil then
      begin
       {Remove Reference}
       Current.RemoveReference;
       Parent.RemoveReference;
       Exit;
      end; 
     try
      {Set the Handle properties}
      FindHandle.Any:=True;
      FindHandle.CurrentEntry:=Current;
     
      {Return Entry}
      SearchRec.FindHandle:=FindHandle.Handle;
      Int64(SearchRec.FindData.StreamSize):=Current.Size;
      if not Ultibo.StringToWideChar(Current.Name,PWideChar(@SearchRec.FindData.cStreamName),(MAX_PATH + 36) shl 1) then Exit; {Multiply by SizeOf(WideChar)}
      //To Do //Use default StringToWideChar from System ? //Watch for difference in size parameter (Bytes/Chars)
    
      Result:=0;
    
      {Unlock Handle}
      FindHandle.WriterUnlock;
     finally
      {Remove Reference}
      Current.RemoveReference;
      Parent.RemoveReference;
     end; 
    end;
  finally
   Folders.Free;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.FindNextStream(var SearchRec:TStreamSearchRec):Integer;
{Continue finding existing streams matching the specifications}
{Note: This does not return the default data stream for files}
var
 FindHandle:TFindHandle;

 Current:TDiskEntry;
begin
 {Base Implementation}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Get the Handle}
  FindHandle:=FDriver.GetFindFromHandle(SearchRec.FindHandle,True,FILESYS_LOCK_WRITE);
  if FindHandle = nil then Exit;
  try
   {Check Parent}
   if FindHandle.ParentEntry = nil then Exit;
  
   {Find Next Stream}
   Current:=MatchEntryEx(FindHandle.ParentEntry,FindHandle.CurrentEntry,FindHandle.Mask,FindHandle.Attr,FindHandle.Any,True,False,False);
   if Current = nil then Exit;
   try
    {Update Handle}
    FindHandle.CurrentEntry:=Current;
  
    {Return Entry}
    SearchRec.FindHandle:=FindHandle.Handle;
    Int64(SearchRec.FindData.StreamSize):=Current.Size;
    if not Ultibo.StringToWideChar(Current.Name,PWideChar(@SearchRec.FindData.cStreamName),(MAX_PATH + 36) shl 1) then Exit; {Multiply by SizeOf(WideChar)}
    //To Do //Use default StringToWideChar from System ? //Watch for difference in size parameter (Bytes/Chars)
  
    Result:=0;
   finally
    {Remove Reference}
    Current.RemoveReference;
   end; 
  finally
   {Unlock Handle}
   FindHandle.WriterUnlock;
  end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

procedure TFileSystem.FindStreamClose(var SearchRec:TStreamSearchRec);
{Close an open find Handle}
var
 FindHandle:TFindHandle;
begin
 {Base Implementation}
 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Get the Handle}
  FindHandle:=FDriver.GetFindFromHandle(SearchRec.FindHandle,True,FILESYS_LOCK_WRITE);
  if FindHandle = nil then Exit;
 
  {Close the Handle} {Do not unlock}
  FDriver.CloseFindHandle(FindHandle);
 
  SearchRec.FindHandle:=INVALID_HANDLE_VALUE;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.FindFirstFileName(const FileName:String;var SearchRec:TLinkSearchRec):Integer;
{Find existing file names matching the specifications}
var
 Name:String;
 Relative:Boolean;
 ParentName:String;
 StreamName:String;
 Folder:TStringObject;
 FindHandle:TFindHandle;
 Folders:TLinkedStringList;

 Parent:TDiskEntry;
 Current:TDiskEntry;
begin
 {Base Implementation}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  SearchRec.FindHandle:=INVALID_HANDLE_VALUE;
  if FDriver = nil then Exit;

  {Split the Path}
  Folders:=TLinkedStringList.Create;
  try
   if SplitPath(FileName,Relative,Folders,Name) then
    begin
     {Get Parent}
     Parent:=FRoot;
     if Relative then Parent:=GetCurrent;
     if Parent = nil then Exit;
     
     {Add Reference}
     Parent.AddReference;
     
     {Get Folders}
     Folder:=TStringObject(Folders.First);
     while Folder <> nil do
      begin
       Parent:=GetEntryEx(Parent,Folder.Value,faDirectory,True,True,False);
       if Parent = nil then Exit;
       
       Folder:=TStringObject(Folder.Next);
      end;
     
     {Split the Name}
     if SplitName(Name,ParentName,StreamName) then Exit;
     
     {Get File or Folder}
     Parent:=GetEntryEx(Parent,Name,faDirectory or faFile,True,True,False);
     if Parent = nil then Exit;
     try
      {Open Handle}
      FindHandle:=FDriver.OpenFindHandle(FVolume,FDrive,Parent,'*',faDirectory or faFile,FIND_FLAG_FILE_NAMES,True,FILESYS_LOCK_WRITE);
      if FindHandle = nil then Exit;
     
      {Find First File Name}
      Current:=Parent.FindFirstName(FindHandle,True);
      if Current = nil then Exit;
     
      {Set the Handle properties}
      FindHandle.CurrentEntry:=Current;
     
      {Return Entry}
      SearchRec.FindHandle:=FindHandle.Handle;
      SearchRec.Name:=Current.Name;
    
      Result:=0;
    
      {Unlock Handle}
      FindHandle.WriterUnlock;
      
      {Remove Reference}
      Current.RemoveReference;
     finally
      {Remove Reference}
      Parent.RemoveReference;
     end;     
    end;
  finally
   Folders.Free;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.FindNextFileName(var SearchRec:TLinkSearchRec):Integer;
{Continue finding existing file names matching the specifications}
var
 FindHandle:TFindHandle;

 Current:TDiskEntry;
begin
 {Base Implementation}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Get the Handle}
  FindHandle:=FDriver.GetFindFromHandle(SearchRec.FindHandle,True,FILESYS_LOCK_WRITE);
  if FindHandle = nil then Exit;
  try
   {Check Parent}
   if FindHandle.ParentEntry = nil then Exit;
  
   {Find Next File Name}
   Current:=FindHandle.ParentEntry.FindNextName(FindHandle,True);
   if Current = nil then Exit;
  
   {Update Handle}
   FindHandle.CurrentEntry:=Current;
  
   {Return Entry}
   SearchRec.FindHandle:=FindHandle.Handle;
   SearchRec.Name:=Current.Name;
  
   Result:=0;
   
   {Remove Reference}
   Current.RemoveReference;
  finally
   {Unlock Handle}
   FindHandle.WriterUnlock;
  end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

procedure TFileSystem.FindFileNameClose(var SearchRec:TLinkSearchRec);
{Close an open find Handle}
var
 FindHandle:TFindHandle;
begin
 {Base Implementation}
 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Get the Handle}
  FindHandle:=FDriver.GetFindFromHandle(SearchRec.FindHandle,True,FILESYS_LOCK_WRITE);
  if FindHandle = nil then Exit;
 
  {Close the Handle} {Do not unlock}
  FDriver.CloseFindHandle(FindHandle);
 
  SearchRec.FindHandle:=INVALID_HANDLE_VALUE;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.CreateHardLink(const LinkName,FileName:String):Boolean;
{Note: Link must not exist, File must exist and must be a file. Both must be on the same volume}
var
 Relative:Boolean;
 SourceName:String;
 TargetName:String;
 ParentName:String;
 StreamName:String;
 Folder:TStringObject;
 Folders:TLinkedStringList;

 Entry:TDiskEntry;
 Source:TDiskEntry;
 Target:TDiskEntry;
 Current:TDiskEntry;
begin
 {Base Implementation}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Split the Source Path}
  Folders:=TLinkedStringList.Create;
  try
   if SplitPath(LinkName,Relative,Folders,SourceName) then
    begin
     {Get Source Parent}
     Source:=FRoot;
     if Relative then Source:=GetCurrent;
     if Source = nil then Exit;
     
     {Add Reference}
     Source.AddReference; 
     
     {Get Source Folders}
     Folder:=TStringObject(Folders.First);
     while Folder <> nil do
      begin
       Source:=GetEntryEx(Source,Folder.Value,faDirectory,True,True,False);
       if Source = nil then Exit;
       
       Folder:=TStringObject(Folder.Next);
      end;
     try
      {Split the Target Path}
      if SplitPath(FileName,Relative,Folders,TargetName) then
       begin
        {Get Target Parent}
        Target:=FRoot;
        if Relative then Target:=GetCurrent;
        if Target = nil then Exit;
       
        {Add Reference}
        Target.AddReference; 
       
        {Get Target Folders}
        Folder:=TStringObject(Folders.First);
        while Folder <> nil do
         begin
          Target:=GetEntryEx(Target,Folder.Value,faDirectory,True,True,False);
          if Target = nil then Exit;
         
          Folder:=TStringObject(Folder.Next);
         end;
        try
         {Split the Source Name}
         if SplitName(SourceName,ParentName,StreamName) then Exit;
       
         {Check Source File or Folder}
         if GetEntry(Source,SourceName,faDirectory or faFile) <> nil then Exit;
        
         {Split the Target Name}
         if SplitName(TargetName,ParentName,StreamName) then Exit;
        
         {Get Target File}
         Entry:=GetEntryEx(Target,TargetName,faFile,True,False,False); {Target must be a File}
         if Entry = nil then Exit;
         try
          {Check Source Name}
          if not CheckLinkName(SourceName) then Exit;
         
          {Add Hardlink}
          Current:=AddHardlink(Entry,Source,SourceName,False);
          if Current = nil then Exit;
       
          Result:=True;
         finally
          {Remove Reference}
          Entry.RemoveReference;
         end;         
        finally
         {Remove Reference}
         Target.RemoveReference;
        end;        
       end;
     finally
      {Remove Reference}
      Source.RemoveReference;
     end;     
    end;
  finally
   Folders.Free;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.DeleteHardLink(const LinkName:String):Boolean;
{Note: Link must exist and must be a file}
var
 Name:String;
 Relative:Boolean;
 ParentName:String;
 StreamName:String;
 Folder:TStringObject;
 Folders:TLinkedStringList;

 Next:TDiskEntry;
 Parent:TDiskEntry;
 Current:TDiskEntry;
begin
 {Base Implementation}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Split the Path}
  Folders:=TLinkedStringList.Create;
  try
   if SplitPath(LinkName,Relative,Folders,Name) then
    begin
     {Get Parent}
     Parent:=FRoot;
     if Relative then Parent:=GetCurrent;
     if Parent = nil then Exit;
     
     {Add Reference}
     Parent.AddReference; 
     
     {Get Folders}
     Folder:=TStringObject(Folders.First);
     while Folder <> nil do
      begin
       Parent:=GetEntryEx(Parent,Folder.Value,faDirectory,True,True,False);
       if Parent = nil then Exit;
       
       Folder:=TStringObject(Folder.Next);
      end;
     try
      {Split the Name}
      if SplitName(Name,ParentName,StreamName) then Exit;
     
      {Get File}
      Current:=GetEntryEx(Parent,Name,faFile,True,False,False); {Link must be a File}
      if Current = nil then Exit;
      try
       {Load Entries}
       if not LoadEntries(Current) then Exit;
      
       {Check Entries}
       if not FEntries.ReaderLock then Exit;
       try
        Next:=TDiskEntry(Current.FirstChild);
        while Next <> nil do
         begin
          //To Do //Should we do CheckFileHandles/UpdateFindHandles on each of these ? //Probably on Streams Yes - See also DeleteFile/RemoveDir
       
          Next:=TDiskEntry(Next.Next);
         end;
       finally
        FEntries.ReaderUnlock;
       end; 
     
       {Check Handles}
       if not FDriver.CheckFileHandles(Current) then Exit;
     
       {Update Handles}
       if not FDriver.UpdateFindHandles(Current) then Exit;
     
       {Remove Hardlink}
       Result:=RemoveHardlink(Parent,Current);
       if Result and (Parent.Recent = Current) then Parent.Recent:=nil;
      finally
       {Remove Reference}
       Current.RemoveReference;
      end;      
     finally
      {Remove Reference}
      Parent.RemoveReference;
     end;     
    end;
  finally
   Folders.Free;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.CreateMountPoint(const PathName,VolumeName:String):Boolean;
{Note: Path must exist and must be a folder, Volume value is not checked}
var
 Name:String;
 Relative:Boolean;
 ParentName:String;
 StreamName:String;
 Folder:TStringObject;
 Folders:TLinkedStringList;

 Parent:TDiskEntry;
 Current:TDiskEntry;
begin
 {Base Implementation}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Split the Path}
  Folders:=TLinkedStringList.Create;
  try
   if SplitPath(PathName,Relative,Folders,Name) then
    begin
     {Get Parent}
     Parent:=FRoot;
     if Relative then Parent:=GetCurrent;
     if Parent = nil then Exit;
     
     {Add Reference}
     Parent.AddReference; 
     
     {Get Folders}
     Folder:=TStringObject(Folders.First);
     while Folder <> nil do
      begin
       Parent:=GetEntryEx(Parent,Folder.Value,faDirectory,True,True,False);
       if Parent = nil then Exit;
       
       Folder:=TStringObject(Folder.Next);
      end;
     try
      {Split the Name}
      if SplitName(Name,ParentName,StreamName) then Exit;
     
      {Get File or Folder}
      Current:=GetEntryEx(Parent,Name,faDirectory,True,False,False); {Path must be a Folder}
      if Current = nil then Exit;
     
      {Add Mount Point}
      Result:=AddMountPoint(Current,VolumeName);
     
      {Remove Reference}
      Current.RemoveReference;
     finally
      {Remove Reference}
      Parent.RemoveReference;
     end;     
    end;
  finally
   Folders.Free;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.DeleteMountPoint(const PathName:String):Boolean;
{Note: Path must exist and must be a folder}
var
 Name:String;
 Relative:Boolean;
 ParentName:String;
 StreamName:String;
 Folder:TStringObject;
 Folders:TLinkedStringList;

 Parent:TDiskEntry;
 Current:TDiskEntry;
begin
 {Base Implementation}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Split the Path}
  Folders:=TLinkedStringList.Create;
  try
   if SplitPath(PathName,Relative,Folders,Name) then
    begin
     {Get Parent}
     Parent:=FRoot;
     if Relative then Parent:=GetCurrent;
     if Parent = nil then Exit;
     
     {Add Reference}
     Parent.AddReference; 
     
     {Get Folders}
     Folder:=TStringObject(Folders.First);
     while Folder <> nil do
      begin
       Parent:=GetEntryEx(Parent,Folder.Value,faDirectory,True,True,False);
       if Parent = nil then Exit;
       
       Folder:=TStringObject(Folder.Next);
      end;
     try
      {Split the Name}
      if SplitName(Name,ParentName,StreamName) then Exit;
     
      {Get File or Folder}
      Current:=GetEntryEx(Parent,Name,faDirectory,True,False,False); {Path must be a Folder}
      if Current = nil then Exit;
     
      //To Do //CheckFileHandles/UpdateFindHandles ?
      
      {Remove Mount Point}
      Result:=RemoveMountPoint(Current);
      if Result and (Parent.Recent = Current) then Parent.Recent:=nil;
     
      {Remove Reference}
      Current.RemoveReference;
     finally
      {Remove Reference}
      Parent.RemoveReference;
     end;     
    end;
  finally
   Folders.Free;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.CreateJunctionPoint(const PathName,FolderName:String):Boolean;
{Note: Path must exist and must be a folder, Folder value is not checked}
var
 Name:String;
 Relative:Boolean;
 ParentName:String;
 StreamName:String;
 Folder:TStringObject;
 Folders:TLinkedStringList;

 Parent:TDiskEntry;
 Current:TDiskEntry;
begin
 {Base Implementation}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Split the Path}
  Folders:=TLinkedStringList.Create;
  try
   if SplitPath(PathName,Relative,Folders,Name) then
    begin
     {Get Parent}
     Parent:=FRoot;
     if Relative then Parent:=GetCurrent;
     if Parent = nil then Exit;
     
     {Add Reference}
     Parent.AddReference; 
     
     {Get Folders}
     Folder:=TStringObject(Folders.First);
     while Folder <> nil do
      begin
       Parent:=GetEntryEx(Parent,Folder.Value,faDirectory,True,True,False);
       if Parent = nil then Exit;
       
       Folder:=TStringObject(Folder.Next);
      end;
     try
      {Split the Name}
      if SplitName(Name,ParentName,StreamName) then Exit;
     
      {Get File or Folder}
      Current:=GetEntryEx(Parent,Name,faDirectory,True,False,False); {Path must be a Folder}
      if Current = nil then Exit;
      
      {Add Junction Point}
      Result:=AddJunctionPoint(Current,FolderName);
      
      {Remove Reference}
      Current.RemoveReference;
     finally
      {Remove Reference}
      Parent.RemoveReference;
     end;     
    end;
  finally
   Folders.Free;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.DeleteJunctionPoint(const PathName:String):Boolean;
{Note: Path must exist and must be a folder}
var
 Name:String;
 Relative:Boolean;
 ParentName:String;
 StreamName:String;
 Folder:TStringObject;
 Folders:TLinkedStringList;

 Parent:TDiskEntry;
 Current:TDiskEntry;
begin
 {Base Implementation}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Split the Path}
  Folders:=TLinkedStringList.Create;
  try
   if SplitPath(PathName,Relative,Folders,Name) then
    begin
     {Get Parent}
     Parent:=FRoot;
     if Relative then Parent:=GetCurrent;
     if Parent = nil then Exit;
     
     {Add Reference}
     Parent.AddReference; 
     
     {Get Folders}
     Folder:=TStringObject(Folders.First);
     while Folder <> nil do
      begin
       Parent:=GetEntryEx(Parent,Folder.Value,faDirectory,True,True,False);
       if Parent = nil then Exit;
       
       Folder:=TStringObject(Folder.Next);
      end;
     try
      {Split the Name}
      if SplitName(Name,ParentName,StreamName) then Exit;
     
      {Get File or Folder}
      Current:=GetEntryEx(Parent,Name,faDirectory,True,False,False); {Path must be a Folder}
      if Current = nil then Exit;
     
      //To Do //CheckFileHandles/UpdateFindHandles ?
      
      {Remove Junction Point}
      Result:=RemoveJunctionPoint(Current);
      if Result and (Parent.Recent = Current) then Parent.Recent:=nil;
      
      {Remove Reference}
      Current.RemoveReference;
     finally
      {Remove Reference}
      Parent.RemoveReference;
     end;     
    end;
  finally
   Folders.Free;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.CreateSymbolicLink(const LinkName,TargetName:String;Directory:Boolean):Boolean;
{Note: Link must not exist, Target value is not checked}
var
 Name:String;
 Relative:Boolean;
 ParentName:String;
 StreamName:String;
 Folder:TStringObject;
 Folders:TLinkedStringList;

 Parent:TDiskEntry;
 Current:TDiskEntry;
begin
 {Base Implementation}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Split the Path}
  Folders:=TLinkedStringList.Create;
  try
   if SplitPath(LinkName,Relative,Folders,Name) then
    begin
     {Get Parent}
     Parent:=FRoot;
     if Relative then Parent:=GetCurrent;
     if Parent = nil then Exit;
     
     {Add Reference}
     Parent.AddReference; 
     
     {Get Folders}
     Folder:=TStringObject(Folders.First);
     while Folder <> nil do
      begin
       Parent:=GetEntryEx(Parent,Folder.Value,faDirectory,True,True,False);
       if Parent = nil then Exit;
       
       Folder:=TStringObject(Folder.Next);
      end;
     try
      {Split the Name}
      if SplitName(Name,ParentName,StreamName) then Exit;
     
      {Get File or Folder}
      if GetEntry(Parent,Name,faDirectory or faFile) <> nil then Exit;
     
      {Check Name}
      if not CheckName(Name) then Exit;
     
      {Add Symbolic Link}
      Current:=AddSymbolicLink(Parent,Name,TargetName,Directory,False);
      if Current = nil then Exit;
     
      Result:=True;
     finally
      {Remove Reference}
      Parent.RemoveReference;
     end;     
    end;
  finally
   Folders.Free;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.CreateSymbolicLinkEx(const LinkName,ShortName,TargetName:String;Directory:Boolean):Boolean;
{Note: Link must not exist, Target value is not checked}
var
 Name:String;
 Relative:Boolean;
 ParentName:String;
 StreamName:String;
 Folder:TStringObject;
 Folders:TLinkedStringList;

 Parent:TDiskEntry;
 Current:TDiskEntry;
begin
 {Base Implementation}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Split the Path}
  Folders:=TLinkedStringList.Create;
  try
   if SplitPath(LinkName,Relative,Folders,Name) then
    begin
     {Get Parent}
     Parent:=FRoot;
     if Relative then Parent:=GetCurrent;
     if Parent = nil then Exit;
     
     {Add Reference}
     Parent.AddReference; 
     
     {Get Folders}
     Folder:=TStringObject(Folders.First);
     while Folder <> nil do
      begin
       Parent:=GetEntryEx(Parent,Folder.Value,faDirectory,True,True,False);
       if Parent = nil then Exit;
       
       Folder:=TStringObject(Folder.Next);
      end;
     try
      {Split the Name}
      if SplitName(Name,ParentName,StreamName) then Exit;
     
      {Get File or Folder}
      if GetEntry(Parent,Name,faDirectory or faFile) <> nil then Exit;
     
      {Check Name}
      if not CheckName(Name) then Exit;
     
      {Check AltName} {Allow Blank}
      if (Length(ShortName) <> 0) and not(CheckAltName(ShortName)) then Exit;
     
      {Add Symbolic Link}
      Current:=AddSymbolicLinkEx(Parent,Name,ShortName,TargetName,Directory,False);
      if Current = nil then Exit;
     
      Result:=True;
     finally
      {Remove Reference}
      Parent.RemoveReference;
     end;     
    end;
  finally
   Folders.Free;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.DeleteSymbolicLink(const LinkName:String):Boolean;
{Note: Link must exist}
var
 Name:String;
 Relative:Boolean;
 ParentName:String;
 StreamName:String;
 Folder:TStringObject;
 Folders:TLinkedStringList;

 Parent:TDiskEntry;
 Current:TDiskEntry;
begin
 {Base Implementation}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Split the Path}
  Folders:=TLinkedStringList.Create;
  try
   if SplitPath(LinkName,Relative,Folders,Name) then
    begin
     {Get Parent}
     Parent:=FRoot;
     if Relative then Parent:=GetCurrent;
     if Parent = nil then Exit;
     
     {Add Reference}
     Parent.AddReference; 
     
     {Get Folders}
     Folder:=TStringObject(Folders.First);
     while Folder <> nil do
      begin
       Parent:=GetEntryEx(Parent,Folder.Value,faDirectory,True,True,False);
       if Parent = nil then Exit;
       
       Folder:=TStringObject(Folder.Next);
      end;
     try
      {Split the Name}
      if SplitName(Name,ParentName,StreamName) then Exit;
     
      {Get File or Folder}
      Current:=GetEntryEx(Parent,Name,faDirectory or faFile,True,False,False);
      if Current = nil then Exit;
     
      //To Do //CheckFileHandles/UpdateFindHandles ?
      
      {Remove Symbolic Link}
      Result:=RemoveSymbolicLink(Parent,Current);
      if Result and (Parent.Recent = Current) then Parent.Recent:=nil;
     
      {Remove Reference}
      Current.RemoveReference;
     finally
      {Remove Reference}
      Parent.RemoveReference;
     end;     
    end;
  finally
   Folders.Free;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.GetMountPointTarget(const PathName:String):String;
var
 Name:String;
 Relative:Boolean;
 ParentName:String;
 StreamName:String;
 Folder:TStringObject;
 Folders:TLinkedStringList;

 Parent:TDiskEntry;
 Current:TDiskEntry;
 Reparse:TDiskReparse;
begin
 {Base Implementation}
 Result:='';

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Split the Path}
  Folders:=TLinkedStringList.Create;
  try
   if SplitPath(PathName,Relative,Folders,Name) then
    begin
     {Get Parent}
     Parent:=FRoot;
     if Relative then Parent:=GetCurrent;
     if Parent = nil then Exit;
     
     {Add Reference}
     Parent.AddReference; 
     
     {Get Folders}
     Folder:=TStringObject(Folders.First);
     while Folder <> nil do
      begin
       Parent:=GetEntryEx(Parent,Folder.Value,faDirectory,True,True,False);
       if Parent = nil then Exit;
       
       Folder:=TStringObject(Folder.Next);
      end;
     try
      {Split the Name}
      if SplitName(Name,ParentName,StreamName) then Exit;
     
      {Get File or Folder}
      Current:=GetEntryEx(Parent,Name,faDirectory or faFile,True,False,False);
      if Current = nil then Exit;
      try
       {Get Reparse}
       Reparse:=GetReparse(Current);
       if Reparse = nil then Exit;
     
       {Get Target}
       Result:=Reparse.Target;
      finally
       {Remove Reference}
       Current.RemoveReference;
      end;
     finally
      {Remove Reference}
      Parent.RemoveReference;
     end;     
    end;
  finally
   Folders.Free;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.GetJunctionPointTarget(const PathName:String):String;
begin
 {Base Implementation}
 Result:=GetMountPointTarget(PathName);
end;

{==============================================================================}

function TFileSystem.GetSymbolicLinkTarget(const LinkName:String):String;
begin
 {Base Implementation}
 Result:=GetMountPointTarget(LinkName);
end;

{==============================================================================}

function TFileSystem.SetFileShortName(const FileName,ShortName:String):Boolean;
{No Stream Support}
var
 Name:String;
 Relative:Boolean;
 ParentName:String;
 StreamName:String;
 Folder:TStringObject;
 Folders:TLinkedStringList;

 Parent:TDiskEntry;
 Current:TDiskEntry;
begin
 {Base Implementation}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Split the Path}
  Folders:=TLinkedStringList.Create;
  try
   if SplitPath(FileName,Relative,Folders,Name) then
    begin
     {Get Parent}
     Parent:=FRoot;
     if Relative then Parent:=GetCurrent;
     if Parent = nil then Exit;
     
     {Add Reference}
     Parent.AddReference; 
     
     {Get Folders}
     Folder:=TStringObject(Folders.First);
     while Folder <> nil do
      begin
       Parent:=GetEntryEx(Parent,Folder.Value,faDirectory,True,True,False);
       if Parent = nil then Exit;
       
       Folder:=TStringObject(Folder.Next);
      end;
     try
      {Split the Name}
      if SplitName(Name,ParentName,StreamName) then Exit;
     
      {Get File or Folder}
      Current:=GetEntryEx(Parent,Name,faDirectory or faFile,True,False,False);
      if Current = nil then Exit;
      try
       {Check AltName} {Allow Blank (Delete AltName)}
       if (Length(ShortName) <> 0) and not(CheckAltName(ShortName)) then Exit;
     
       {Check Handles}
       if not FDriver.CheckFileHandles(Current) then Exit;
     
       {Rename File or Folder}
       Result:=RenameEntryEx(Parent,Current,ShortName);
       if Result and (Parent.Recent = Current) then Parent.Recent:=nil;
      finally
       {Remove Reference}
       Current.RemoveReference;
      end;
     finally
      {Remove Reference}
      Parent.RemoveReference;
     end;     
    end;
  finally
   Folders.Free;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.SetFileShortNameEx(Handle:Integer;const ShortName:String):Boolean;
{No Stream Support}
var
 FileHandle:TFileHandle;
begin
 {Base Implementation}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Check AltName} {Allow Blank (Delete AltName)}
  if (Length(ShortName) <> 0) and not(CheckAltName(ShortName)) then Exit;
  
  {Get the Handle}
  FileHandle:=FDriver.GetFileFromHandle(Handle,True,FILESYS_LOCK_WRITE); //To Do //Reader   
  if FileHandle = nil then Exit;
  try
   {Check the Mode}
   if FileHandle.OpenMode = fmOpenRead then Exit;

   {Check the Handle}
   if FileHandle.HandleEntry = nil then Exit;
   if FileHandle.ParentEntry = nil then Exit;

   {Rename File or Folder}
   Result:=RenameEntryEx(FileHandle.ParentEntry,FileHandle.HandleEntry,ShortName);
   if Result and (FileHandle.ParentEntry.Recent = FileHandle.HandleEntry) then FileHandle.ParentEntry.Recent:=nil;
  finally
   {Unlock Handle}
   FileHandle.WriterUnlock;
  end; 
 finally  
  ReaderUnlock;
 end; 
end;
  
{==============================================================================}

function TFileSystem.GetFileSecurity(const FileName:String;Descriptor:Pointer;var Size:LongWord):Boolean;
var
 Name:String;
 Relative:Boolean;
 ParentName:String;
 StreamName:String;
 Folder:TStringObject;
 Folders:TLinkedStringList;

 Parent:TDiskEntry;
 Current:TDiskEntry;
 Security:TDiskSecurity;
begin
 {Base Implementation}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;
  {if Descriptor = nil then Exit;} {Descriptor may be nil on first call to get Size}

  {Split the Path}
  Folders:=TLinkedStringList.Create;
  try
   if SplitPath(FileName,Relative,Folders,Name) then
    begin
     {Get Parent}
     Parent:=FRoot;
     if Relative then Parent:=GetCurrent;
     if Parent = nil then Exit;
     
     {Add Reference}
     Parent.AddReference; 
     
     {Get Folders}
     Folder:=TStringObject(Folders.First);
     while Folder <> nil do
      begin
       Parent:=GetEntryEx(Parent,Folder.Value,faDirectory,True,True,False);
       if Parent = nil then Exit;
       
       Folder:=TStringObject(Folder.Next);
      end;
     try
      {Split the Name}
      if SplitName(Name,ParentName,StreamName) then Exit;
     
      {Get File or Folder}
      Current:=GetEntryEx(Parent,Name,faDirectory or faFile,True,False,False);
      if Current = nil then Exit;
      try
       {Get Security}
       Security:=GetSecurity(Current);
       if Security = nil then Exit;
     
       {Get Descriptor}
       if not GetDescriptorFromSecurity(Security,Descriptor,Size) then Exit;
     
       Result:=True;
      finally
       {Remove Reference}
       Current.RemoveReference;
      end;
     finally
      {Remove Reference}
      Parent.RemoveReference;
     end;     
    end;
  finally
   Folders.Free;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.SetFileSecurity(const FileName:String;Descriptor:Pointer):Boolean;
var
 Name:String;
 Relative:Boolean;
 ParentName:String;
 StreamName:String;
 Folder:TStringObject;
 Folders:TLinkedStringList;

 Parent:TDiskEntry;
 Current:TDiskEntry;
 Security:TDiskSecurity;
begin
 {Base Implementation}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;
  if Descriptor = nil then Exit;

  {Split the Path}
  Folders:=TLinkedStringList.Create;
  try
   if SplitPath(FileName,Relative,Folders,Name) then
    begin
     {Get Parent}
     Parent:=FRoot;
     if Relative then Parent:=GetCurrent;
     if Parent = nil then Exit;
     
     {Add Reference}
     Parent.AddReference; 
     
     {Get Folders}
     Folder:=TStringObject(Folders.First);
     while Folder <> nil do
      begin
       Parent:=GetEntryEx(Parent,Folder.Value,faDirectory,True,True,False);
       if Parent = nil then Exit;
       
       Folder:=TStringObject(Folder.Next);
      end;
     try
      {Split the Name}
      if SplitName(Name,ParentName,StreamName) then Exit;
     
      {Get File or Folder}
      Current:=GetEntryEx(Parent,Name,faDirectory or faFile,True,False,False);
      if Current = nil then Exit;
      try
       {Get Security}
       Security:=GetSecurityFromDescriptor(Descriptor);
       if Security = nil then Exit;
       try
        {Set Security}
        if not SetSecurity(Parent,Current,Security) then Exit;
      
        Result:=True;
       finally
        if not Result then Security.Free; {If SetSecurity returns true then it must either retain or free the security object}
       end;
      finally
       {Remove Reference}
       Current.RemoveReference;
      end;
     finally
      {Remove Reference}
      Parent.RemoveReference;
     end;     
    end;
  finally
   Folders.Free;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.GetPathName(const FileName:String):String;
{Get the path from the supplied name (Does not include trailing slash)}
var
 Name:String;
 Relative:Boolean;
 ParentName:String;
 StreamName:String;
 StreamType:String;
 Folder:TStringObject;
 Folders:TLinkedStringList;

 Parent:TDiskEntry;
 Current:TDiskEntry;
begin
 {Base Implementation}
 Result:=FileName;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;
  {if not FLongNames then Exit;}

  {Split the Path}
  Folders:=TLinkedStringList.Create;
  try
   if SplitPath(FileName,Relative,Folders,Name) then
    begin
     {Get Parent}
     Parent:=FRoot;
     if Relative then Parent:=GetCurrent;
     if Parent = nil then Exit;
     
     {Add Reference}
     Parent.AddReference; 
     
     {Get Folders}
     Folder:=TStringObject(Folders.First);
     while Folder <> nil do
      begin
       Parent:=GetEntryEx(Parent,Folder.Value,faDirectory,True,True,False);
       if Parent = nil then Exit;
       
       Folder:=TStringObject(Folder.Next);
      end;
     
     {Split the Name}
     if SplitName(Name,ParentName,StreamName) then
      begin
       {Get File or Folder}
       Parent:=GetEntryEx(Parent,ParentName,faDirectory or faFile,True,True,False);
       if Parent = nil then Exit;
       
       {Get Stream}
       Current:=GetEntryEx(Parent,StreamName,faStream,True,False,False);
       if Current = nil then
        begin
         {Split the Stream}
         if SplitStream(StreamName,StreamName,StreamType) then
          begin
           {Get Stream}
           Current:=GetEntryEx(Parent,StreamName,faStream,True,False,False);
          end;
        end;
       if Current = nil then
        begin
         {Remove Reference}
         Parent.RemoveReference;
         Exit;
        end; 
      end
     else
      begin
       {Get File or Folder}
       Current:=GetEntryEx(Parent,Name,faDirectory or faFile,True,False,False);
       if Current = nil then
        begin
         {Remove Reference}
         Parent.RemoveReference;
         Exit;
        end; 
      end;
     
     {Get Parent Name}
     Result:=GetEntryName(Parent,False);

     {Remove Reference}
     Current.RemoveReference;
     Parent.RemoveReference;
    end;
  finally
   Folders.Free;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.GetShortName(const FileName:String):String;
{Convert the supplied name to its Short name form}
var
 Name:String;
 Relative:Boolean;
 ParentName:String;
 StreamName:String;
 StreamType:String;
 Folder:TStringObject;
 Folders:TLinkedStringList;

 Parent:TDiskEntry;
 Current:TDiskEntry;
begin
 {Base Implementation}
 Result:=FileName;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;
  if not FLongNames then Exit;

  {Split the Path}
  Folders:=TLinkedStringList.Create;
  try
   if SplitPath(FileName,Relative,Folders,Name) then
    begin
     {Get Parent}
     Parent:=FRoot;
     if Relative then Parent:=GetCurrent;
     if Parent = nil then Exit;
     
     {Add Reference}
     Parent.AddReference; 
     
     {Get Folders}
     Folder:=TStringObject(Folders.First);
     while Folder <> nil do
      begin
       Parent:=GetEntryEx(Parent,Folder.Value,faDirectory,True,True,False);
       if Parent = nil then Exit;
       
       Folder:=TStringObject(Folder.Next);
      end;
     
     {Split the Name}
     if SplitName(Name,ParentName,StreamName) then
      begin
       {Get File or Folder}
       Parent:=GetEntryEx(Parent,ParentName,faDirectory or faFile,True,True,False);
       if Parent = nil then Exit;
       
       {Get Stream}
       Current:=GetEntryEx(Parent,StreamName,faStream,True,False,False);
       if Current = nil then
        begin
         {Split the Stream}
         if SplitStream(StreamName,StreamName,StreamType) then
          begin
           {Get Stream}
           Current:=GetEntryEx(Parent,StreamName,faStream,True,False,False);
          end;
        end;
       if Current = nil then
        begin
         {Remove Reference}
         Parent.RemoveReference;
         Exit;
        end; 
      end
     else
      begin
       {Get File or Folder}
       Current:=GetEntryEx(Parent,Name,faDirectory or faFile,True,False,False);
       if Current = nil then
        begin
         {Remove Reference}
         Parent.RemoveReference;
         Exit;
        end; 
      end;
     
     {Get Entry Short Name}
     Result:=GetEntryName(Current,True);
     
     {Remove Reference}
     Current.RemoveReference;
     Parent.RemoveReference;
    end;
  finally
   Folders.Free;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.GetLongName(const FileName:String):String;
{Convert the supplied name to its Long name form}
var
 Name:String;
 Relative:Boolean;
 ParentName:String;
 StreamName:String;
 StreamType:String;
 Folder:TStringObject;
 Folders:TLinkedStringList;

 Parent:TDiskEntry;
 Current:TDiskEntry;
begin
 {Base Implementation}
 Result:=FileName;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;
  if not FLongNames then Exit;

  {Split the Path}
  Folders:=TLinkedStringList.Create;
  try
   if SplitPath(FileName,Relative,Folders,Name) then
    begin
     {Get Parent}
     Parent:=FRoot;
     if Relative then Parent:=GetCurrent;
     if Parent = nil then Exit;
     
     {Add Reference}
     Parent.AddReference; 
     
     {Get Folders}
     Folder:=TStringObject(Folders.First);
     while Folder <> nil do
      begin
       Parent:=GetEntryEx(Parent,Folder.Value,faDirectory,True,True,False);
       if Parent = nil then Exit;
       
       Folder:=TStringObject(Folder.Next);
      end;
     
     {Split the Name}
     if SplitName(Name,ParentName,StreamName) then
      begin
       {Get File or Folder}
       Parent:=GetEntryEx(Parent,ParentName,faDirectory or faFile,True,True,False);
       if Parent = nil then Exit;
       
       {Get Stream}
       Current:=GetEntryEx(Parent,StreamName,faStream,True,False,False);
       if Current = nil then
        begin
         {Split the Stream}
         if SplitStream(StreamName,StreamName,StreamType) then
          begin
           {Get Stream}
           Current:=GetEntryEx(Parent,StreamName,faStream,True,False,False);
          end;
        end;
       if Current = nil then
        begin
         {Remove Reference}
         Parent.RemoveReference;
         Exit;
        end; 
      end
     else
      begin
       {Get File or Folder}
       Current:=GetEntryEx(Parent,Name,faDirectory or faFile,True,False,False);
       if Current = nil then
        begin
         {Remove Reference}
         Parent.RemoveReference;
         Exit;
        end; 
      end;
     
     {Get Entry Long Name}
     Result:=GetEntryName(Current,False);

     {Remove Reference}
     Current.RemoveReference;
     Parent.RemoveReference;
    end;
  finally
   Folders.Free;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.GetTrueName(const FileName:String):String;
{Convert the supplied name to its True name form}
{Note: Almost the same as GetShortName function}
var
 Name:String;
 Relative:Boolean;
 ParentName:String;
 StreamName:String;
 StreamType:String;
 Folder:TStringObject;
 Folders:TLinkedStringList;

 Parent:TDiskEntry;
 Current:TDiskEntry;
begin
 {Base Implementation}
 Result:=FileName;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;
  if not(FLongNames) and not(FReparsePoints) then Exit;

  {Split the Path}
  Folders:=TLinkedStringList.Create;
  try
   if SplitPath(FileName,Relative,Folders,Name) then
    begin
     {Get Parent}
     Parent:=FRoot;
     if Relative then Parent:=GetCurrent;
     if Parent = nil then Exit;
     
     {Add Reference}
     Parent.AddReference; 
     
     {Get Folders}
     Folder:=TStringObject(Folders.First);
     while Folder <> nil do
      begin
       Parent:=GetEntryEx(Parent,Folder.Value,faDirectory,True,True,False);
       if Parent = nil then Exit;
       
       Folder:=TStringObject(Folder.Next);
      end;
     
     {Split the Name}
     if SplitName(Name,ParentName,StreamName) then
      begin
       {Get File or Folder}
       Parent:=GetEntryEx(Parent,ParentName,faDirectory or faFile,True,True,False);
       if Parent = nil then Exit;
       
       {Get Stream}
       Current:=GetEntryEx(Parent,StreamName,faStream,True,False,False);
       if Current = nil then
        begin
         {Split the Stream}
         if SplitStream(StreamName,StreamName,StreamType) then
          begin
           {Get Stream}
           Current:=GetEntryEx(Parent,StreamName,faStream,True,False,False);
          end;
        end;
       if Current = nil then
        begin
         {Remove Reference}
         Parent.RemoveReference;
         Exit;
        end; 
      end
     else
      begin
       {Get File or Folder}
       Current:=GetEntryEx(Parent,Name,faDirectory or faFile,True,False,False);
       if Current = nil then
        begin
         {Remove Reference}
         Parent.RemoveReference;
         Exit;
        end; 
      end;
     
     {Get Entry Short Name}
     Result:=GetEntryName(Current,True);
     
     {Remove Reference}
     Current.RemoveReference;
     Parent.RemoveReference;
    end;
  finally
   Folders.Free;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.FileCreateEx(const FileName,ShortName:String;Mode:Integer = fmOpenReadWrite or fmShareExclusive):THandle;
{Create new entry or truncate existing entry and return Handle}
{Note: Cannot create Folders with FileCreateEx}
{Note: ShortName does not apply to Streams}
var
 Name:String;
 Relative:Boolean;
 ParentName:String;
 StreamName:String;
 StreamType:String;
 Folder:TStringObject;
 FileHandle:TFileHandle;
 Folders:TLinkedStringList;

 Parent:TDiskEntry;
 Current:TDiskEntry;
begin
 {Base Implementation}
 Result:=INVALID_HANDLE_VALUE;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Split the Path}
  Folders:=TLinkedStringList.Create;
  try
   if SplitPath(FileName,Relative,Folders,Name) then
    begin
     {Get Parent}
     Parent:=FRoot;
     if Relative then Parent:=GetCurrent;
     if Parent = nil then Exit;
     
     {Add Reference}
     Parent.AddReference; 
     
     {Get Folders}
     Folder:=TStringObject(Folders.First);
     while Folder <> nil do
      begin
       Parent:=GetEntryEx(Parent,Folder.Value,faDirectory,True,True,False);
       if Parent = nil then Exit;
       
       Folder:=TStringObject(Folder.Next);
      end;
     
     {Split the Name}
     if SplitName(Name,ParentName,StreamName) then
      begin
       {Get File or Folder}
       Parent:=GetEntryEx(Parent,ParentName,faDirectory or faFile,True,True,False);
       if Parent = nil then Exit;
       
       {Get Stream}
       Current:=GetEntryEx(Parent,StreamName,faStream,True,False,False);
       if Current = nil then
        begin
         {Split the Stream}
         if SplitStream(StreamName,StreamName,StreamType) then
          begin
           {Get Stream}
           Current:=GetEntryEx(Parent,StreamName,faStream,True,False,False);
          end;
        end;
       if Current = nil then
        begin
         {Check Name}
         if not CheckName(StreamName) then
          begin
           {Remove Reference}
           Parent.RemoveReference;
           Exit;
          end; 
         
         {Add Stream}
         Current:=AddEntry(Parent,StreamName,faStream,True); {Not AddEntryEx}
         if Current = nil then
          begin
           {Remove Reference}
           Parent.RemoveReference;
           Exit;
          end; 
        end;
      end
     else
      begin
       {Get File or Folder}
       Current:=GetEntryEx(Parent,Name,faDirectory or faFile,True,False,False);
       if Current = nil then
        begin
         {Check Name}
         if not CheckName(Name) then
          begin
           {Remove Reference}
           Parent.RemoveReference;
           Exit;
          end; 
         
         {Check AltName} {Allow Blank}
         if (Length(ShortName) <> 0) and not(CheckAltName(ShortName)) then
          begin
           {Remove Reference}
           Parent.RemoveReference;
           Exit;
          end; 
         
         {Add File}
         Current:=AddEntryEx(Parent,Name,ShortName,faFile,True);
         if Current = nil then
          begin
           {Remove Reference}
           Parent.RemoveReference;
           Exit;
          end; 
         
         {Check Encryption}
         if (FFolderEncryption) and ((Parent.Attributes and faEncrypted) = faEncrypted) then
          begin
           {Set Encrypted}
           Current.Attributes:=(Current.Attributes or faEncrypted);
           if not SetEntry(Parent,Current) then
            begin
             {Remove Reference}
             Current.RemoveReference;
             Parent.RemoveReference;
             Exit;
            end; 
          end;
         
         {Check Compression}
         if (FFolderCompression) and ((Parent.Attributes and faCompressed) = faCompressed) then
          begin
           {Set Compressed}
           Current.Attributes:=(Current.Attributes or faCompressed);
           if not SetEntry(Parent,Current) then
            begin
             {Remove Reference}
             Current.RemoveReference;
             Parent.RemoveReference;
             Exit;
            end; 
          end;
        end;
      end;
     try
      {Open Handle}
      FileHandle:=FDriver.OpenFileHandle(FVolume,FDrive,Parent,Current,Mode,True,FILESYS_LOCK_WRITE);
      if FileHandle = nil then Exit;
     
      {Set the Size} {In case of existing file}
      if Current.Size <> 0 then if not SizeEntry(FileHandle.ParentEntry,FileHandle.HandleEntry,0) then Exit;
    
      {Set Attributes} {Entry will be updated by FileClose}
      Current.Attributes:=(Current.Attributes or faArchive);
    
      {Return the Handle}
      Result:=FileHandle.Handle;
    
      {Unlock Handle}
      FileHandle.WriterUnlock;
     finally
      {Remove Reference}
      Current.RemoveReference;
      Parent.RemoveReference;
     end;     
    end;
  finally
   Folders.Free;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.CreateDirEx(const DirName,ShortName:String):Boolean;
{Create a new entry}{No File or Stream support}
var
 Name:String;
 Relative:Boolean;
 Folder:TStringObject;
 Folders:TLinkedStringList;

 Parent:TDiskEntry;
 Current:TDiskEntry;
begin
 {Base Implementation}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSystem.CreateDirEx DirName = ' + DirName + ' ShortName = ' + ShortName);
  {$ENDIF}
  
  {Split the Path}
  Folders:=TLinkedStringList.Create;
  try
   if SplitPath(DirName,Relative,Folders,Name) then
    begin
     {$IFDEF FILESYS_DEBUG}
     if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSystem.CreateDirEx Name = ' + Name);
     {$ENDIF}
     
     {Get Parent}
     Parent:=FRoot;
     if Relative then Parent:=GetCurrent;
     if Parent = nil then Exit;
     
     {Add Reference}
     Parent.AddReference; 
     
     {Get Folders}
     Folder:=TStringObject(Folders.First);
     while Folder <> nil do
      begin
       Parent:=GetEntryEx(Parent,Folder.Value,faDirectory,True,True,False);
       if Parent = nil then Exit;
       
       Folder:=TStringObject(Folder.Next);
      end;
     try
      {$IFDEF FILESYS_DEBUG}
      if FILESYS_LOG_ENABLED then FileSysLogDebug('TFileSystem.CreateDirEx Parent = ' + Parent.Name);
      {$ENDIF}
     
      {Check File or Folder}
      if GetEntry(Parent,Name,faDirectory or faFile) <> nil then Exit;
     
      {Check Name}
      if not CheckName(Name) then Exit;
     
      {Check AltName} {Allow Blank}
      if (Length(ShortName) <> 0) and not(CheckAltName(ShortName)) then Exit;
     
      {Add Folder}
      Current:=AddEntryEx(Parent,Name,ShortName,faDirectory,True);
      if Current = nil then Exit;
      try
       {Check Encryption}
       if (FFolderEncryption) and ((Parent.Attributes and faEncrypted) = faEncrypted) then
        begin
         {Set Encrypted}
         Current.Attributes:=(Current.Attributes or faEncrypted);
         if not SetEntry(Parent,Current) then Exit;
        end;
     
       {Check Compression}
       if (FFolderCompression) and ((Parent.Attributes and faCompressed) = faCompressed) then
        begin
         {Set Compressed}
         Current.Attributes:=(Current.Attributes or faCompressed);
         if not SetEntry(Parent,Current) then Exit;
        end;
     
       Result:=True;
      finally
       {Remove Reference}
       Current.RemoveReference;
      end;      
     finally
      {Remove Reference}
      Parent.RemoveReference;
     end;     
    end;
  finally
   Folders.Free;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.FileGetAttrEx(Handle:Integer):Integer; 
{Get the Attributes of an existing entry with an open Handle}
var
 FileHandle:TFileHandle;
begin
 {Base Implementation}
 Result:=-1;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;
 
  {Get the Handle}
  FileHandle:=FDriver.GetFileFromHandle(Handle,True,FILESYS_LOCK_WRITE); //To Do //Reader   
  if FileHandle = nil then Exit;
  try
   {Check the Mode}
   if FileHandle.OpenMode = fmOpenWrite then Exit;
 
   {Check the Handle}
   if FileHandle.HandleEntry = nil then Exit;
 
   {Get Attributes} {Hide internal Attributes}
   Result:=(FileHandle.HandleEntry.Attributes and FMaskAttributes); {faFindMask}
  finally
   {Unlock Handle}
   FileHandle.WriterUnlock;
  end; 
 finally  
  ReaderUnlock;
 end; 
end;
 
{==============================================================================}

function TFileSystem.FileGetDateEx(Handle:Integer):TFileTime;
{Get the Date/Time of an existing entry with an open Handle}
{Note: Returned time is UTC}
var
 FileTime:TFileTime;
begin
 {Base Implementation}
 Int64(Result):=-1;

 if GetFileTime(Handle,nil,nil,@FileTime) then
  begin
   Result:=FileTime;
  end;
end;

{==============================================================================}

function TFileSystem.FileSetDateEx(Handle:Integer;Age:TFileTime):Integer;
{Set the Date/Time of an existing entry with an open Handle}
{Note: Passed time is assumed to be UTC}
begin
 {Base Implementation}
 Result:=-1;

 if SetFileTime(Handle,nil,nil,@Age) then
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function TFileSystem.GetFileTime(Handle:Integer;CreateTime,AccessTime,ModifyTime:PFileTime):Boolean;
{Get the Dates and Times of an existing entry with an open Handle}
{Note: Returned time is UTC}
var
 FileHandle:TFileHandle;
begin
 {Base Implementation}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Check Params}
  if (CreateTime = nil) and (AccessTime = nil) and (ModifyTime = nil) then Exit;
 
  {Get the Handle}
  FileHandle:=FDriver.GetFileFromHandle(Handle,True,FILESYS_LOCK_WRITE); //To Do //Reader   
  if FileHandle = nil then Exit;
  try
   {Check the Mode}
   if FileHandle.OpenMode = fmOpenWrite then Exit;
 
   {Check the Handle}
   if FileHandle.HandleEntry = nil then Exit;
 
   {Get the Time}
   if CreateTime <> nil then CreateTime^:=FileHandle.HandleEntry.CreateTime;
   if AccessTime <> nil then AccessTime^:=FileHandle.HandleEntry.AccessTime;
   if ModifyTime <> nil then ModifyTime^:=FileHandle.HandleEntry.WriteTime;
 
   Result:=True;
  finally
   {Unlock Handle}
   FileHandle.WriterUnlock;
  end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.SetFileTime(Handle:Integer;CreateTime,AccessTime,ModifyTime:PFileTime):Boolean;
{Set the Dates and Times of an existing entry with an open Handle}
{Note: Passed times are assumed to be UTC and are converted to Local}
var
 FileHandle:TFileHandle;
begin
 {Base Implementation}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Check Params}
  if (CreateTime = nil) and (AccessTime = nil) and (ModifyTime = nil) then Exit;
 
  {Get the Handle}
  FileHandle:=FDriver.GetFileFromHandle(Handle,True,FILESYS_LOCK_WRITE); //To Do //Reader   
  if FileHandle = nil then Exit;
  try
   {Check the Mode}
   if FileHandle.OpenMode = fmOpenRead then Exit;
  
   {Check the Handle}
   if FileHandle.HandleEntry = nil then Exit;
  
   {Set the Time}
   if CreateTime <> nil then FileHandle.HandleEntry.CreateTime:=CreateTime^;
   if AccessTime <> nil then FileHandle.HandleEntry.AccessTime:=AccessTime^;
   if ModifyTime <> nil then FileHandle.HandleEntry.WriteTime:=ModifyTime^;
  
   Result:=SetEntry(FileHandle.ParentEntry,FileHandle.HandleEntry);
  finally
   {Unlock Handle}
   FileHandle.WriterUnlock;
  end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TFileSystem.CloseFile(Handle:THandle):Boolean; {Equivalent to Win32 CloseHandle}
{Close open handle}
var
 FileHandle:TFileHandle;
begin
 {Base Implementation}
 Result:=False;
 
 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;

  {Get the Handle}
  FileHandle:=FDriver.GetFileFromHandle(Handle,True,FILESYS_LOCK_WRITE);
  if FileHandle = nil then Exit;
 
  {Update Entry} {Dont check return}
  if FileHandle.OpenMode <> fmOpenRead then SetEntry(FileHandle.ParentEntry,FileHandle.HandleEntry);

  {Close the Handle} {Do not unlock}
  FDriver.CloseFileHandle(FileHandle);
  
  Result:=True;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}
{==============================================================================}
{TDiskChunk}
constructor TDiskChunk.Create(ALocalLock:TMutexHandle);
begin
 {}
 inherited Create;
 FLocalLock:=ALocalLock;
end;

{==============================================================================}

destructor TDiskChunk.Destroy; 
begin
 {}
 FLocalLock:=INVALID_HANDLE_VALUE;
 inherited Destroy;
end;

{==============================================================================}

function TDiskChunk.AcquireLock:Boolean;
begin
 {}
 Result:=(MutexLock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskChunk.ReleaseLock:Boolean;
begin
 {}
 Result:=(MutexUnlock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}
{==============================================================================}
{TDiskTable}
constructor TDiskTable.Create(ALocalLock:TMutexHandle);
begin
 {}
 inherited Create;
 FLocalLock:=ALocalLock;
end;

{==============================================================================}

destructor TDiskTable.Destroy; 
begin
 {}
 FLocalLock:=INVALID_HANDLE_VALUE;
 inherited Destroy;
end;

{==============================================================================}

function TDiskTable.AcquireLock:Boolean;
begin
 {}
 Result:=(MutexLock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskTable.ReleaseLock:Boolean;
begin
 {}
 Result:=(MutexUnlock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}
{==============================================================================}
{TDiskBlock}
constructor TDiskBlock.Create(ALocalLock:TMutexHandle);
begin
 {}
 inherited Create;
 FLocalLock:=ALocalLock;
end;

{==============================================================================}

destructor TDiskBlock.Destroy; 
begin
 {}
 FLocalLock:=INVALID_HANDLE_VALUE;
 inherited Destroy;
end;

{==============================================================================}

function TDiskBlock.AcquireLock:Boolean;
begin
 {}
 Result:=(MutexLock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskBlock.ReleaseLock:Boolean;
begin
 {}
 Result:=(MutexUnlock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}
{==============================================================================}
{TDiskEntry}
constructor TDiskEntry.Create(ALocalLock:TMutexHandle);
begin
 {}
 inherited Create;
 FLocalLock:=ALocalLock;
 
 FRecent:=nil;
end;

{==============================================================================}

destructor TDiskEntry.Destroy; 
begin
 {}
 FRecent:=nil;
 
 FLocalLock:=INVALID_HANDLE_VALUE;
 inherited Destroy;
end;

{==============================================================================}

function TDiskEntry.GetName:String;
begin
 {}
 Result:='';
 
 if not AcquireLock then Exit;
 
 Result:=FName;
 UniqueString(Result);
 
 ReleaseLock;
end;

{==============================================================================}

procedure TDiskEntry.SetName(const AName:String);
begin
 {}
 if not AcquireLock then Exit;

 FName:=AName;
 UniqueString(FName);
 FHash:=GenerateNameHash(FName,NAME_HASH_SIZE); 
 
 ReleaseLock;
end;

{==============================================================================}

function TDiskEntry.GetAltName:String;
begin
 {}
 Result:='';
 
 if not AcquireLock then Exit;

 Result:=FAltName;
 UniqueString(Result);
 
 ReleaseLock;
end;

{==============================================================================}

procedure TDiskEntry.SetAltName(const AAltName:String);
begin
 {}
 if not AcquireLock then Exit;

 FAltName:=AAltName;
 UniqueString(FAltName);
 FAltHash:=GenerateNameHash(FAltName,NAME_HASH_SIZE); 
 
 ReleaseLock;
end;

{==============================================================================}

function TDiskEntry.AcquireLock:Boolean;
begin
 {}
 Result:=(MutexLock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskEntry.ReleaseLock:Boolean;
begin
 {}
 Result:=(MutexUnlock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskEntry.AddReference:Boolean;
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;

 Inc(FReferenceCount);

 Result:=True;
 
 ReleaseLock;
end;
 
{==============================================================================}

function TDiskEntry.RemoveReference:Boolean;
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;

 if FReferenceCount < 1 then Exit;
 
 Dec(FReferenceCount);

 Result:=True;
 
 ReleaseLock;
end;

{==============================================================================}

function TDiskEntry.FindFirstName(AHandle:TFindHandle;AReference:Boolean):TDiskEntry;
begin
 {Virtual Base Method - No Function}
 Result:=nil;
end;

{==============================================================================}

function TDiskEntry.FindPrevName(AHandle:TFindHandle;AReference:Boolean):TDiskEntry;
begin
 {Virtual Base Method - No Function}
 Result:=nil;
end;

{==============================================================================}

function TDiskEntry.FindNextName(AHandle:TFindHandle;AReference:Boolean):TDiskEntry;
begin
 {Virtual Base Method - No Function}
 Result:=nil;
end;

{==============================================================================}

function TDiskEntry.FindLastName(AHandle:TFindHandle;AReference:Boolean):TDiskEntry;
begin
 {Virtual Base Method - No Function}
 Result:=nil;
end;

{==============================================================================}
{==============================================================================}
{TDiskCatalog}
constructor TDiskCatalog.Create(ALocalLock:TMutexHandle);
begin
 {}
 inherited Create;
 FLock:=SynchronizerCreate;
 FLocalLock:=ALocalLock;
end;

{==============================================================================}

destructor TDiskCatalog.Destroy;
begin
 {}
 WriterLock;
 try
  FLocalLock:=INVALID_HANDLE_VALUE;
  inherited Destroy;
 finally 
  {WriterUnlock;} {Can destroy Synchronizer while holding lock}
  SynchronizerDestroy(FLock);
 end;
end;

{==============================================================================}

function TDiskCatalog.AcquireLock:Boolean;
begin
 {}
 Result:=(MutexLock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskCatalog.ReleaseLock:Boolean;
begin
 {}
 Result:=(MutexUnlock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskCatalog.GetName:String;
begin
 {}
 Result:='';
 
 if not AcquireLock then Exit;
 
 Result:=FName;
 UniqueString(Result);
 
 ReleaseLock;
end;

{==============================================================================}

procedure TDiskCatalog.SetName(const AName:String);
begin
 {}
 if not AcquireLock then Exit;
 
 FName:=AName;
 UniqueString(FName);
 FHash:=GenerateNameHash(FName,NAME_HASH_SIZE); 
 
 ReleaseLock;
end;

{==============================================================================}

function TDiskCatalog.GetPath:String;
begin
 {}
 Result:='';
 
 if not AcquireLock then Exit;

 Result:=FPath;
 UniqueString(Result);
 
 ReleaseLock;
end;

{==============================================================================}

procedure TDiskCatalog.SetPath(const APath:String);
begin
 {}
 if not AcquireLock then Exit;

 FPath:=APath;
 UniqueString(FPath);
 
 ReleaseLock;
end;

{==============================================================================}

function TDiskCatalog.GetMediaType:TMediaType;
begin
 {}
 Result:=FMediaType;
end;

{==============================================================================}

procedure TDiskCatalog.SetMediaType(AMediaType:TMediaType);
begin
 {}
 FMediaType:=AMediaType;
end;

{==============================================================================}

function TDiskCatalog.GetFloppyType:TFloppyType;
begin
 {}
 Result:=FFloppyType;
end;

{==============================================================================}

procedure TDiskCatalog.SetFloppyType(AFloppyType:TFloppyType);
begin
 {}
 FFloppyType:=AFloppyType;
end;

{==============================================================================}

function TDiskCatalog.GetAttributes:LongWord;
begin
 {}
 Result:=FAttributes;
end;

{==============================================================================}

procedure TDiskCatalog.SetAttributes(AAttributes:LongWord);
begin
 {}
 FAttributes:=AAttributes;
end;

{==============================================================================}

function TDiskCatalog.GetSectorSize:Word;
begin
 {}
 Result:=FSectorSize;
end;

{==============================================================================}

procedure TDiskCatalog.SetSectorSize(ASectorSize:Word);
begin
 {}
 FSectorSize:=ASectorSize;
end;

{==============================================================================}

function TDiskCatalog.GetSectorCount:Int64;
begin
 {}
 Result:=FSectorCount;
end;

{==============================================================================}

procedure TDiskCatalog.SetSectorCount(const ASectorCount:Int64);
begin
 {}
 FSectorCount:=ASectorCount;
end;

{==============================================================================}

function TDiskCatalog.ReaderLock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskCatalog.ReaderUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerReaderUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskCatalog.WriterLock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskCatalog.WriterUnlock:Boolean;
begin
 {}
 Result:=(SynchronizerWriterUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}
{==============================================================================}
{TDiskReparse}
constructor TDiskReparse.Create(ALocalLock:TMutexHandle);
begin
 {}
 inherited Create;
 FLocalLock:=ALocalLock;
end;

{==============================================================================}

destructor TDiskReparse.Destroy; 
begin
 {}
 FLocalLock:=INVALID_HANDLE_VALUE;
 inherited Destroy;
end;

{==============================================================================}

function TDiskReparse.AcquireLock:Boolean;
begin
 {}
 Result:=(MutexLock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskReparse.ReleaseLock:Boolean;
begin
 {}
 Result:=(MutexUnlock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskReparse.GetTarget:String;
begin
 {Virtual Base Method - No Function}
 Result:='';
end;

{==============================================================================}

procedure TDiskReparse.SetTarget(const ATarget:String);
begin
 {Virtual Base Method - No Function}
end;

{==============================================================================}
{==============================================================================}
{TDiskSecurity}
constructor TDiskSecurity.Create(ALocalLock:TMutexHandle);
begin
 {}
 inherited Create;
 FLocalLock:=ALocalLock;
end;

{==============================================================================}

constructor TDiskSecurity.CreateFromSecurity(ALocalLock:TMutexHandle;ASecurity:TDiskSecurity);
begin
 {Virtual Base Method - No Function}
 Create(ALocalLock);
end;

{==============================================================================}

constructor TDiskSecurity.CreateFromDescriptor(ALocalLock:TMutexHandle;ADescriptor:Pointer);
begin
 {Virtual Base Method - No Function}
 Create(ALocalLock);
end;

{==============================================================================}

destructor TDiskSecurity.Destroy; 
begin
 {}
 FLocalLock:=INVALID_HANDLE_VALUE;
 inherited Destroy;
end;

{==============================================================================}

function TDiskSecurity.AcquireLock:Boolean;
begin
 {}
 Result:=(MutexLock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskSecurity.ReleaseLock:Boolean;
begin
 {}
 Result:=(MutexUnlock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskSecurity.SecuritySize:LongWord;
begin
 {Virtual Base Method - No Function}
 Result:=0;
end;

{==============================================================================}

function TDiskSecurity.SecurityDescriptor:Pointer;
begin
 {Virtual Base Method - No Function}
 Result:=nil;
end;

{==============================================================================}

function TDiskSecurity.SecurityDescriptorEx(ALocal:Boolean):Pointer;
begin
 {Virtual Base Method - No Function}
 Result:=nil;
end;

{==============================================================================}

function TDiskSecurity.InheritedDescriptor:Pointer;
begin
 {Virtual Base Method - No Function}
 Result:=nil;
end;

{==============================================================================}

function TDiskSecurity.MergedDescriptor(AChild:Pointer):Pointer;
begin
 {Virtual Base Method - No Function}
 Result:=nil;
end;

{==============================================================================}

function TDiskSecurity.ReleaseDescriptor(ADescriptor:Pointer;AInherited,AMerged:Boolean):Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskSecurity.CopyToSecurity(ASecurity:TDiskSecurity):Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskSecurity.CopyFromSecurity(ASecurity:TDiskSecurity):Boolean;
begin
 {Base Implementation}
 Result:=ASecurity.CopyToSecurity(Self);
end;

{==============================================================================}

function TDiskSecurity.CopyToDescriptor(ADescriptor:Pointer;ASize:LongWord):Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskSecurity.CopyToDescriptorEx(ADescriptor:Pointer;ASize:LongWord;ALocal:Boolean):Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}

function TDiskSecurity.CopyFromDescriptor(ADescriptor:Pointer;ASize:LongWord):Boolean;
begin
 {Virtual Base Method - No Function}
 Result:=False;
end;

{==============================================================================}
{==============================================================================}
{TDiskAcl}
constructor TDiskAcl.Create(ALocalLock:TMutexHandle);
begin
 {}
 inherited Create;
 FLocalLock:=ALocalLock;
end;

{==============================================================================}

destructor TDiskAcl.Destroy; 
begin
 {}
 FLocalLock:=INVALID_HANDLE_VALUE;
 inherited Destroy;
end;

{==============================================================================}

function TDiskAcl.AcquireLock:Boolean;
begin
 {}
 Result:=(MutexLock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskAcl.ReleaseLock:Boolean;
begin
 {}
 Result:=(MutexUnlock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}
{==============================================================================}
{TDiskAce}
constructor TDiskAce.Create(ALocalLock:TMutexHandle);
begin
 {}
 inherited Create;
 FLocalLock:=ALocalLock;
end;

{==============================================================================}

destructor TDiskAce.Destroy; 
begin
 {}
 FLocalLock:=INVALID_HANDLE_VALUE;
 inherited Destroy;
end;

{==============================================================================}

function TDiskAce.AcquireLock:Boolean;
begin
 {}
 Result:=(MutexLock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TDiskAce.ReleaseLock:Boolean;
begin
 {}
 Result:=(MutexUnlock(FLocalLock) = ERROR_SUCCESS);
end;

{==============================================================================}
{==============================================================================}
{TCache}
constructor TCache.Create(ADriver:TFileSysDriver);
begin
 {}
 inherited Create;
 FDriver:=ADriver;

 FLock:=CriticalSectionCreate;

 FBuffer:=nil;
 FPageSize:=0;
 FCacheSize:=0;
 FCacheMode:=cmNONE;
 FCacheState:=csCLEAN;
 FCacheTimeout:=FILESYS_CACHE_FLUSH_TIMEOUT; 

 FReadCached:=0;
 FReadDirect:=0;

 FWriteBack:=0;
 FWriteThrough:=0;
 FWriteDirect:=0;

 FHitCount:=0;
 FMissCount:=0;

 FFailCount:=0;
 FSuccessCount:=0;

 FFlushCount:=0;
 FDiscardCount:=0;
 FUnknownCount:=0;

 FFirstPage:=nil;
 FLastPage:=nil;
 FFirstEmpty:=nil;
 FLastEmpty:=nil;
 FFirstClean:=nil;
 FLastClean:=nil;
 FFirstDirty:=nil;
 FLastDirty:=nil;

 FTimer:=nil;
 FThread:=nil;
end;

{==============================================================================}

destructor TCache.Destroy;
begin
 {}
 AcquireLock;
 try
  FThread:=nil;
  FTimer:=nil;

  FFirstDirty:=nil;
  FLastDirty:=nil;
  FFirstClean:=nil;
  FLastClean:=nil;
  FFirstEmpty:=nil;
  FLastEmpty:=nil;
  FFirstPage:=nil;
  FLastPage:=nil;

  FBuffer:=nil;
  FDriver:=nil;
  inherited Destroy;
 finally
  {ReleaseLock;} {Can destroy Critical Section while holding lock} 
  CriticalSectionDestroy(FLock);
 end;
end;

{==============================================================================}

function TCache.AcquireLock:Boolean;
begin
 {}
 Result:=(CriticalSectionLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TCache.ReleaseLock:Boolean;
begin
 {}
 Result:=(CriticalSectionUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TCache.AddPage(APage:TCachePage):Boolean;
{Add a new page to the Page list and the Empty list}
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if APage = nil then Exit;

  if not LinkPage(APage) then Exit;
  APage.PageState:=psUNKNOWN;
  
  if not LinkEmpty(APage) then Exit;
  APage.PageState:=psEMPTY;
  
  Result:=True;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function TCache.RemovePage(APage:TCachePage):Boolean;
{Remove a Page from the Page list and any other lists then Free the Page}
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if APage = nil then Exit;

  case APage.PageState of
   psUNKNOWN:begin
     APage.PageState:=psUNKNOWN;
     
     if not UnlinkPage(APage) then Exit;
     APage.Free;
     
     Result:=True;
    end;
   psEMPTY:begin
     if not UnlinkEmpty(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     if not UnlinkPage(APage) then Exit;
     APage.Free;
     
     Result:=True;
    end;
   psCLEAN:begin
     if not UnlinkClean(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     if not UnlinkPage(APage) then Exit;
     
     APage.Free;
     
     Result:=True;
    end;
   psDIRTY:begin
     if not UnlinkDirty(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     if not UnlinkPage(APage) then Exit;
     APage.Free;
     
     Result:=True;
    end;
  end;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function TCache.AddEmpty(APage:TCachePage):Boolean;
{Add a Page to the Empty list, removing from other lists if needed}
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if APage = nil then Exit;

  case APage.PageState of
   psUNKNOWN:begin
     if not LinkEmpty(APage) then Exit;
     APage.PageState:=psEMPTY;
     
     Result:=True;
    end;
   psEMPTY:begin
     Result:=True;
    end;
   psCLEAN:begin
     if not UnlinkClean(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     if not LinkEmpty(APage) then Exit;
     APage.PageState:=psEMPTY;
     
     Result:=True;
    end;
   psDIRTY:begin
     if not UnlinkDirty(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     if not LinkEmpty(APage) then Exit;
     APage.PageState:=psEMPTY;
     
     Result:=True;
    end;
  end;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function TCache.AddClean(APage:TCachePage):Boolean;
{Add a Page to the Clean list, removing from other lists if needed}
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if APage = nil then Exit;

  case APage.PageState of
   psUNKNOWN:begin
     if not LinkClean(APage) then Exit;
     APage.PageState:=psCLEAN;
     
     Result:=True;
    end;
   psEMPTY:begin
     if not UnlinkEmpty(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     if not LinkClean(APage) then Exit;
     APage.PageState:=psCLEAN;
     
     Result:=True;
    end;
   psCLEAN:begin
     Result:=True;
    end;
   psDIRTY:begin
     if not UnlinkDirty(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     if not LinkClean(APage) then Exit;
     APage.PageState:=psCLEAN;
     
     Result:=True;
    end;
  end;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function TCache.AddDirty(APage:TCachePage):Boolean;
{Add a Page to the Dirty list, removing from other lists if needed}
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if APage = nil then Exit;

  case APage.PageState of
   psUNKNOWN:begin
     if not LinkDirty(APage) then Exit;
     APage.PageState:=psDIRTY;
     
     Result:=SchedulePage(APage,FCacheTimeout);
    end;
   psEMPTY:begin
     if not UnlinkEmpty(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     if not LinkDirty(APage) then Exit;
     APage.PageState:=psDIRTY;
     
     Result:=SchedulePage(APage,FCacheTimeout);
    end;
   psCLEAN:begin
     if not UnlinkClean(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     if not LinkDirty(APage) then Exit;
     APage.PageState:=psDIRTY;
     
     Result:=SchedulePage(APage,FCacheTimeout);
    end;
   psDIRTY:begin
     Result:=True;
    end;
  end;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function TCache.AddUnknown(APage:TCachePage):Boolean;
{Make a Page Unknown by removing from any other lists if needed}
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if APage = nil then Exit;

  case APage.PageState of
   psUNKNOWN:begin
     Result:=True;
    end;
   psEMPTY:begin
     if not UnlinkEmpty(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     Result:=True;
    end;
   psCLEAN:begin
     if not UnlinkClean(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     Result:=True;
    end;
   psDIRTY:begin
     if not UnlinkDirty(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     Result:=True;
    end;
  end;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function TCache.UpdateClean(APage:TCachePage):Boolean;
{Move a Page to the end of the Clean list}
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if APage = nil then Exit;

  case APage.PageState of
   psCLEAN:begin
     if not UnlinkClean(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     if not LinkClean(APage) then Exit;
     APage.PageState:=psCLEAN;
     
     Result:=True;
    end;
   psDIRTY:begin
     Result:=True;
    end;
  end;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function TCache.UpdateDirty(APage:TCachePage):Boolean;
{Move a Page to the end of the Dirty list} {Not Used}
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if APage = nil then Exit;

  case APage.PageState of
   psCLEAN:begin
     Result:=True;
    end;
   psDIRTY:begin
     if not UnlinkDirty(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     if not LinkDirty(APage) then Exit;
     APage.PageState:=psDIRTY;
     
     Result:=True;
    end;
  end;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function TCache.RoundPageSize(APageSize:LongWord):LongWord;
{Round Page Size to the power of 2 of Sector Size}

{Note: Caller must hold the lock}
begin
 {}
 Result:=MIN_SECTOR_SIZE; 
 
 {Round up to next power of 2 of Minimum Sector Size}
 while Result < APageSize do
  begin
   Result:=Result shl 1;
  end;
end;

{==============================================================================}

function TCache.RoundCacheSize(ACacheSize,APageSize:LongWord):LongWord;
{Round Cache Size to the next multiple of Page Size}

{Note: Caller must hold the lock}
begin
 {}
 Result:=0;
 
 if APageSize = 0 then Exit;
 
 {Round up to next multiple of Page Size}
 Result:=APageSize;
 while Result < ACacheSize do
  begin
   Inc(Result,APageSize);
  end;
end;

{==============================================================================}

function TCache.LinkPage(APage:TCachePage):Boolean;
{Link APage to PrevPage,NextPage siblings and Adjust FirstPage/LastPage}

{Note: Caller must hold the lock}
var
 Prev:TCachePage;
begin
 {}
 Result:=False;
 
 if FDriver = nil then Exit;
 if APage = nil then Exit;

 Prev:=FLastPage;
 if Prev = nil then
  begin
   {Is First Object}
   APage.PrevPage:=nil;
   APage.NextPage:=nil;
   FFirstPage:=APage;
   FLastPage:=APage;
  end
 else
  begin
   {Not First Object}
   Prev.NextPage:=APage;
   APage.PrevPage:=Prev;
   APage.NextPage:=nil;
   FLastPage:=APage;
  end;
  
 Result:=True;
end;

{==============================================================================}

function TCache.UnlinkPage(APage:TCachePage):Boolean;
{Unlink APage from PrevPage,NextPage Siblings and Adjust FirstPage/LastPage}

{Note: Caller must hold the lock}
var
 Prev,Next:TCachePage;
begin
 {}
 Result:=False;
 
 if FDriver = nil then Exit;
 if APage = nil then Exit;

 if APage.PrevPage <> nil then
  begin
   {Not First Object}
   Prev:=APage.PrevPage;
   if APage.NextPage <> nil then
    begin
     {Not Last Object}
     Next:=APage.NextPage;
     Prev.NextPage:=Next;
     Next.PrevPage:=Prev;
    end
   else
    begin
     {Is Last Object}
     Prev.NextPage:=nil;
     FLastPage:=Prev;
    end;
  end
 else
  begin
   {Is First Object}
   if APage.NextPage <> nil then
    begin
     {Not Last Object}
     Next:=APage.NextPage;
     Next.PrevPage:=nil;
     FFirstPage:=Next;
    end
   else
    begin
     {Is Last Object}
     FFirstPage:=nil;
     FLastPage:=nil;
    end;
  end;
  
 APage.PrevPage:=nil;
 APage.NextPage:=nil;
 
 Result:=True;
end;

{==============================================================================}

function TCache.LinkEmpty(APage:TCachePage):Boolean;
{Link APage to PrevLink,NextLink siblings and Adjust FirstEmpty/LastEmpty}

{Note: Caller must hold the lock}
var
 Prev:TCachePage;
begin
 {}
 Result:=False;

 if FDriver = nil then Exit;
 if APage = nil then Exit;

 Prev:=FLastEmpty;
 if Prev = nil then
  begin
   {Is First Object}
   APage.PrevLink:=nil;
   APage.NextLink:=nil;
   FFirstEmpty:=APage;
   FLastEmpty:=APage;
  end
 else
  begin
   {Not First Object}
   Prev.NextLink:=APage;
   APage.PrevLink:=Prev;
   APage.NextLink:=nil;
   FLastEmpty:=APage;
  end;
  
 Result:=True;
end;

{==============================================================================}

function TCache.UnlinkEmpty(APage:TCachePage):Boolean;
{Unlink APage from PrevLink,NextLink Siblings and Adjust FirstEmpty/LastEmpty}

{Note: Caller must hold the lock}
var
 Prev,Next:TCachePage;
begin
 {}
 Result:=False;
 
 if FDriver = nil then Exit;
 if APage = nil then Exit;

 if APage.PrevLink <> nil then
  begin
   {Not First Object}
   Prev:=APage.PrevLink;
   if APage.NextLink <> nil then
    begin
     {Not Last Object}
     Next:=APage.NextLink;
     Prev.NextLink:=Next;
     Next.PrevLink:=Prev;
    end
   else
    begin
     {Is Last Object}
     Prev.NextLink:=nil;
     FLastEmpty:=Prev;
    end;
  end
 else
  begin
   {Is First Object}
   if APage.NextLink <> nil then
    begin
     {Not Last Object}
     Next:=APage.NextLink;
     Next.PrevLink:=nil;
     FFirstEmpty:=Next;
    end
   else
    begin
     {Is Last Object}
     FFirstEmpty:=nil;
     FLastEmpty:=nil;
    end;
  end;
 
 APage.PrevLink:=nil;
 APage.NextLink:=nil;
 
 Result:=True;
end;

{==============================================================================}

function TCache.LinkClean(APage:TCachePage):Boolean;
{Link APage to PrevLink,NextLink siblings and Adjust FirstClean/LastClean}

{Note: Caller must hold the lock}
var
 Prev:TCachePage;
begin
 {}
 Result:=False;
 
 if FDriver = nil then Exit;
 if APage = nil then Exit;

 Prev:=FLastClean;
 if Prev = nil then
  begin
   {Is First Object}
   APage.PrevLink:=nil;
   APage.NextLink:=nil;
   FFirstClean:=APage;
   FLastClean:=APage;
  end
 else
  begin
   {Not First Object}
   Prev.NextLink:=APage;
   APage.PrevLink:=Prev;
   APage.NextLink:=nil;
   FLastClean:=APage;
  end;
  
 Result:=True;
end;

{==============================================================================}

function TCache.UnlinkClean(APage:TCachePage):Boolean;
{Unlink APage from PrevLink,NextLink Siblings and Adjust FirstClean/LastClean}

{Note: Caller must hold the lock}
var
 Prev,Next:TCachePage;
begin
 {}
 Result:=False;
 
 if FDriver = nil then Exit;
 if APage = nil then Exit;

 if APage.PrevLink <> nil then
  begin
   {Not First Object}
   Prev:=APage.PrevLink;
   if APage.NextLink <> nil then
    begin
     {Not Last Object}
     Next:=APage.NextLink;
     Prev.NextLink:=Next;
     Next.PrevLink:=Prev;
    end
   else
    begin
     {Is Last Object}
     Prev.NextLink:=nil;
     FLastClean:=Prev;
    end;
  end
 else
  begin
   {Is First Object}
   if APage.NextLink <> nil then
    begin
     {Not Last Object}
     Next:=APage.NextLink;
     Next.PrevLink:=nil;
     FFirstClean:=Next;
    end
   else
    begin
     {Is Last Object}
     FFirstClean:=nil;
     FLastClean:=nil;
    end;
  end;
  
 APage.PrevLink:=nil;
 APage.NextLink:=nil;
 
 Result:=True;
end;

{==============================================================================}

function TCache.LinkDirty(APage:TCachePage):Boolean;
{Link APage to PrevLink,NextLink siblings and Adjust FirstDirty/LastDirty}

{Note: Caller must hold the lock}
var
 Prev:TCachePage;
begin
 {}
 Result:=False;
 
 if FDriver = nil then Exit;
 if APage = nil then Exit;

 Prev:=FLastDirty;
 if Prev = nil then
  begin
   {Is First Object}
   APage.PrevLink:=nil;
   APage.NextLink:=nil;
   FFirstDirty:=APage;
   FLastDirty:=APage;
  end
 else
  begin
   {Not First Object}
   Prev.NextLink:=APage;
   APage.PrevLink:=Prev;
   APage.NextLink:=nil;
   FLastDirty:=APage;
  end;
  
 Result:=True;
end;

{==============================================================================}

function TCache.UnlinkDirty(APage:TCachePage):Boolean;
{Unlink APage from PrevLink,NextLink Siblings and Adjust FirstDirty/LastDirty}

{Note: Caller must hold the lock}
var
 Prev,Next:TCachePage;
begin
 {}
 Result:=False;
 
 if FDriver = nil then Exit;
 if APage = nil then Exit;

 if APage.PrevLink <> nil then
  begin
   {Not First Object}
   Prev:=APage.PrevLink;
   if APage.NextLink <> nil then
    begin
     {Not Last Object}
     Next:=APage.NextLink;
     Prev.NextLink:=Next;
     Next.PrevLink:=Prev;
    end
   else
    begin
     {Is Last Object}
     Prev.NextLink:=nil;
     FLastDirty:=Prev;
    end;
  end
 else
  begin
   {Is First Object}
   if APage.NextLink <> nil then
    begin
     {Not Last Object}
     Next:=APage.NextLink;
     Next.PrevLink:=nil;
     FFirstDirty:=Next;
    end
   else
    begin
     {Is Last Object}
     FFirstDirty:=nil;
     FLastDirty:=nil;
    end;
  end;
  
 APage.PrevLink:=nil;
 APage.NextLink:=nil;
 
 Result:=True;
end;

{==============================================================================}

function TCache.PrepareDeviceWrite(ADevice:TDiskDevice;APage:TCachePage;ASector,ACount:LongWord):Boolean;
{Prepare a Cache Page for Write by ensuring that required sectors are cached}
{Passed Sector will be the starting sector for the write to this Page}
{Passed Count will be the write count to this Page (Calculated by caller)}

{Note: Only called internally by DeviceWrite}
{Note: Caller must hold the lock}
var
 Count:LongWord;
 Offset:PtrUInt;
begin
 {}
 Result:=False;
  
 if FDriver = nil then Exit;
 if APage = nil then Exit;
 if ADevice = nil then Exit;
 if ADevice.Controller = nil then Exit;
  
 {$IFDEF CACHE_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TCache.PrepareDeviceWrite: Page.Sector = ' + IntToStr(APage.Sector) + ' Page.Count = ' + IntToStr(APage.Count));
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TCache.PrepareDeviceWrite: Sector = ' + IntToStr(ASector) + ' Count = ' + IntToStr(ACount));
 {$ENDIF}
  
 {Check Count}
 if ACount = APage.Count then
  begin
   {Cache nothing (This case should be checked by caller)}
   Result:=True;
  end
 else
  begin
   {Check Sector}
   if ASector > APage.Sector then
    begin
     {Write begins after start of page}
     {$IFDEF CACHE_DEBUG}
     if FILESYS_LOG_ENABLED then FileSysLogDebug('TCache.PrepareDeviceWrite: Caching Start Sectors (Sector = ' + IntToStr(APage.Sector) + ' Count = ' + IntToStr(ASector - APage.Sector) + ')');
     {$ENDIF}
     
     {Cache starting sectors}
     if not ADevice.Controller.Read(ADevice,APage.Sector,ASector - APage.Sector,APage.Data^) then Exit;
    end;    
    
   {Check Sector + Count} 
   if (ASector + ACount) < (APage.Sector + APage.Count) then
    begin
     {Write ends before end of page}
     {$IFDEF CACHE_DEBUG}
     if FILESYS_LOG_ENABLED then FileSysLogDebug('TCache.PrepareDeviceWrite: Caching End Sectors (Sector = ' + IntToStr(ASector + ACount) + ' Count = ' + IntToStr((APage.Sector + APage.Count) - (ASector + ACount)) + ')');
     {$ENDIF}
     
     {Cache ending sectors}
     Count:=(APage.Sector + APage.Count) - (ASector + ACount);
     Offset:=(ASector + ACount) - APage.Sector;
     
     if not ADevice.Controller.Read(ADevice,ASector + ACount,Count,Pointer(APage.Data + (Offset shl ADevice.SectorShiftCount))^) then Exit;
    end;
   
   Result:=True;
  end;  
end;

{==============================================================================}

function TCache.CalculateDevicePage(ADevice:TDiskDevice;ASector:LongWord;var ACount:LongWord):Boolean;
{Calculate the number of sectors remaining in a page given the starting sector}

{Note: Only called internally by DeviceRead/DeviceWrite/DeviceErase}
{Note: Caller must hold the lock}
var
 SectorCount:Word;
 SectorStart:LongWord;
begin
 {}
 Result:=False;

 if FDriver = nil then Exit;
 if ADevice = nil then Exit;
 
 {$IFDEF CACHE_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TCache.CalculateDevicePage: Sector = ' + IntToStr(ASector) + ' Count = ' + IntToStr(ACount));
 {$ENDIF}
 
 {Check for Sector Size bigger than Page Size}
 if ADevice.SectorSize = 0 then Exit;
 if ADevice.SectorSize > FPageSize then Exit;
 if ASector >= ADevice.SectorCount then Exit;
 
 {Calculate Sector Count and Start Sector}
 SectorCount:=FPageSize div ADevice.SectorSize;
 if SectorCount = 0 then Exit;
 SectorStart:=ASector - (ASector mod SectorCount);
 if (SectorStart + SectorCount) > ADevice.SectorCount then
  begin
   SectorCount:=(ADevice.SectorCount - SectorStart);
  end;
 
 {$IFDEF CACHE_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TCache.CalculateDevicePage: SectorCount = ' + IntToStr(SectorCount) + ' SectorStart = ' + IntToStr(SectorStart));
 {$ENDIF}
 
 {Check Start Sector}
 if ASector > SectorStart then
  begin
   Dec(ACount,ASector - SectorStart);
  end;
  
 {Check Sector Count} 
 if (ASector + ACount) > (SectorStart + SectorCount) then
  begin
   Dec(ACount,(ASector + ACount) - (SectorStart + SectorCount));
  end;
 
 Result:=True;
end;

{==============================================================================}

function TCache.OpenCache(ACacheSize,APageSize:LongWord;ACacheMode:TCacheMode):Boolean;
{Allocate the Memory, Create the Empty Pages and Open Cache}
var
 Count:Integer;
 PageSize:LongWord;
 PageCount:LongWord;
 CacheSize:LongWord;
 PageOffset:LongWord;
 Page:TCachePage;
begin
 {}
 Result:=False;

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if ACacheSize = 0 then Exit;
  if APageSize = 0 then Exit;
  
  {$IFDEF CACHE_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TCache.OpenCache: CacheSize = ' + IntToStr(ACacheSize) + ' PageSize = ' + IntToStr(APageSize));
  {$ENDIF}
  
  {Check for already Open}
  if FCacheSize > 0 then Exit;
  
  {Check for silly Sizes}
  if APageSize > ACacheSize then Exit;
  
  {Normalize the Sizes}
  PageSize:=RoundPageSize(APageSize);
  CacheSize:=RoundCacheSize(ACacheSize,PageSize);
  if PageSize = 0 then Exit;
  if CacheSize = 0 then Exit;
  if PageSize > CacheSize then Exit;
  PageCount:=CacheSize div PageSize;
  
  {$IFDEF CACHE_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TCache.OpenCache: CacheSize = ' + IntToStr(CacheSize) + ' PageSize = ' + IntToStr(PageSize) + ' PageCount = ' + IntToStr(PageCount));
  {$ENDIF}
  
  {Check for Caching Enabled}
  if ACacheMode <> cmNONE then
   begin
    {Allocate the Memory}
    FBuffer:=GetAlignedMem(CacheSize,PageSize);
    if FBuffer = nil then Exit;
    
    {Allocate the Pages}
    PageOffset:=0;
    for Count:=0 to PageCount - 1 do
     begin
      Page:=TCachePage.Create;
      Page.Data:=Pointer(PtrUInt(FBuffer) + PageOffset);
      AddPage(Page);
      Inc(PageOffset,PageSize);
     end;
   end;
  
  {Set the Sizes}
  FPageSize:=PageSize;
  FPageCount:=PageCount;
  FCacheSize:=CacheSize;
  FCacheMode:=ACacheMode;
  FCacheState:=csCLEAN;
  
  {Create Timer}
  FTimer:=TCacheTimer.Create(Self);
  
  {Start Timer}
  FTimer.StartTimer(FILESYS_CACHE_TIMER_INTERVAL);
  
  {Create Thread}
  FThread:=TCacheThread.Create(Self);
  {FThread.FreeOnTerminate:=True;} {Freed by CloseCache}
  
  {Start Thread}
  FThread.Start; 
  
  Result:=True;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function TCache.CloseCache:Boolean;
{Flush all Dirty Pages, Release the Memory and Close the Cache}
var
 NextPage:TCachePage;
 CurrentPage:TCachePage;
begin
 {}
 Result:=False;

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  
  {$IFDEF CACHE_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TCache.CloseCache');
  {$ENDIF}
  
  {Check for already Closed}
  if FCacheSize = 0 then Exit;
  
  {Terminate Thread}
  FThread.Terminate;
  
  {Stop Timer}
  FTimer.StopTimer;

  {Wait For Thread}
  FThread.WaitFor;
  
  {Destroy Timer}
  FTimer.Free;
  FTimer:=nil;
 
  {Destroy Thread}
  FThread.Free;
  FThread:=nil;
  
  {Flush the Pages}
  NextPage:=FFirstDirty;
  while NextPage <> nil do
   begin
    CurrentPage:=NextPage;
    NextPage:=NextPage.NextLink;
    
    FlushPage(CurrentPage);
   end;
  
  {Free the Pages}
  NextPage:=FFirstPage;
  while NextPage <> nil do
   begin
    CurrentPage:=NextPage;
    NextPage:=NextPage.NextPage;
    
    RemovePage(CurrentPage);
   end;
   
  {Free the Memory}
  FreeMem(FBuffer);
  
  {Set the Sizes}
  FPageSize:=0;
  FPageCount:=0;
  FCacheSize:=0;
  FCacheMode:=cmNONE;
  FCacheState:=csCLEAN;
  
  Result:=True;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function TCache.DeviceRead(ADevice:TDiskDevice;ASector,ACount:LongWord;var ABuffer):Boolean;
{Read Data from the Physical Device using either Cached or Direct access}
{Note: AllocDevicePage does all checks for Size, Sector and Count}
var
 Buffer:Pointer;
 Page:TCachePage;
 ReadCount:LongWord;
 OffsetCount:LongWord;
begin
 {}
 Result:=False;
 
 if FDriver = nil then Exit;
 if ADevice = nil then Exit;
 if ADevice.Controller = nil then Exit;
 
 {$IFDEF CACHE_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TCache.DeviceRead: Device = ' + ADevice.Name + ' Sector = ' + IntToStr(ASector) + ' Count = ' + IntToStr(ACount));
 {$ENDIF}
 
 {Get Buffer}
 Buffer:=@ABuffer;
 while ACount > 0 do
  begin
   if not AcquireLock then Exit;
   try
    if (FCacheSize > 0) and (FCacheMode <> cmNONE) then
     begin
      {Read Cached}
      Inc(FReadCached);
      
      {Get Page}
      Page:=GetDevicePage(ADevice,ASector);
      if Page <> nil then
       begin
        {Found in Cache}
        Inc(FHitCount);
        
        {Get Count}
        OffsetCount:=ASector - Page.Sector;           {Offset from Page Sector to Read Sector}
        ReadCount:=Page.Count - OffsetCount;          {Number of Sectors to Read from Page}
        if ReadCount > ACount then ReadCount:=ACount;
        
        {Read from Page to Buffer}
        System.Move(Pointer(PtrUInt(Page.Data) + (OffsetCount shl ADevice.SectorShiftCount))^,Buffer^,ReadCount shl ADevice.SectorShiftCount);
        
        {Update Page}
        Page.PageTime:=GetTickCount64;
        if not UpdateClean(Page) then Exit; {Does nothing if Dirty}
        
        {Update Count}
        Dec(ACount,ReadCount);
        
        {Update Buffer and Sector}
        if ACount > 0 then
         begin
          Inc(Buffer,ReadCount shl ADevice.SectorShiftCount);
          Inc(ASector,ReadCount);
         end; 
        
        Result:=True;
       end
      else
       begin
        {Not Found in Cache}
        Inc(FMissCount);
        
        {Allocate a Page}
        Page:=AllocDevicePage(ADevice,ASector,False);
        if Page <> nil then
         begin
          {Allocate Succeeded}
          Inc(FSuccessCount);
          
          {Get Count}
          OffsetCount:=ASector - Page.Sector;           {Offset from Page Sector to Read Sector}
          ReadCount:=Page.Count - OffsetCount;          {Number of Sectors to Read from Page}
          if ReadCount > ACount then ReadCount:=ACount; 
          
          {Read from Device to Page}
          if not ADevice.Controller.Read(ADevice,Page.Sector,Page.Count,Page.Data^) then Exit;
          
          {Read from Page to Buffer}
          System.Move(Pointer(PtrUInt(Page.Data) + (OffsetCount shl ADevice.SectorShiftCount))^,Buffer^,ReadCount shl ADevice.SectorShiftCount);
          
          {PageTime updated by AllocDevicePage}
         end
        else
         begin
          {Allocate Failed}
          Inc(FFailCount);

          {Get Count}
          ReadCount:=ACount;
          if not CalculateDevicePage(ADevice,ASector,ReadCount) then Exit;
          
          {Direct Read}
          if not ADevice.Controller.Read(ADevice,ASector,ReadCount,Buffer^) then Exit;
         end;
         
        {Update Count}
        Dec(ACount,ReadCount);
        
        {Update Buffer and Sector}
        if ACount > 0 then
         begin
          Inc(Buffer,ReadCount shl ADevice.SectorShiftCount);
          Inc(ASector,ReadCount);
         end; 
        
        Result:=True;
       end;
     end
    else
     begin
      {No Cache}
      Inc(FReadDirect);
      
      {Direct Read}
      Result:=ADevice.Controller.Read(ADevice,ASector,ACount,Buffer^);
      
      {Update Count}
      Dec(ACount,ACount);
     end;
   finally
    ReleaseLock;
   end;
  end; 
end;

{==============================================================================}

function TCache.DeviceWrite(ADevice:TDiskDevice;ASector,ACount:LongWord;const ABuffer):Boolean;
{Write Data to the Physical Device using either Cached or Direct access}
{Note: AllocDevicePage does all checks for Size, Sector and Count}
var
 Buffer:Pointer;
 Page:TCachePage;
 WriteCount:LongWord;
 OffsetCount:LongWord;
begin
 {}
 Result:=False;
 
 if FDriver = nil then Exit;
 if ADevice = nil then Exit;
 if ADevice.Controller = nil then Exit;
 
 {$IFDEF CACHE_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TCache.DeviceWrite: Device = ' + ADevice.Name + ' Sector = ' + IntToStr(ASector) + ' Count = ' + IntToStr(ACount));
 {$ENDIF}
 
 {Get Buffer}
 Buffer:=@ABuffer;
 while ACount > 0 do
  begin
   if not AcquireLock then Exit;
   try
    if (FCacheSize > 0) and (FCacheMode <> cmNONE) then
     begin
      if (FCacheMode = cmREADWRITE) and (ADevice.Removable = False) then
       begin
        {Write Back Cached}
        Inc(FWriteBack);
        
        {Get Page}
        Page:=GetDevicePage(ADevice,ASector);
        if Page <> nil then
         begin
          {Found in Cache}
          Inc(FHitCount);
          
          {Get Count}
          OffsetCount:=ASector - Page.Sector;             {Offset from Page Sector to Write Sector}
          WriteCount:=Page.Count - OffsetCount;           {Number of Sectors to Write to Page}
          if WriteCount > ACount then WriteCount:=ACount;
          
          {Write to Page from Buffer}
          System.Move(Buffer^,Pointer(PtrUInt(Page.Data) + (OffsetCount shl ADevice.SectorShiftCount))^,WriteCount shl ADevice.SectorShiftCount);
          
          {Update Page}
          Page.PageTime:=GetTickCount64;
          if Page.PageState <> psDIRTY then Page.WriteTime:=GetTickCount64;
          if not AddDirty(Page) then Exit;
          
          {Update State}
          FCacheState:=csDIRTY;
          
          {Update Count}
          Dec(ACount,WriteCount);
          
          {Update Buffer and Sector}
          if ACount > 0 then
           begin
            Inc(Buffer,WriteCount shl ADevice.SectorShiftCount);
            Inc(ASector,WriteCount);
           end; 
           
          Result:=True;
         end
        else
         begin
          {Not Found in Cache}
          Inc(FMissCount);
          
          {Allocate a Page}
          Page:=AllocDevicePage(ADevice,ASector,True);
          if Page <> nil then
           begin
            {Allocate Succeeded}
            Inc(FSuccessCount);
            
            {Get Count}
            OffsetCount:=ASector - Page.Sector;             {Offset from Page Sector to Write Sector}
            WriteCount:=Page.Count - OffsetCount;           {Number of Sectors to Write to Page}
            if WriteCount > ACount then WriteCount:=ACount;
            
            {Check for less than Page}
            if WriteCount < Page.Count then
             begin
              {Prepare Page for Write}
              if not PrepareDeviceWrite(ADevice,Page,ASector,WriteCount) then Exit;
             end;
            
            {Write to Page from Buffer}
            System.Move(Buffer^,Pointer(PtrUInt(Page.Data) + (OffsetCount shl ADevice.SectorShiftCount))^,WriteCount shl ADevice.SectorShiftCount);
            
            {PageTime and WriteTime updated by AllocDevicePage}
            
            {Update State}
            FCacheState:=csDIRTY;
           end
          else
           begin
            {Allocate Failed}
            Inc(FFailCount);
    
            {Get Count}
            WriteCount:=ACount;
            if not CalculateDevicePage(ADevice,ASector,WriteCount) then Exit;
    
            {Direct Write}
            if not ADevice.Controller.Write(ADevice,ASector,WriteCount,Buffer^) then Exit;
           end;
           
          {Update Count}
          Dec(ACount,WriteCount);
          
          {Update Buffer and Sector}
          if ACount > 0 then
           begin
            Inc(Buffer,WriteCount shl ADevice.SectorShiftCount);
            Inc(ASector,WriteCount);
           end; 
          
          Result:=True;
         end;
       end
      else
       begin
        {Write Through Cached (ReadOnly Cache or Removable Device)}
        Inc(FWriteThrough);
        
        {Get Page}
        Page:=GetDevicePage(ADevice,ASector);
        if Page <> nil then
         begin
          {Found in Cache}
          Inc(FHitCount);
          
          {Get Count}
          OffsetCount:=ASector - Page.Sector;             {Offset from Page Sector to Write Sector}
          WriteCount:=Page.Count - OffsetCount;           {Number of Sectors to Write to Page}
          if WriteCount > ACount then WriteCount:=ACount;
          
          {Write to Page from Buffer}
          System.Move(Buffer^,Pointer(PtrUInt(Page.Data) + (OffsetCount shl ADevice.SectorShiftCount))^,WriteCount shl ADevice.SectorShiftCount);
          
          {Write from Page to Device}
          if not ADevice.Controller.Write(ADevice,(Page.Sector + OffsetCount),WriteCount,Pointer(PtrUInt(Page.Data) + (OffsetCount shl ADevice.SectorShiftCount))^) then Exit;
          
          {Update Page}
          Page.PageTime:=GetTickCount64;
          if not UpdateClean(Page) then Exit; {Read Only Page is always Clean}
          
          {Update Count}
          Dec(ACount,WriteCount);
          
          {Update Buffer and Sector}
          if ACount > 0 then
           begin
            Inc(Buffer,WriteCount shl ADevice.SectorShiftCount);
            Inc(ASector,WriteCount);
           end; 
          
          Result:=True;
         end
        else
         begin
          {Not Found in Cache}
          Inc(FMissCount);
          
          {Allocate a Page}
          Page:=AllocDevicePage(ADevice,ASector,False); {Allocate Clean}
          if Page <> nil then
           begin
            {Allocate Succeeded}
            Inc(FSuccessCount);
            
            {Get Count}
            OffsetCount:=ASector - Page.Sector;             {Offset from Page Sector to Write Sector}
            WriteCount:=Page.Count - OffsetCount;           {Number of Sectors to Write to Page}
            if WriteCount > ACount then WriteCount:=ACount;
            
            {Check for less than Page}
            if WriteCount < Page.Count then
             begin
              {Prepare Page for Write}
              if not PrepareDeviceWrite(ADevice,Page,ASector,WriteCount) then Exit;
             end;
            
            {Write to Page from Buffer}
            System.Move(Buffer^,Pointer(PtrUInt(Page.Data) + (OffsetCount shl ADevice.SectorShiftCount))^,WriteCount shl ADevice.SectorShiftCount);
            
            {Write from Page to Device}
            if not ADevice.Controller.Write(ADevice,(Page.Sector + OffsetCount),WriteCount,Pointer(PtrUInt(Page.Data) + (OffsetCount shl ADevice.SectorShiftCount))^) then Exit;
  
            {PageTime updated by AllocDevicePage}
           end
          else
           begin
            {Allocate Failed}
            Inc(FFailCount);
        
            {Get Count}
            WriteCount:=ACount;
            if not CalculateDevicePage(ADevice,ASector,WriteCount) then Exit;
        
            {Direct Write}
            if not ADevice.Controller.Write(ADevice,ASector,WriteCount,Buffer^) then Exit;
           end;
           
          {Update Count}
          Dec(ACount,WriteCount);
          
          {Update Buffer and Sector}
          if ACount > 0 then
           begin
            Inc(Buffer,WriteCount shl ADevice.SectorShiftCount);
            Inc(ASector,WriteCount);
           end; 
          
          Result:=True;
         end;
       end;
     end
    else
     begin
      {No Cache}
      Inc(FWriteDirect);
      
      {Direct Write}
      Result:=ADevice.Controller.Write(ADevice,ASector,ACount,Buffer^);
      
      {Update Count}
      Dec(ACount,ACount);
     end;
   finally
    ReleaseLock;
   end;
  end; 
end;

{==============================================================================}

function TCache.DeviceErase(ADevice:TDiskDevice;ASector,ACount:LongWord):Boolean;
{Erase Data from the Physical Device and update cached pages accordingly}
var
 Page:TCachePage;
 EraseCount:LongWord;
 OffsetCount:LongWord;
begin
 {}
 Result:=False;
 
 if FDriver = nil then Exit;
 if ADevice = nil then Exit;
 if ADevice.Controller = nil then Exit;
 
 {$IFDEF CACHE_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TCache.DeviceErase: Device = ' + ADevice.Name + ' Sector = ' + IntToStr(ASector) + ' Count = ' + IntToStr(ACount));
 {$ENDIF}
 
 {Check Count}
 while ACount > 0 do
  begin
   if not AcquireLock then Exit;
   try
    if (FCacheSize > 0) and (FCacheMode <> cmNONE) then
     begin
      {Get Page}
      Page:=GetDevicePage(ADevice,ASector);
      if Page <> nil then
       begin
        {Found in Cache}
        {Get Count}
        OffsetCount:=ASector - Page.Sector;             {Offset from Page Sector to Erase Sector}
        EraseCount:=Page.Count - OffsetCount;           {Number of Sectors to Erase from Page}
        if EraseCount > ACount then EraseCount:=ACount;
 
        {Erase from Device}
        if not ADevice.Controller.Erase(ADevice,ASector,EraseCount) then Exit;
        
        {Check for Dirty}
        if Page.PageState = psDIRTY then
         begin
          {Flush Page}
          if not FlushPage(Page) then Exit;
         end;
         
        {Discard Page}
        if not DiscardPage(Page) then Exit;
        
        {Update Count}
        Dec(ACount,EraseCount);
    
        {Update Sector}
        if ACount > 0 then
         begin
          Inc(ASector,EraseCount);
         end; 
    
        Result:=True;
       end
      else
       begin
        {Not Found in Cache}
        {Get Count}
        EraseCount:=ACount;
        if not CalculateDevicePage(ADevice,ASector,EraseCount) then Exit;
        
        {Erase from Device}
        if not ADevice.Controller.Erase(ADevice,ASector,EraseCount) then Exit;
        
        {Update Count}
        Dec(ACount,EraseCount);
    
        {Update Sector}
        if ACount > 0 then
         begin
          Inc(ASector,EraseCount);
         end; 
    
        Result:=True;
       end;
     end
    else
     begin
      {Not Cached}
      {Direct Erase}
      Result:=ADevice.Controller.Erase(ADevice,ASector,ACount);
      
      {Update Count}
      Dec(ACount,ACount);
     end;
   finally
    ReleaseLock;
   end;
  end; 
end;

{==============================================================================}

function TCache.GetDevicePage(ADevice:TDiskDevice;ASector:LongWord):TCachePage;
{Get the Clean or Dirty Page that contains this Sector on this Device}
var
 Page:TCachePage;
begin
 {}
 Result:=nil;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if ADevice = nil then Exit;
  
  {Check Clean Pages}
  {Page:=FFirstClean;} {Search backwards}
  Page:=FLastClean;
  while Page <> nil do
   begin
    {Check Page Type and Device}
    if (Page.PageType = ptDEVICE) and (Page.Device = ADevice) then
     begin
      {Check Page Sector and Count (Also checks Count 0)}
      if (Page.Sector <= ASector) and ((Page.Sector + Page.Count) > ASector) then
       begin
        Result:=Page;
        Exit;
       end;
     end;
     
    {Page:=Page.NextLink;}
    Page:=Page.PrevLink; {Search backwards}
   end;
  
  {Check Dirty Pages}
  {Page:=FFirstDirty;} {Search backwards}
  Page:=FLastDirty;
  while Page <> nil do
   begin
    {Check Page Type and Device}
    if (Page.PageType = ptDEVICE) and (Page.Device = ADevice) then
     begin
      {Check Page Sector and Count (Also checks Count 0)}
      if (Page.Sector <= ASector) and ((Page.Sector + Page.Count) > ASector) then
       begin
        Result:=Page;
        Exit;
       end;
     end;
     
    {Page:=Page.NextLink;} {Search backwards}
    Page:=Page.PrevLink;
   end;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function TCache.GetEmptyPage:TCachePage;
{Get the First Empty Page, Discard First Clean Page if none Empty}
begin
 {}
 Result:=nil;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  
  {Get First Empty Page}
  Result:=FFirstEmpty;
  if Result <> nil then Exit;
  
  {If no Empty then Discard Oldest}
  if not DiscardCache(True,False) then Exit;
  
  {Get First Empty Page}
  Result:=FFirstEmpty;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function TCache.AllocDevicePage(ADevice:TDiskDevice;ASector:LongWord;AWrite:Boolean):TCachePage;
{Allocate an Empty Page to the Device and mark as Clean or Dirty}
var
 Page:TCachePage;
 SectorCount:Word;
 SectorStart:LongWord;
begin
 {}
 Result:=nil;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if ADevice = nil then Exit;
  
  {Check for Sector Size bigger than Page Size}
  if ADevice.SectorSize = 0 then Exit;
  if ADevice.SectorSize > FPageSize then Exit;
  if ASector >= ADevice.SectorCount then Exit;
  
  {Calculate Sector Count and Start Sector}
  SectorCount:=FPageSize div ADevice.SectorSize;
  if SectorCount = 0 then Exit;
  SectorStart:=ASector - (ASector mod SectorCount);
  if (SectorStart + SectorCount) > ADevice.SectorCount then
   begin
    SectorCount:=(ADevice.SectorCount - SectorStart);
   end;
  
  {Get Empty Page}
  Page:=GetEmptyPage;
  if Page <> nil then
   begin
    if AWrite then
     begin
      if AddDirty(Page) then
       begin
        Page.Device:=ADevice;
        Page.Sector:=SectorStart;
        Page.Count:=SectorCount;
        Page.PageTime:=GetTickCount64;
        Page.WriteTime:=GetTickCount64;
        Page.PageType:=ptDEVICE;
        
        Result:=Page;
       end;
     end
    else
     begin
      if AddClean(Page) then
       begin
        Page.Device:=ADevice;
        Page.Sector:=SectorStart;
        Page.Count:=SectorCount;
        Page.PageTime:=GetTickCount64;
        Page.PageType:=ptDEVICE;
        
        Result:=Page;
       end;
     end;
   end
  else
   begin
    {If no Empty Page then Flush}
    if FlushCache(True,False) then
     begin
      {Get Empty Page}
      Page:=GetEmptyPage;
      if Page <> nil then
       begin
        if AWrite then
         begin
          if AddDirty(Page) then
           begin
            Page.Device:=ADevice;
            Page.Sector:=SectorStart;
            Page.Count:=SectorCount;
            Page.PageTime:=GetTickCount64;
            Page.WriteTime:=GetTickCount64;
            Page.PageType:=ptDEVICE;
            
            Result:=Page;
           end;
         end
        else
         begin
          if AddClean(Page) then
           begin
            Page.Device:=ADevice;
            Page.Sector:=SectorStart;
            Page.Count:=SectorCount;
            Page.PageTime:=GetTickCount64;
            Page.PageType:=ptDEVICE;
            
            Result:=Page;
           end;
         end;
       end;
     end;
   end;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function TCache.DiscardPage(APage:TCachePage):Boolean;
{Return a Clean Page to Empty}
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if APage = nil then Exit;
  
  {Check for Clean}
  if APage.PageState = psCLEAN then
   begin
    if not AddEmpty(APage) then Exit;
    
    Inc(FDiscardCount);
    
    APage.Device:=nil;
    APage.Sector:=0;
    APage.Count:=0;
    APage.PageTime:=0;
    APage.WriteTime:=0;
    APage.PageType:=ptNONE;
    
    Result:=True;
   end
  else
   begin
    {Return a Non Clean Page to Unknown}
    if not AddUnknown(APage) then Exit;
    
    Inc(FUnknownCount);
    
    Result:=True;
   end;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function TCache.DiscardCache(AFirst,AAll:Boolean):Boolean;
{Find any Clean Pages older than CacheTimeout and Discard them}
var
 CurrentTime:Int64;
 NextPage:TCachePage;
 CurrentPage:TCachePage;
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  
  {Get Counter}
  CurrentTime:=GetTickCount64;
  
  {Check Clean Pages}
  NextPage:=FFirstClean;
  while NextPage <> nil do
   begin
    CurrentPage:=NextPage;
    NextPage:=NextPage.NextLink;
    if (AFirst) or (AAll) or ((CurrentPage.PageTime + (FCacheTimeout * 60)) < CurrentTime) then
     begin
      DiscardPage(CurrentPage);
      if AFirst then Break; {Discard only the First Page}
     end
    else
     begin
      Break; {No more pages old enough to Discard}
     end;
   end;
   
  Result:=True;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function TCache.ReleaseDevicePages(ADevice:TDiskDevice):Boolean;
{Return all Clean or Dirty Pages on the Device to Empty}
var
 NextPage:TCachePage;
 CurrentPage:TCachePage;
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if ADevice = nil then Exit;
  
  {Flush Dirty Pages}
  NextPage:=FFirstDirty;
  while NextPage <> nil do
   begin
    CurrentPage:=NextPage;
    NextPage:=NextPage.NextLink;
    
    if (CurrentPage.PageType = ptDEVICE) and (CurrentPage.Device = ADevice) then
     begin
      FlushPage(CurrentPage);
     end;
   end;
  
  {Discard Clean Pages}
  NextPage:=FFirstClean;
  while NextPage <> nil do
   begin
    CurrentPage:=NextPage;
    NextPage:=NextPage.NextLink;
    
    if (CurrentPage.PageType = ptDEVICE) and (CurrentPage.Device = ADevice) then
     begin
      DiscardPage(CurrentPage);
     end;
   end;
   
  Result:=True;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function TCache.FlushPage(APage:TCachePage):Boolean;
{Return a Dirty Page to Clean}
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if APage = nil then Exit;
  
  {Unschedule Page}
  UnschedulePage(APage);
  
  {Check for Dirty}
  if APage.PageState = psDIRTY then
   begin
    {Check Sector Count}
    if APage.Count > 0 then
     begin
      case APage.PageType of
       ptNONE:begin
         {Return a Page with no Type to Clean}
         if not AddClean(APage) then Exit;
         Inc(FFlushCount);
         APage.WriteTime:=0;
         
         Result:=True;
        end;
       ptDEVICE:begin
         {Write Page to Device}
         if APage.Device = nil then Exit;
         if APage.Device.Controller = nil then Exit;
         if not APage.Device.Controller.Write(APage.Device,APage.Sector,APage.Count,APage.Data^) then Exit;
         
         {Return to Clean}
         if not AddClean(APage) then Exit;
         Inc(FFlushCount);
         APage.WriteTime:=0;
         
         Result:=True;
        end;
      end;
     end
    else
     begin
      {Return a 0 Sector Page to Clean}
      if not AddClean(APage) then Exit;
      Inc(FFlushCount);
      APage.WriteTime:=0;
      
      Result:=True;
     end;
   end
  else
   begin
    {Return a Non Dirty Page to Unknown}
    if not AddUnknown(APage) then Exit;
    Inc(FUnknownCount);
    APage.WriteTime:=0;
    
    Result:=True;
   end;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function TCache.FlushPageEx(APage:TCachePage):Boolean;
{Return a Dirty Page to Clean if it is older than CacheTimeout}

{Note: Only called by CacheThread with page scheduled from CacheTimer}
var
 Page:TCachePage;
begin
 {}
 Result:=False;

 {$IFDEF CACHE_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TCache.FlushPageEx (Page=' + PtrToHex(APage) + ' FirstDirty=' + PtrToHex(FFirstDirty) + ')');
 {$ENDIF}
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if APage = nil then Exit;
 
  {Check Page}
  Page:=FFirstDirty;
  if APage <> Page then
   begin
    {Find Page}
    while Page <> nil do
     begin
      if Page = APage then Break;
      {Get Next}
      Page:=Page.NextLink;
     end;
   end;  
  
  {Check Page}
  if (APage = Page) and ((APage.WriteTime + FCacheTimeout) <= GetTickCount64) then
   begin
    {Check for Dirty}
    if APage.PageState = psDIRTY then
     begin
      {Check Sector Count}
      if APage.Count > 0 then
       begin
        case APage.PageType of
         ptNONE:begin
           {Return a Page with no Type to Clean}
           if not AddClean(APage) then Exit;
           Inc(FFlushCount);
           APage.WriteTime:=0;
           
           Result:=True;
          end;
         ptDEVICE:begin
           {Write Page to Device}
           if APage.Device = nil then Exit;
           if APage.Device.Controller = nil then Exit;
           if not APage.Device.Controller.Write(APage.Device,APage.Sector,APage.Count,APage.Data^) then Exit;
           
           {Return to Clean}
           if not AddClean(APage) then Exit;
           Inc(FFlushCount);
           APage.WriteTime:=0;
           
           Result:=True;
          end;
        end;
       end
      else
       begin
        {Return a 0 Sector Page to Clean}
        if not AddClean(APage) then Exit;
        Inc(FFlushCount);
        APage.WriteTime:=0;
        
        Result:=True;
       end;
     end
    else
     begin
      {Return a Non Dirty Page to Unknown}
      if not AddUnknown(APage) then Exit;
      Inc(FUnknownCount);
      APage.WriteTime:=0;
      
      Result:=True;
     end;
    
    {Update Cache State}
    if FFirstDirty = nil then FCacheState:=csCLEAN;
  {$IFDEF CACHE_DEBUG}    
   end
  else
   begin
    if APage <> Page then
     begin
      if FILESYS_LOG_ENABLED then FileSysLogDebug('TCache.FlushPageEx - Non Dirty Page (Page=' + PtrToHex(APage) + ' Dirty=' + PtrToHex(Page) + ')');
     end
    else
     begin
      if FILESYS_LOG_ENABLED then FileSysLogDebug('TCache.FlushPageEx - Not Ready Page (Page=' + PtrToHex(APage) + ' WriteTime=' + IntToStr(APage.WriteTime) + ' TickCount=' + IntToStr(GetTickCount64) + ')'); 
     end;
  {$ENDIF}   
   end;   
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function TCache.FlushCache(AFirst,AAll:Boolean):Boolean;
{Find any Dirty Pages older than CacheTimeout and Flush them}
var
 CurrentTime:Int64;
 NextPage:TCachePage;
 CurrentPage:TCachePage;
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  
  {Check Cache State}
  if FCacheState = csDIRTY then
   begin
    {Get Counter}
    CurrentTime:=GetTickCount64;
    
    {Check Dirty Pages}
    NextPage:=FFirstDirty;
    while NextPage <> nil do
     begin
      CurrentPage:=NextPage;
      NextPage:=NextPage.NextLink;
      
      if (AFirst) or (AAll) or ((CurrentPage.WriteTime + FCacheTimeout) < CurrentTime) then
       begin
        FlushPage(CurrentPage);
        
        if AFirst then Break; {Flush only the First Page}
       end
      else
       begin
        Break; {No more pages old enough to Flush}
       end;
     end;
     
    {Update Cache State}
    if FFirstDirty = nil then FCacheState:=csCLEAN;
   end;
   
  Result:=True;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}
   
function TCache.CheckTimer:Boolean;
begin
 {}
 Result:=False;
 
 {Check Timer}
 if FTimer = nil then Exit;

 {Check Timer}
 Result:=FTimer.CheckTimer;
end;

{==============================================================================}

function TCache.ProcessTimer:Boolean;
begin
 {}
 Result:=False;
 
 {Check Timer}
 if FTimer = nil then Exit;

 {Process Timer}
 Result:=FTimer.ProcessTimer;
end;

{==============================================================================}
   
function TCache.SchedulePage(APage:TCachePage;ATimeout:LongWord):Boolean;
begin
 {}
 Result:=False;
 
 {Check Timer}
 if FTimer = nil then Exit;
 
 {Check Page}
 {if APage = nil then Exit;} {Do not check}
 
 {Schedule Page}
 Result:=FTimer.SchedulePage(APage,ATimeout);
end;

{==============================================================================}

function TCache.UnschedulePage(APage:TCachePage):Boolean; 
begin
 {}
 Result:=False;
 
 {Check Timer}
 if FTimer = nil then Exit;
 
 {Check Page}
 {if APage = nil then Exit;} {Do not check}
 
 {Unschedule Page}
 Result:=FTimer.UnschedulePage(APage);
end;

{==============================================================================}
{==============================================================================}
{TCacheEx}
constructor TCacheEx.Create(ADriver:TFileSysDriver);
begin
 {}
 inherited Create(ADriver);
 FLastUsed:=nil;
end;

{==============================================================================}

destructor TCacheEx.Destroy;
begin
 {}
 FLastUsed:=nil;
 inherited Destroy;
end;

{==============================================================================}

function TCacheEx.GetDevicePage(ADevice:TDiskDevice;ASector:LongWord):TCachePage;
{Get the Clean or Dirty Page that contains this Sector on this Device}
var
 Page:TCachePage;
begin
 {}
 Result:=nil;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if ADevice = nil then Exit;
  
  {Check Last Page}
  Page:=FLastUsed;
  if Page <> nil then
   begin
    {Check Page Type and Device}
    if (Page.PageType = ptDEVICE) and (Page.Device = ADevice) then
     begin
      {Check Page State}
      if (Page.PageState = psCLEAN) or (Page.PageState = psDIRTY) then
       begin
        {Check Page Sector and Count (Also checks Count 0)}
        if (Page.Sector <= ASector) and ((Page.Sector + Page.Count) > ASector) then
         begin
          Result:=Page;
          Exit;
         end;
       end;
     end;
   end;
   
  {Call Inherited}
  Result:=inherited GetDevicePage(ADevice,ASector);
  
  {Update Last}
  FLastUsed:=Result;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function TCacheEx.AllocDevicePage(ADevice:TDiskDevice;ASector:LongWord;AWrite:Boolean):TCachePage;
begin
 {}
 Result:=nil;
 
 if not AcquireLock then Exit;
 try
  {Call Inherited}
  Result:=inherited AllocDevicePage(ADevice,ASector,AWrite);
  
  {Update Last}
  FLastUsed:=Result;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}
{==============================================================================}
{THashCache}
constructor THashCache.Create(ADriver:TFileSysDriver);
begin
 {}
 inherited Create;
 FDriver:=ADriver;

 FLock:=CriticalSectionCreate;

 FKeyBits:=0;
 FKeyMask:=0;
 FKeyBuckets:=nil;

 FBuffer:=nil;
 FPageSize:=0;
 FPageCount:=0;
 FCacheSize:=0;
 FCacheKeys:=0;
 FCacheMode:=cmNONE;
 FCacheState:=csCLEAN;
 FFlushTimeout:=FILESYS_CACHE_FLUSH_TIMEOUT;  
 FDiscardTimeout:=FILESYS_CACHE_DISCARD_TIMEOUT; 

 FReadCached:=0;
 FReadDirect:=0;

 FWriteBack:=0;
 FWriteThrough:=0;
 FWriteDirect:=0;

 FHitCount:=0;
 FMissCount:=0;

 FFailCount:=0;
 FSuccessCount:=0;

 FFlushCount:=0;
 FDiscardCount:=0;
 FUnknownCount:=0;

 FFirstPage:=nil;
 FLastPage:=nil;
 FFirstEmpty:=nil;
 FLastEmpty:=nil;
 FFirstClean:=nil;
 FLastClean:=nil;
 FFirstDirty:=nil;
 FLastDirty:=nil;

 FTimer:=nil;
 FThread:=nil;
end;

{==============================================================================}

destructor THashCache.Destroy;
begin
 {}
 AcquireLock;
 try
  FThread:=nil;
  FTimer:=nil;

  FFirstDirty:=nil;
  FLastDirty:=nil;
  FFirstClean:=nil;
  FLastClean:=nil;
  FFirstEmpty:=nil;
  FLastEmpty:=nil;
  FFirstPage:=nil;
  FLastPage:=nil;

  FBuffer:=nil;
  
  FKeyBuckets:=nil;
  
  FDriver:=nil;
  inherited Destroy;
 finally
  {ReleaseLock;} {Can destroy Critical Section while holding lock} 
  CriticalSectionDestroy(FLock);
 end;
end;

{==============================================================================}

function THashCache.AcquireLock:Boolean;
begin
 {}
 Result:=(CriticalSectionLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function THashCache.ReleaseLock:Boolean;
begin
 {}
 Result:=(CriticalSectionUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function THashCache.AddPage(APage:TCachePage):Boolean;
{Add a new page to the Page list and the Empty list}
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if APage = nil then Exit;

  if not LinkPage(APage) then Exit;
  APage.PageState:=psUNKNOWN;
  
  if not LinkEmpty(APage) then Exit;
  APage.PageState:=psEMPTY;
  
  Result:=True;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function THashCache.RemovePage(APage:TCachePage):Boolean;
{Remove a Page from the Page list and any other lists then Free the Page}
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if APage = nil then Exit;

  case APage.PageState of
   psUNKNOWN:begin
     APage.PageState:=psUNKNOWN;
     
     if not UnlinkPage(APage) then Exit;
     APage.Free;
     
     Result:=True;
    end;
   psEMPTY:begin
     if not UnlinkEmpty(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     if not UnlinkPage(APage) then Exit;
     APage.Free;
     
     Result:=True;
    end;
   psCLEAN:begin
     if not KeyUnlink(THashCachePage(APage)) then Exit;
     
     if not UnlinkClean(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     if not UnlinkPage(APage) then Exit;
     APage.Free;
     
     Result:=True;
    end;
   psDIRTY:begin
     if not KeyUnlink(THashCachePage(APage)) then Exit;
     
     if not UnlinkDirty(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     if not UnlinkPage(APage) then Exit;
     APage.Free;
     
     Result:=True;
    end;
  end;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function THashCache.AddEmpty(APage:TCachePage):Boolean;
{Add a Page to the Empty list, removing from other lists if needed}
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if APage = nil then Exit;

  case APage.PageState of
   psUNKNOWN:begin
     if not LinkEmpty(APage) then Exit;
     APage.PageState:=psEMPTY;
     
     Result:=True;
    end;
   psEMPTY:begin
     Result:=True;
    end;
   psCLEAN:begin
     if not KeyUnlink(THashCachePage(APage)) then Exit;
     
     if not UnlinkClean(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     if not LinkEmpty(APage) then Exit;
     APage.PageState:=psEMPTY;
     
     Result:=True;
    end;
   psDIRTY:begin
     if not KeyUnlink(THashCachePage(APage)) then Exit;
     
     if not UnlinkDirty(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     if not LinkEmpty(APage) then Exit;
     APage.PageState:=psEMPTY;
     
     Result:=True;
    end;
  end;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function THashCache.AddClean(APage:TCachePage):Boolean;
{Add a Page to the Clean list, removing from other lists if needed}
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if APage = nil then Exit;

  case APage.PageState of
   psUNKNOWN:begin
     if not LinkClean(APage) then Exit;
     APage.PageState:=psCLEAN;
     
     if not KeyLink(THashCachePage(APage)) then Exit;
     
     Result:=True;
    end;
   psEMPTY:begin
     if not UnlinkEmpty(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     if not LinkClean(APage) then Exit;
     APage.PageState:=psCLEAN;
     
     if not KeyLink(THashCachePage(APage)) then Exit;
     
     Result:=True;
    end;
   psCLEAN:begin
     Result:=True;
    end;
   psDIRTY:begin
     if not UnlinkDirty(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     if not LinkClean(APage) then Exit;
     APage.PageState:=psCLEAN;
     
     {No need to KeyLink}
     
     Result:=True;
    end;
  end;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function THashCache.AddDirty(APage:TCachePage):Boolean;
{Add a Page to the Dirty list, removing from other lists if needed}
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if APage = nil then Exit;

  case APage.PageState of
   psUNKNOWN:begin
     if not LinkDirty(APage) then Exit;
     APage.PageState:=psDIRTY;
     
     if not KeyLink(THashCachePage(APage)) then Exit;
     
     Result:=SchedulePage(APage,FFlushTimeout);
    end;
   psEMPTY:begin
     if not UnlinkEmpty(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     if not LinkDirty(APage) then Exit;
     APage.PageState:=psDIRTY;
     
     if not KeyLink(THashCachePage(APage)) then Exit;
     
     Result:=SchedulePage(APage,FFlushTimeout);
    end;
   psCLEAN:begin
     if not UnlinkClean(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     if not LinkDirty(APage) then Exit;
     APage.PageState:=psDIRTY;
     
     {No need to KeyLink}
     
     Result:=SchedulePage(APage,FFlushTimeout);
    end;
   psDIRTY:begin
     Result:=True;
    end;
  end;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function THashCache.AddUnknown(APage:TCachePage):Boolean;
{Make a Page Unknown by removing from any other lists if needed}
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  
  if FDriver = nil then Exit;
  if APage = nil then Exit;

  case APage.PageState of
   psUNKNOWN:begin
     Result:=True;
    end;
   psEMPTY:begin
     if not UnlinkEmpty(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     Result:=True;
    end;
   psCLEAN:begin
     if not KeyUnlink(THashCachePage(APage)) then Exit;
     
     if not UnlinkClean(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     Result:=True;
    end;
   psDIRTY:begin
     if not KeyUnlink(THashCachePage(APage)) then Exit;
     
     if not UnlinkDirty(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     Result:=True;
    end;
  end;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function THashCache.UpdateClean(APage:TCachePage):Boolean;
{Move a Page to the end of the Clean list}
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if APage = nil then Exit;

  case APage.PageState of
   psCLEAN:begin
     if not UnlinkClean(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     if not LinkClean(APage) then Exit;
     APage.PageState:=psCLEAN;
     
     {No need to KeyLink}
     
     Result:=True;
    end;
   psDIRTY:begin
     Result:=True;
    end;
  end;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function THashCache.UpdateDirty(APage:TCachePage):Boolean;
{Move a Page to the end of the Dirty list} {Not Used}
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if APage = nil then Exit;

  case APage.PageState of
   psCLEAN:begin
     Result:=True;
    end;
   psDIRTY:begin
     if not UnlinkDirty(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     if not LinkDirty(APage) then Exit;
     APage.PageState:=psDIRTY;
     
     {No need to KeyLink}
     
     Result:=True;
    end;
  end;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function THashCache.RoundPageSize(APageSize:LongWord):LongWord;
{Round Page Size to the power of 2 of Sector Size}

{Note: Caller must hold the lock}
begin
 {}
 Result:=MIN_SECTOR_SIZE;

 {Round up to next power of 2 of Minimum Sector Size}
 while Result < APageSize do
  begin
   Result:=Result shl 1;
  end;
end;

{==============================================================================}

function THashCache.RoundCacheSize(ACacheSize,APageSize:LongWord):LongWord;
{Round Cache Size to the next multiple of Page Size}

{Note: Caller must hold the lock}
begin
 {}
 Result:=0;
 
 if APageSize = 0 then Exit;
  
 {Round up to next multiple of Page Size}
 Result:=APageSize;
 while Result < ACacheSize do
  begin
   Inc(Result,APageSize);
  end;
end;

{==============================================================================}

function THashCache.AdjustCacheKeys(ACacheKeys:LongWord):LongWord;
{Adjust Cache Keys to be within safe limits}

{Note: Caller must hold the lock}
begin
 {}
 Result:=0;
 
 if ACacheKeys = 0 then Exit;
  
 Result:=ACacheKeys;
 if Result < keyHashMinBits then Result:=keyHashMinBits;
 if Result > keyHashMaxBits then Result:=keyHashMaxBits;
end;

{==============================================================================}

function THashCache.CalculatePageCount(ADevice:TDiskDevice):Word;
{Calculate the power of 2 multiple of sector size which will fit within the page}

{Note: Caller must hold the lock}
var
 Value:LongWord;
begin
 {}
 Result:=0;
 
 if FPageSize = 0 then Exit;
 if ADevice = nil then Exit;
 if ADevice.SectorSize = 0 then Exit;
  
 Result:=1;
 Value:=ADevice.SectorSize;
 while Value < FPageSize do
  begin
   Result:=Result shl 1;
   Value:=Value shl 1;
  end;
 if Value > FPageSize then
  begin
   Result:=Result shr 1;
  end;
end;

{==============================================================================}

function THashCache.CalculatePageShift(ADevice:TDiskDevice):Word;
{Calculate the shift count for Page to Key conversion}

{Note: Caller must hold the lock}
begin
 {}
 Result:=0;
 
 if ADevice = nil then Exit;
 if ADevice.PageCount = 0 then Exit;
  
 while (ADevice.PageCount shr Result) > 1 do
  begin
   Inc(Result);
  end;
end;

{==============================================================================}

function THashCache.CalculatePageMask(ADevice:TDiskDevice):LongWord;
{Calculate the mask for Sector to Page conversion}

{Note: Caller must hold the lock}
begin
 {}
 Result:=$FFFFFFFF;
 
 if ADevice = nil then Exit;
 if ADevice.PageCount = 0 then Exit;
  
 Result:=((Result shr ADevice.PageShift) shl ADevice.PageShift);
end;

{==============================================================================}

function THashCache.KeyLink(APage:THashCachePage):Boolean;
{Link APage to KeyPrev,KeyNext siblings and Adjust First}

{Note: Caller must hold the lock}
var
 Offset:LongWord;
 FirstKey:THashCachePage;
begin
 {}
 Result:=False;
 
 if APage = nil then Exit;
 
 {Get Offset}
 Offset:=(APage.KeyHash and FKeyMask) shl 2;
 
 {Get First Key}
 FirstKey:=THashCachePage(Pointer(PtrUInt(FKeyBuckets) + Offset)^);
 if FirstKey = nil then
  begin
   {Is First Object}
   APage.KeyPrev:=nil;
   APage.KeyNext:=nil;
   THashCachePage(Pointer(PtrUInt(FKeyBuckets) + Offset)^):=APage;
  end
 else
  begin
   {Not First Object}
   FirstKey.KeyPrev:=APage;
   APage.KeyPrev:=nil;
   APage.KeyNext:=FirstKey;
   THashCachePage(Pointer(PtrUInt(FKeyBuckets) + Offset)^):=APage;
  end;
  
 Result:=True;
end;

{==============================================================================}

function THashCache.KeyUnlink(APage:THashCachePage):Boolean;
{Unlink APage from KeyPrev,KeyNext siblings and Adjust First}

{Note: Caller must hold the lock}
var
 Offset:LongWord;
 PrevKey,NextKey:THashCachePage;
begin
 {}
 Result:=False;
 
 if APage = nil then Exit;
 
 if APage.KeyPrev <> nil then
  begin
   {Not First Object}
   PrevKey:=APage.KeyPrev;
   if APage.KeyNext <> nil then
    begin
     {Not Last Object}
     NextKey:=APage.KeyNext;
     PrevKey.KeyNext:=NextKey;
     NextKey.KeyPrev:=PrevKey;
    end
   else
    begin
     {Is Last Object}
     PrevKey.KeyNext:=nil;
    end;
  end
 else
  begin
   {Get Offset}
   Offset:=(APage.KeyHash and FKeyMask) shl 2;
   
   {Is First Object}
   if APage.KeyNext <> nil then
    begin
     {Not Last Object}
     NextKey:=APage.KeyNext;
     NextKey.KeyPrev:=nil;
     THashCachePage(Pointer(PtrUInt(FKeyBuckets) + Offset)^):=NextKey;
    end
   else
    begin
     {Is Last Object}
     THashCachePage(Pointer(PtrUInt(FKeyBuckets) + Offset)^):=nil;
    end;
  end;
  
 APage.KeyPrev:=nil;
 APage.KeyNext:=nil;
 
 Result:=True;
end;

{==============================================================================}

function THashCache.KeyFirst(AKeyHash:LongWord):THashCachePage;
{Note: Caller must hold the lock}
var
 Offset:LongWord;
begin
 {}
 Result:=nil;
 
 if FKeyBuckets = nil then Exit;
 
 {Get Offset}
 Offset:=(AKeyHash and FKeyMask) shl 2;
 
 {Get First Key}
 Result:=THashCachePage(Pointer(PtrUInt(FKeyBuckets) + Offset)^);
end;

{==============================================================================}

function THashCache.LinkPage(APage:TCachePage):Boolean;
{Link APage to PrevPage,NextPage siblings and Adjust FirstPage/LastPage}

{Note: Caller must hold the lock}
var
 Prev:TCachePage;
begin
 {}
 Result:=False;
 
 if FDriver = nil then Exit;
 if APage = nil then Exit;

 Prev:=FLastPage;
 if Prev = nil then
  begin
   {Is First Object}
   APage.PrevPage:=nil;
   APage.NextPage:=nil;
   FFirstPage:=APage;
   FLastPage:=APage;
  end
 else
  begin
   {Not First Object}
   Prev.NextPage:=APage;
   APage.PrevPage:=Prev;
   APage.NextPage:=nil;
   FLastPage:=APage;
  end;
  
 Result:=True;
end;

{==============================================================================}

function THashCache.UnlinkPage(APage:TCachePage):Boolean;
{Unlink APage from PrevPage,NextPage Siblings and Adjust FirstPage/LastPage}

{Note: Caller must hold the lock}
var
 Prev,Next:TCachePage;
begin
 {}
 Result:=False;
 
 if FDriver = nil then Exit;
 if APage = nil then Exit;

 if APage.PrevPage <> nil then
  begin
   {Not First Object}
   Prev:=APage.PrevPage;
   if APage.NextPage <> nil then
    begin
     {Not Last Object}
     Next:=APage.NextPage;
     Prev.NextPage:=Next;
     Next.PrevPage:=Prev;
    end
   else
    begin
     {Is Last Object}
     Prev.NextPage:=nil;
     FLastPage:=Prev;
    end;
  end
 else
  begin
   {Is First Object}
   if APage.NextPage <> nil then
    begin
     {Not Last Object}
     Next:=APage.NextPage;
     Next.PrevPage:=nil;
     FFirstPage:=Next;
    end
   else
    begin
     {Is Last Object}
     FFirstPage:=nil;
     FLastPage:=nil;
    end;
  end;
 
 APage.PrevPage:=nil;
 APage.NextPage:=nil;
 
 Result:=True;
end;

{==============================================================================}

function THashCache.LinkEmpty(APage:TCachePage):Boolean;
{Link APage to PrevLink,NextLink siblings and Adjust FirstEmpty/LastEmpty}

{Note: Caller must hold the lock}
var
 Prev:TCachePage;
begin
 {}
 Result:=False;
 
 if FDriver = nil then Exit;
 if APage = nil then Exit;

 Prev:=FLastEmpty;
 if Prev = nil then
  begin
   {Is First Object}
   APage.PrevLink:=nil;
   APage.NextLink:=nil;
   FFirstEmpty:=APage;
   FLastEmpty:=APage;
  end
 else
  begin
   {Not First Object}
   Prev.NextLink:=APage;
   APage.PrevLink:=Prev;
   APage.NextLink:=nil;
   FLastEmpty:=APage;
  end;
  
 Result:=True;
end;

{==============================================================================}

function THashCache.UnlinkEmpty(APage:TCachePage):Boolean;
{Unlink APage from PrevLink,NextLink Siblings and Adjust FirstEmpty/LastEmpty}

{Note: Caller must hold the lock}
var
 Prev,Next:TCachePage;
begin
 {}
 Result:=False;
 
 if FDriver = nil then Exit;
 if APage = nil then Exit;

 if APage.PrevLink <> nil then
  begin
   {Not First Object}
   Prev:=APage.PrevLink;
   if APage.NextLink <> nil then
    begin
     {Not Last Object}
     Next:=APage.NextLink;
     Prev.NextLink:=Next;
     Next.PrevLink:=Prev;
    end
   else
    begin
     {Is Last Object}
     Prev.NextLink:=nil;
     FLastEmpty:=Prev;
    end;
  end
 else
  begin
   {Is First Object}
   if APage.NextLink <> nil then
    begin
     {Not Last Object}
     Next:=APage.NextLink;
     Next.PrevLink:=nil;
     FFirstEmpty:=Next;
    end
   else
    begin
     {Is Last Object}
     FFirstEmpty:=nil;
     FLastEmpty:=nil;
    end;
  end;
  
 APage.PrevLink:=nil;
 APage.NextLink:=nil;
 
 Result:=True;
end;

{==============================================================================}

function THashCache.LinkClean(APage:TCachePage):Boolean;
{Link APage to PrevLink,NextLink siblings and Adjust FirstClean/LastClean}

{Note: Caller must hold the lock}
var
 Prev:TCachePage;
begin
 {}
 Result:=False;
 
 if FDriver = nil then Exit;
 if APage = nil then Exit;

 Prev:=FLastClean;
 if Prev = nil then
  begin
   {Is First Object}
   APage.PrevLink:=nil;
   APage.NextLink:=nil;
   FFirstClean:=APage;
   FLastClean:=APage;
  end
 else
  begin
   {Not First Object}
   Prev.NextLink:=APage;
   APage.PrevLink:=Prev;
   APage.NextLink:=nil;
   FLastClean:=APage;
  end;
  
 Result:=True;
end;

{==============================================================================}

function THashCache.UnlinkClean(APage:TCachePage):Boolean;
{Unlink APage from PrevLink,NextLink Siblings and Adjust FirstClean/LastClean}

{Note: Caller must hold the lock}
var
 Prev,Next:TCachePage;
begin
 {}
 Result:=False;
 
 if FDriver = nil then Exit;
 if APage = nil then Exit;

 if APage.PrevLink <> nil then
  begin
   {Not First Object}
   Prev:=APage.PrevLink;
   if APage.NextLink <> nil then
    begin
     {Not Last Object}
     Next:=APage.NextLink;
     Prev.NextLink:=Next;
     Next.PrevLink:=Prev;
    end
   else
    begin
     {Is Last Object}
     Prev.NextLink:=nil;
     FLastClean:=Prev;
    end;
  end
 else
  begin
   {Is First Object}
   if APage.NextLink <> nil then
    begin
     {Not Last Object}
     Next:=APage.NextLink;
     Next.PrevLink:=nil;
     FFirstClean:=Next;
    end
   else
    begin
     {Is Last Object}
     FFirstClean:=nil;
     FLastClean:=nil;
    end;
  end;
  
 APage.PrevLink:=nil;
 APage.NextLink:=nil;
 
 Result:=True;
end;

{==============================================================================}

function THashCache.LinkDirty(APage:TCachePage):Boolean;
{Link APage to PrevLink,NextLink siblings and Adjust FirstDirty/LastDirty}

{Note: Caller must hold the lock}
var
 Prev:TCachePage;
begin
 {}
 Result:=False;
 
 if FDriver = nil then Exit;
 if APage = nil then Exit;

 Prev:=FLastDirty;
 if Prev = nil then
  begin
   {Is First Object}
   APage.PrevLink:=nil;
   APage.NextLink:=nil;
   FFirstDirty:=APage;
   FLastDirty:=APage;
  end
 else
  begin
   {Not First Object}
   Prev.NextLink:=APage;
   APage.PrevLink:=Prev;
   APage.NextLink:=nil;
   FLastDirty:=APage;
  end;
  
 Result:=True;
end;

{==============================================================================}

function THashCache.UnlinkDirty(APage:TCachePage):Boolean;
{Unlink APage from PrevLink,NextLink Siblings and Adjust FirstDirty/LastDirty}

{Note: Caller must hold the lock}
var
 Prev,Next:TCachePage;
begin
 {}
 Result:=False;
 
 if FDriver = nil then Exit;
 if APage = nil then Exit;

 if APage.PrevLink <> nil then
  begin
   {Not First Object}
   Prev:=APage.PrevLink;
   if APage.NextLink <> nil then
    begin
     {Not Last Object}
     Next:=APage.NextLink;
     Prev.NextLink:=Next;
     Next.PrevLink:=Prev;
    end
   else
    begin
     {Is Last Object}
     Prev.NextLink:=nil;
     FLastDirty:=Prev;
    end;
  end
 else
  begin
   {Is First Object}
   if APage.NextLink <> nil then
    begin
     {Not Last Object}
     Next:=APage.NextLink;
     Next.PrevLink:=nil;
     FFirstDirty:=Next;
    end
   else
    begin
     {Is Last Object}
     FFirstDirty:=nil;
     FLastDirty:=nil;
    end;
  end;
  
 APage.PrevLink:=nil;
 APage.NextLink:=nil;
 
 Result:=True;
end;

{==============================================================================}

function THashCache.PrepareDeviceWrite(ADevice:TDiskDevice;APage:TCachePage;ASector,ACount:LongWord):Boolean;
{Prepare a Cache Page for Write by ensuring that required sectors are cached}
{Passed Sector will be the starting sector for the write to this Page}
{Passed Count will be the write count to this Page (Calculated by caller)}

{Note: Only called internally by DeviceWrite}
{Note: Caller must hold the lock}
var
 Count:LongWord;
 Offset:PtrUInt;
begin
 {}
 Result:=False;
  
 if FDriver = nil then Exit;
 if APage = nil then Exit;
 if ADevice = nil then Exit;
 if ADevice.Controller = nil then Exit;
  
 {$IFDEF CACHE_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('THashCache.PrepareDeviceWrite: Page.Sector = ' + IntToStr(APage.Sector) + ' Page.Count = ' + IntToStr(APage.Count));
 if FILESYS_LOG_ENABLED then FileSysLogDebug('THashCache.PrepareDeviceWrite: Sector = ' + IntToStr(ASector) + ' Count = ' + IntToStr(ACount));
 {$ENDIF}
  
 {Check Count}
 if ACount = APage.Count then
  begin
   {Cache nothing (This case should be checked by caller)}
   Result:=True;
  end
 else
  begin
   {Check Sector}
   if ASector > APage.Sector then
    begin
     {Write begins after start of page}
     {$IFDEF CACHE_DEBUG}
     if FILESYS_LOG_ENABLED then FileSysLogDebug('THashCache.PrepareDeviceWrite: Caching Start Sectors (Sector = ' + IntToStr(APage.Sector) + ' Count = ' + IntToStr(ASector - APage.Sector) + ')');
     {$ENDIF}
     
     {Cache starting sectors}
     if not ADevice.Controller.Read(ADevice,APage.Sector,ASector - APage.Sector,APage.Data^) then Exit;
    end;    
    
   {Check Sector + Count} 
   if (ASector + ACount) < (APage.Sector + APage.Count) then
    begin
     {Write ends before end of page}
     {$IFDEF CACHE_DEBUG}
     if FILESYS_LOG_ENABLED then FileSysLogDebug('THashCache.PrepareDeviceWrite: Caching End Sectors (Sector = ' + IntToStr(ASector + ACount) + ' Count = ' + IntToStr((APage.Sector + APage.Count) - (ASector + ACount)) + ')');
     {$ENDIF}
     
     {Cache ending sectors}
     Count:=(APage.Sector + APage.Count) - (ASector + ACount);
     Offset:=(ASector + ACount) - APage.Sector;
     
     if not ADevice.Controller.Read(ADevice,ASector + ACount,Count,Pointer(APage.Data + (Offset shl ADevice.SectorShiftCount))^) then Exit;
    end;
   
   Result:=True;
  end;  
end;

{==============================================================================}

function THashCache.CalculateDevicePage(ADevice:TDiskDevice;ASector:LongWord;var ACount:LongWord):Boolean;
{Calculate the number of sectors remaining in a page given the starting sector}

{Note: Only called internally by DeviceRead/DeviceWrite/DeviceErase}
{Note: Caller must hold the lock}
var
 SectorCount:Word;
 SectorStart:LongWord;
begin
 {}
 Result:=False;

 if FDriver = nil then Exit;
 if ADevice = nil then Exit;

 {$IFDEF CACHE_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('THashCache.CalculateDevicePage: Sector = ' + IntToStr(ASector) + ' Count = ' + IntToStr(ACount));
 {$ENDIF}
 
 {Check for Sector Size bigger than Page Size}
 if ADevice.SectorSize = 0 then Exit;
 if ADevice.SectorSize > FPageSize then Exit;
 if ASector >= ADevice.SectorCount then Exit;
 
 {Calculate Page Count / Shift / Mask}
 if ADevice.PageCount = 0 then
  begin
   ADevice.PageCount:=CalculatePageCount(ADevice);
   if ADevice.PageCount = 0 then Exit;
   ADevice.PageShift:=CalculatePageShift(ADevice);
   ADevice.PageMask:=CalculatePageMask(ADevice);
   
   {$IFDEF CACHE_DEBUG}
   if FILESYS_LOG_ENABLED then
    begin
     FileSysLogDebug('THashCache.CalculateDevicePage: Device = ' + ADevice.Name);
     FileSysLogDebug('THashCache.CalculateDevicePage:  PageCount = ' + IntToStr(ADevice.PageCount));
     FileSysLogDebug('THashCache.CalculateDevicePage:  PageShift = ' + IntToStr(ADevice.PageShift));
     FileSysLogDebug('THashCache.CalculateDevicePage:  PageMask = ' + IntToHex(ADevice.PageMask,8));
    end;
   {$ENDIF}
  end;
  
 {Calculate Sector Count and Start Sector}
 SectorCount:=ADevice.PageCount;
 SectorStart:=(ASector and ADevice.PageMask);
 if (SectorStart + SectorCount) > ADevice.SectorCount then
  begin
   SectorCount:=(ADevice.SectorCount - SectorStart);
  end;
  
 {$IFDEF CACHE_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('THashCache.CalculateDevicePage: SectorCount = ' + IntToStr(SectorCount) + ' SectorStart = ' + IntToStr(SectorStart));
 {$ENDIF}
 
 {Check Start Sector}
 if ASector > SectorStart then
  begin
   Dec(ACount,ASector - SectorStart);
  end;
  
 {Check Sector Count} 
 if (ASector + ACount) > (SectorStart + SectorCount) then
  begin
   Dec(ACount,(ASector + ACount) - (SectorStart + SectorCount));
  end;
 
 Result:=True;
end;

{==============================================================================}

function THashCache.OpenCache(ACacheSize,ACacheKeys,APageSize:LongWord;ACacheMode:TCacheMode):Boolean;
{Allocate the Memory, Create the Empty Pages and Open Cache}
var
 Count:Integer;
 PageSize:LongWord;
 PageCount:LongWord;
 CacheSize:LongWord;
 CacheKeys:LongWord;
 PageOffset:LongWord;
 Page:TCachePage;
begin
 {}
 Result:=False;

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if ACacheSize = 0 then Exit;
  if ACacheKeys = 0 then Exit;
  if APageSize = 0 then Exit;
 
  {$IFDEF CACHE_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('THashCache.OpenCache: CacheSize = ' + IntToStr(ACacheSize) + ' CacheKeys = ' + IntToStr(ACacheKeys) + ' PageSize = ' + IntToStr(APageSize));
  {$ENDIF}
  
  {Check for already Open}
  if FCacheSize > 0 then Exit;
  
  {Check for silly Sizes}
  if APageSize > ACacheSize then Exit;
  
  {Normalize the Sizes}
  PageSize:=RoundPageSize(APageSize);
  CacheSize:=RoundCacheSize(ACacheSize,PageSize);
  CacheKeys:=AdjustCacheKeys(ACacheKeys);
  if PageSize = 0 then Exit;
  if CacheSize = 0 then Exit;
  if CacheKeys = 0 then Exit;
  if PageSize > CacheSize then Exit;
  PageCount:=CacheSize div PageSize;
  
  {$IFDEF CACHE_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('THashCache.OpenCache: CacheSize = ' + IntToStr(CacheSize) + ' CacheKeys = ' + IntToStr(CacheKeys) + ' PageSize = ' + IntToStr(PageSize) + ' PageCount = ' + IntToStr(PageCount));
  {$ENDIF}
  
  {Check for Caching Enabled}
  if ACacheMode <> cmNONE then
   begin
    {Create the Buckets}
    FKeyBits:=CacheKeys;
    FKeyMask:=keyHashMasks[FKeyBits];
    FKeyBuckets:=AllocMem((keyHashMasks[FKeyBits] + 1) shl 2); {Multiply bucket count (Mask + 1) by SizeOf(Pointer)}
    
    {Allocate the Memory}
    FBuffer:=GetAlignedMem(CacheSize,PageSize);
    if FBuffer = nil then Exit;
    
    {Allocate the Pages}
    PageOffset:=0;
    for Count:=0 to PageCount - 1 do
     begin
      Page:=THashCachePage.Create;
      Page.Data:=Pointer(PtrUInt(FBuffer) + PageOffset);
      AddPage(Page);
      Inc(PageOffset,PageSize);
     end;
   end;
   
  {Set the Sizes}
  FPageSize:=PageSize;
  FPageCount:=PageCount;
  FCacheSize:=CacheSize;
  FCacheKeys:=CacheKeys;
  FCacheMode:=ACacheMode;
  FCacheState:=csCLEAN;
  
  {Create Timer}
  FTimer:=THashCacheTimer.Create(Self);
  
  {Start Timer}
  FTimer.StartTimer(FILESYS_CACHE_TIMER_INTERVAL);

  {Create Thread}
  FThread:=THashCacheThread.Create(Self);
  {FThread.FreeOnTerminate:=True;} {Freed by CloseCache}
  
  {Start Thread}
  FThread.Start; 
  
  Result:=True;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function THashCache.CloseCache:Boolean;
{Flush all Dirty Pages, Release the Memory and Close the Cache}
var
 NextPage:TCachePage;
 CurrentPage:TCachePage;
begin
 {}
 Result:=False;

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  
  {$IFDEF CACHE_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('THashCache.CloseCache');
  {$ENDIF}
  
  {Check for already Closed}
  if FCacheSize = 0 then Exit;
  
  {Terminate Thread}
  FThread.Terminate;
  
  {Stop Timer}
  FTimer.StopTimer;

  {Wait For Thread}
  FThread.WaitFor;
  
  {Destroy Timer}
  FTimer.Free;
  FTimer:=nil;
 
  {Destroy Thread}
  FThread.Free;
  FThread:=nil;
  
  {Flush the Pages}
  NextPage:=FFirstDirty;
  while NextPage <> nil do
   begin
    CurrentPage:=NextPage;
    NextPage:=NextPage.NextLink;
    
    FlushPage(CurrentPage);
   end;
  
  {Free the Pages}
  NextPage:=FFirstPage;
  while NextPage <> nil do
   begin
    CurrentPage:=NextPage;
    NextPage:=NextPage.NextPage;
    
    RemovePage(CurrentPage);
   end;
  
  {Free the Memory}
  FreeMem(FBuffer);
  FBuffer:=nil;
  
  {Free the Buckets}
  ZeroMemory(FKeyBuckets,(keyHashMasks[FKeyBits] + 1) shl 2); {Multiply bucket count (Mask + 1) by SizeOf(Pointer)}
  FreeMem(FKeyBuckets);
  FKeyBuckets:=nil;
  FKeyBits:=0;
  FKeyMask:=0;
  
  {Set the Sizes}
  FPageSize:=0;
  FPageCount:=0;
  FCacheSize:=0;
  FCacheKeys:=0;
  FCacheMode:=cmNONE;
  FCacheState:=csCLEAN;
  
  Result:=True;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function THashCache.DeviceRead(ADevice:TDiskDevice;ASector,ACount:LongWord;var ABuffer):Boolean;
{Read Data from the Physical Device using either Cached or Direct access}
{Note: AllocDevicePage does all checks for Size, Sector and Count}
var
 Buffer:Pointer;
 Page:TCachePage;
 ReadCount:LongWord;
 OffsetCount:LongWord;
begin
 {}
 Result:=False;
 
 if FDriver = nil then Exit;
 if ADevice = nil then Exit;
 if ADevice.Controller = nil then Exit;
 
 {$IFDEF CACHE_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('THashCache.DeviceRead: Device = ' + ADevice.Name + ' Sector = ' + IntToStr(ASector) + ' Count = ' + IntToStr(ACount));
 {$ENDIF}
 
 {Get Buffer}
 Buffer:=@ABuffer;
 while ACount > 0 do
  begin
   if not AcquireLock then Exit;
   try
    if (FCacheSize > 0) and (FCacheMode <> cmNONE) then
     begin
      {Read Cached}
      Inc(FReadCached);
      
      {Get Page}
      Page:=GetDevicePage(ADevice,ASector);
      if Page <> nil then
       begin
        {Found in Cache}
        Inc(FHitCount);
        
        {Get Count}
        OffsetCount:=ASector - Page.Sector;           {Offset from Page Sector to Read Sector}
        ReadCount:=Page.Count - OffsetCount;          {Number of Sectors to Read from Page}
        if ReadCount > ACount then ReadCount:=ACount;
        
        {Read from Page to Buffer}
        System.Move(Pointer(PtrUInt(Page.Data) + (OffsetCount shl ADevice.SectorShiftCount))^,Buffer^,ReadCount shl ADevice.SectorShiftCount);
        
        {Update Page}
        Page.PageTime:=GetTickCount64;
        if not UpdateClean(Page) then Exit; {Does nothing if Dirty}
        
        {Update Count}
        Dec(ACount,ReadCount);
        
        {Update Buffer and Sector}
        if ACount > 0 then
         begin
          Inc(Buffer,ReadCount shl ADevice.SectorShiftCount);
          Inc(ASector,ReadCount);
         end; 
        
        Result:=True;
       end
      else
       begin
        {Not Found in Cache}
        Inc(FMissCount);
        
        {Allocate a Page}
        Page:=AllocDevicePage(ADevice,ASector,False);
        if Page <> nil then
         begin
          {Allocate Succeeded}
          Inc(FSuccessCount);
          
          {Get Count}
          OffsetCount:=ASector - Page.Sector;           {Offset from Page Sector to Read Sector}
          ReadCount:=Page.Count - OffsetCount;          {Number of Sectors to Read from Page}
          if ReadCount > ACount then ReadCount:=ACount; 
          
          {Read from Device to Page}
          if not ADevice.Controller.Read(ADevice,Page.Sector,Page.Count,Page.Data^) then Exit;
          
          {Read from Page to Buffer}
          System.Move(Pointer(PtrUInt(Page.Data) + (OffsetCount shl ADevice.SectorShiftCount))^,Buffer^,ReadCount shl ADevice.SectorShiftCount);
          
          {PageTime updated by AllocDevicePage}
         end
        else
         begin
          {Allocate Failed}
          Inc(FFailCount);

          {Get Count}
          ReadCount:=ACount;
          if not CalculateDevicePage(ADevice,ASector,ReadCount) then Exit;
          
          {Direct Read}
          if not ADevice.Controller.Read(ADevice,ASector,ReadCount,Buffer^) then Exit;
         end;
         
        {Update Count}
        Dec(ACount,ReadCount);
        
        {Update Buffer and Sector}
        if ACount > 0 then
         begin
          Inc(Buffer,ReadCount shl ADevice.SectorShiftCount);
          Inc(ASector,ReadCount);
         end; 
        
        Result:=True;
       end;
     end
    else
     begin
      {No Cache}
      Inc(FReadDirect);
      
      {Direct Read}
      Result:=ADevice.Controller.Read(ADevice,ASector,ACount,Buffer^);
      
      {Update Count}
      Dec(ACount,ACount);
     end;
   finally
    ReleaseLock;
   end;
  end; 
end;

{==============================================================================}

function THashCache.DeviceWrite(ADevice:TDiskDevice;ASector,ACount:LongWord;const ABuffer):Boolean;
{Write Data to the Physical Device using either Cached or Direct access}
{Note: AllocDevicePage does all checks for Size, Sector and Count}
var
 Buffer:Pointer;
 Page:TCachePage;
 WriteCount:LongWord;
 OffsetCount:LongWord;
begin
 {}
 Result:=False;

 if FDriver = nil then Exit;
 if ADevice = nil then Exit;
 if ADevice.Controller = nil then Exit;
 
 {$IFDEF CACHE_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('THashCache.DeviceWrite: Device = ' + ADevice.Name + ' Sector = ' + IntToStr(ASector) + ' Count = ' + IntToStr(ACount));
 {$ENDIF}
 
 {Get Buffer}
 Buffer:=@ABuffer;
 while ACount > 0 do
  begin
   if not AcquireLock then Exit;
   try
    if (FCacheSize > 0) and (FCacheMode <> cmNONE) then
     begin
      if (FCacheMode = cmREADWRITE) and (ADevice.Removable = False) then
       begin
        {Write Back Cached}
        Inc(FWriteBack);
        
        {Get Page}
        Page:=GetDevicePage(ADevice,ASector);
        if Page <> nil then
         begin
          {Found in Cache}
          Inc(FHitCount);
          
          {Get Count}
          OffsetCount:=ASector - Page.Sector;             {Offset from Page Sector to Write Sector}
          WriteCount:=Page.Count - OffsetCount;           {Number of Sectors to Write to Page}
          if WriteCount > ACount then WriteCount:=ACount;
          
          {Write to Page from Buffer}
          System.Move(Buffer^,Pointer(PtrUInt(Page.Data) + (OffsetCount shl ADevice.SectorShiftCount))^,WriteCount shl ADevice.SectorShiftCount);
          
          {Update Page}
          Page.PageTime:=GetTickCount64;
          if Page.PageState <> psDIRTY then Page.WriteTime:=GetTickCount64;
          if not AddDirty(Page) then Exit;
          
          {Update State}
          FCacheState:=csDIRTY;
          
          {Update Count}
          Dec(ACount,WriteCount);
          
          {Update Buffer and Sector}
          if ACount > 0 then
           begin
            Inc(Buffer,WriteCount shl ADevice.SectorShiftCount);
            Inc(ASector,WriteCount);
           end; 
           
          Result:=True;
         end
        else
         begin
          {Not Found in Cache}
          Inc(FMissCount);
          
          {Allocate a Page}
          Page:=AllocDevicePage(ADevice,ASector,True);
          if Page <> nil then
           begin
            {Allocate Succeeded}
            Inc(FSuccessCount);
            
            {Get Count}
            OffsetCount:=ASector - Page.Sector;             {Offset from Page Sector to Write Sector}
            WriteCount:=Page.Count - OffsetCount;           {Number of Sectors to Write to Page}
            if WriteCount > ACount then WriteCount:=ACount;
            
            {Check for less than Page}
            if WriteCount < Page.Count then
             begin
              {Prepare Page for Write}
              if not PrepareDeviceWrite(ADevice,Page,ASector,WriteCount) then Exit;
             end;
            
            {Write to Page from Buffer}
            System.Move(Buffer^,Pointer(PtrUInt(Page.Data) + (OffsetCount shl ADevice.SectorShiftCount))^,WriteCount shl ADevice.SectorShiftCount);
            
            {PageTime and WriteTime updated by AllocDevicePage}
            
            {Update State}
            FCacheState:=csDIRTY;
           end
          else
           begin
            {Allocate Failed}
            Inc(FFailCount);
    
            {Get Count}
            WriteCount:=ACount;
            if not CalculateDevicePage(ADevice,ASector,WriteCount) then Exit;
    
            {Direct Write}
            if not ADevice.Controller.Write(ADevice,ASector,WriteCount,Buffer^) then Exit;
           end;
           
          {Update Count}
          Dec(ACount,WriteCount);
          
          {Update Buffer and Sector}
          if ACount > 0 then
           begin
            Inc(Buffer,WriteCount shl ADevice.SectorShiftCount);
            Inc(ASector,WriteCount);
           end; 
          
          Result:=True;
         end;
       end
      else
       begin
        {Write Through Cached (ReadOnly Cache or Removable Device)}
        Inc(FWriteThrough);
        
        {Get Page}
        Page:=GetDevicePage(ADevice,ASector);
        if Page <> nil then
         begin
          {Found in Cache}
          Inc(FHitCount);
          
          {Get Count}
          OffsetCount:=ASector - Page.Sector;             {Offset from Page Sector to Write Sector}
          WriteCount:=Page.Count - OffsetCount;           {Number of Sectors to Write to Page}
          if WriteCount > ACount then WriteCount:=ACount;
          
          {Write to Page from Buffer}
          System.Move(Buffer^,Pointer(PtrUInt(Page.Data) + (OffsetCount shl ADevice.SectorShiftCount))^,WriteCount shl ADevice.SectorShiftCount);
          
          {Write from Page to Device}
          if not ADevice.Controller.Write(ADevice,(Page.Sector + OffsetCount),WriteCount,Pointer(PtrUInt(Page.Data) + (OffsetCount shl ADevice.SectorShiftCount))^) then Exit;
          
          {Update Page}
          Page.PageTime:=GetTickCount64;
          if not UpdateClean(Page) then Exit; {Read Only Page is always Clean}
          
          {Update Count}
          Dec(ACount,WriteCount);
          
          {Update Buffer and Sector}
          if ACount > 0 then
           begin
            Inc(Buffer,WriteCount shl ADevice.SectorShiftCount);
            Inc(ASector,WriteCount);
           end; 
          
          Result:=True;
         end
        else
         begin
          {Not Found in Cache}
          Inc(FMissCount);
          
          {Allocate a Page}
          Page:=AllocDevicePage(ADevice,ASector,False); {Allocate Clean}
          if Page <> nil then
           begin
            {Allocate Succeeded}
            Inc(FSuccessCount);
            
            {Get Count}
            OffsetCount:=ASector - Page.Sector;             {Offset from Page Sector to Write Sector}
            WriteCount:=Page.Count - OffsetCount;           {Number of Sectors to Write to Page}
            if WriteCount > ACount then WriteCount:=ACount;
            
            {Check for less than Page}
            if WriteCount < Page.Count then
             begin
              {Prepare Page for Write}
              if not PrepareDeviceWrite(ADevice,Page,ASector,WriteCount) then Exit;
             end;
            
            {Write to Page from Buffer}
            System.Move(Buffer^,Pointer(PtrUInt(Page.Data) + (OffsetCount shl ADevice.SectorShiftCount))^,WriteCount shl ADevice.SectorShiftCount);
            
            {Write from Page to Device}
            if not ADevice.Controller.Write(ADevice,(Page.Sector + OffsetCount),WriteCount,Pointer(PtrUInt(Page.Data) + (OffsetCount shl ADevice.SectorShiftCount))^) then Exit;
  
            {PageTime updated by AllocDevicePage}
           end
          else
           begin
            {Allocate Failed}
            Inc(FFailCount);
        
            {Get Count}
            WriteCount:=ACount;
            if not CalculateDevicePage(ADevice,ASector,WriteCount) then Exit;
        
            {Direct Write}
            if not ADevice.Controller.Write(ADevice,ASector,WriteCount,Buffer^) then Exit;
           end;
           
          {Update Count}
          Dec(ACount,WriteCount);
          
          {Update Buffer and Sector}
          if ACount > 0 then
           begin
            Inc(Buffer,WriteCount shl ADevice.SectorShiftCount);
            Inc(ASector,WriteCount);
           end; 
          
          Result:=True;
         end;
       end;
     end
    else
     begin
      {No Cache}
      Inc(FWriteDirect);
      
      {Direct Write}
      Result:=ADevice.Controller.Write(ADevice,ASector,ACount,Buffer^);
      
      {Update Count}
      Dec(ACount,ACount);
     end;
   finally
    ReleaseLock;
   end;
  end; 
end;

{==============================================================================}

function THashCache.DeviceErase(ADevice:TDiskDevice;ASector,ACount:LongWord):Boolean;
{Erase Data from the Physical Device and update cached pages accordingly}
var
 Page:TCachePage;
 EraseCount:LongWord;
 OffsetCount:LongWord;
begin
 {}
 Result:=False;
 
 if FDriver = nil then Exit;
 if ADevice = nil then Exit;
 if ADevice.Controller = nil then Exit;
 
 {$IFDEF CACHE_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('THashCache.DeviceErase: Device = ' + ADevice.Name + ' Sector = ' + IntToStr(ASector) + ' Count = ' + IntToStr(ACount));
 {$ENDIF}
 
 {Check Count}
 while ACount > 0 do
  begin
   if not AcquireLock then Exit;
   try
    if (FCacheSize > 0) and (FCacheMode <> cmNONE) then
     begin
      {Get Page}
      Page:=GetDevicePage(ADevice,ASector);
      if Page <> nil then
       begin
        {Found in Cache}
        {Get Count}
        OffsetCount:=ASector - Page.Sector;             {Offset from Page Sector to Erase Sector}
        EraseCount:=Page.Count - OffsetCount;           {Number of Sectors to Erase from Page}
        if EraseCount > ACount then EraseCount:=ACount;
 
        {Erase from Device}
        if not ADevice.Controller.Erase(ADevice,ASector,EraseCount) then Exit;
        
        {Check for Dirty}
        if Page.PageState = psDIRTY then
         begin
          {Flush Page}
          if not FlushPage(Page) then Exit;
         end;
         
        {Discard Page}
        if not DiscardPage(Page) then Exit;
        
        {Update Count}
        Dec(ACount,EraseCount);
    
        {Update Sector}
        if ACount > 0 then
         begin
          Inc(ASector,EraseCount);
         end; 
    
        Result:=True;
       end
      else
       begin
        {Not Found in Cache}
        {Get Count}
        EraseCount:=ACount;
        if not CalculateDevicePage(ADevice,ASector,EraseCount) then Exit;
        
        {Erase from Device}
        if not ADevice.Controller.Erase(ADevice,ASector,EraseCount) then Exit;
        
        {Update Count}
        Dec(ACount,EraseCount);
    
        {Update Sector}
        if ACount > 0 then
         begin
          Inc(ASector,EraseCount);
         end; 
    
        Result:=True;
       end;
     end
    else
     begin
      {Not Cached}
      {Direct Erase}
      Result:=ADevice.Controller.Erase(ADevice,ASector,ACount);
      
      {Update Count}
      Dec(ACount,ACount);
     end;
   finally
    ReleaseLock;
   end;
  end; 
end;

{==============================================================================}

function THashCache.GetDevicePage(ADevice:TDiskDevice;ASector:LongWord):TCachePage;
{Get the Clean or Dirty Page that contains this Sector on this Device}
var
 Page:TCachePage;
 KeyHash:LongWord;
 SectorStart:LongWord;
begin
 {}
 Result:=nil;
 
 if not AcquireLock then Exit;
 try
  {$IFDEF CACHE_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('THashCache.GetDevicePage: Sector = ' + IntToStr(ASector));
  {$ENDIF}
  
  if FDriver = nil then Exit;
  if ADevice = nil then Exit;
  if ADevice.PageCount = 0 then Exit;
  
  {Get Hash}
  SectorStart:=(ASector and ADevice.PageMask);
  KeyHash:=(SectorStart shr ADevice.PageShift);
  
  {$IFDEF CACHE_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('THashCache.GetDevicePage: SectorStart = ' + IntToStr(SectorStart) + ' KeyHash = ' + IntToStr(KeyHash));
  {$ENDIF}
  
  {Check Pages}
  Page:=KeyFirst(KeyHash);
  while Page <> nil do
   begin
    {Check Page Type and Device}
    if (Page.PageType = ptDEVICE) and (Page.Device = ADevice) then
     begin
      {Check Page Sector}
      if Page.Sector = SectorStart then
       begin
        {$IFDEF CACHE_DEBUG}
        if FILESYS_LOG_ENABLED then FileSysLogDebug('THashCache.GetDevicePage: Page.Sector = ' + IntToStr(Page.Sector) + ' Page.Count = ' + IntToStr(Page.Count));
        {$ENDIF}
        
        Result:=Page;
        Exit;
       end;
     end;
     
    Page:=THashCachePage(Page).KeyNext;
   end;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function THashCache.GetEmptyPage:TCachePage;
{Get the First Empty Page, Discard First Clean Page if none Empty}
begin
 {}
 Result:=nil;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  
  {Get First Empty Page}
  Result:=FFirstEmpty;
  if Result <> nil then Exit;
  
  {If no Empty then Discard Oldest}
  if not DiscardCache(True,False) then Exit;
  
  {Get First Empty Page}
  Result:=FFirstEmpty;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function THashCache.AllocDevicePage(ADevice:TDiskDevice;ASector:LongWord;AWrite:Boolean):TCachePage;
{Allocate an Empty Page to the Device and mark as Clean or Dirty}
var
 Page:TCachePage;
 SectorCount:Word;
 SectorStart:LongWord;
begin
 {}
 Result:=nil;
 
 if not AcquireLock then Exit;
 try
  {$IFDEF CACHE_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('THashCache.AllocDevicePage: Sector = ' + IntToStr(ASector));
  {$ENDIF}
  
  if FDriver = nil then Exit;
  if ADevice = nil then Exit;
  
  {Check for Sector Size bigger than Page Size}
  if ADevice.SectorSize = 0 then Exit;
  if ADevice.SectorSize > FPageSize then Exit;
  if ASector >= ADevice.SectorCount then Exit;
  
  {Calculate Page Count / Shift / Mask}
  if ADevice.PageCount = 0 then
   begin
    ADevice.PageCount:=CalculatePageCount(ADevice);
    if ADevice.PageCount = 0 then Exit;
    ADevice.PageShift:=CalculatePageShift(ADevice);
    ADevice.PageMask:=CalculatePageMask(ADevice);
    
    {$IFDEF CACHE_DEBUG}
    if FILESYS_LOG_ENABLED then
     begin
      FileSysLogDebug('THashCache.AllocDevicePage: Device = ' + ADevice.Name);
      FileSysLogDebug('THashCache.AllocDevicePage:  PageCount = ' + IntToStr(ADevice.PageCount));
      FileSysLogDebug('THashCache.AllocDevicePage:  PageShift = ' + IntToStr(ADevice.PageShift));
      FileSysLogDebug('THashCache.AllocDevicePage:  PageMask = ' + IntToHex(ADevice.PageMask,8));
     end;
    {$ENDIF}
   end;
   
  {Calculate Sector Count and Start Sector}
  SectorCount:=ADevice.PageCount;
  SectorStart:=(ASector and ADevice.PageMask);
  if (SectorStart + SectorCount) > ADevice.SectorCount then
   begin
    SectorCount:=(ADevice.SectorCount - SectorStart);
   end;
   
  {$IFDEF CACHE_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('THashCache.AllocDevicePage: SectorCount = ' + IntToStr(SectorCount) + ' SectorStart = ' + IntToStr(SectorStart));
  {$ENDIF}

  {Get Empty Page}
  Page:=GetEmptyPage;
  if Page <> nil then
   begin
    THashCachePage(Page).KeyHash:=(SectorStart shr ADevice.PageShift);
    
    {$IFDEF CACHE_DEBUG}
    if FILESYS_LOG_ENABLED then FileSysLogDebug('THashCache.AllocDevicePage: KeyHash = ' + IntToStr(THashCachePage(Page).KeyHash));
    {$ENDIF}
    
    if AWrite then
     begin
      if AddDirty(Page) then
       begin
        Page.Device:=ADevice;
        Page.Sector:=SectorStart;
        Page.Count:=SectorCount;
        Page.PageTime:=GetTickCount64;
        Page.WriteTime:=GetTickCount64;
        Page.PageType:=ptDEVICE;
        
        Result:=Page;
       end;
     end
    else
     begin
      if AddClean(Page) then
       begin
        Page.Device:=ADevice;
        Page.Sector:=SectorStart;
        Page.Count:=SectorCount;
        Page.PageTime:=GetTickCount64;
        Page.PageType:=ptDEVICE;
        
        Result:=Page;
       end;
     end;
   end
  else
   begin
    {If no Empty Page then Flush}
    if FlushCache(True,False) then
     begin
      {Get Empty Page}
      Page:=GetEmptyPage;
      if Page <> nil then
       begin
        THashCachePage(Page).KeyHash:=(SectorStart shr ADevice.PageShift);
        
        {$IFDEF CACHE_DEBUG}
        if FILESYS_LOG_ENABLED then FileSysLogDebug('THashCache.AllocDevicePage: KeyHash = ' + IntToStr(THashCachePage(Page).KeyHash));
        {$ENDIF}
        
        if AWrite then
         begin
          if AddDirty(Page) then
           begin
            Page.Device:=ADevice;
            Page.Sector:=SectorStart;
            Page.Count:=SectorCount;
            Page.PageTime:=GetTickCount64;
            Page.WriteTime:=GetTickCount64;
            Page.PageType:=ptDEVICE;
            
            Result:=Page;
           end;
         end
        else
         begin
          if AddClean(Page) then
           begin
            Page.Device:=ADevice;
            Page.Sector:=SectorStart;
            Page.Count:=SectorCount;
            Page.PageTime:=GetTickCount64;
            Page.PageType:=ptDEVICE;
            
            Result:=Page;
           end;
         end;
       end;
     end;
   end;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function THashCache.DiscardPage(APage:TCachePage):Boolean;
{Return a Clean Page to Empty}
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if APage = nil then Exit;
  
  {Check for Clean}
  if APage.PageState = psCLEAN then
   begin
    if not AddEmpty(APage) then Exit;
    Inc(FDiscardCount);
    APage.Device:=nil;
    APage.Sector:=0;
    APage.Count:=0;
    APage.PageTime:=0;
    APage.WriteTime:=0;
    APage.PageType:=ptNONE;
    
    Result:=True;
   end
  else
   begin
    {Return a Non Clean Page to Unknown}
    if not AddUnknown(APage) then Exit;
    Inc(FUnknownCount);
    
    Result:=True;
   end;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function THashCache.DiscardCache(AFirst,AAll:Boolean):Boolean;
{Find any Clean Pages older than DiscardTimeout and Discard them}
var
 CurrentTime:Int64;
 NextPage:TCachePage;
 CurrentPage:TCachePage;
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  
  {Get Counter}
  CurrentTime:=GetTickCount64;
  
  {Check Clean Pages}
  NextPage:=FFirstClean;
  while NextPage <> nil do
   begin
    CurrentPage:=NextPage;
    NextPage:=NextPage.NextLink;
    if (AFirst) or (AAll) or ((CurrentPage.PageTime + FDiscardTimeout) < CurrentTime) then
     begin
      DiscardPage(CurrentPage);
      if AFirst then Break; {Discard only the First Page}
     end
    else
     begin
      Break; {No more pages old enough to Discard}
     end;
   end;
   
  Result:=True;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function THashCache.ReleaseDevicePages(ADevice:TDiskDevice):Boolean;
{Return all Clean or Dirty Pages on the Device to Empty}
var
 NextPage:TCachePage;
 CurrentPage:TCachePage;
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if ADevice = nil then Exit;

  {Flush Dirty Pages}
  NextPage:=FFirstDirty;
  while NextPage <> nil do
   begin
    CurrentPage:=NextPage;
    NextPage:=NextPage.NextLink;
    
    if (CurrentPage.PageType = ptDEVICE) and (CurrentPage.Device = ADevice) then
     begin
      FlushPage(CurrentPage);
     end;
   end;
   
  {Discard Clean Pages}
  NextPage:=FFirstClean;
  while NextPage <> nil do
   begin
    CurrentPage:=NextPage;
    NextPage:=NextPage.NextLink;
    
    if (CurrentPage.PageType = ptDEVICE) and (CurrentPage.Device = ADevice) then
     begin
      DiscardPage(CurrentPage);
     end;
   end;
   
  Result:=True;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function THashCache.FlushPage(APage:TCachePage):Boolean;
{Return a Dirty Page to Clean}
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if APage = nil then Exit;

  {Unschedule Page}
  UnschedulePage(APage);
  
  {Check for Dirty}
  if APage.PageState = psDIRTY then
   begin
    {Check Sector Count}
    if APage.Count > 0 then
     begin
      case APage.PageType of
       ptNONE:begin
         {Return a Page with no Type to Clean}
         if not AddClean(APage) then Exit;
         Inc(FFlushCount);
         APage.WriteTime:=0;
         
         Result:=True;
        end;
       ptDEVICE:begin
         {Write Page to Device}
         if APage.Device = nil then Exit;
         if APage.Device.Controller = nil then Exit;
         if not APage.Device.Controller.Write(APage.Device,APage.Sector,APage.Count,APage.Data^) then Exit;
         
         {Return to Clean}
         if not AddClean(APage) then Exit;
         Inc(FFlushCount);
         APage.WriteTime:=0;
         
         Result:=True;
        end;
      end;
     end
    else
     begin
      {Return a 0 Sector Page to Clean}
      if not AddClean(APage) then Exit;
      Inc(FFlushCount);
      APage.WriteTime:=0;
      
      Result:=True;
     end;
   end
  else
   begin
    {Return a Non Dirty Page to Unknown}
    if not AddUnknown(APage) then Exit;
    Inc(FUnknownCount);
    APage.WriteTime:=0;
    
    Result:=True;
   end;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function THashCache.FlushPageEx(APage:TCachePage):Boolean;
{Return a Dirty Page to Clean if it is older than FlushTimeout}

{Note: Only called by CacheThread with page scheduled from CacheTimer}
var
 Page:TCachePage;
begin
 {}
 Result:=False;

 {$IFDEF CACHE_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('THashCache.FlushPageEx (Page=' + PtrToHex(APage) + ' FirstDirty=' + PtrToHex(FFirstDirty) + ')');
 {$ENDIF}
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if APage = nil then Exit;
 
  {Check Page}
  Page:=FFirstDirty;
  if APage <> Page then
   begin
    {Find Page}
    while Page <> nil do
     begin
      if Page = APage then Break;
      {Get Next}
      Page:=Page.NextLink;
     end;
   end;  
   
  {Check Page}
  if (APage = Page) and ((APage.WriteTime + FFlushTimeout) <= GetTickCount64) then
   begin
    {Check for Dirty}
    if APage.PageState = psDIRTY then
     begin
      {Check Sector Count}
      if APage.Count > 0 then
       begin
        case APage.PageType of
         ptNONE:begin
           {Return a Page with no Type to Clean}
           if not AddClean(APage) then Exit;
           Inc(FFlushCount);
           APage.WriteTime:=0;
           
           Result:=True;
          end;
         ptDEVICE:begin
           {Write Page to Device}
           if APage.Device = nil then Exit;
           if APage.Device.Controller = nil then Exit;
           if not APage.Device.Controller.Write(APage.Device,APage.Sector,APage.Count,APage.Data^) then Exit;
           
           {Return to Clean}
           if not AddClean(APage) then Exit;
           Inc(FFlushCount);
           APage.WriteTime:=0;
           
           Result:=True;
          end;
        end;
       end
      else
       begin
        {Return a 0 Sector Page to Clean}
        if not AddClean(APage) then Exit;
        Inc(FFlushCount);
        APage.WriteTime:=0;
        
        Result:=True;
       end;
     end
    else
     begin
      {Return a Non Dirty Page to Unknown}
      if not AddUnknown(APage) then Exit;
      Inc(FUnknownCount);
      APage.WriteTime:=0;
      
      Result:=True;
     end;
   
    {Update Cache State}
    if FFirstDirty = nil then FCacheState:=csCLEAN;
  {$IFDEF CACHE_DEBUG}
   end
  else
   begin
    if APage <> Page then
     begin
      if FILESYS_LOG_ENABLED then FileSysLogDebug('THashCache.FlushPageEx - Non Dirty Page (Page=' + PtrToHex(APage) + ' Dirty=' + PtrToHex(Page) + ')');
     end
    else
     begin
      if FILESYS_LOG_ENABLED then FileSysLogDebug('THashCache.FlushPageEx - Not Ready Page (Page=' + PtrToHex(APage) + ' WriteTime=' + IntToStr(APage.WriteTime) + ' TickCount=' + IntToStr(GetTickCount64) + ')'); 
     end;
  {$ENDIF}
   end;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function THashCache.FlushCache(AFirst,AAll:Boolean):Boolean;
{Find any Dirty Pages older than FlushTimeout and Flush them}
var
 CurrentTime:Int64;
 NextPage:TCachePage;
 CurrentPage:TCachePage;
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  
  {Check Cache State}
  if FCacheState = csDIRTY then
   begin
    {Get Counter}
    CurrentTime:=GetTickCount64;
    
    {Check Dirty Pages}
    NextPage:=FFirstDirty;
    while NextPage <> nil do
     begin
      CurrentPage:=NextPage;
      NextPage:=NextPage.NextLink;
      
      if (AFirst) or (AAll) or ((CurrentPage.WriteTime + FFlushTimeout) < CurrentTime) then
       begin
        FlushPage(CurrentPage);
        
        if AFirst then Break; {Flush only the First Page}
       end
      else
       begin
        Break; {No more pages old enough to Flush}
       end;
     end;
     
    {Update Cache State}
    if FFirstDirty = nil then FCacheState:=csCLEAN;
   end;
   
  Result:=True;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}
   
function THashCache.CheckTimer:Boolean;
begin
 {}
 Result:=False;
 
 {Check Timer}
 if FTimer = nil then Exit;

 {Check Timer}
 Result:=FTimer.CheckTimer;
end;

{==============================================================================}

function THashCache.ProcessTimer:Boolean;
begin
 {}
 Result:=False;
 
 {Check Timer}
 if FTimer = nil then Exit;

 {Process Timer}
 Result:=FTimer.ProcessTimer;
end;

{==============================================================================}
   
function THashCache.SchedulePage(APage:TCachePage;ATimeout:LongWord):Boolean;
begin
 {}
 Result:=False;
 
 {Check Timer}
 if FTimer = nil then Exit;
 
 {Check Page}
 {if APage = nil then Exit;} {Do not check}
 
 {Schedule Page}
 Result:=FTimer.SchedulePage(APage,ATimeout);
end;

{==============================================================================}

function THashCache.UnschedulePage(APage:TCachePage):Boolean; 
begin
 {}
 Result:=False;
 
 {Check Timer}
 if FTimer = nil then Exit;
 
 {Check Page}
 {if APage = nil then Exit;} {Do not check}
 
 {Unschedule Page}
 Result:=FTimer.UnschedulePage(APage);
end;

{==============================================================================}
{==============================================================================}
{TIncrementalCache}
constructor TIncrementalCache.Create(ADriver:TFileSysDriver);
begin
 {}
 inherited Create;
 FDriver:=ADriver;

 FLock:=CriticalSectionCreate;

 FKeyBits:=0;
 FKeyMask:=0;
 FKeyBuckets:=nil;

 FBuffer:=nil;
 FPageSize:=0;
 FPageCount:=0;
 FCacheSize:=0;
 FCacheKeys:=0;
 FCacheMode:=cmNONE;
 FCacheState:=csCLEAN;
 FFlushTimeout:=FILESYS_CACHE_FLUSH_TIMEOUT;  
 FDiscardTimeout:=FILESYS_CACHE_DISCARD_TIMEOUT; 

 FReadCached:=0;
 FReadDirect:=0;

 FWriteBack:=0;
 FWriteThrough:=0;
 FWriteDirect:=0;

 FHitCount:=0;
 FMissCount:=0;

 FFailCount:=0;
 FSuccessCount:=0;

 FFlushCount:=0;
 FDiscardCount:=0;
 FUnknownCount:=0;

 FFirstPage:=nil;
 FLastPage:=nil;
 FFirstEmpty:=nil;
 FLastEmpty:=nil;
 FFirstClean:=nil;
 FLastClean:=nil;
 FFirstDirty:=nil;
 FLastDirty:=nil;

 FTimer:=nil;
 FThread:=nil;
end;

{==============================================================================}

destructor TIncrementalCache.Destroy;
begin
 {}
 AcquireLock;
 try
  FThread:=nil;
  FTimer:=nil;

  FFirstDirty:=nil;
  FLastDirty:=nil;
  FFirstClean:=nil;
  FLastClean:=nil;
  FFirstEmpty:=nil;
  FLastEmpty:=nil;
  FFirstPage:=nil;
  FLastPage:=nil;

  FBuffer:=nil;
  FKeyBuckets:=nil;
  FDriver:=nil;
  inherited Destroy;
 finally
  {ReleaseLock;} {Can destroy Critical Section while holding lock} 
  CriticalSectionDestroy(FLock);
 end;
end;

{==============================================================================}

function TIncrementalCache.AcquireLock:Boolean;
begin
 {}
 Result:=(CriticalSectionLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TIncrementalCache.ReleaseLock:Boolean;
begin
 {}
 Result:=(CriticalSectionUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TIncrementalCache.AddPage(APage:TCachePage):Boolean;
{Add a new page to the Page list and the Empty list}
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if APage = nil then Exit;

  if not LinkPage(APage) then Exit;
  APage.PageState:=psUNKNOWN;
  
  if not LinkEmpty(APage) then Exit;
  APage.PageState:=psEMPTY;
  
  Result:=True;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function TIncrementalCache.RemovePage(APage:TCachePage):Boolean;
{Remove a Page from the Page list and any other lists then Free the Page}
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if APage = nil then Exit;

  case APage.PageState of
   psUNKNOWN:begin
     APage.PageState:=psUNKNOWN;
     
     if not UnlinkPage(APage) then Exit;
     APage.Free;
     
     Result:=True;
    end;
   psEMPTY:begin
     if not UnlinkEmpty(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     if not UnlinkPage(APage) then Exit;
     APage.Free;
     
     Result:=True;
    end;
   psCLEAN:begin
     if not KeyUnlink(THashCachePage(APage)) then Exit;
     
     if not UnlinkClean(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     if not UnlinkPage(APage) then Exit;
     APage.Free;
     
     Result:=True;
    end;
   psDIRTY:begin
     if not KeyUnlink(THashCachePage(APage)) then Exit;
     
     if not UnlinkDirty(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     if not UnlinkPage(APage) then Exit;
     APage.Free;
     
     Result:=True;
    end;
  end;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function TIncrementalCache.AddEmpty(APage:TCachePage):Boolean;
{Add a Page to the Empty list, removing from other lists if needed}
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if APage = nil then Exit;

  case APage.PageState of
   psUNKNOWN:begin
     if not LinkEmpty(APage) then Exit;
     APage.PageState:=psEMPTY;
     
     Result:=True;
    end;
   psEMPTY:begin
     
     Result:=True;
    end;
   psCLEAN:begin
     if not KeyUnlink(THashCachePage(APage)) then Exit;
     
     if not UnlinkClean(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     if not LinkEmpty(APage) then Exit;
     APage.PageState:=psEMPTY;
     
     Result:=True;
    end;
   psDIRTY:begin
     if not KeyUnlink(THashCachePage(APage)) then Exit;
     
     if not UnlinkDirty(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     if not LinkEmpty(APage) then Exit;
     APage.PageState:=psEMPTY;
     
     Result:=True;
    end;
  end;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function TIncrementalCache.AddClean(APage:TCachePage):Boolean;
{Add a Page to the Clean list, removing from other lists if needed}
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if APage = nil then Exit;

  case APage.PageState of
   psUNKNOWN:begin
     if not LinkClean(APage) then Exit;
     APage.PageState:=psCLEAN;
     
     if not KeyLink(THashCachePage(APage)) then Exit;
     
     Result:=True;
    end;
   psEMPTY:begin
     if not UnlinkEmpty(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     if not LinkClean(APage) then Exit;
     APage.PageState:=psCLEAN;
     
     if not KeyLink(THashCachePage(APage)) then Exit;
     
     Result:=True;
    end;
   psCLEAN:begin
     Result:=True;
    end;
   psDIRTY:begin
     if not UnlinkDirty(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     if not LinkClean(APage) then Exit;
     APage.PageState:=psCLEAN;
     
     {No need to KeyLink}
     
     Result:=True;
    end;
  end;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function TIncrementalCache.AddDirty(APage:TCachePage):Boolean;
{Add a Page to the Dirty list, removing from other lists if needed}
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if APage = nil then Exit;

  case APage.PageState of
   psUNKNOWN:begin
     if not LinkDirty(APage) then Exit;
     APage.PageState:=psDIRTY;
     
     if not KeyLink(THashCachePage(APage)) then Exit;
     
     Result:=SchedulePage(APage,FFlushTimeout);
    end;
   psEMPTY:begin
     if not UnlinkEmpty(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     if not LinkDirty(APage) then Exit;
     APage.PageState:=psDIRTY;
     
     if not KeyLink(THashCachePage(APage)) then Exit;
     
     Result:=SchedulePage(APage,FFlushTimeout);
    end;
   psCLEAN:begin
     if not UnlinkClean(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     if not LinkDirty(APage) then Exit;
     APage.PageState:=psDIRTY;
     
     {No need to KeyLink}
     
     Result:=SchedulePage(APage,FFlushTimeout);
    end;
   psDIRTY:begin
     Result:=True;
    end;
  end;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function TIncrementalCache.AddUnknown(APage:TCachePage):Boolean;
{Make a Page Unknown by removing from any other lists if needed}
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if APage = nil then Exit;

  case APage.PageState of
   psUNKNOWN:begin
     Result:=True;
    end;
   psEMPTY:begin
     if not UnlinkEmpty(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     Result:=True;
    end;
   psCLEAN:begin
     if not KeyUnlink(THashCachePage(APage)) then Exit;
     
     if not UnlinkClean(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     Result:=True;
    end;
   psDIRTY:begin
     if not KeyUnlink(THashCachePage(APage)) then Exit;
     
     if not UnlinkDirty(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     Result:=True;
    end;
  end;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function TIncrementalCache.UpdateClean(APage:TCachePage):Boolean;
{Move a Page to the end of the Clean list}
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if APage = nil then Exit;

  case APage.PageState of
   psCLEAN:begin
     if not UnlinkClean(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     if not LinkClean(APage) then Exit;
     APage.PageState:=psCLEAN;
     
     {No need to KeyLink}
     
     Result:=True;
    end;
   psDIRTY:begin
     Result:=True;
    end;
  end;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function TIncrementalCache.UpdateDirty(APage:TCachePage):Boolean;
{Move a Page to the end of the Dirty list} {Not Used}
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if APage = nil then Exit;

  case APage.PageState of
   psCLEAN:begin
     Result:=True;
    end;
   psDIRTY:begin
     if not UnlinkDirty(APage) then Exit;
     APage.PageState:=psUNKNOWN;
     
     if not LinkDirty(APage) then Exit;
     APage.PageState:=psDIRTY;
     
     {No need to KeyLink}
     
     Result:=True;
    end;
  end;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function TIncrementalCache.RoundPageSize(APageSize:LongWord):LongWord;
{Round Page Size to the power of 2 of Sector Size}

{Note: Caller must hold the lock}
begin
 {}
 Result:=MIN_SECTOR_SIZE;

 {Round up to next power of 2 of Minimum Sector Size}
 while Result < APageSize do
  begin
   Result:=Result shl 1;
  end;
end;

{==============================================================================}

function TIncrementalCache.RoundCacheSize(ACacheSize,APageSize:LongWord):LongWord;
{Round Cache Size to the next multiple of Page Size}

{Note: Caller must hold the lock}
begin
 {}
 Result:=0;
 
 if APageSize = 0 then Exit;
  
 {Round up to next multiple of Page Size}
 Result:=APageSize;
 while Result < ACacheSize do
  begin
   Inc(Result,APageSize);
  end;
end;

{==============================================================================}

function TIncrementalCache.AdjustCacheKeys(ACacheKeys:LongWord):LongWord;
{Adjust Cache Keys to be within safe limits}

{Note: Caller must hold the lock}
begin
 {}
 Result:=0;
 
 if ACacheKeys = 0 then Exit;
  
 Result:=ACacheKeys;
 if Result < keyHashMinBits then Result:=keyHashMinBits;
 if Result > keyHashMaxBits then Result:=keyHashMaxBits;
end;

{==============================================================================}

function TIncrementalCache.CalculatePageCount(ADevice:TDiskDevice):Word;
{Calculate the power of 2 multiple of sector size which will fit within the page}

{Note: Caller must hold the lock}
var
 Value:LongWord;
begin
 {}
 Result:=0;
 
 if FPageSize = 0 then Exit;
 if ADevice = nil then Exit;
 if ADevice.SectorSize = 0 then Exit;
  
 Result:=1;
 Value:=ADevice.SectorSize;
 while Value < FPageSize do
  begin
   Result:=Result shl 1;
   Value:=Value shl 1;
  end;
 if Value > FPageSize then
  begin
   Result:=Result shr 1;
  end;
end;

{==============================================================================}

function TIncrementalCache.CalculatePageShift(ADevice:TDiskDevice):Word;
{Calculate the shift count for Page to Key conversion}

{Note: Caller must hold the lock}
begin
 {}
 Result:=0;
 
 if ADevice = nil then Exit;
 if ADevice.PageCount = 0 then Exit;
  
 while (ADevice.PageCount shr Result) > 1 do
  begin
   Inc(Result);
  end;
end;

{==============================================================================}

function TIncrementalCache.CalculatePageMask(ADevice:TDiskDevice):LongWord;
{Calculate the mask for Sector to Page conversion}

{Note: Caller must hold the lock}
begin
 {}
 Result:=$FFFFFFFF;
 
 if ADevice = nil then Exit;
 if ADevice.PageCount = 0 then Exit;
  
 Result:=((Result shr ADevice.PageShift) shl ADevice.PageShift);
end;

{==============================================================================}

function TIncrementalCache.KeyLink(APage:THashCachePage):Boolean;
{Link APage to KeyPrev,KeyNext siblings and Adjust First}

{Note: Caller must hold the lock}
var
 Offset:LongWord;
 FirstKey:THashCachePage;
begin
 {}
 Result:=False;
 
 if APage = nil then Exit;
 
 {Get Offset}
 Offset:=(APage.KeyHash and FKeyMask) shl 2;
 
 {Get First Key}
 FirstKey:=THashCachePage(Pointer(PtrUInt(FKeyBuckets) + Offset)^);
 if FirstKey = nil then
  begin
   {Is First Object}
   APage.KeyPrev:=nil;
   APage.KeyNext:=nil;
   THashCachePage(Pointer(PtrUInt(FKeyBuckets) + Offset)^):=APage;
  end
 else
  begin
   {Not First Object}
   FirstKey.KeyPrev:=APage;
   APage.KeyPrev:=nil;
   APage.KeyNext:=FirstKey;
   THashCachePage(Pointer(PtrUInt(FKeyBuckets) + Offset)^):=APage;
  end;
  
 Result:=True;
end;

{==============================================================================}

function TIncrementalCache.KeyUnlink(APage:THashCachePage):Boolean;
{Unlink APage from KeyPrev,KeyNext siblings and Adjust First}

{Note: Caller must hold the lock}
var
 Offset:LongWord;
 PrevKey,NextKey:THashCachePage;
begin
 {}
 Result:=False;
 
 if APage = nil then Exit;
 
 if APage.KeyPrev <> nil then
  begin
   {Not First Object}
   PrevKey:=APage.KeyPrev;
   if APage.KeyNext <> nil then
    begin
     {Not Last Object}
     NextKey:=APage.KeyNext;
     PrevKey.KeyNext:=NextKey;
     NextKey.KeyPrev:=PrevKey;
    end
   else
    begin
     {Is Last Object}
     PrevKey.KeyNext:=nil;
    end;
  end
 else
  begin
   {Get Offset}
   Offset:=(APage.KeyHash and FKeyMask) shl 2;
   
   {Is First Object}
   if APage.KeyNext <> nil then
    begin
     {Not Last Object}
     NextKey:=APage.KeyNext;
     NextKey.KeyPrev:=nil;
     THashCachePage(Pointer(PtrUInt(FKeyBuckets) + Offset)^):=NextKey;
    end
   else
    begin
     {Is Last Object}
     THashCachePage(Pointer(PtrUInt(FKeyBuckets) + Offset)^):=nil;
    end;
  end;
  
 APage.KeyPrev:=nil;
 APage.KeyNext:=nil;
 
 Result:=True;
end;

{==============================================================================}

function TIncrementalCache.KeyFirst(AKeyHash:LongWord):THashCachePage;
{Note: Caller must hold the lock}
var
 Offset:LongWord;
begin
 {}
 Result:=nil;
 
 if FKeyBuckets = nil then Exit;
 
 {Get Offset}
 Offset:=(AKeyHash and FKeyMask) shl 2;
 
 {Get First Key}
 Result:=THashCachePage(Pointer(PtrUInt(FKeyBuckets) + Offset)^);
end;

{==============================================================================}

function TIncrementalCache.LinkPage(APage:TCachePage):Boolean;
{Link APage to PrevPage,NextPage siblings and Adjust FirstPage/LastPage}

{Note: Caller must hold the lock}
var
 Prev:TCachePage;
begin
 {}
 Result:=False;
 
 if FDriver = nil then Exit;
 if APage = nil then Exit;

 Prev:=FLastPage;
 if Prev = nil then
  begin
   {Is First Object}
   APage.PrevPage:=nil;
   APage.NextPage:=nil;
   FFirstPage:=APage;
   FLastPage:=APage;
  end
 else
  begin
   {Not First Object}
   Prev.NextPage:=APage;
   APage.PrevPage:=Prev;
   APage.NextPage:=nil;
   FLastPage:=APage;
  end;
  
 Result:=True;
end;

{==============================================================================}

function TIncrementalCache.UnlinkPage(APage:TCachePage):Boolean;
{Unlink APage from PrevPage,NextPage Siblings and Adjust FirstPage/LastPage}

{Note: Caller must hold the lock}
var
 Prev,Next:TCachePage;
begin
 {}
 Result:=False;
 
 if FDriver = nil then Exit;
 if APage = nil then Exit;

 if APage.PrevPage <> nil then
  begin
   {Not First Object}
   Prev:=APage.PrevPage;
   if APage.NextPage <> nil then
    begin
     {Not Last Object}
     Next:=APage.NextPage;
     Prev.NextPage:=Next;
     Next.PrevPage:=Prev;
    end
   else
    begin
     {Is Last Object}
     Prev.NextPage:=nil;
     FLastPage:=Prev;
    end;
  end
 else
  begin
   {Is First Object}
   if APage.NextPage <> nil then
    begin
     {Not Last Object}
     Next:=APage.NextPage;
     Next.PrevPage:=nil;
     FFirstPage:=Next;
    end
   else
    begin
     {Is Last Object}
     FFirstPage:=nil;
     FLastPage:=nil;
    end;
  end;
  
 APage.PrevPage:=nil;
 APage.NextPage:=nil;
 
 Result:=True;
end;

{==============================================================================}

function TIncrementalCache.LinkEmpty(APage:TCachePage):Boolean;
{Link APage to PrevLink,NextLink siblings and Adjust FirstEmpty/LastEmpty}

{Note: Caller must hold the lock}
var
 Prev:TCachePage;
begin
 {}
 Result:=False;
 
 if FDriver = nil then Exit;
 if APage = nil then Exit;

 Prev:=FLastEmpty;
 if Prev = nil then
  begin
   {Is First Object}
   APage.PrevLink:=nil;
   APage.NextLink:=nil;
   FFirstEmpty:=APage;
   FLastEmpty:=APage;
  end
 else
  begin
   {Not First Object}
   Prev.NextLink:=APage;
   APage.PrevLink:=Prev;
   APage.NextLink:=nil;
   FLastEmpty:=APage;
  end;
  
 Result:=True;
end;

{==============================================================================}

function TIncrementalCache.UnlinkEmpty(APage:TCachePage):Boolean;
{Unlink APage from PrevLink,NextLink Siblings and Adjust FirstEmpty/LastEmpty}

{Note: Caller must hold the lock}
var
 Prev,Next:TCachePage;
begin
 {}
 Result:=False;
 
 if FDriver = nil then Exit;
 if APage = nil then Exit;

 if APage.PrevLink <> nil then
  begin
   {Not First Object}
   Prev:=APage.PrevLink;
   if APage.NextLink <> nil then
    begin
     {Not Last Object}
     Next:=APage.NextLink;
     Prev.NextLink:=Next;
     Next.PrevLink:=Prev;
    end
   else
    begin
     {Is Last Object}
     Prev.NextLink:=nil;
     FLastEmpty:=Prev;
    end;
  end
 else
  begin
   {Is First Object}
   if APage.NextLink <> nil then
    begin
     {Not Last Object}
     Next:=APage.NextLink;
     Next.PrevLink:=nil;
     FFirstEmpty:=Next;
    end
   else
    begin
     {Is Last Object}
     FFirstEmpty:=nil;
     FLastEmpty:=nil;
    end;
  end;
  
 APage.PrevLink:=nil;
 APage.NextLink:=nil;
 
 Result:=True;
end;

{==============================================================================}

function TIncrementalCache.LinkClean(APage:TCachePage):Boolean;
{Link APage to PrevLink,NextLink siblings and Adjust FirstClean/LastClean}

{Note: Caller must hold the lock}
var
 Prev:TCachePage;
begin
 {}
 Result:=False;
 
 if FDriver = nil then Exit;
 if APage = nil then Exit;

 Prev:=FLastClean;
 if Prev = nil then
  begin
   {Is First Object}
   APage.PrevLink:=nil;
   APage.NextLink:=nil;
   FFirstClean:=APage;
   FLastClean:=APage;
  end
 else
  begin
   {Not First Object}
   Prev.NextLink:=APage;
   APage.PrevLink:=Prev;
   APage.NextLink:=nil;
   FLastClean:=APage;
  end;
  
 Result:=True;
end;

{==============================================================================}

function TIncrementalCache.UnlinkClean(APage:TCachePage):Boolean;
{Unlink APage from PrevLink,NextLink Siblings and Adjust FirstClean/LastClean}

{Note: Caller must hold the lock}
var
 Prev,Next:TCachePage;
begin
 {}
 Result:=False;
 
 if FDriver = nil then Exit;
 if APage = nil then Exit;

 if APage.PrevLink <> nil then
  begin
   {Not First Object}
   Prev:=APage.PrevLink;
   if APage.NextLink <> nil then
    begin
     {Not Last Object}
     Next:=APage.NextLink;
     Prev.NextLink:=Next;
     Next.PrevLink:=Prev;
    end
   else
    begin
     {Is Last Object}
     Prev.NextLink:=nil;
     FLastClean:=Prev;
    end;
  end
 else
  begin
   {Is First Object}
   if APage.NextLink <> nil then
    begin
     {Not Last Object}
     Next:=APage.NextLink;
     Next.PrevLink:=nil;
     FFirstClean:=Next;
    end
   else
    begin
     {Is Last Object}
     FFirstClean:=nil;
     FLastClean:=nil;
    end;
  end;
  
 APage.PrevLink:=nil;
 APage.NextLink:=nil;
 
 Result:=True;
end;

{==============================================================================}

function TIncrementalCache.LinkDirty(APage:TCachePage):Boolean;
{Link APage to PrevLink,NextLink siblings and Adjust FirstDirty/LastDirty}

{Note: Caller must hold the lock}
var
 Prev:TCachePage;
begin
 {}
 Result:=False;
 
 if FDriver = nil then Exit;
 if APage = nil then Exit;

 Prev:=FLastDirty;
 if Prev = nil then
  begin
   {Is First Object}
   APage.PrevLink:=nil;
   APage.NextLink:=nil;
   FFirstDirty:=APage;
   FLastDirty:=APage;
  end
 else
  begin
   {Not First Object}
   Prev.NextLink:=APage;
   APage.PrevLink:=Prev;
   APage.NextLink:=nil;
   FLastDirty:=APage;
  end;
  
 Result:=True;
end;

{==============================================================================}

function TIncrementalCache.UnlinkDirty(APage:TCachePage):Boolean;
{Unlink APage from PrevLink,NextLink Siblings and Adjust FirstDirty/LastDirty}

{Note: Caller must hold the lock}
var
 Prev,Next:TCachePage;
begin
 {}
 Result:=False;
 
 if FDriver = nil then Exit;
 if APage = nil then Exit;

 if APage.PrevLink <> nil then
  begin
   {Not First Object}
   Prev:=APage.PrevLink;
   if APage.NextLink <> nil then
    begin
     {Not Last Object}
     Next:=APage.NextLink;
     Prev.NextLink:=Next;
     Next.PrevLink:=Prev;
    end
   else
    begin
     {Is Last Object}
     Prev.NextLink:=nil;
     FLastDirty:=Prev;
    end;
  end
 else
  begin
   {Is First Object}
   if APage.NextLink <> nil then
    begin
     {Not Last Object}
     Next:=APage.NextLink;
     Next.PrevLink:=nil;
     FFirstDirty:=Next;
    end
   else
    begin
     {Is Last Object}
     FFirstDirty:=nil;
     FLastDirty:=nil;
    end;
  end;
  
 APage.PrevLink:=nil;
 APage.NextLink:=nil;
 
 Result:=True;
end;

{==============================================================================}

function TIncrementalCache.PrepareDeviceRead(ADevice:TDiskDevice;APage:TCachePage;ASector,ACount:LongWord):Boolean;
{Prepare an incremental Cache Page for Read by ensuring that all required sectors are cached}
{Passed Sector will be the starting sector for the read from this Page}
{Passed Count will be the read count from this Page (Calculated by caller)}

{Note: Only called internally by DeviceRead}
{Note: Caller must hold the lock}
var
 Offset:PtrUInt;
 Page:TIncrementalCachePage;
begin
 {}
 Result:=False;
 
 if FDriver = nil then Exit;
 if APage = nil then Exit;
 if ADevice = nil then Exit;
 if ADevice.Controller = nil then Exit;
 
 {$IFDEF CACHE_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TIncrementalCache.PrepareDeviceRead: Page.Sector = ' + IntToStr(APage.Sector) + ' Page.Count = ' + IntToStr(APage.Count));
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TIncrementalCache.PrepareDeviceRead: Sector = ' + IntToStr(ASector) + ' Count = ' + IntToStr(ACount));
 {$ENDIF}
 
 {Get Page}
 Page:=TIncrementalCachePage(APage);
 
 {$IFDEF CACHE_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TIncrementalCache.PrepareDeviceRead: Page.ReadSector = ' + IntToStr(Page.ReadSector) + ' Page.ReadCount = ' + IntToStr(Page.ReadCount));
 {$ENDIF}
 
 {Check Page}
 if Page.ReadCount = Page.Count then
  begin
   {Full Page}
   Result:=True;
  end
 else if Page.ReadCount = 0 then
  begin
   {Empty Page}
   {Check Count}
   if ACount = Page.Count then
    begin
     {Full Read}
     {Read from Device to Page}
     if not ADevice.Controller.Read(ADevice,Page.Sector,Page.Count,Page.Data^) then Exit;
     
     Page.ReadSector:=Page.Sector;
     Page.ReadCount:=Page.Count;
     
     Result:=True;
    end
   else
    begin
     {Partial Read}
     {Read from Device to Page}
     //if not ADevice.Controller.Read(ADevice,ASector,ACount,Page.ReadData^) then Exit;  //To Do
     
     Page.ReadSector:=ASector;
     Page.ReadCount:=ACount;
     Result:=True;
 
     //To Do
 
    end;
  end
 else
  begin
   {Partial Page}
 
   //To Do
 
  end;
end;

{==============================================================================}

function TIncrementalCache.PrepareDeviceWrite(ADevice:TDiskDevice;APage:TCachePage;ASector,ACount:LongWord):Boolean;
{Prepare an incremental Cache Page for Write by ensuring that required sectors are cached}
{Passed Sector will be the starting sector for the write to this Page}
{Passed Count will be the write count to this Page (Calculated by caller)}

{Note: Only called internally by DeviceWrite}
{Note: Caller must hold the lock}
var
 Count:LongWord;
 Offset:PtrUInt;
 Page:TIncrementalCachePage;
begin
 {}
 Result:=False;
 
 if FDriver = nil then Exit;
 if APage = nil then Exit;
 if ADevice = nil then Exit;
 if ADevice.Controller = nil then Exit;

 {$IFDEF CACHE_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TIncrementalCache.PrepareDeviceWrite: Page.Sector = ' + IntToStr(APage.Sector) + ' Page.Count = ' + IntToStr(APage.Count));
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TIncrementalCache.PrepareDeviceWrite: Sector = ' + IntToStr(ASector) + ' Count = ' + IntToStr(ACount));
 {$ENDIF}
 
 {Get Page}
 Page:=TIncrementalCachePage(APage);
 
 {$IFDEF CACHE_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TIncrementalCache.PrepareDeviceWrite: Page.ReadSector = ' + IntToStr(Page.ReadSector) + ' Page.ReadCount = ' + IntToStr(Page.ReadCount));
 {$ENDIF}
 
 {Check Page}
 if Page.ReadCount = Page.Count then
  begin
   {Full Page}
   Result:=True;
  end
 else if Page.ReadCount = 0 then
  begin
   {Empty Page}
   {Check Count}
   if ACount = Page.Count then
    begin
     {Full Read}
     {Read from Device to Page}
     //if not ADevice.Controller.Read(ADevice,Page.Sector,Page.Count,Page.Data^) then Exit;
     
     Page.ReadSector:=Page.Sector;
     Page.ReadCount:=Page.Count;
     
     Result:=True;
    end
   else
    begin
     {Partial Read}
   
     //To Do
     
    end;
  end
 else
  begin
   {Partial Page}

   //To Do

  end;
end;

{==============================================================================}

function TIncrementalCache.CalculateDevicePage(ADevice:TDiskDevice;ASector:LongWord;var ACount:LongWord):Boolean;
{Calculate the number of sectors remaining in a page given the starting sector}

{Note: Only called internally by DeviceRead/DeviceWrite/DeviceErase}
{Note: Caller must hold the lock}
var
 SectorCount:Word;
 SectorStart:LongWord;
begin
 {}
 Result:=False;

 if FDriver = nil then Exit;
 if ADevice = nil then Exit;

 {$IFDEF CACHE_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TIncrementalCache.CalculateDevicePage: Sector = ' + IntToStr(ASector) + ' Count = ' + IntToStr(ACount));
 {$ENDIF}
 
 {Check for Sector Size bigger than Page Size}
 if ADevice.SectorSize = 0 then Exit;
 if ADevice.SectorSize > FPageSize then Exit;
 if ASector >= ADevice.SectorCount then Exit;
 
 {Calculate Page Count / Shift / Mask}
 if ADevice.PageCount = 0 then
  begin
   ADevice.PageCount:=CalculatePageCount(ADevice);
   if ADevice.PageCount = 0 then Exit;
   ADevice.PageShift:=CalculatePageShift(ADevice);
   ADevice.PageMask:=CalculatePageMask(ADevice);
   
   {$IFDEF CACHE_DEBUG}
   if FILESYS_LOG_ENABLED then
    begin
     FileSysLogDebug('TIncrementalCache.CalculateDevicePage: Device = ' + ADevice.Name);
     FileSysLogDebug('TIncrementalCache.CalculateDevicePage:  PageCount = ' + IntToStr(ADevice.PageCount));
     FileSysLogDebug('TIncrementalCache.CalculateDevicePage:  PageShift = ' + IntToStr(ADevice.PageShift));
     FileSysLogDebug('TIncrementalCache.CalculateDevicePage:  PageMask = ' + IntToHex(ADevice.PageMask,8));
    end;
   {$ENDIF}
  end;
  
 {Calculate Sector Count and Start Sector}
 SectorCount:=ADevice.PageCount;
 SectorStart:=(ASector and ADevice.PageMask);
 if (SectorStart + SectorCount) > ADevice.SectorCount then
  begin
   SectorCount:=(ADevice.SectorCount - SectorStart);
  end;
  
 {$IFDEF CACHE_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TIncrementalCache.CalculateDevicePage: SectorCount = ' + IntToStr(SectorCount) + ' SectorStart = ' + IntToStr(SectorStart));
 {$ENDIF}
 
 {Check Start Sector}
 if ASector > SectorStart then
  begin
   Dec(ACount,ASector - SectorStart);
  end;
  
 {Check Sector Count} 
 if (ASector + ACount) > (SectorStart + SectorCount) then
  begin
   Dec(ACount,(ASector + ACount) - (SectorStart + SectorCount));
  end;
 
 Result:=True;
end;

{==============================================================================}

function TIncrementalCache.OpenCache(ACacheSize,ACacheKeys,APageSize:LongWord;ACacheMode:TCacheMode):Boolean;
{Allocate the Memory, Create the Empty Pages and Open Cache}
var
 Count:Integer;
 PageSize:LongWord;
 PageCount:LongWord;
 CacheSize:LongWord;
 CacheKeys:LongWord;
 PageOffset:LongWord;
 Page:TCachePage;
begin
 {}
 Result:=False;

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if ACacheSize = 0 then Exit;
  if ACacheKeys = 0 then Exit;
  if APageSize = 0 then Exit;
  
  {$IFDEF CACHE_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TIncrementalCache.OpenCache: CacheSize = ' + IntToStr(ACacheSize) + ' CacheKeys = ' + IntToStr(ACacheKeys) + ' PageSize = ' + IntToStr(APageSize));
  {$ENDIF}
  
  {Check for already Open}
  if FCacheSize > 0 then Exit;
  
  {Check for silly Sizes}
  if APageSize > ACacheSize then Exit;
  
  {Normalize the Sizes}
  PageSize:=RoundPageSize(APageSize);
  CacheSize:=RoundCacheSize(ACacheSize,PageSize);
  CacheKeys:=AdjustCacheKeys(ACacheKeys);
  if PageSize = 0 then Exit;
  if CacheSize = 0 then Exit;
  if CacheKeys = 0 then Exit;
  if PageSize > CacheSize then Exit;
  PageCount:=CacheSize div PageSize;
  
  {$IFDEF CACHE_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TIncrementalCache.OpenCache: CacheSize = ' + IntToStr(CacheSize) + ' CacheKeys = ' + IntToStr(CacheKeys) + ' PageSize = ' + IntToStr(PageSize) + ' PageCount = ' + IntToStr(PageCount));
  {$ENDIF}
  
  {Check for Caching Enabled}
  if ACacheMode <> cmNONE then
   begin
    {Create the Buckets}
    FKeyBits:=CacheKeys;
    FKeyMask:=keyHashMasks[FKeyBits];
    FKeyBuckets:=AllocMem((keyHashMasks[FKeyBits] + 1) shl 2); {Multiply bucket count (Mask + 1) by SizeOf(Pointer)}
    
    {Allocate the Memory}
    FBuffer:=GetAlignedMem(CacheSize,PageSize);
    if FBuffer = nil then Exit;
    
    {Allocate the Pages}
    PageOffset:=0;
    for Count:=0 to PageCount - 1 do
     begin
      Page:=TIncrementalCachePage.Create;
      Page.Data:=Pointer(PtrUInt(FBuffer) + PageOffset);
      AddPage(Page);
      Inc(PageOffset,PageSize);
     end;
   end;
   
  {Set the Sizes}
  FPageSize:=PageSize;
  FPageCount:=PageCount;
  FCacheSize:=CacheSize;
  FCacheKeys:=CacheKeys;
  FCacheMode:=ACacheMode;
  FCacheState:=csCLEAN;
  
  {Create Timer}
  FTimer:=TIncrementalCacheTimer.Create(Self);
  
  {Start Timer}
  FTimer.StartTimer(FILESYS_CACHE_TIMER_INTERVAL);
  
  {Create Thread}
  FThread:=TIncrementalCacheThread.Create(Self);
  {FThread.FreeOnTerminate:=True;} {Freed by CloseCache}
  
  {Start Thread}
  FThread.Start; 
  
  Result:=True;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function TIncrementalCache.CloseCache:Boolean;
{Flush all Dirty Pages, Release the Memory and Close the Cache}
var
 NextPage:TCachePage;
 CurrentPage:TCachePage;
begin
 {}
 Result:=False;

 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  
  {$IFDEF CACHE_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TIncrementalCache.CloseCache');
  {$ENDIF}
  
  {Check for already Closed}
  if FCacheSize = 0 then Exit;
  
  {Terminate Thread}
  FThread.Terminate;
  
  {Stop Timer}
  FTimer.StopTimer;

  {Wait For Thread}
  FThread.WaitFor;
  
  {Destroy Timer}
  FTimer.Free;
  FTimer:=nil;
 
  {Destroy Thread}
  FThread.Free;
  FThread:=nil;
  
  {Flush the Pages}
  NextPage:=FFirstDirty;
  while NextPage <> nil do
   begin
    CurrentPage:=NextPage;
    NextPage:=NextPage.NextLink;
    
    FlushPage(CurrentPage);
   end;
   
  {Free the Pages}
  NextPage:=FFirstPage;
  while NextPage <> nil do
   begin
    CurrentPage:=NextPage;
    NextPage:=NextPage.NextPage;
    
    RemovePage(CurrentPage);
   end;
  
  {Free the Memory}
  FreeMem(FBuffer);
  FBuffer:=nil;
  
  {Free the Buckets}
  ZeroMemory(FKeyBuckets,(keyHashMasks[FKeyBits] + 1) shl 2); {Multiply bucket count (Mask + 1) by SizeOf(Pointer)}
  FreeMem(FKeyBuckets);
  FKeyBuckets:=nil;
  FKeyBits:=0;
  FKeyMask:=0;
  
  {Set the Sizes}
  FPageSize:=0;
  FPageCount:=0;
  FCacheSize:=0;
  FCacheKeys:=0;
  FCacheMode:=cmNONE;
  FCacheState:=csCLEAN;
  
  Result:=True;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function TIncrementalCache.DeviceRead(ADevice:TDiskDevice;ASector,ACount:LongWord;var ABuffer):Boolean;
{Read Data from the Physical Device using either Cached or Direct access}
{Note: AllocDevicePage does all checks for Size, Sector and Count}
var
 Buffer:Pointer;
 Page:TCachePage;
 ReadCount:LongWord;
 OffsetCount:LongWord;
begin
 {}
 Result:=False;
 
 if FDriver = nil then Exit;
 if ADevice = nil then Exit;
 if ADevice.Controller = nil then Exit;
 
 {$IFDEF CACHE_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TIncrementalCache.DeviceRead: Device = ' + ADevice.Name + ' Sector = ' + IntToStr(ASector) + ' Count = ' + IntToStr(ACount));
 {$ENDIF}
 
 {Get Buffer}
 Buffer:=@ABuffer;
 while ACount > 0 do
  begin
   if not AcquireLock then Exit;
   try
    if (FCacheSize > 0) and (FCacheMode <> cmNONE) then
     begin
      {Read Cached}
      Inc(FReadCached);
      
      {Get Page}
      Page:=GetDevicePage(ADevice,ASector);
      if Page <> nil then
       begin
        {Found in Cache}
        Inc(FHitCount);
        
        {Get Count}
        OffsetCount:=ASector - Page.Sector;           {Offset from Page Sector to Read Sector}
        ReadCount:=Page.Count - OffsetCount;          {Number of Sectors to Read from Page}
        if ReadCount > ACount then ReadCount:=ACount;
        
        //To Do //PrepareDeviceRead
        
        {Read from Page to Buffer}
        System.Move(Pointer(PtrUInt(Page.Data) + (OffsetCount shl ADevice.SectorShiftCount))^,Buffer^,ReadCount shl ADevice.SectorShiftCount);
        
        {Update Page}
        Page.PageTime:=GetTickCount64;
        if not UpdateClean(Page) then Exit; {Does nothing if Dirty}
        
        {Update Count}
        Dec(ACount,ReadCount);
        
        {Update Buffer and Sector}
        if ACount > 0 then
         begin
          Inc(Buffer,ReadCount shl ADevice.SectorShiftCount);
          Inc(ASector,ReadCount);
         end; 
        
        Result:=True;
       end
      else
       begin
        {Not Found in Cache}
        Inc(FMissCount);
        
        {Allocate a Page}
        Page:=AllocDevicePage(ADevice,ASector,False);
        if Page <> nil then
         begin
          {Allocate Succeeded}
          Inc(FSuccessCount);
          
          {Get Count}
          OffsetCount:=ASector - Page.Sector;           {Offset from Page Sector to Read Sector}
          ReadCount:=Page.Count - OffsetCount;          {Number of Sectors to Read from Page}
          if ReadCount > ACount then ReadCount:=ACount; 
          
          //To Do //PrepareDeviceRead
          
          {Read from Device to Page}
          if not ADevice.Controller.Read(ADevice,Page.Sector,Page.Count,Page.Data^) then Exit;
          
          {Read from Page to Buffer}
          System.Move(Pointer(PtrUInt(Page.Data) + (OffsetCount shl ADevice.SectorShiftCount))^,Buffer^,ReadCount shl ADevice.SectorShiftCount);
          
          {PageTime updated by AllocDevicePage}
         end
        else
         begin
          {Allocate Failed}
          Inc(FFailCount);

          {Get Count}
          ReadCount:=ACount;
          if not CalculateDevicePage(ADevice,ASector,ReadCount) then Exit;
          
          {Direct Read}
          if not ADevice.Controller.Read(ADevice,ASector,ReadCount,Buffer^) then Exit;
         end;
         
        {Update Count}
        Dec(ACount,ReadCount);
        
        {Update Buffer and Sector}
        if ACount > 0 then
         begin
          Inc(Buffer,ReadCount shl ADevice.SectorShiftCount);
          Inc(ASector,ReadCount);
         end; 
        
        Result:=True;
       end;
     end
    else
     begin
      {No Cache}
      Inc(FReadDirect);
      
      {Direct Read}
      Result:=ADevice.Controller.Read(ADevice,ASector,ACount,Buffer^);
      
      {Update Count}
      Dec(ACount,ACount);
     end;
   finally
    ReleaseLock;
   end;
  end; 
end;

{==============================================================================}

function TIncrementalCache.DeviceWrite(ADevice:TDiskDevice;ASector,ACount:LongWord;const ABuffer):Boolean;
{Write Data to the Physical Device using either Cached or Direct access}
{Note: AllocDevicePage does all checks for Size, Sector and Count}
var
 Buffer:Pointer;
 Page:TCachePage;
 WriteCount:LongWord;
 OffsetCount:LongWord;
begin
 {}
 Result:=False;
 
 if FDriver = nil then Exit;
 if ADevice = nil then Exit;
 if ADevice.Controller = nil then Exit;
 
 {$IFDEF CACHE_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('THashCache.DeviceWrite: Device = ' + ADevice.Name + ' Sector = ' + IntToStr(ASector) + ' Count = ' + IntToStr(ACount));
 {$ENDIF}
 
 {Get Buffer}
 Buffer:=@ABuffer;
 while ACount > 0 do
  begin
   if not AcquireLock then Exit;
   try
    if (FCacheSize > 0) and (FCacheMode <> cmNONE) then
     begin
      if (FCacheMode = cmREADWRITE) and (ADevice.Removable = False) then
       begin
        {Write Back Cached}
        Inc(FWriteBack);
        
        {Get Page}
        Page:=GetDevicePage(ADevice,ASector);
        if Page <> nil then
         begin
          {Found in Cache}
          Inc(FHitCount);
          
          {Get Count}
          OffsetCount:=ASector - Page.Sector;             {Offset from Page Sector to Write Sector}
          WriteCount:=Page.Count - OffsetCount;           {Number of Sectors to Write to Page}
          if WriteCount > ACount then WriteCount:=ACount;
          
          //To Do //PrepareDeviceWrite
          
          {Write to Page from Buffer}
          System.Move(Buffer^,Pointer(PtrUInt(Page.Data) + (OffsetCount shl ADevice.SectorShiftCount))^,WriteCount shl ADevice.SectorShiftCount);
          
          //To Do //CompleteDeviceWrite
          
          {Update Page}
          Page.PageTime:=GetTickCount64;
          if Page.PageState <> psDIRTY then Page.WriteTime:=GetTickCount64;
          if not AddDirty(Page) then Exit;
          
          {Update State}
          FCacheState:=csDIRTY;
          
          {Update Count}
          Dec(ACount,WriteCount);
          
          {Update Buffer and Sector}
          if ACount > 0 then
           begin
            Inc(Buffer,WriteCount shl ADevice.SectorShiftCount);
            Inc(ASector,WriteCount);
           end; 
           
          Result:=True;
         end
        else
         begin
          {Not Found in Cache}
          Inc(FMissCount);
          
          {Allocate a Page}
          Page:=AllocDevicePage(ADevice,ASector,True);
          if Page <> nil then
           begin
            {Allocate Succeeded}
            Inc(FSuccessCount);
            
            {Get Count}
            OffsetCount:=ASector - Page.Sector;             {Offset from Page Sector to Write Sector}
            WriteCount:=Page.Count - OffsetCount;           {Number of Sectors to Write to Page}
            if WriteCount > ACount then WriteCount:=ACount;
            
            {Check for less than Page}
            if WriteCount < Page.Count then
             begin
              {Prepare Page for Write}
              if not PrepareDeviceWrite(ADevice,Page,ASector,WriteCount) then Exit;
             end;
            
            {Write to Page from Buffer}
            System.Move(Buffer^,Pointer(PtrUInt(Page.Data) + (OffsetCount shl ADevice.SectorShiftCount))^,WriteCount shl ADevice.SectorShiftCount);
            
            //To Do //CompleteDeviceWrite
            
            {PageTime and WriteTime updated by AllocDevicePage}
            
            {Update State}
            FCacheState:=csDIRTY;
           end
          else
           begin
            {Allocate Failed}
            Inc(FFailCount);
    
            {Get Count}
            WriteCount:=ACount;
            if not CalculateDevicePage(ADevice,ASector,WriteCount) then Exit;
    
            {Direct Write}
            if not ADevice.Controller.Write(ADevice,ASector,WriteCount,Buffer^) then Exit;
           end;
           
          {Update Count}
          Dec(ACount,WriteCount);
          
          {Update Buffer and Sector}
          if ACount > 0 then
           begin
            Inc(Buffer,WriteCount shl ADevice.SectorShiftCount);
            Inc(ASector,WriteCount);
           end; 
          
          Result:=True;
         end;
       end
      else
       begin
        {Write Through Cached (ReadOnly Cache or Removable Device)}
        Inc(FWriteThrough);
        
        {Get Page}
        Page:=GetDevicePage(ADevice,ASector);
        if Page <> nil then
         begin
          {Found in Cache}
          Inc(FHitCount);
          
          {Get Count}
          OffsetCount:=ASector - Page.Sector;             {Offset from Page Sector to Write Sector}
          WriteCount:=Page.Count - OffsetCount;           {Number of Sectors to Write to Page}
          if WriteCount > ACount then WriteCount:=ACount;
          
          //To Do //PrepareDeviceWrite
          
          {Write to Page from Buffer}
          System.Move(Buffer^,Pointer(PtrUInt(Page.Data) + (OffsetCount shl ADevice.SectorShiftCount))^,WriteCount shl ADevice.SectorShiftCount);
          
          //To Do //CompleteDeviceWrite
          
          {Write from Page to Device}
          if not ADevice.Controller.Write(ADevice,(Page.Sector + OffsetCount),WriteCount,Pointer(PtrUInt(Page.Data) + (OffsetCount shl ADevice.SectorShiftCount))^) then Exit;
          
          {Update Page}
          Page.PageTime:=GetTickCount64;
          if not UpdateClean(Page) then Exit; {Read Only Page is always Clean}
          
          {Update Count}
          Dec(ACount,WriteCount);
          
          {Update Buffer and Sector}
          if ACount > 0 then
           begin
            Inc(Buffer,WriteCount shl ADevice.SectorShiftCount);
            Inc(ASector,WriteCount);
           end; 
          
          Result:=True;
         end
        else
         begin
          {Not Found in Cache}
          Inc(FMissCount);
          
          {Allocate a Page}
          Page:=AllocDevicePage(ADevice,ASector,False); {Allocate Clean}
          if Page <> nil then
           begin
            {Allocate Succeeded}
            Inc(FSuccessCount);
            
            {Get Count}
            OffsetCount:=ASector - Page.Sector;             {Offset from Page Sector to Write Sector}
            WriteCount:=Page.Count - OffsetCount;           {Number of Sectors to Write to Page}
            if WriteCount > ACount then WriteCount:=ACount;
            
            {Check for less than Page}
            if WriteCount < Page.Count then
             begin
              {Prepare Page for Write}
              if not PrepareDeviceWrite(ADevice,Page,ASector,WriteCount) then Exit;
             end;
            
            {Write to Page from Buffer}
            System.Move(Buffer^,Pointer(PtrUInt(Page.Data) + (OffsetCount shl ADevice.SectorShiftCount))^,WriteCount shl ADevice.SectorShiftCount);
            
            //To Do //CompleteDeviceWrite
            
            {Write from Page to Device}
            if not ADevice.Controller.Write(ADevice,(Page.Sector + OffsetCount),WriteCount,Pointer(PtrUInt(Page.Data) + (OffsetCount shl ADevice.SectorShiftCount))^) then Exit;
  
            {PageTime updated by AllocDevicePage}
           end
          else
           begin
            {Allocate Failed}
            Inc(FFailCount);
        
            {Get Count}
            WriteCount:=ACount;
            if not CalculateDevicePage(ADevice,ASector,WriteCount) then Exit;
        
            {Direct Write}
            if not ADevice.Controller.Write(ADevice,ASector,WriteCount,Buffer^) then Exit;
           end;
           
          {Update Count}
          Dec(ACount,WriteCount);
          
          {Update Buffer and Sector}
          if ACount > 0 then
           begin
            Inc(Buffer,WriteCount shl ADevice.SectorShiftCount);
            Inc(ASector,WriteCount);
           end; 
          
          Result:=True;
         end;
       end;
     end
    else
     begin
      {No Cache}
      Inc(FWriteDirect);
      
      {Direct Write}
      Result:=ADevice.Controller.Write(ADevice,ASector,ACount,Buffer^);
      
      {Update Count}
      Dec(ACount,ACount);
     end;
   finally
    ReleaseLock;
   end;
  end; 
end;

{==============================================================================}

function TIncrementalCache.DeviceErase(ADevice:TDiskDevice;ASector,ACount:LongWord):Boolean;
{Erase Data from the Physical Device and update cached pages accordingly}
var
 Page:TCachePage;
 EraseCount:LongWord;
 OffsetCount:LongWord;
begin
 {}
 Result:=False;
 
 if FDriver = nil then Exit;
 if ADevice = nil then Exit;
 if ADevice.Controller = nil then Exit;
 
 {$IFDEF CACHE_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TIncrementalCache.DeviceErase: Device = ' + ADevice.Name + ' Sector = ' + IntToStr(ASector) + ' Count = ' + IntToStr(ACount));
 {$ENDIF}
 
 {Check Count}
 while ACount > 0 do
  begin
   if not AcquireLock then Exit;
   try
    if (FCacheSize > 0) and (FCacheMode <> cmNONE) then
     begin
      {Get Page}
      Page:=GetDevicePage(ADevice,ASector);
      if Page <> nil then
       begin
        {Found in Cache}
        {Get Count}
        OffsetCount:=ASector - Page.Sector;             {Offset from Page Sector to Erase Sector}
        EraseCount:=Page.Count - OffsetCount;           {Number of Sectors to Erase from Page}
        if EraseCount > ACount then EraseCount:=ACount;
 
        {Erase from Device}
        if not ADevice.Controller.Erase(ADevice,ASector,EraseCount) then Exit;
        
        {Check for Dirty}
        if Page.PageState = psDIRTY then
         begin
          {Flush Page}
          if not FlushPage(Page) then Exit;
         end;
         
        {Discard Page}
        if not DiscardPage(Page) then Exit;
        
        {Update Count}
        Dec(ACount,EraseCount);
    
        {Update Sector}
        if ACount > 0 then
         begin
          Inc(ASector,EraseCount);
         end; 
    
        Result:=True;
       end
      else
       begin
        {Not Found in Cache}
        {Get Count}
        EraseCount:=ACount;
        if not CalculateDevicePage(ADevice,ASector,EraseCount) then Exit;
        
        {Erase from Device}
        if not ADevice.Controller.Erase(ADevice,ASector,EraseCount) then Exit;
        
        {Update Count}
        Dec(ACount,EraseCount);
    
        {Update Sector}
        if ACount > 0 then
         begin
          Inc(ASector,EraseCount);
         end; 
    
        Result:=True;
       end;
     end
    else
     begin
      {Not Cached}
      {Direct Erase}
      Result:=ADevice.Controller.Erase(ADevice,ASector,ACount);
      
      {Update Count}
      Dec(ACount,ACount);
     end;
   finally
    ReleaseLock;
   end;
  end; 
end;

{==============================================================================}

function TIncrementalCache.GetDevicePage(ADevice:TDiskDevice;ASector:LongWord):TCachePage;
{Get the Clean or Dirty Page that contains this Sector on this Device}
var
 Page:TCachePage;
 KeyHash:LongWord;
 SectorStart:LongWord;
begin
 {}
 Result:=nil;
 
 if not AcquireLock then Exit;
 try
  {$IFDEF CACHE_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TIncrementalCache.GetDevicePage: Sector = ' + IntToStr(ASector));
  {$ENDIF}
  
  if FDriver = nil then Exit;
  if ADevice = nil then Exit;
  if ADevice.PageCount = 0 then Exit;

  {Get Hash}
  SectorStart:=(ASector and ADevice.PageMask);
  KeyHash:=(SectorStart shr ADevice.PageShift);
  
  {$IFDEF CACHE_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TIncrementalCache.GetDevicePage: SectorStart = ' + IntToStr(SectorStart) + ' KeyHash = ' + IntToStr(KeyHash));
  {$ENDIF}

  {Check Pages}
  Page:=KeyFirst(KeyHash);
  while Page <> nil do
   begin
    {Check Page Type and Device}
    if (Page.PageType = ptDEVICE) and (Page.Device = ADevice) then
     begin
      {Check Page Sector}
      if Page.Sector = SectorStart then
       begin
        {$IFDEF CACHE_DEBUG}
        if FILESYS_LOG_ENABLED then FileSysLogDebug('TIncrementalCache.GetDevicePage: Page.Sector = ' + IntToStr(Page.Sector) + ' Page.Count = ' + IntToStr(Page.Count));
        {$ENDIF}
        
        Result:=Page;
        Exit;
       end;
     end;
     
    Page:=THashCachePage(Page).KeyNext;
   end;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function TIncrementalCache.GetEmptyPage:TCachePage;
{Get the First Empty Page, Discard First Clean Page if none Empty}
begin
 {}
 Result:=nil;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;

  {Get First Empty Page}
  Result:=FFirstEmpty;
  if Result <> nil then Exit;

  {If no Empty then Discard Oldest}
  if not DiscardCache(True,False) then Exit;

  {Get First Empty Page}
  Result:=FFirstEmpty;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function TIncrementalCache.AllocDevicePage(ADevice:TDiskDevice;ASector:LongWord;AWrite:Boolean):TCachePage;
{Allocate an Empty Page to the Device and mark as Clean or Dirty}
var
 Page:TCachePage;
 SectorCount:Word;
 SectorStart:LongWord;
begin
 {}
 Result:=nil;
 
 if not AcquireLock then Exit;
 try
  {$IFDEF CACHE_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TIncrementalCache.AllocDevicePage: Sector = ' + IntToStr(ASector));
  {$ENDIF}
  
  if FDriver = nil then Exit;
  if ADevice = nil then Exit;

  {Check for Sector Size bigger than Page Size}
  if ADevice.SectorSize = 0 then Exit;
  if ADevice.SectorSize > FPageSize then Exit;
  if ASector >= ADevice.SectorCount then Exit;

  {Calculate Page Count / Shift / Mask}
  if ADevice.PageCount = 0 then
   begin
    ADevice.PageCount:=CalculatePageCount(ADevice);
    if ADevice.PageCount = 0 then Exit;
    ADevice.PageShift:=CalculatePageShift(ADevice);
    ADevice.PageMask:=CalculatePageMask(ADevice);
    
    {$IFDEF CACHE_DEBUG}
    if FILESYS_LOG_ENABLED then
     begin
      FileSysLogDebug('TIncrementalCache.AllocDevicePage: Device = ' + ADevice.Name);
      FileSysLogDebug('TIncrementalCache.AllocDevicePage:  PageCount = ' + IntToStr(ADevice.PageCount));
      FileSysLogDebug('TIncrementalCache.AllocDevicePage:  PageShift = ' + IntToStr(ADevice.PageShift));
      FileSysLogDebug('TIncrementalCache.AllocDevicePage:  PageMask = ' + IntToHex(ADevice.PageMask,8));
     end;
    {$ENDIF}
   end;

  {Calculate Sector Count and Start Sector}
  SectorCount:=ADevice.PageCount;
  SectorStart:=(ASector and ADevice.PageMask);
  if (SectorStart + SectorCount) > ADevice.SectorCount then
   begin
    SectorCount:=(ADevice.SectorCount - SectorStart);
   end;
   
  {$IFDEF CACHE_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TIncrementalCache.AllocDevicePage: SectorCount = ' + IntToStr(SectorCount) + ' SectorStart = ' + IntToStr(SectorStart));
  {$ENDIF}

  {Get Empty Page}
  Page:=GetEmptyPage;
  if Page <> nil then
   begin
    THashCachePage(Page).KeyHash:=(SectorStart shr ADevice.PageShift);
    
    {$IFDEF CACHE_DEBUG}
    if FILESYS_LOG_ENABLED then FileSysLogDebug('TIncrementalCache.AllocDevicePage: KeyHash = ' + IntToStr(THashCachePage(Page).KeyHash));
    {$ENDIF}
    
    if AWrite then
     begin
      if AddDirty(Page) then
       begin
        Page.Device:=ADevice;
        Page.Sector:=SectorStart;
        Page.Count:=SectorCount;
        Page.PageTime:=GetTickCount64;
        Page.WriteTime:=GetTickCount64;
        Page.PageType:=ptDEVICE;
        TIncrementalCachePage(Page).ReadSector:=0;
        TIncrementalCachePage(Page).ReadCount:=0;
        TIncrementalCachePage(Page).DirtySector:=0;
        TIncrementalCachePage(Page).DirtyCount:=0;
        
        Result:=Page;
       end;
     end
    else
     begin
      if AddClean(Page) then
       begin
        Page.Device:=ADevice;
        Page.Sector:=SectorStart;
        Page.Count:=SectorCount;
        Page.PageTime:=GetTickCount64;
        Page.PageType:=ptDEVICE;
        TIncrementalCachePage(Page).ReadSector:=0;
        TIncrementalCachePage(Page).ReadCount:=0;
        TIncrementalCachePage(Page).DirtySector:=0;
        TIncrementalCachePage(Page).DirtyCount:=0;
        
        Result:=Page;
       end;
     end;
   end
  else
   begin
    {If no Empty Page then Flush}
    if FlushCache(True,False) then
     begin
      {Get Empty Page}
      Page:=GetEmptyPage;
      if Page <> nil then
       begin
        THashCachePage(Page).KeyHash:=(SectorStart shr ADevice.PageShift);
        
        {$IFDEF CACHE_DEBUG}
        if FILESYS_LOG_ENABLED then FileSysLogDebug('TIncrementalCache.AllocDevicePage: KeyHash = ' + IntToStr(THashCachePage(Page).KeyHash));
        {$ENDIF}
        
        if AWrite then
         begin
          if AddDirty(Page) then
           begin
            Page.Device:=ADevice;
            Page.Sector:=SectorStart;
            Page.Count:=SectorCount;
            Page.PageTime:=GetTickCount64;
            Page.WriteTime:=GetTickCount64;
            Page.PageType:=ptDEVICE;
            TIncrementalCachePage(Page).ReadSector:=0;
            TIncrementalCachePage(Page).ReadCount:=0;
            TIncrementalCachePage(Page).DirtySector:=0;
            TIncrementalCachePage(Page).DirtyCount:=0;
            
            Result:=Page;
           end;
         end
        else
         begin
          if AddClean(Page) then
           begin
            Page.Device:=ADevice;
            Page.Sector:=SectorStart;
            Page.Count:=SectorCount;
            Page.PageTime:=GetTickCount64;
            Page.PageType:=ptDEVICE;
            TIncrementalCachePage(Page).ReadSector:=0;
            TIncrementalCachePage(Page).ReadCount:=0;
            TIncrementalCachePage(Page).DirtySector:=0;
            TIncrementalCachePage(Page).DirtyCount:=0;
            
            Result:=Page;
           end;
         end;
       end;
     end;
   end;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function TIncrementalCache.DiscardPage(APage:TCachePage):Boolean;
{Return a Clean Page to Empty}
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if APage = nil then Exit;
  
  {Check for Clean}
  if APage.PageState = psCLEAN then
   begin
    if not AddEmpty(APage) then Exit;
    
    Inc(FDiscardCount);
    
    APage.Device:=nil;
    APage.Sector:=0;
    APage.Count:=0;
    APage.PageTime:=0;
    APage.WriteTime:=0;
    APage.PageType:=ptNONE;
    TIncrementalCachePage(APage).ReadSector:=0;
    TIncrementalCachePage(APage).ReadCount:=0;
    TIncrementalCachePage(APage).DirtySector:=0;
    TIncrementalCachePage(APage).DirtyCount:=0;
    
    Result:=True;
   end
  else
   begin
    {Return a Non Clean Page to Unknown}
    if not AddUnknown(APage) then Exit;
    
    Inc(FUnknownCount);
    
    Result:=True;
   end;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function TIncrementalCache.DiscardCache(AFirst,AAll:Boolean):Boolean;
{Find any Clean Pages older than DiscardTimeout and Discard them}
var
 CurrentTime:Int64;
 NextPage:TCachePage;
 CurrentPage:TCachePage;
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  
  {Get Counter}
  CurrentTime:=GetTickCount64;
  
  {Check Clean Pages}
  NextPage:=FFirstClean;
  while NextPage <> nil do
   begin
    CurrentPage:=NextPage;
    NextPage:=NextPage.NextLink;
    if (AFirst) or (AAll) or ((CurrentPage.PageTime + FDiscardTimeout) < CurrentTime) then
     begin
      DiscardPage(CurrentPage);
      if AFirst then Break; {Discard only the First Page}
     end
    else
     begin
      Break; {No more pages old enough to Discard}
     end;
   end;
   
  Result:=True;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function TIncrementalCache.ReleaseDevicePages(ADevice:TDiskDevice):Boolean;
{Return all Clean or Dirty Pages on the Device to Empty}
var
 NextPage:TCachePage;
 CurrentPage:TCachePage;
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if ADevice = nil then Exit;
  
  {Flush Dirty Pages}
  NextPage:=FFirstDirty;
  while NextPage <> nil do
   begin
    CurrentPage:=NextPage;
    NextPage:=NextPage.NextLink;
    
    if (CurrentPage.PageType = ptDEVICE) and (CurrentPage.Device = ADevice) then
     begin
      FlushPage(CurrentPage);
     end;
   end;
  
  {Discard Clean Pages}
  NextPage:=FFirstClean;
  while NextPage <> nil do
   begin
    CurrentPage:=NextPage;
    NextPage:=NextPage.NextLink;
    
    if (CurrentPage.PageType = ptDEVICE) and (CurrentPage.Device = ADevice) then
     begin
      DiscardPage(CurrentPage);
     end;
   end;
  
  Result:=True;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function TIncrementalCache.FlushPage(APage:TCachePage):Boolean;
{Return a Dirty Page to Clean}
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if APage = nil then Exit;

  {Unschedule Page}
  UnschedulePage(APage);
  
  {Check for Dirty}
  if APage.PageState = psDIRTY then
   begin
    {Check Sector Count}
    if APage.Count > 0 then
     begin
      case APage.PageType of
       ptNONE:begin
         {Return a Page with no Type to Clean}
         if not AddClean(APage) then Exit;
         Inc(FFlushCount);
         APage.WriteTime:=0;
         TIncrementalCachePage(APage).DirtySector:=0;
         TIncrementalCachePage(APage).DirtyCount:=0;
         
         Result:=True;
        end;
       ptDEVICE:begin
         {Write Page to Device}
         if APage.Device = nil then Exit;
         if APage.Device.Controller = nil then Exit;
         if not APage.Device.Controller.Write(APage.Device,APage.Sector,APage.Count,APage.Data^) then Exit;
         
         {Return to Clean}
         if not AddClean(APage) then Exit;
         Inc(FFlushCount);
         APage.WriteTime:=0;
         TIncrementalCachePage(APage).DirtySector:=0;
         TIncrementalCachePage(APage).DirtyCount:=0;
         
         Result:=True;
        end;
      end;
     end
    else
     begin
      {Return a 0 Sector Page to Clean}
      if not AddClean(APage) then Exit;
      Inc(FFlushCount);
      APage.WriteTime:=0;
      TIncrementalCachePage(APage).DirtySector:=0;
      TIncrementalCachePage(APage).DirtyCount:=0;
      
      Result:=True;
     end;
   end
  else
   begin
    {Return a Non Dirty Page to Unknown}
    if not AddUnknown(APage) then Exit;
    Inc(FUnknownCount);
    APage.WriteTime:=0;
    TIncrementalCachePage(APage).DirtySector:=0;
    TIncrementalCachePage(APage).DirtyCount:=0;
    
    Result:=True;
   end;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function TIncrementalCache.FlushPageEx(APage:TCachePage):Boolean;
{Return a Dirty Page to Clean if it is older than FlushTimeout}

{Note: Only called by CacheThread with page scheduled from CacheTimer}
var
 Page:TCachePage;
begin
 {}
 Result:=False;

 {$IFDEF CACHE_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('TIncrementalCache.FlushPageEx (Page=' + PtrToHex(APage) + ' FirstDirty=' + PtrToHex(FFirstDirty) + ')');
 {$ENDIF}
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  if APage = nil then Exit;
 
  {Check Page}
  Page:=FFirstDirty;
  if APage <> Page then
   begin
    {Find Page}
    while Page <> nil do
     begin
      if Page = APage then Break;
      {Get Next}
      Page:=Page.NextLink;
     end;
   end;  
  
  {Check Page}
  if (APage = Page) and ((APage.WriteTime + FFlushTimeout) <= GetTickCount64) then
   begin
    {Check for Dirty}
    if APage.PageState = psDIRTY then
     begin
      {Check Sector Count}
      if APage.Count > 0 then
       begin
        case APage.PageType of
         ptNONE:begin
           {Return a Page with no Type to Clean}
           if not AddClean(APage) then Exit;
           Inc(FFlushCount);
           APage.WriteTime:=0;
           TIncrementalCachePage(APage).DirtySector:=0;
           TIncrementalCachePage(APage).DirtyCount:=0;
           
           Result:=True;
          end;
         ptDEVICE:begin
           {Write Page to Device}
           if APage.Device = nil then Exit;
           if APage.Device.Controller = nil then Exit;
           if not APage.Device.Controller.Write(APage.Device,APage.Sector,APage.Count,APage.Data^) then Exit;
           
           {Return to Clean}
           if not AddClean(APage) then Exit;
           Inc(FFlushCount);
           APage.WriteTime:=0;
           TIncrementalCachePage(APage).DirtySector:=0;
           TIncrementalCachePage(APage).DirtyCount:=0;
           
           Result:=True;
          end;
        end;
       end
      else
       begin
        {Return a 0 Sector Page to Clean}
        if not AddClean(APage) then Exit;
        Inc(FFlushCount);
        APage.WriteTime:=0;
        TIncrementalCachePage(APage).DirtySector:=0;
        TIncrementalCachePage(APage).DirtyCount:=0;
        
        Result:=True;
       end;
     end
    else
     begin
      {Return a Non Dirty Page to Unknown}
      if not AddUnknown(APage) then Exit;
      Inc(FUnknownCount);
      APage.WriteTime:=0;
      TIncrementalCachePage(APage).DirtySector:=0;
      TIncrementalCachePage(APage).DirtyCount:=0;
      
      Result:=True;
     end;
     
    {Update Cache State}
    if FFirstDirty = nil then FCacheState:=csCLEAN;
  {$IFDEF CACHE_DEBUG}    
   end
  else
   begin
    if APage <> Page then
     begin
      if FILESYS_LOG_ENABLED then FileSysLogDebug('TIncrementalCache.FlushPageEx - Non Dirty Page (Page=' + PtrToHex(APage) + ' Dirty=' + PtrToHex(Page) + ')');
     end
    else
     begin
      if FILESYS_LOG_ENABLED then FileSysLogDebug('TIncrementalCache.FlushPageEx - Not Ready Page (Page=' + PtrToHex(APage) + ' WriteTime=' + IntToStr(APage.WriteTime) + ' TickCount=' + IntToStr(GetTickCount64) + ')'); 
     end;
  {$ENDIF}   
   end;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}

function TIncrementalCache.FlushCache(AFirst,AAll:Boolean):Boolean;
{Find any Dirty Pages older than FlushTimeout and Flush them}
var
 CurrentTime:Int64;
 NextPage:TCachePage;
 CurrentPage:TCachePage;
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  if FDriver = nil then Exit;
  
  {Check Cache State}
  if FCacheState = csDIRTY then
   begin
    {Get Counter}
    CurrentTime:=GetTickCount64;
    
    {Check Dirty Pages}
    NextPage:=FFirstDirty;
    while NextPage <> nil do
     begin
      CurrentPage:=NextPage;
      NextPage:=NextPage.NextLink;
      
      if (AFirst) or (AAll) or ((CurrentPage.WriteTime + FFlushTimeout) < CurrentTime) then
       begin
        FlushPage(CurrentPage);
        
        if AFirst then Break; {Flush only the First Page}
       end
      else
       begin
        Break; {No more pages old enough to Flush}
       end;
     end;
     
    {Update Cache State}
    if FFirstDirty = nil then FCacheState:=csCLEAN;
   end;
   
  Result:=True;
 finally
  ReleaseLock;
 end;
end;

{==============================================================================}
   
function TIncrementalCache.CheckTimer:Boolean;
begin
 {}
 Result:=False;
 
 {Check Timer}
 if FTimer = nil then Exit;

 {Check Timer}
 Result:=FTimer.CheckTimer;
end;

{==============================================================================}

function TIncrementalCache.ProcessTimer:Boolean;
begin
 {}
 Result:=False;
 
 {Check Timer}
 if FTimer = nil then Exit;

 {Process Timer}
 Result:=FTimer.ProcessTimer;
end;

{==============================================================================}
   
function TIncrementalCache.SchedulePage(APage:TCachePage;ATimeout:LongWord):Boolean;
begin
 {}
 Result:=False;
 
 {Check Timer}
 if FTimer = nil then Exit;
 
 {Check Page}
 {if APage = nil then Exit;} {Do not check}
 
 {Schedule Page}
 Result:=FTimer.SchedulePage(APage,ATimeout);
end;

{==============================================================================}

function TIncrementalCache.UnschedulePage(APage:TCachePage):Boolean; 
begin
 {}
 Result:=False;
 
 {Check Timer}
 if FTimer = nil then Exit;
 
 {Check Page}
 {if APage = nil then Exit;} {Do not check}
 
 {Unschedule Page}
 Result:=FTimer.UnschedulePage(APage);
end;

{==============================================================================}
{==============================================================================}
{TCachePage}
constructor TCachePage.Create;
begin
 {}
 inherited Create;
 FDevice:=nil;

 FData:=nil;

 FSector:=0;
 FCount:=0;

 FPageTime:=0;
 FWriteTime:=0;
 FPageType:=ptNONE;
 FPageState:=psUNKNOWN;

 FPrevPage:=nil;
 FNextPage:=nil;
 
 FPrevLink:=nil;
 FNextLink:=nil;
end;

{==============================================================================}

destructor TCachePage.Destroy;
begin
 {}
 FPrevLink:=nil;
 FNextLink:=nil;
 
 FPrevPage:=nil;
 FNextPage:=nil;

 FData:=nil;

 FDevice:=nil;
 inherited Destroy;
end;

{==============================================================================}
{==============================================================================}
{THashCachePage}
 {Nothing}
 
{==============================================================================}
{==============================================================================}
{TIncrementalCachePage}
function TIncrementalCachePage.ReadData:Pointer;
begin
 {}
 Result:=nil;
 //To Do
end;

{==============================================================================}

function TIncrementalCachePage.DirtyData:Pointer;
begin
 {}
 Result:=nil;
 //To Do
end;

{==============================================================================}
{==============================================================================}
{TCacheTimer}
constructor TCacheTimer.Create(ACache:TCache);
begin
 {}
 inherited Create;
 FCache:=ACache;
 
 FLock:=MutexCreate;
 FInterval:=0;
 FCheckTimer:=INVALID_HANDLE_VALUE;
 FProcessSemaphore:=INVALID_HANDLE_VALUE;
 
 FCount:=0;
 FMaxCount:=0;
 
 FFirst:=nil;
 FLast:=nil;
end;

{==============================================================================}

destructor TCacheTimer.Destroy; 
begin
 {}
 AcquireLock;
 try
  if FProcessSemaphore <> INVALID_HANDLE_VALUE then SemaphoreDestroy(FProcessSemaphore);
  FProcessSemaphore:=INVALID_HANDLE_VALUE;
  if FCheckTimer <> INVALID_HANDLE_VALUE then TimerDestroy(FCheckTimer);
  FCheckTimer:=INVALID_HANDLE_VALUE;
  
  FFirst:=nil;
  FLast:=nil;
  inherited Destroy;
 finally 
  ReleaseLock; {Cannot destroy Mutex while holding lock} 
  MutexDestroy(FLock);
 end; 
end;

{==============================================================================}

function TCacheTimer.AcquireLock:Boolean;
begin
 {}
 Result:=(MutexLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TCacheTimer.ReleaseLock:Boolean;
begin
 {}
 Result:=(MutexUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TCacheTimer.Dequeue(AMax:Integer):TCachePage;
{Get and remove the first page from the timer list if the key is less than or equal to Max}
{Max: The maximum value of the key for the page to be dequeued}
{Return: Dequeued Page or nil on non ready or failure}
var
 Item:PCacheTimerItem;
begin
 {}
 Result:=nil;

 if not AcquireLock then Exit;
 try
  {Get Item (First)}
  Item:=FFirst;
  if Item <> nil then
   begin
    {Check Key}
    if Item.Key <= AMax then
     begin
      {Remove First}
      FFirst:=Item.Next;
      
      {Check Next}
      if Item.Next = nil then
       begin
        FLast:=nil;
       end
      else
       begin
        Item.Next.Prev:=nil;
       end;
      
      {Check First}
      if FFirst <> nil then
       begin
        {Update Key}
        Inc(FFirst.Key,Item.Key);
       end;
      
      {Decrement Count}
      Dec(FCount);
      
      {Return Result}
      Result:=TCachePage(Item.Page);
      
      {Release Item}
      FreeMem(Item);
     end;
   end;
 finally
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TCacheTimer.FirstKey:Integer;
{Get the first Key value from the timer list}
{Return: First Key value from timer list or CACHE_TIMER_KEY_NONE on failure}
var
 Item:PCacheTimerItem;
begin
 {}
 Result:=CACHE_TIMER_KEY_NONE;
 
 if not AcquireLock then Exit;
 try
  {Get Item (First)}
  Item:=FFirst;
  if Item <> nil then
   begin
    {Return Key}
    Result:=Item.Key;
   end;
 finally
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TCacheTimer.InsertKey(APage:TCachePage;AKey:Integer):Boolean;
{Insert the supplied page in the timer list in delta ascending order based on Key}
{Page: The page to be inserted}
{Key: The key to order the insertion on}
{Return: True if completed or False on failure}
var
 Offset:Integer;
 Item:PCacheTimerItem;
 Prev:PCacheTimerItem;
 Next:PCacheTimerItem;
begin
 {}
 Result:=False;
 
 {Check Key}
 if AKey = CACHE_TIMER_KEY_NONE then Exit;

 if not AcquireLock then Exit;
 try
  {Get Item}
  Item:=GetMem(SizeOf(TCacheTimerItem));
  if Item = nil then Exit;
  
  {Find Position}
  Offset:=0;
  Prev:=nil;
  Next:=FFirst;
  while Next <> nil do
   begin
    {Delta Ascending}
    if AKey < (Offset + Next.Key) then
     begin
      Dec(Next.Key,(AKey - Offset));
      Break; 
     end;
    Inc(Offset,Next.Key);  
    Prev:=Next;
    Next:=Next.Next; 
   end;
  
  {Insert Item}
  Item.Key:=(AKey - Offset);
  Item.Page:=APage;
  Item.Prev:=Prev;
  Item.Next:=Next;
  
  {Check Prev}
  if Prev = nil then
   begin
    FFirst:=Item;
    
    {Check Next}
    if Next = nil then
     begin
      FLast:=Item;
     end
    else
     begin
      Next.Prev:=Item;
     end;      
   end
  else
   begin
    Prev.Next:=Item;
    
    {Check Next}
    if Next = nil then
     begin
      FLast:=Item;
     end
    else
     begin
      Next.Prev:=Item;
     end;      
   end;
  
  {Increment Count}
  Inc(FCount);
  if FCount > FMaxCount then FMaxCount:=FCount;
  
  {Return Result} 
  Result:=True;       
 finally
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TCacheTimer.DeleteKey(APage:TCachePage):Boolean;
{Delete the supplied page from the timer list}
{Page: The page to be deleted}
{Return: True if completed or False on failure}
var
 Item:PCacheTimerItem;
 Prev:PCacheTimerItem;
 Next:PCacheTimerItem;
begin
 {}
 Result:=False;

 if not AcquireLock then Exit;
 try
  {Find Item}
  Item:=FFirst;
  while Item <> nil do
   begin
    if Item.Page = APage then
     begin
      Break;
     end;
     
    Item:=Item.Next;
   end;
   
  {Check Item}
  if Item <> nil then
   begin
    {Delete Element}
    {Get Prev/Next}
    Prev:=Item.Prev;
    Next:=Item.Next;
    {Check Prev}
    if Prev = nil then
     begin
      FFirst:=Next;
      
      {Check Next}
      if Next = nil then
       begin
        FLast:=nil;
       end
      else
       begin
        Next.Prev:=nil;
       end;    
     end
    else
     begin
      Prev.Next:=Next;
      
      {Check Next}
      if Next = nil then
       begin
        FLast:=Prev;
       end
      else
       begin
        Next.Prev:=Prev;
       end;
     end;  
     
    {Check Next}
    if Next <> nil then
     begin
      {Update Key}
      Inc(Next.Key,Item.Key);
     end;
     
    {Decrement Count}
    Dec(FCount);
     
    {Release Item}
    FreeMem(Item);
    
    {Return Result} 
    Result:=True;       
   end; 
 finally
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TCacheTimer.DecrementKey:Integer;
{Decrement the first Key value in the Timer list}
{Return: First Key value in timer list after decrement or CACHE_TIMER_KEY_NONE on failure}
var
 Item:PCacheTimerItem;
begin
 {}
 Result:=CACHE_TIMER_KEY_NONE;
 
 if not AcquireLock then Exit;
 try
  {Get Item (First)}
  Item:=FFirst;
  if Item <> nil then
   begin
    {Decrement Key}
    if Item.Key > (CACHE_TIMER_KEY_MIN + FInterval) then
     begin
      Dec(Item.Key,FInterval);
     end;
         
    {Return Result}
    Result:=Item.Key;
   end;
 finally
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TCacheTimer.StartTimer(AInterval:LongWord):Boolean;
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  {Check Cache}
  if FCache = nil then Exit;
  
  {Check Interval}
  if AInterval < 1 then Exit;
  
  {Check Timer/Semaphore}
  if FCheckTimer <> INVALID_HANDLE_VALUE then Exit;
  if FProcessSemaphore <> INVALID_HANDLE_VALUE then Exit;
  
  {Set Interval}
  FInterval:=AInterval;
  
  {Create Process Semaphore}
  FProcessSemaphore:=SemaphoreCreate(0);
  if FProcessSemaphore = INVALID_HANDLE_VALUE then Exit;
  
  {Create Check Timer}
  FCheckTimer:=TimerCreateEx(FInterval,TIMER_STATE_ENABLED,TIMER_FLAG_RESCHEDULE or TIMER_FLAG_WORKER,TTimerEvent(CacheCheckTimer),FCache); {Rescheduled Automatically}
  if FCheckTimer = INVALID_HANDLE_VALUE then
   begin
    {Destroy Process Semaphore}
    SemaphoreDestroy(FProcessSemaphore);
    FProcessSemaphore:=INVALID_HANDLE_VALUE;
    
    Exit;
   end; 
 
  {Return Result}
  Result:=True;
 finally
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TCacheTimer.StopTimer:Boolean;
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  {Check Timer/Semaphore}
  if FCheckTimer = INVALID_HANDLE_VALUE then Exit;
  if FProcessSemaphore = INVALID_HANDLE_VALUE then Exit;
  
  {Destroy Check Timer}
  if TimerDestroy(FCheckTimer) <> ERROR_SUCCESS then Exit;
  FCheckTimer:=INVALID_HANDLE_VALUE;

  {Destroy Process Semaphore}
  if SemaphoreDestroy(FProcessSemaphore) <> ERROR_SUCCESS then Exit;
  FProcessSemaphore:=INVALID_HANDLE_VALUE;
  
  {Reset Interval}
  FInterval:=0;
  
  {Return Result}
  Result:=True;
 finally
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TCacheTimer.CheckTimer:Boolean;
begin
 {}
 Result:=False;

 {Decrement Key}
 if DecrementKey <= 0 then
  begin
   {Signal Semaphore}
   Result:=(SemaphoreSignal(FProcessSemaphore) = ERROR_SUCCESS);
  end;
end;

{==============================================================================}

function TCacheTimer.ProcessTimer:Boolean;
var
 Page:TCachePage;
begin
 {}
 Result:=False;

 {Check Cache}
 if FCache = nil then Exit;
   
 {Wait Semaphore}
 if SemaphoreWait(FProcessSemaphore) = ERROR_SUCCESS then
  begin
   {Dequeue Page}
   Page:=Dequeue(0);
   while Page <> nil do
    begin
     {Flush Page}
     Result:=FCache.FlushPageEx(Page);
     if not Result then Exit;
     
     {Yield}
     Sleep(0);
     
     {Dequeue Page}
     Page:=Dequeue(0);
    end;
  end;
end;

{==============================================================================}

function TCacheTimer.SchedulePage(APage:TCachePage;ATimeout:LongWord):Boolean;
begin
 {}
 Result:=False;
 
 {Check Page}
 {if APage = nil then Exit;} {Do not check}

 {Check Timeout} 
 if ATimeout < 1 then ATimeout:=FInterval;

 {Insert Key}
 Result:=InsertKey(APage,ATimeout + FInterval); {Allow one extra interval to account for first decrement}
end;

{==============================================================================}

function TCacheTimer.UnschedulePage(APage:TCachePage):Boolean; 
begin
 {}
 Result:=False;
 
 {Check Page}
 {if APage = nil then Exit;} {Do not check}

 {Delete Key}
 Result:=DeleteKey(APage);
end; 

{==============================================================================}
{==============================================================================}
{THashCacheTimer}
constructor THashCacheTimer.Create(ACache:THashCache);
begin
 {}
 inherited Create;
 FCache:=ACache;
 
 FLock:=MutexCreate;
 FInterval:=0;
 FCheckTimer:=INVALID_HANDLE_VALUE;
 FProcessSemaphore:=INVALID_HANDLE_VALUE;
 
 FCount:=0;
 FMaxCount:=0;
 
 FFirst:=nil;
 FLast:=nil;
end;

{==============================================================================}

destructor THashCacheTimer.Destroy; 
begin
 {}
 AcquireLock;
 try
  if FProcessSemaphore <> INVALID_HANDLE_VALUE then SemaphoreDestroy(FProcessSemaphore);
  FProcessSemaphore:=INVALID_HANDLE_VALUE;
  if FCheckTimer <> INVALID_HANDLE_VALUE then TimerDestroy(FCheckTimer);
  FCheckTimer:=INVALID_HANDLE_VALUE;
  
  FFirst:=nil;
  FLast:=nil;
  inherited Destroy;
 finally 
  ReleaseLock; {Cannot destroy Mutex while holding lock} 
  MutexDestroy(FLock);
 end; 
end;

{==============================================================================}

function THashCacheTimer.AcquireLock:Boolean;
begin
 {}
 Result:=(MutexLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function THashCacheTimer.ReleaseLock:Boolean;
begin
 {}
 Result:=(MutexUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function THashCacheTimer.Dequeue(AMax:Integer):TCachePage;
{Get and remove the first page from the timer list if the key is less than or equal to Max}
{Max: The maximum value of the key for the page to be dequeued}
{Return: Dequeued Page or nil on non ready or failure}
var
 Item:PCacheTimerItem;
begin
 {}
 Result:=nil;

 if not AcquireLock then Exit;
 try
  {Get Item (First)}
  Item:=FFirst;
  if Item <> nil then
   begin
    {Check Key}
    if Item.Key <= AMax then
     begin
      {Remove First}
      FFirst:=Item.Next;
      
      {Check Next}
      if Item.Next = nil then
       begin
        FLast:=nil;
       end
      else
       begin
        Item.Next.Prev:=nil;
       end;
      
      {Check First}
      if FFirst <> nil then
       begin
        {Update Key}
        Inc(FFirst.Key,Item.Key);
       end;
      
      {Decrement Count}
      Dec(FCount);
      
      {Return Result}
      Result:=TCachePage(Item.Page);
      
      {Release Item}
      FreeMem(Item);
     end;
   end;
 finally
  ReleaseLock;
 end; 
end;

{==============================================================================}

function THashCacheTimer.FirstKey:Integer;
{Get the first Key value from the timer list}
{Return: First Key value from timer list or CACHE_TIMER_KEY_NONE on failure}
var
 Item:PCacheTimerItem;
begin
 {}
 Result:=CACHE_TIMER_KEY_NONE;
 
 if not AcquireLock then Exit;
 try
  {Get Item (First)}
  Item:=FFirst;
  if Item <> nil then
   begin
    {Return Key}
    Result:=Item.Key;
   end;
 finally
  ReleaseLock;
 end; 
end;

{==============================================================================}

function THashCacheTimer.InsertKey(APage:TCachePage;AKey:Integer):Boolean;
{Insert the supplied page in the timer list in delta ascending order based on Key}
{Page: The page to be inserted}
{Key: The key to order the insertion on}
{Return: True if completed or False on failure}
var
 Offset:Integer;
 Item:PCacheTimerItem;
 Prev:PCacheTimerItem;
 Next:PCacheTimerItem;
begin
 {}
 Result:=False;
 
 {Check Key}
 if AKey = CACHE_TIMER_KEY_NONE then Exit;

 if not AcquireLock then Exit;
 try
  {Get Item}
  Item:=GetMem(SizeOf(TCacheTimerItem));
  if Item = nil then Exit;
  
  {Find Position}
  Offset:=0;
  Prev:=nil;
  Next:=FFirst;
  while Next <> nil do
   begin
    {Delta Ascending}
    if AKey < (Offset + Next.Key) then
     begin
      Dec(Next.Key,(AKey - Offset));
      Break; 
     end;
    Inc(Offset,Next.Key);  
    Prev:=Next;
    Next:=Next.Next; 
   end;
  
  {Insert Item}
  Item.Key:=(AKey - Offset);
  Item.Page:=APage;
  Item.Prev:=Prev;
  Item.Next:=Next;
  
  {Check Prev}
  if Prev = nil then
   begin
    FFirst:=Item;
    
    {Check Next}
    if Next = nil then
     begin
      FLast:=Item;
     end
    else
     begin
      Next.Prev:=Item;
     end;      
   end
  else
   begin
    Prev.Next:=Item;
    
    {Check Next}
    if Next = nil then
     begin
      FLast:=Item;
     end
    else
     begin
      Next.Prev:=Item;
     end;      
   end;
  
  {Increment Count}
  Inc(FCount);
  if FCount > FMaxCount then FMaxCount:=FCount;
  
  {Return Result} 
  Result:=True;       
 finally
  ReleaseLock;
 end; 
end;

{==============================================================================}

function THashCacheTimer.DeleteKey(APage:TCachePage):Boolean;
{Delete the supplied page from the timer list}
{Page: The page to be deleted}
{Return: True if completed or False on failure}
var
 Item:PCacheTimerItem;
 Prev:PCacheTimerItem;
 Next:PCacheTimerItem;
begin
 {}
 Result:=False;

 if not AcquireLock then Exit;
 try
  {Find Item}
  Item:=FFirst;
  while Item <> nil do
   begin
    if Item.Page = APage then
     begin
      Break;
     end;
     
    Item:=Item.Next;
   end;
   
  {Check Item}
  if Item <> nil then
   begin
    {Delete Element}
    {Get Prev/Next}
    Prev:=Item.Prev;
    Next:=Item.Next;
    {Check Prev}
    if Prev = nil then
     begin
      FFirst:=Next;
      
      {Check Next}
      if Next = nil then
       begin
        FLast:=nil;
       end
      else
       begin
        Next.Prev:=nil;
       end;    
     end
    else
     begin
      Prev.Next:=Next;
      
      {Check Next}
      if Next = nil then
       begin
        FLast:=Prev;
       end
      else
       begin
        Next.Prev:=Prev;
       end;
     end;  
     
    {Check Next}
    if Next <> nil then
     begin
      {Update Key}
      Inc(Next.Key,Item.Key);
     end;
     
    {Decrement Count}
    Dec(FCount);
    
    {Release Item}
    FreeMem(Item);
    
    {Return Result} 
    Result:=True;       
   end; 
 finally
  ReleaseLock;
 end; 
end;

{==============================================================================}

function THashCacheTimer.DecrementKey:Integer;
{Decrement the first Key value in the Timer list}
{Return: First Key value in timer list after decrement or CACHE_TIMER_KEY_NONE on failure}
var
 Item:PCacheTimerItem;
begin
 {}
 Result:=CACHE_TIMER_KEY_NONE;
 
 if not AcquireLock then Exit;
 try
  {Get Item (First)}
  Item:=FFirst;
  if Item <> nil then
   begin
    {Decrement Key}
    if Item.Key > (CACHE_TIMER_KEY_MIN + FInterval) then
     begin
      Dec(Item.Key,FInterval);
     end;
         
    {Return Result}
    Result:=Item.Key;
   end;
 finally
  ReleaseLock;
 end; 
end;

{==============================================================================}

function THashCacheTimer.StartTimer(AInterval:LongWord):Boolean;
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  {Check Cache}
  if FCache = nil then Exit;
  
  {Check Interval}
  if AInterval < 1 then Exit;
  
  {Check Timer/Semaphore}
  if FCheckTimer <> INVALID_HANDLE_VALUE then Exit;
  if FProcessSemaphore <> INVALID_HANDLE_VALUE then Exit;
  
  {Set Interval}
  FInterval:=AInterval;
  
  {Create Process Semaphore}
  FProcessSemaphore:=SemaphoreCreate(0);
  if FProcessSemaphore = INVALID_HANDLE_VALUE then Exit;
  
  {Create Check Timer}
  FCheckTimer:=TimerCreateEx(FInterval,TIMER_STATE_ENABLED,TIMER_FLAG_RESCHEDULE or TIMER_FLAG_WORKER,TTimerEvent(CacheCheckTimer),FCache); {Rescheduled Automatically}
  if FCheckTimer = INVALID_HANDLE_VALUE then
   begin
    {Destroy Process Semaphore}
    SemaphoreDestroy(FProcessSemaphore);
    FProcessSemaphore:=INVALID_HANDLE_VALUE;
    
    Exit;
   end; 
 
  {Return Result}
  Result:=True;
 finally
  ReleaseLock;
 end; 
end;

{==============================================================================}

function THashCacheTimer.StopTimer:Boolean;
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  {Check Timer/Semaphore}
  if FCheckTimer = INVALID_HANDLE_VALUE then Exit;
  if FProcessSemaphore = INVALID_HANDLE_VALUE then Exit;
  
  {Destroy Check Timer}
  if TimerDestroy(FCheckTimer) <> ERROR_SUCCESS then Exit;
  FCheckTimer:=INVALID_HANDLE_VALUE;

  {Destroy Process Semaphore}
  if SemaphoreDestroy(FProcessSemaphore) <> ERROR_SUCCESS then Exit;
  FProcessSemaphore:=INVALID_HANDLE_VALUE;
  
  {Reset Interval}
  FInterval:=0;
  
  {Return Result}
  Result:=True;
 finally
  ReleaseLock;
 end; 
end;

{==============================================================================}

function THashCacheTimer.CheckTimer:Boolean;
begin
 {}
 Result:=False;

 {Decrement Key}
 if DecrementKey <= 0 then
  begin
   {Signal Semaphore}
   Result:=(SemaphoreSignal(FProcessSemaphore) = ERROR_SUCCESS);
  end;
end;

{==============================================================================}

function THashCacheTimer.ProcessTimer:Boolean;
var
 Page:TCachePage;
begin
 {}
 Result:=False;

 {Check Cache}
 if FCache = nil then Exit;
 
 {Wait Semaphore}
 if SemaphoreWait(FProcessSemaphore) = ERROR_SUCCESS then
  begin
   {Dequeue Page}
   Page:=Dequeue(0);
   while Page <> nil do
    begin
     {Flush Page}
     Result:=FCache.FlushPageEx(Page);
     if not Result then Exit;
     
     {Yield}
     Sleep(0);
     
     {Dequeue Page}
     Page:=Dequeue(0);
    end;
  end;
end;

{==============================================================================}

function THashCacheTimer.SchedulePage(APage:TCachePage;ATimeout:LongWord):Boolean;
begin
 {}
 Result:=False;
 
 {Check Page}
 {if APage = nil then Exit;} {Do not check}

 {Check Timeout} 
 if ATimeout < 1 then ATimeout:=FInterval;

 {Insert Key}
 Result:=InsertKey(APage,ATimeout + FInterval); {Allow one extra interval to account for first decrement}
end;

{==============================================================================}

function THashCacheTimer.UnschedulePage(APage:TCachePage):Boolean; 
begin
 {}
 Result:=False;
 
 {Check Page}
 {if APage = nil then Exit;} {Do not check}

 {Delete Key}
 Result:=DeleteKey(APage);
end; 

{==============================================================================}
{==============================================================================}
{TIncrementalCacheTimer}
constructor TIncrementalCacheTimer.Create(ACache:TIncrementalCache);
begin
 {}
 inherited Create;
 FCache:=ACache;
 
 FLock:=MutexCreate;
 FInterval:=0;
 FCheckTimer:=INVALID_HANDLE_VALUE;
 FProcessSemaphore:=INVALID_HANDLE_VALUE;
 
 FCount:=0;
 FMaxCount:=0;
 
 FFirst:=nil;
 FLast:=nil;
end;

{==============================================================================}

destructor TIncrementalCacheTimer.Destroy; 
begin
 {}
 AcquireLock;
 try
  if FProcessSemaphore <> INVALID_HANDLE_VALUE then SemaphoreDestroy(FProcessSemaphore);
  FProcessSemaphore:=INVALID_HANDLE_VALUE;
  if FCheckTimer <> INVALID_HANDLE_VALUE then TimerDestroy(FCheckTimer);
  FCheckTimer:=INVALID_HANDLE_VALUE;
  
  FFirst:=nil;
  FLast:=nil;
  inherited Destroy;
 finally 
  ReleaseLock; {Cannot destroy Mutex while holding lock} 
  MutexDestroy(FLock);
 end; 
end;

{==============================================================================}

function TIncrementalCacheTimer.AcquireLock:Boolean;
begin
 {}
 Result:=(MutexLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TIncrementalCacheTimer.ReleaseLock:Boolean;
begin
 {}
 Result:=(MutexUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TIncrementalCacheTimer.Dequeue(AMax:Integer):TCachePage;
{Get and remove the first page from the timer list if the key is less than or equal to Max}
{Max: The maximum value of the key for the page to be dequeued}
{Return: Dequeued Page or nil on non ready or failure}
var
 Item:PCacheTimerItem;
begin
 {}
 Result:=nil;

 if not AcquireLock then Exit;
 try
  {Get Item (First)}
  Item:=FFirst;
  if Item <> nil then
   begin
    {Check Key}
    if Item.Key <= AMax then
     begin
      {Remove First}
      FFirst:=Item.Next;
     
      {Check Next}
      if Item.Next = nil then
       begin
        FLast:=nil;
       end
      else
       begin
        Item.Next.Prev:=nil;
       end;
      
      {Check First}
      if FFirst <> nil then
       begin
        {Update Key}
        Inc(FFirst.Key,Item.Key);
       end;
      
      {Decrement Count}
      Dec(FCount);
      
      {Return Result}
      Result:=TCachePage(Item.Page);
      
      {Release Item}
      FreeMem(Item);
     end;
   end;
 finally
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TIncrementalCacheTimer.FirstKey:Integer;
{Get the first Key value from the timer list}
{Return: First Key value from timer list or CACHE_TIMER_KEY_NONE on failure}
var
 Item:PCacheTimerItem;
begin
 {}
 Result:=CACHE_TIMER_KEY_NONE;
 
 if not AcquireLock then Exit;
 try
  {Get Item (First)}
  Item:=FFirst;
  if Item <> nil then
   begin
    {Return Key}
    Result:=Item.Key;
   end;
 finally
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TIncrementalCacheTimer.InsertKey(APage:TCachePage;AKey:Integer):Boolean;
{Insert the supplied page in the timer list in delta ascending order based on Key}
{Page: The page to be inserted}
{Key: The key to order the insertion on}
{Return: True if completed or False on failure}
var
 Offset:Integer;
 Item:PCacheTimerItem;
 Prev:PCacheTimerItem;
 Next:PCacheTimerItem;
begin
 {}
 Result:=False;
 
 {Check Key}
 if AKey = CACHE_TIMER_KEY_NONE then Exit;

 if not AcquireLock then Exit;
 try
  {Get Item}
  Item:=GetMem(SizeOf(TCacheTimerItem));
  if Item = nil then Exit;
  
  {Find Position}
  Offset:=0;
  Prev:=nil;
  Next:=FFirst;
  while Next <> nil do
   begin
    {Delta Ascending}
    if AKey < (Offset + Next.Key) then
     begin
      Dec(Next.Key,(AKey - Offset));
      Break; 
     end;
    Inc(Offset,Next.Key);  
    Prev:=Next;
    Next:=Next.Next; 
   end;
  
  {Insert Item}
  Item.Key:=(AKey - Offset);
  Item.Page:=APage;
  Item.Prev:=Prev;
  Item.Next:=Next;
  
  {Check Prev}
  if Prev = nil then
   begin
    FFirst:=Item;
    
    {Check Next}
    if Next = nil then
     begin
      FLast:=Item;
     end
    else
     begin
      Next.Prev:=Item;
     end;      
   end
  else
   begin
    Prev.Next:=Item;
    
    {Check Next}
    if Next = nil then
     begin
      FLast:=Item;
     end
    else
     begin
      Next.Prev:=Item;
     end;      
   end;
  
  {Increment Count}
  Inc(FCount);
  if FCount > FMaxCount then FMaxCount:=FCount;
  
  {Return Result} 
  Result:=True;       
 finally
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TIncrementalCacheTimer.DeleteKey(APage:TCachePage):Boolean;
{Delete the supplied page from the timer list}
{Page: The page to be deleted}
{Return: True if completed or False on failure}
var
 Item:PCacheTimerItem;
 Prev:PCacheTimerItem;
 Next:PCacheTimerItem;
begin
 {}
 Result:=False;

 if not AcquireLock then Exit;
 try
  {Find Item}
  Item:=FFirst;
  while Item <> nil do
   begin
    if Item.Page = APage then
     begin
      Break;
     end;
     
    Item:=Item.Next;
   end;
   
  {Check Item}
  if Item <> nil then
   begin
    {Delete Element}
    {Get Prev/Next}
    Prev:=Item.Prev;
    Next:=Item.Next;
    {Check Prev}
    if Prev = nil then
     begin
      FFirst:=Next;
      
      {Check Next}
      if Next = nil then
       begin
        FLast:=nil;
       end
      else
       begin
        Next.Prev:=nil;
       end;    
     end
    else
     begin
      Prev.Next:=Next;
      
      {Check Next}
      if Next = nil then
       begin
        FLast:=Prev;
       end
      else
       begin
        Next.Prev:=Prev;
       end;
     end;  
     
    {Check Next}
    if Next <> nil then
     begin
      {Update Key}
      Inc(Next.Key,Item.Key);
     end;
     
    {Decrement Count}
    Dec(FCount);
     
    {Release Item}
    FreeMem(Item);
    
    {Return Result} 
    Result:=True;       
   end; 
 finally
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TIncrementalCacheTimer.DecrementKey:Integer;
{Decrement the first Key value in the Timer list}
{Return: First Key value in timer list after decrement or CACHE_TIMER_KEY_NONE on failure}
var
 Item:PCacheTimerItem;
begin
 {}
 Result:=CACHE_TIMER_KEY_NONE;
 
 if not AcquireLock then Exit;
 try
  {Get Item (First)}
  Item:=FFirst;
  if Item <> nil then
   begin
    {Decrement Key}
    if Item.Key > (CACHE_TIMER_KEY_MIN + FInterval) then
     begin
      Dec(Item.Key,FInterval);
     end;
         
    {Return Result}
    Result:=Item.Key;
   end;
 finally
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TIncrementalCacheTimer.StartTimer(AInterval:LongWord):Boolean;
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  {Check Cache}
  if FCache = nil then Exit;
  
  {Check Interval}
  if AInterval < 1 then Exit;
  
  {Check Timer/Semaphore}
  if FCheckTimer <> INVALID_HANDLE_VALUE then Exit;
  if FProcessSemaphore <> INVALID_HANDLE_VALUE then Exit;
  
  {Set Interval}
  FInterval:=AInterval;
  
  {Create Process Semaphore}
  FProcessSemaphore:=SemaphoreCreate(0);
  if FProcessSemaphore = INVALID_HANDLE_VALUE then Exit;
  
  {Create Check Timer}
  FCheckTimer:=TimerCreateEx(FInterval,TIMER_STATE_ENABLED,TIMER_FLAG_RESCHEDULE or TIMER_FLAG_WORKER,TTimerEvent(CacheCheckTimer),FCache); {Rescheduled Automatically}
  if FCheckTimer = INVALID_HANDLE_VALUE then
   begin
    {Destroy Process Semaphore}
    SemaphoreDestroy(FProcessSemaphore);
    FProcessSemaphore:=INVALID_HANDLE_VALUE;
    
    Exit;
   end; 
 
  {Return Result}
  Result:=True;
 finally
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TIncrementalCacheTimer.StopTimer:Boolean;
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  {Check Timer/Semaphore}
  if FCheckTimer = INVALID_HANDLE_VALUE then Exit;
  if FProcessSemaphore = INVALID_HANDLE_VALUE then Exit;
  
  {Destroy Check Timer}
  if TimerDestroy(FCheckTimer) <> ERROR_SUCCESS then Exit;
  FCheckTimer:=INVALID_HANDLE_VALUE;

  {Destroy Process Semaphore}
  if SemaphoreDestroy(FProcessSemaphore) <> ERROR_SUCCESS then Exit;
  FProcessSemaphore:=INVALID_HANDLE_VALUE;
  
  {Reset Interval}
  FInterval:=0;
  
  {Return Result}
  Result:=True;
 finally
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TIncrementalCacheTimer.CheckTimer:Boolean;
begin
 {}
 Result:=False;

 {Decrement Key}
 if DecrementKey <= 0 then
  begin
   {Signal Semaphore}
   Result:=(SemaphoreSignal(FProcessSemaphore) = ERROR_SUCCESS);
  end;
end;

{==============================================================================}

function TIncrementalCacheTimer.ProcessTimer:Boolean;
var
 Page:TCachePage;
begin
 {}
 Result:=False;

 {Check Cache}
 if FCache = nil then Exit;
   
 {Wait Semaphore}
 if SemaphoreWait(FProcessSemaphore) = ERROR_SUCCESS then
  begin
   {Dequeue Page}
   Page:=Dequeue(0);
   while Page <> nil do
    begin
     {Flush Page}
     Result:=FCache.FlushPageEx(Page);
     if not Result then Exit;
     
     {Yield}
     Sleep(0);
     
     {Dequeue Page}
     Page:=Dequeue(0);
    end;
  end;
end;

{==============================================================================}

function TIncrementalCacheTimer.SchedulePage(APage:TCachePage;ATimeout:LongWord):Boolean;
begin
 {}
 Result:=False;
 
 {Check Page}
 {if APage = nil then Exit;} {Do not check}

 {Check Timeout} 
 if ATimeout < 1 then ATimeout:=FInterval;

 {Insert Key}
 Result:=InsertKey(APage,ATimeout + FInterval); {Allow one extra interval to account for first decrement}
end;

{==============================================================================}

function TIncrementalCacheTimer.UnschedulePage(APage:TCachePage):Boolean; 
begin
 {}
 Result:=False;
 
 {Check Page}
 {if APage = nil then Exit;} {Do not check}

 {Delete Key}
 Result:=DeleteKey(APage);
end; 

{==============================================================================}
{==============================================================================}
{TCacheThread}
constructor TCacheThread.Create(ACache:TCache);
begin
 {}
 inherited Create(True,THREAD_STACK_DEFAULT_SIZE);
 FCache:=ACache;
end;

{==============================================================================}

destructor TCacheThread.Destroy;
begin
 {}
 FCache:=nil;
 inherited Destroy;
end;

{==============================================================================}

procedure TCacheThread.Execute;
begin
 {}
 try
  {Set Name}
  ThreadSetName(GetCurrentThreadID,FILESYS_CACHE_THREAD_NAME);
  
  {Set Priority}
  ThreadSetPriority(GetCurrentThreadID,FILESYS_CACHE_THREAD_PRIORITY);

  while not Terminated do
   begin
    if FCache <> nil then
     begin
      {Process Timer}
      FCache.ProcessTimer;
     end;
   end;
 except
  on E: Exception do
   begin
    if FILESYS_LOG_ENABLED then FileSysLogError('CacheThread: Exception: ' + E.Message + ' at ' + PtrToHex(ExceptAddr));
   end;
 end; 
end;

{==============================================================================}
{==============================================================================}
{THashCacheThread}
constructor THashCacheThread.Create(ACache:THashCache);
begin
 {}
 inherited Create(True,THREAD_STACK_DEFAULT_SIZE);
 FCache:=ACache;
end;

{==============================================================================}

destructor THashCacheThread.Destroy;
begin
 {}
 FCache:=nil;
 inherited Destroy;
end;

{==============================================================================}

procedure THashCacheThread.Execute;
begin
 {}
 try
  {Set Name}
  ThreadSetName(GetCurrentThreadID,FILESYS_CACHE_THREAD_NAME);

  {Set Priority}
  ThreadSetPriority(GetCurrentThreadID,FILESYS_CACHE_THREAD_PRIORITY);
  
  while not Terminated do
   begin
    if FCache <> nil then
     begin
      {Process Timer}
      FCache.ProcessTimer;
     end;
   end;
 except
  on E: Exception do
   begin
    if FILESYS_LOG_ENABLED then FileSysLogError('CacheThread: Exception: ' + E.Message + ' at ' + PtrToHex(ExceptAddr));
   end;
 end; 
end;

{==============================================================================}
{==============================================================================}
{TIncrementalCacheThread}
constructor TIncrementalCacheThread.Create(ACache:TIncrementalCache);
begin
 {}
 inherited Create(True,THREAD_STACK_DEFAULT_SIZE); 
 FCache:=ACache;
end;

{==============================================================================}

destructor TIncrementalCacheThread.Destroy;
begin
 {}
 FCache:=nil;
 inherited Destroy;
end;

{==============================================================================}

procedure TIncrementalCacheThread.Execute;
begin
 {}
 try
  {Set Name}
  ThreadSetName(GetCurrentThreadID,FILESYS_CACHE_THREAD_NAME);

  {Set Priority}
  ThreadSetPriority(GetCurrentThreadID,FILESYS_CACHE_THREAD_PRIORITY);

  while not Terminated do
   begin
    if FCache <> nil then
     begin
      {Process Timer}
      FCache.ProcessTimer;
     end;
   end;
 except
  on E: Exception do
   begin
    if FILESYS_LOG_ENABLED then FileSysLogError('CacheThread: Exception: ' + E.Message + ' at ' + PtrToHex(ExceptAddr));
   end;
 end; 
end;

{==============================================================================}
{==============================================================================}
{TEntryTimer}
constructor TEntryTimer.Create(ADriver:TFileSysDriver);
begin
 {}
 inherited Create;
 FDriver:=ADriver;
 
 FLock:=MutexCreate;
 FInterval:=0;
 FCheckTimer:=INVALID_HANDLE_VALUE;
 FProcessTimer:=INVALID_HANDLE_VALUE;
 
 FCount:=0;
 FMaxCount:=0;
 
 FFirst:=nil;
 FLast:=nil;
end;

{==============================================================================}

destructor TEntryTimer.Destroy; 
begin
 {}
 AcquireLock;
 try
  if FProcessTimer <> INVALID_HANDLE_VALUE then TimerDestroy(FProcessTimer);
  FProcessTimer:=INVALID_HANDLE_VALUE;
  if FCheckTimer <> INVALID_HANDLE_VALUE then TimerDestroy(FCheckTimer);
  FCheckTimer:=INVALID_HANDLE_VALUE;
  
  FFirst:=nil;
  FLast:=nil;
  inherited Destroy;
 finally 
  ReleaseLock; {Cannot destroy Mutex while holding lock} 
  MutexDestroy(FLock);
 end; 
end;

{==============================================================================}

function TEntryTimer.AcquireLock:Boolean;
begin
 {}
 Result:=(MutexLock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TEntryTimer.ReleaseLock:Boolean;
begin
 {}
 Result:=(MutexUnlock(FLock) = ERROR_SUCCESS);
end;

{==============================================================================}

function TEntryTimer.Dequeue:TDiskEntry;
{Get and remove the first entry from the timer list}
{Return: Dequeued Entry or nil on failure}
var
 Item:PEntryTimerItem;
begin
 {}
 Result:=nil;

 if not AcquireLock then Exit;
 try
  {Get Item (First)}
  Item:=FFirst;
  if Item <> nil then
   begin
    {Remove First}
    FFirst:=Item.Next;
   
    {Check Next}
    if Item.Next = nil then
     begin
      FLast:=nil;
     end
    else
     begin
      Item.Next.Prev:=nil;
     end;
    
    {Check First}
    if FFirst <> nil then
     begin
      {Update Key}
      Inc(FFirst.Key,Item.Key);
     end;
      
    {Decrement Count}
    Dec(FCount);
    
    {Return Result}
    Result:=TDiskEntry(Item.Entry);
    
    {Release Item}
    FreeMem(Item);
   end;
 finally
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TEntryTimer.FirstKey:Integer;
{Get the first Key value from the timer list}
{Return: First Key value from timer list or ENTRY_TIMER_KEY_NONE on failure}
var
 Item:PEntryTimerItem;
begin
 {}
 Result:=ENTRY_TIMER_KEY_NONE;
 
 if not AcquireLock then Exit;
 try
  {Get Item (First)}
  Item:=FFirst;
  if Item <> nil then
   begin
    {Return Key}
    Result:=Item.Key;
   end;
 finally
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TEntryTimer.InsertKey(AEntry:TDiskEntry;AKey:Integer):Boolean;
{Insert the supplied entry in the timer list in delta ascending order based on Key}
{Entry: The entry to be inserted}
{Key: The key to order the insertion on}
{Return: True if completed or False on failure}
var
 Offset:Integer;
 Item:PEntryTimerItem;
 Prev:PEntryTimerItem;
 Next:PEntryTimerItem;
begin
 {}
 Result:=False;
 
 {Check Key}
 if AKey = ENTRY_TIMER_KEY_NONE then Exit;

 if not AcquireLock then Exit;
 try
  {Get Item}
  Item:=GetMem(SizeOf(TEntryTimerItem));
  if Item = nil then Exit;
  
  {Find Position}
  Offset:=0;
  Prev:=nil;
  Next:=FFirst;
  while Next <> nil do
   begin
    {Delta Ascending}
    if AKey < (Offset + Next.Key) then
     begin
      Dec(Next.Key,(AKey - Offset));
      Break; 
     end;
    Inc(Offset,Next.Key);  
    Prev:=Next;
    Next:=Next.Next; 
   end;
  
  {Insert Item}
  Item.Key:=(AKey - Offset);
  Item.Entry:=AEntry;
  Item.Prev:=Prev;
  Item.Next:=Next;
  
  {Check Prev}
  if Prev = nil then
   begin
    FFirst:=Item;
    
    {Check Next}
    if Next = nil then
     begin
      FLast:=Item;
     end
    else
     begin
      Next.Prev:=Item;
     end;      
   end
  else
   begin
    Prev.Next:=Item;
    
    {Check Next}
    if Next = nil then
     begin
      FLast:=Item;
     end
    else
     begin
      Next.Prev:=Item;
     end;      
   end;
  
  {Increment Count}
  Inc(FCount);
  if FCount > FMaxCount then FMaxCount:=FCount;
  
  {Return Result} 
  Result:=True;       
 finally
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TEntryTimer.DeleteKey(AEntry:TDiskEntry):Boolean;
{Delete the supplied entry from the timer list}
{Entry: The Entry to be deleted}
{Return: True if completed or False on failure}
var
 Item:PEntryTimerItem;
 Prev:PEntryTimerItem;
 Next:PEntryTimerItem;
begin
 {}
 Result:=False;

 if not AcquireLock then Exit;
 try
  {Find Item}
  Item:=FFirst;
  while Item <> nil do
   begin
    if Item.Entry = AEntry then
     begin
      Break;
     end;
     
    Item:=Item.Next;
   end;
   
  {Check Item}
  if Item <> nil then
   begin
    {Delete Element}
    {Get Prev/Next}
    Prev:=Item.Prev;
    Next:=Item.Next;
    {Check Prev}
    if Prev = nil then
     begin
      FFirst:=Next;
      
      {Check Next}
      if Next = nil then
       begin
        FLast:=nil;
       end
      else
       begin
        Next.Prev:=nil;
       end;    
     end
    else
     begin
      Prev.Next:=Next;
      
      {Check Next}
      if Next = nil then
       begin
        FLast:=Prev;
       end
      else
       begin
        Next.Prev:=Prev;
       end;
     end;  
     
    {Check Next}
    if Next <> nil then
     begin
      {Update Key}
      Inc(Next.Key,Item.Key);
     end;
     
    {Decrement Count}
    Dec(FCount);
     
    {Release Item}
    FreeMem(Item);
    
    {Return Result} 
    Result:=True;       
   end; 
 finally
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TEntryTimer.DecrementKey:Integer;
{Decrement the first Key value in the Timer list}
{Return: First Key value in timer list after decrement or ENTRY_TIMER_KEY_NONE on failure}
var
 Item:PEntryTimerItem;
begin
 {}
 Result:=ENTRY_TIMER_KEY_NONE;
 
 if not AcquireLock then Exit;
 try
  {Get Item (First)}
  Item:=FFirst;
  if Item <> nil then
   begin
    {Decrement Key}
    if Item.Key > (ENTRY_TIMER_KEY_MIN + FInterval) then
     begin
      Dec(Item.Key,FInterval);
     end;
         
    {Return Result}
    Result:=Item.Key;
   end;
 finally
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TEntryTimer.StartTimer(AInterval:LongWord):Boolean;
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;
  
  {Check Interval}
  if AInterval < 1 then Exit;
  
  {Check Timers}
  if FCheckTimer <> INVALID_HANDLE_VALUE then Exit;
  if FProcessTimer <> INVALID_HANDLE_VALUE then Exit;
  
  {Set Interval}
  FInterval:=AInterval;
  
  {Create Check Timer}
  FCheckTimer:=TimerCreateEx(FInterval,TIMER_STATE_ENABLED,TIMER_FLAG_RESCHEDULE or TIMER_FLAG_WORKER,TTimerEvent(EntryCheckTimer),FDriver); {Rescheduled Automatically}
  if FCheckTimer = INVALID_HANDLE_VALUE then Exit;
  
  {Create Process Timer}
  FProcessTimer:=TimerCreateEx(FInterval,TIMER_STATE_ENABLED,TIMER_FLAG_WORKER,TTimerEvent(EntryProcessTimer),FDriver); {Rescheduled by Timer Event}
  if FProcessTimer = INVALID_HANDLE_VALUE then
   begin
    {Destroy Check Timer}
    TimerDestroy(FCheckTimer);
    FCheckTimer:=INVALID_HANDLE_VALUE;
    
    Exit;
   end; 
 
  {Return Result}
  Result:=True;
 finally
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TEntryTimer.StopTimer:Boolean;
begin
 {}
 Result:=False;
 
 if not AcquireLock then Exit;
 try
  {Check Timers}
  if FCheckTimer = INVALID_HANDLE_VALUE then Exit;
  if FProcessTimer = INVALID_HANDLE_VALUE then Exit;
  
  {Destroy Check Timer}
  if TimerDestroy(FCheckTimer) <> ERROR_SUCCESS then Exit;
  FCheckTimer:=INVALID_HANDLE_VALUE;

  {Destroy Process Timer}
  if TimerDestroy(FProcessTimer) <> ERROR_SUCCESS then Exit;
  FProcessTimer:=INVALID_HANDLE_VALUE;
  
  {Reset Interval}
  FInterval:=0;
  
  {Return Result}
  Result:=True;
 finally
  ReleaseLock;
 end; 
end;

{==============================================================================}

function TEntryTimer.CheckTimer:Boolean;
begin
 {}
 Result:=False;

 {Decrement Key}
 if DecrementKey <= 0 then
  begin
   {Return Result}
   Result:=True;
  end;
end;

{==============================================================================}

function TEntryTimer.ProcessTimer:Boolean;
{Note: Calls to ProcessTimer must be serialized so that multiple threads
 do not call simultaneously. This is done by creating the timer as non
 rescheduled and having this routine reenable the timer on completion}
var
 Entry:TDiskEntry;
begin
 {}
 Result:=False;
 try
  {Check Driver}
  if FDriver = nil then Exit;
   
  {Setup Result}
  Result:=True;
     
  {Get First Key}
  while FirstKey <= 0 do 
   begin
    {Dequeue Entry}
    Entry:=Dequeue;
    if Entry <> nil then
     begin    
      {Check Entry}
      if Entry.ReferenceCount < 1 then
       begin
        {$IFDEF FILESYS_DEBUG}
        if FILESYS_LOG_ENABLED then FileSysLogDebug('EntryTimer: Destroying Entry (Name=' + Entry.Name + ')');
        {$ENDIF}
        
        {Destroy Entry}
        Entry.Free;
       end
      else
       begin    
        {$IFDEF FILESYS_DEBUG}
        if FILESYS_LOG_ENABLED then FileSysLogDebug('EntryTimer: Rescheduling Entry (Name=' + Entry.Name + ' ReferenceCount=' + IntToStr(Entry.ReferenceCount) + ')');
        {$ENDIF}

        {Insert Key}
        Result:=InsertKey(Entry,FILESYS_ENTRY_DELETE_TIMEOUT);
       end; 
     end;  
   end;
 finally 
  {Enable Timer}
  TimerEnable(FProcessTimer);
 end; 
end;

{==============================================================================}

function TEntryTimer.ScheduleEntry(AEntry:TDiskEntry;ATimeout:LongWord):Boolean;
begin
 {}
 Result:=False;
 
 {Check Entry}
 {if AEntry = nil then Exit;} {Do not check}

 {Check Timeout} 
 if ATimeout < 1 then ATimeout:=FInterval;

 {Insert Key}
 Result:=InsertKey(AEntry,ATimeout);
end;

{==============================================================================}

function TEntryTimer.UnscheduleEntry(AEntry:TDiskEntry):Boolean; 
begin
 {}
 Result:=False;
 
 {Check Entry}
 {if AEntry = nil then Exit;} {Do not check}

 {Delete Key}
 Result:=DeleteKey(AEntry);
end; 

{==============================================================================}
{==============================================================================}
{TDefaultRecognizer}
constructor TDefaultRecognizer.Create(ADriver:TFileSysDriver);
begin
 {}
 inherited Create(ADriver);
 FAllowDrive:=False;
 FAllowDefault:=False;
 FPartitioner:=TDefaultPartitioner.Create(FDriver,Self);
end;

{==============================================================================}

function TDefaultRecognizer.GetName:String;
begin
 {}
 Result:='Default';
end;

{==============================================================================}

function TDefaultRecognizer.RecognizePartitionId(APartitionId:Byte):Boolean;
{Note: Default recognizer does not recognize any partition Ids}
begin
 {}
 Result:=False;
end;

{==============================================================================}

function TDefaultRecognizer.RecognizePartition(APartition:TDiskPartition):Boolean;
{Note: Remove PartitionId from here when recognized by another module}
{Note: Caller must hold the partition lock}
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;
  if APartition = nil then Exit;

  case APartition.PartitionId of
   pidXENIXROOT,
   pidXENIXUSR,
   pidAIXOS2,
   pidAIX,
   pidOS2BOOT,
   pidUnknown013,
   pidOPUS,
   pidHIDDEN12,
   pidCompaqDiag,
   pidUnknown019,
   pidHIDDEN16,
   pidUnknown021,
   pidHIDDEN16HUGE,
   pidHIDDENHPFS,
   pidASTSWAP,
   pidWillowtech,
   pidUnknown026,
   pidHIDDEN32,
   pidHIDDEN32LBA,
   pidUnknown029,
   pidHIDDEN16LBA,
   pidUnknown031,
   pidWillowsoft,
   pidOxygen,
   pidOxygenExtended,
   pidReserved035,
   pidNECMSDOS,
   pidUnknown037,
   pidUnknown038,
   pidUnknown039,
   pidUnknown040,
   pidUnknown041,
   pidUnknown042,
   pidUnknown043,
   pidUnknown044,
   pidUnknown045,
   pidUnknown046,
   pidUnknown047,
   pidUnknown048,
   pidReserved049,
   pidAlienNOS,
   pidReserved051,
   pidReserved052,
   pidOS2JFS,
   pidReserved054,
   pidUnknown055,
   pidTheos057,
   pidPlan9,
   pidTheos058,
   pidTheos059,
   pidPowerQuest,
   pidHiddenNetware,
   pidUnknown062,
   pidUnknown063,
   pidVENIX286,
   pidPersonalRISC,
   pidSFS,
   pidPTSDOS,
   pidGoBack,
   pidEUMEL069,
   pidEUMEL070,
   pidEUMEL071,
   pidEUMEL072,
   pidUnknown073,
   pidAdaOS,
   pidUnknown075,
   pidOberon,
   pidQNX4077,
   pidQNX4078,
   pidQNX4079,
   pidOnTrack080,
   pidNOVELL081,
   pidCPM,
   pidOnTrack083,
   pidOnTrack084,
   pidEZDrive,
   pidGoldenBow,
   pidUnknown087,
   pidUnknown088,
   pidUnknown089,
   pidUnknown090,
   pidUnknown091,
   pidPriamEdisk,
   pidUnknown093,
   pidUnknown094,
   pidUnknown095,
   pidUnknown096,
   pidSpeedStor097,
   pidUnknown098,
   pidSysV,
   pidNetware286,
   pidNWFS,
   pidUnknown102,
   pidNovell103,
   pidNovell104,
   pidUnknown106,
   pidUnknown107,
   pidUnknown108,
   pidUnknown109,
   pidUnknown110,
   pidUnknown111,
   pidDiskSecure,
   pidUnknown113,
   pidUnknown114,
   pidReserved115,
   pidReserved116,
   pidPCIX,
   pidReserved118,
   pidUnknown119,
   pidUnknown120,
   pidUnknown121,
   pidUnknown122,
   pidUnknown123,
   pidUnknown125,
   pidUnknown126,
   pidUnknown127,
   pidMinix,
   pidLinuxMinix,
   pidHIDDENC,
   pidFAT16Stripe,
   pidNTFSStripe,
   pidUnknown136,
   pidUnknown137,
   pidUnknown138,
   pidUnknown139,
   pidUnknown140,
   pidUnknown141,
   pidUnknown142,
   pidUnknown143,
   pidUnknown144,
   pidUnknown145,
   pidUnknown146,
   pidAmoeba,
   pidAmoebaBBT,
   pidUnknown149,
   pidUnknown150,
   pidUnknown151,
   pidUnknown152,
   pidUnknown153,
   pidUnknown154,
   pidUnknown155,
   pidUnknown156,
   pidUnknown157,
   pidUnknown158,
   pidUnknown159,
   pidPhoenixPM,
   pidReserved161,
   pidUnknown162,
   pidReserved163,
   pidReserved164,
   pidFreeBSD,
   pidOpenBSD,
   pidNeXTStep,
   pidUnknown168,
   pidUnknown169,
   pidUnknown170,
   pidDarwinBoot,
   pidUnknown172,
   pidUnknown173,
   pidUnknown174,
   pidUnknown175,
   pidUnknown176,
   pidUnknown177,
   pidUnknown178,
   pidUnknown179,
   pidReserved180,
   pidUnknown181,
   pidFAT16MirrorA,
   pidNTFSMirrorA,
   pidBSDIswap,
   pidUnknown185,
   pidUnknown186,
   pidUnknown187,
   pidUnknown188,
   pidUnknown189,
   pidUnknown190,
   pidUnknown191,
   pidUnknown192,
   pidDRDOSFAT12,
   pidUnknown194,
   pidUnknown195,
   pidDRDOSFAT16,
   pidUnknown197,
   pidFAT16MirrorB,
   pidNTFSMirrorB,
   pidUnknown200,
   pidUnknown201,
   pidUnknown202,
   pidUnknown203,
   pidUnknown204,
   pidUnknown205,
   pidUnknown206,
   pidUnknown207,
   pidUnknown208,
   pidUnknown209,
   pidTinyEFAT,
   pidEFAT,
   pidSecuredEFAT,
   pidOpticalEFAT,
   pidUnknown214,
   pidUnknown215,
   pidCPM86,
   pidUnknown217,
   pidUnknown218,
   pidConcurrentCPM,
   pidUnknown220,
   pidUnknown221,
   pidUnknown222,
   pidUnknown223,
   pidUnknown224,
   pidSpeedStorFAT12,
   pidUnknown226,
   pidUnknown227,
   pidSpeedStorFAT16,
   pidReserved229,
   pidReserved230,
   pidUnknown231,
   pidUnknown232,
   pidUnknown233,
   pidUnknown234,
   pidBeOSBFS1,
   pidUnknown236,
   pidUnknown237,
   pidUnknown238,
   pidUnknown239,
   pidLinuxRISC,
   pidStorageDimension,
   pidDOS33Secondary,
   pidSpeedStor243,
   pidSpeedStor244,
   pidPrologue,
   pidSpeedStor246,
   pidOSGEFAT,
   pidUnknown248,
   pidUnknown249,
   pidBochsX86,
   pidVMware,
   pidVMwareSwap,
   pidLinuxRAID,
   pidLANstep,
   pidXenixBBT:begin
     {}
     APartition.Recognized:=True;
     Result:=True;
    end;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}
{==============================================================================}
{TDefaultPartitioner}
constructor TDefaultPartitioner.Create(ADriver:TFileSysDriver;ARecognizer:TRecognizer);
begin
 {}
 inherited Create(ADriver,ARecognizer);
end;

{==============================================================================}

function TDefaultPartitioner.AcceptPartition(ADevice:TDiskDevice;APartition,AParent:TDiskPartition;APartitionId:Byte):Boolean;
{Note: Remove PartitionId from here when recognized by another module}
{Note: Caller must hold the device and partition lock}
var
 Volume:TDiskVolume;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  if FDriver = nil then Exit;
  if FRecognizer = nil then Exit;

  if APartition = nil then
   begin
    {Accept Create Partition}
    if ADevice = nil then Exit;
    
    {Check Device}
    if (ADevice.MediaType <> mtFIXED) and (ADevice.MediaType <> mtREMOVABLE) then Exit;
    
    {Check Partition and Volume}
    if FDriver.GetPartitionByDevice(ADevice,False,FILESYS_LOCK_NONE) = nil then {Do not lock}
     begin
      Volume:=FDriver.GetVolumeByDevice(ADevice,True,FILESYS_LOCK_READ);
      if Volume <> nil then
       begin
        try
         {Check File System Type}
         if Volume.FileSysType <> fsUNKNOWN then Exit;
        finally  
         Volume.ReaderUnlock;
        end; 
       end;
     end; 
    
    {Check Parent}
    if AParent <> nil then Exit;
    
    {Check Type}
    case APartitionId of
     pidXENIXROOT,
     pidXENIXUSR,
     pidAIXOS2,
     pidAIX,
     pidOS2BOOT,
     pidUnknown013,
     pidOPUS,
     pidHIDDEN12,
     pidCompaqDiag,
     pidUnknown019,
     pidHIDDEN16,
     pidUnknown021,
     pidHIDDEN16HUGE,
     pidHIDDENHPFS,
     pidASTSWAP,
     pidWillowtech,
     pidUnknown026,
     pidHIDDEN32,
     pidHIDDEN32LBA,
     pidUnknown029,
     pidHIDDEN16LBA,
     pidUnknown031,
     pidWillowsoft,
     pidOxygen,
     pidOxygenExtended,
     pidReserved035,
     pidNECMSDOS,
     pidUnknown037,
     pidUnknown038,
     pidUnknown039,
     pidUnknown040,
     pidUnknown041,
     pidUnknown042,
     pidUnknown043,
     pidUnknown044,
     pidUnknown045,
     pidUnknown046,
     pidUnknown047,
     pidUnknown048,
     pidReserved049,
     pidAlienNOS,
     pidReserved051,
     pidReserved052,
     pidOS2JFS,
     pidReserved054,
     pidUnknown055,
     pidTheos057,
     pidPlan9,
     pidTheos058,
     pidTheos059,
     pidPowerQuest,
     pidHiddenNetware,
     pidUnknown062,
     pidUnknown063,
     pidVENIX286,
     pidPersonalRISC,
     pidSFS,
     pidPTSDOS,
     pidGoBack,
     pidEUMEL069,
     pidEUMEL070,
     pidEUMEL071,
     pidEUMEL072,
     pidUnknown073,
     pidAdaOS,
     pidUnknown075,
     pidOberon,
     pidQNX4077,
     pidQNX4078,
     pidQNX4079,
     pidOnTrack080,
     pidNOVELL081,
     pidCPM,
     pidOnTrack083,
     pidOnTrack084,
     pidEZDrive,
     pidGoldenBow,
     pidUnknown087,
     pidUnknown088,
     pidUnknown089,
     pidUnknown090,
     pidUnknown091,
     pidPriamEdisk,
     pidUnknown093,
     pidUnknown094,
     pidUnknown095,
     pidUnknown096,
     pidSpeedStor097,
     pidUnknown098,
     pidSysV,
     pidNetware286,
     pidNWFS,
     pidUnknown102,
     pidNovell103,
     pidNovell104,
     pidUnknown106,
     pidUnknown107,
     pidUnknown108,
     pidUnknown109,
     pidUnknown110,
     pidUnknown111,
     pidDiskSecure,
     pidUnknown113,
     pidUnknown114,
     pidReserved115,
     pidReserved116,
     pidPCIX,
     pidReserved118,
     pidUnknown119,
     pidUnknown120,
     pidUnknown121,
     pidUnknown122,
     pidUnknown123,
     pidUnknown125,
     pidUnknown126,
     pidUnknown127,
     pidMinix,
     pidLinuxMinix,
     pidHIDDENC,
     pidFAT16Stripe,
     pidNTFSStripe,
     pidUnknown136,
     pidUnknown137,
     pidUnknown138,
     pidUnknown139,
     pidUnknown140,
     pidUnknown141,
     pidUnknown142,
     pidUnknown143,
     pidUnknown144,
     pidUnknown145,
     pidUnknown146,
     pidAmoeba,
     pidAmoebaBBT,
     pidUnknown149,
     pidUnknown150,
     pidUnknown151,
     pidUnknown152,
     pidUnknown153,
     pidUnknown154,
     pidUnknown155,
     pidUnknown156,
     pidUnknown157,
     pidUnknown158,
     pidUnknown159,
     pidPhoenixPM,
     pidReserved161,
     pidUnknown162,
     pidReserved163,
     pidReserved164,
     pidFreeBSD,
     pidOpenBSD,
     pidNeXTStep,
     pidUnknown168,
     pidUnknown169,
     pidUnknown170,
     pidDarwinBoot,
     pidUnknown172,
     pidUnknown173,
     pidUnknown174,
     pidUnknown175,
     pidUnknown176,
     pidUnknown177,
     pidUnknown178,
     pidUnknown179,
     pidReserved180,
     pidUnknown181,
     pidFAT16MirrorA,
     pidNTFSMirrorA,
     pidBSDIswap,
     pidUnknown185,
     pidUnknown186,
     pidUnknown187,
     pidUnknown188,
     pidUnknown189,
     pidUnknown190,
     pidUnknown191,
     pidUnknown192,
     pidDRDOSFAT12,
     pidUnknown194,
     pidUnknown195,
     pidDRDOSFAT16,
     pidUnknown197,
     pidFAT16MirrorB,
     pidNTFSMirrorB,
     pidUnknown200,
     pidUnknown201,
     pidUnknown202,
     pidUnknown203,
     pidUnknown204,
     pidUnknown205,
     pidUnknown206,
     pidUnknown207,
     pidUnknown208,
     pidUnknown209,
     pidTinyEFAT,
     pidEFAT,
     pidSecuredEFAT,
     pidOpticalEFAT,
     pidUnknown214,
     pidUnknown215,
     pidCPM86,
     pidUnknown217,
     pidUnknown218,
     pidConcurrentCPM,
     pidUnknown220,
     pidUnknown221,
     pidUnknown222,
     pidUnknown223,
     pidUnknown224,
     pidSpeedStorFAT12,
     pidUnknown226,
     pidUnknown227,
     pidSpeedStorFAT16,
     pidReserved229,
     pidReserved230,
     pidUnknown231,
     pidUnknown232,
     pidUnknown233,
     pidUnknown234,
     pidBeOSBFS1,
     pidUnknown236,
     pidUnknown237,
     pidUnknown238,
     pidUnknown239,
     pidLinuxRISC,
     pidStorageDimension,
     pidDOS33Secondary,
     pidSpeedStor243,
     pidSpeedStor244,
     pidPrologue,
     pidSpeedStor246,
     pidOSGEFAT,
     pidUnknown248,
     pidUnknown249,
     pidBochsX86,
     pidVMware,
     pidVMwareSwap,
     pidLinuxRAID,
     pidLANstep,
     pidXenixBBT:begin
       Result:=True;
      end;
    end;
   end
  else
   begin
    if APartitionId = pidUnused then
     begin
      {Accept Delete Partition}
      {Check Children}
      if (AParent = nil) and (FDriver.GetPartitionByPartition(APartition,False,FILESYS_LOCK_NONE) <> nil) then Exit; {Do not lock}
      
      Result:=True;
     end
    else if APartitionId <> APartition.PartitionId then
     begin
      {Accept Modify Partition}
      {Check Extended}
      if APartition.Extended then Exit;
      
      {Nothing}
     end
    else if APartitionId = APartition.PartitionId then
     begin
      {Accept Activate Partition}
      {Check Primary}
      if not APartition.Primary then Exit;
      
      {Nothing}
     end;
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}
{==============================================================================}
{TExtDiskController}
function TExtDiskController.GetCylinders(ADevice:TDiskDevice):LongWord;
{Note: Caller must hold the device lock}
var
 Value:Int64;
 Heads:LongWord;
 Sectors:LongWord;
 Media:TMediaType;
 Floppy:TFloppyType;
begin
 {}
 Result:=0;
  
 if not ReaderLock then Exit;
 try
  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Check Block Count}
  if ADevice.Storage.BlockCount = 0 then Exit;
  
  {Check Heads}
  Heads:=GetHeads(ADevice);
  if Heads = 0 then Exit;
  
  {Check Sectors}
  Sectors:=GetSectors(ADevice);
  if Sectors = 0 then Exit;
  
  {Check Media Type}
  Media:=MediaType(ADevice);
  case Media of
   mtFLOPPY,mtFIXED,mtREMOVABLE,mtCDROM,mtDVD,mtOTHER:begin
     {Check Floppy Type}
     Floppy:=FloppyType(ADevice);
     if (Media = mtFLOPPY) and (Floppy <> ftATAPI) then
      begin
       case Floppy of
        ft360K:begin
          {Setup Cylinders}
          Result:=40;
         end;
        ft12M:begin
          {Setup Cylinders}
          Result:=80;
         end;
        ft720K:begin
          {Setup Cylinders}
          Result:=80;
         end;
        ft144M:begin
          {Setup Cylinders}
          Result:=80;
         end;
        ft288M:begin
          {Setup Cylinders}
          Result:=80;
         end;
       end;
      end
     else
      begin
       {Setup Cylinders}
       Result:=ADevice.Storage.BlockCount div (Heads * Sectors);
      end;
    end;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TExtDiskController.GetHeads(ADevice:TDiskDevice):LongWord;
{Note: Caller must hold the device lock}
var
 Value:Int64;
 Sectors:LongWord;
 Media:TMediaType;
 Floppy:TFloppyType;
begin
 {}
 Result:=0;
  
 if not ReaderLock then Exit;
 try
  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;
  
  {Check Block Count}
  if ADevice.Storage.BlockCount = 0 then Exit;
  
  {Check Sectors}
  Sectors:=GetSectors(ADevice);
  if Sectors = 0 then Exit;
  
  {Check Media Type}
  Media:=MediaType(ADevice);
  case Media of
   mtFLOPPY,mtFIXED,mtREMOVABLE,mtCDROM,mtDVD,mtOTHER:begin
     {Check Floppy Type}
     Floppy:=FloppyType(ADevice);
     if (Media = mtFLOPPY) and (Floppy <> ftATAPI) then
      begin
       case Floppy of
        ft360K:begin
          {Setup Heads}
          Result:=2;
         end;
        ft12M:begin
          {Setup Heads}
          Result:=2;
         end;
        ft720K:begin
          {Setup Heads}
          Result:=2;
         end;
        ft144M:begin
          {Setup Heads}
          Result:=2;
         end;
        ft288M:begin
          {Setup Heads}
          Result:=2;
         end;
       end;
      end
     else
      begin
       {Setup Heads}
       if ADevice.Storage.BlockCount > (255 * 63) then
        begin
         Result:=255; {Default to 255 Heads}
        end
       else
        begin       
         Value:=ADevice.Storage.BlockCount div Sectors;
         if (Value mod 255 = 0) then
          begin
           Result:=255; {Assume 255 Heads}
          end
         else if (Value mod 64 = 0) then
          begin
           Result:=64;  {Assume 64 Heads}
          end
         else if (Value mod 16 = 0) then
          begin
           Result:=16;  {Assume 16 Heads}
          end
         else if (Value mod 15 = 0) then
          begin
           Result:=15;  {Assume 15 Heads}
          end
         else if (Value mod 4 = 0) then
          begin
           Result:=4;   {Assume 4 Heads}
          end
         else if (Value mod 2 = 0) then
          begin
           Result:=2;   {Assume 2 Heads}
          end;
        end;
      end;
    end;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TExtDiskController.GetSectors(ADevice:TDiskDevice):LongWord;
{Note: Caller must hold the device lock}
var
 Value:Int64;
 Media:TMediaType;
 Floppy:TFloppyType;
begin
 {}
 Result:=0;
  
 if not ReaderLock then Exit;
 try
  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;
  
  {Check Block Count}
  if ADevice.Storage.BlockCount = 0 then Exit;
  
  {Check Media Type}
  Media:=MediaType(ADevice);
  case Media of
   mtFLOPPY,mtFIXED,mtREMOVABLE,mtCDROM,mtDVD,mtOTHER:begin
     {Check Floppy Type}
     Floppy:=FloppyType(ADevice);
     if (Media = mtFLOPPY) and (Floppy <> ftATAPI) then
      begin
       case Floppy of
        ft360K:begin
          {Setup Sectors}
          Result:=9;
         end;
        ft12M:begin
          {Setup Sectors}
          Result:=15;
         end;
        ft720K:begin
          {Setup Sectors}
          Result:=9;
         end;
        ft144M:begin
          {Setup Sectors}
          Result:=18;
         end;
        ft288M:begin
          {Setup Sectors}
          Result:=36;
         end;
       end;
      end
     else
      begin
       {Setup Sectors}
       if ADevice.Storage.BlockCount > (255 * 63) then
        begin
         Result:=63; {Default to 63 Sectors}
        end
       else
        begin       
         Value:=ADevice.Storage.BlockCount;
         if (Value mod 63 = 0) then
          begin
           Result:=63; {Assume 63 Sectors}
          end
         else if (Value mod 32 = 0) then
          begin
           Result:=32; {Assume 32 Sectors}
          end
         else if (Value mod 17 = 0) then
          begin
           Result:=17; {Assume 17 Sectors}
          end;
        end;  
      end;
    end;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TExtDiskController.GetLogicalShiftCount(ADevice:TDiskDevice):Word;
{Note: Caller must hold the device lock}
var
 Cylinders:LongWord;
begin
 {}
 Result:=0;
  
 if not ReaderLock then Exit;
 try
  {Check Device}
  if ADevice = nil then Exit;

  {Check Cylinders}
  Cylinders:=GetCylinders(ADevice);
  if Cylinders = 0 then Exit;
  
  while (Cylinders shr Result) > 1024 do
   begin
    Inc(Result);
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}
{==============================================================================}
{TATADiskController}
constructor TATADiskController.Create(ADriver:TFileSysDriver);
begin
 {}
 inherited Create(ADriver);
 FDescription:=FILESYS_ATA_CONTROLLER_DESCRIPTION;
end;

{==============================================================================}

function TATADiskController.ControllerInit:Boolean; 
begin
 {}
 Result:=False;
 
 if not WriterLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TATADiskController.ControllerInit');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                    Name = ' + Name);
  {$ENDIF}

  if FDriver = nil then Exit;
 
  {Nothing}
  Result:=True;
 finally  
  WriterUnlock;
 end; 
end;

{==============================================================================}

function TATADiskController.LocateDevices:Boolean; 
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TATADiskController.LocateDevices');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                    Name = ' + Name);
  {$ENDIF}

  if FDriver = nil then Exit;

  {Nothing (ATA devices are added and removed by notification}
  Result:=True;
 finally  
  ReaderUnlock;
 end; 
end; 

{==============================================================================}
{==============================================================================}
{TATAPIDiskController}
constructor TATAPIDiskController.Create(ADriver:TFileSysDriver);
begin
 {}
 inherited Create(ADriver);
 FDescription:=FILESYS_ATAPI_CONTROLLER_DESCRIPTION;
end;

{==============================================================================}

function TATAPIDiskController.ControllerInit:Boolean; 
begin
 {}
 Result:=False;
 
 if not WriterLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TATAPIDiskController.ControllerInit');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                    Name = ' + Name);
  {$ENDIF}

  if FDriver = nil then Exit;
 
  {Nothing}
  Result:=True;
 finally  
  WriterUnlock;
 end; 
end;

{==============================================================================}

function TATAPIDiskController.LocateDevices:Boolean; 
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TATAPIDiskController.LocateDevices');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                      Name = ' + Name);
  {$ENDIF}

  if FDriver = nil then Exit;

  {Nothing (ATAPI devices are added and removed by notification}
  Result:=True;
 finally  
  ReaderUnlock;
 end; 
end; 

{==============================================================================}
{==============================================================================}
{TSCSIDiskController}
constructor TSCSIDiskController.Create(ADriver:TFileSysDriver);
begin
 {}
 inherited Create(ADriver);
 FDescription:=FILESYS_SCSI_CONTROLLER_DESCRIPTION;
end;

{==============================================================================}

function TSCSIDiskController.ControllerInit:Boolean; 
begin
 {}
 Result:=False;
 
 if not WriterLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TSCSIDiskController.ControllerInit');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                    Name = ' + Name);
  {$ENDIF}

  if FDriver = nil then Exit;
 
  {Nothing}
  Result:=True;
 finally  
  WriterUnlock;
 end; 
end;

{==============================================================================}

function TSCSIDiskController.LocateDevices:Boolean; 
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TSCSIDiskController.LocateDevices');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                     Name = ' + Name);
  {$ENDIF}

  if FDriver = nil then Exit;

  {Nothing (SCSI devices are added and removed by notification}
  Result:=True;
 finally  
  ReaderUnlock;
 end; 
end; 

{==============================================================================}
{==============================================================================}
{TUSBDiskController}
constructor TUSBDiskController.Create(ADriver:TFileSysDriver);
begin
 {}
 inherited Create(ADriver);
 FDescription:=FILESYS_USB_CONTROLLER_DESCRIPTION;
end;

{==============================================================================}

function TUSBDiskController.ControllerInit:Boolean; 
begin
 {}
 Result:=False;
 
 if not WriterLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TUSBDiskController.ControllerInit');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                    Name = ' + Name);
  {$ENDIF}

  if FDriver = nil then Exit;
 
  {Nothing}
  Result:=True;
 finally  
  WriterUnlock;
 end; 
end;

{==============================================================================}

function TUSBDiskController.LocateDevices:Boolean; 
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TUSBDiskController.LocateDevices');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                    Name = ' + Name);
  {$ENDIF}

  if FDriver = nil then Exit;

  {Nothing (USB devices are added and removed by notification}
  Result:=True;
 finally  
  ReaderUnlock;
 end; 
end; 

{==============================================================================}

function TUSBDiskController.Read(ADevice:TDiskDevice;ASector:LongWord;ACount:Word;var ABuffer):Boolean; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Count} 
  if ACount = 0 then Exit;

  {Check Readable}
  if not ADevice.Readable then Exit;
 
  {Check Storage}
  if ADevice.Storage = nil then Exit;
 
  {Read Storage}
  Result:=(StorageDeviceRead(ADevice.Storage,ASector,ACount,@ABuffer) = ERROR_SUCCESS);
 finally  
  ReaderUnlock;
 end; 
end;
 
{==============================================================================}

function TUSBDiskController.Write(ADevice:TDiskDevice;ASector:LongWord;ACount:Word;const ABuffer):Boolean; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Count} 
  if ACount = 0 then Exit;

  {Check Writeable}
  if not ADevice.Writeable then Exit;
 
  {Check Storage}
  if ADevice.Storage = nil then Exit;
 
  {Write Storage}
  Result:=(StorageDeviceWrite(ADevice.Storage,ASector,ACount,@ABuffer) = ERROR_SUCCESS);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TUSBDiskController.Reset(ADevice:TDiskDevice):Boolean; 
{Note: Caller must hold the device lock}
var
 Argument:LongWord;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;
 
  {Reset Storage}
  Result:=(StorageDeviceControl(ADevice.Storage,STORAGE_CONTROL_RESET,Argument,Argument) = ERROR_SUCCESS);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TUSBDiskController.LockMedia(ADevice:TDiskDevice):Boolean; 
{Note: Caller must hold the device lock}
var
 Argument:LongWord;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Lock Media}
  Result:=(StorageDeviceControl(ADevice.Storage,STORAGE_CONTROL_LOCK,Argument,Argument) = ERROR_SUCCESS);
  if Result then ADevice.FLocked:=Locked(ADevice);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TUSBDiskController.UnlockMedia(ADevice:TDiskDevice):Boolean; 
{Note: Caller must hold the device lock}
var
 Argument:LongWord;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Unlock Media}
  Result:=(StorageDeviceControl(ADevice.Storage,STORAGE_CONTROL_UNLOCK,Argument,Argument) = ERROR_SUCCESS);
  if Result then ADevice.FLocked:=Locked(ADevice);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TUSBDiskController.EjectMedia(ADevice:TDiskDevice):Boolean; 
{Note: Caller must hold the device lock}
var
 Argument:LongWord;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Eject Media}
  Result:=(StorageDeviceControl(ADevice.Storage,STORAGE_CONTROL_EJECT,Argument,Argument) = ERROR_SUCCESS);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TUSBDiskController.MediaReady(ADevice:TDiskDevice):Boolean; 
{Note: Caller must hold the device lock}
var
 Argument:LongWord;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Check Ready}
  Result:=(StorageDeviceControl(ADevice.Storage,STORAGE_CONTROL_TEST_READY,Argument,Argument) = ERROR_SUCCESS);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TUSBDiskController.MediaChanged(ADevice:TDiskDevice):Boolean; 
{Note: Caller must hold the device lock}
var
 Argument:LongWord;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Check Changed}
  Result:=(StorageDeviceControl(ADevice.Storage,STORAGE_CONTROL_TEST_CHANGED,Argument,Argument) = ERROR_SUCCESS);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TUSBDiskController.MediaLocked(ADevice:TDiskDevice):Boolean; 
{Note: Caller must hold the device lock}
var
 Argument:LongWord;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Check Locked}
  Result:=(StorageDeviceControl(ADevice.Storage,STORAGE_CONTROL_TEST_LOCKED,Argument,Argument) = ERROR_SUCCESS);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TUSBDiskController.Information(ADevice:TDiskDevice):String; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:='';

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Return Result}
  Result:=FILESYS_USB_DEVICE_DESCRIPTION; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TUSBDiskController.VendorId(ADevice:TDiskDevice):Word; 
{Note: Caller must hold the device lock}
var
 Argument:LongWord;
begin
 {}
 Result:=0;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get VendorId}
  if StorageDeviceControl(ADevice.Storage,STORAGE_CONTROL_GET_VENDORID,Argument,Argument) = ERROR_SUCCESS then
   begin
    Result:=Argument;
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TUSBDiskController.DeviceId(ADevice:TDiskDevice):Word; 
{Note: Caller must hold the device lock}
var
 Argument:LongWord;
begin
 {}
 Result:=0;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get DeviceId}
  if StorageDeviceControl(ADevice.Storage,STORAGE_CONTROL_GET_PRODUCTID,Argument,Argument) = ERROR_SUCCESS then
   begin
    Result:=Argument;
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}
   
function TUSBDiskController.Manufacturer(ADevice:TDiskDevice):String; 
{Note: Caller must hold the device lock}
var
 Len:LongWord;
 Argument:LongWord;
begin
 {}
 Result:='';

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Manufacturer}
  if StorageDeviceControl(ADevice.Storage,STORAGE_CONTROL_GET_MANUFACTURER,Argument,Argument) = ERROR_SUCCESS then
   begin
    Len:=StrLen(PChar(Argument));
    if Len > 0 then
     begin
      SetLength(Result,Len);
      StrLCopy(PChar(Result),PChar(Argument),Len);
     end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TUSBDiskController.Product(ADevice:TDiskDevice):String; 
{Note: Caller must hold the device lock}
var
 Len:LongWord;
 Argument:LongWord;
begin
 {}
 Result:='';

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Product}
  if StorageDeviceControl(ADevice.Storage,STORAGE_CONTROL_GET_PRODUCT,Argument,Argument) = ERROR_SUCCESS then
   begin
    Len:=StrLen(PChar(Argument));
    if Len > 0 then
     begin
      SetLength(Result,Len);
      StrLCopy(PChar(Result),PChar(Argument),Len);
     end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TUSBDiskController.SerialNumber(ADevice:TDiskDevice):String; 
{Note: Caller must hold the device lock}
var
 Len:LongWord;
 Argument:LongWord;
begin
 {}
 Result:='';

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Serial Number}
  if StorageDeviceControl(ADevice.Storage,STORAGE_CONTROL_GET_SERIAL,Argument,Argument) = ERROR_SUCCESS then
   begin
    Len:=StrLen(PChar(Argument));
    if Len > 0 then
     begin
      SetLength(Result,Len);
      StrLCopy(PChar(Result),PChar(Argument),Len);
     end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}
   
function TUSBDiskController.LogicalUnitNo(ADevice:TDiskDevice):LongWord; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=0;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Return Result}
  Result:=ADevice.Storage.TargetLUN;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}
   
function TUSBDiskController.LBA(ADevice:TDiskDevice):Boolean; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Nothing (Always support LBA)}
  Result:=True;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TUSBDiskController.MediaType(ADevice:TDiskDevice):TMediaType; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=mtUNKNOWN;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Media Type}
  case ADevice.Storage.Device.DeviceType of
   STORAGE_TYPE_HDD:Result:=mtFIXED;
   STORAGE_TYPE_FDD:Result:=mtFLOPPY;
   STORAGE_TYPE_CDROM:Result:=mtCDROM;
   STORAGE_TYPE_OPTICAL,STORAGE_TYPE_TAPE:Result:=mtOTHER;
   STORAGE_TYPE_REMOVABLE:Result:=mtREMOVABLE;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TUSBDiskController.FloppyType(ADevice:TDiskDevice):TFloppyType; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=ftUNKNOWN;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Floppy Type}
  if (ADevice.Storage.Device.DeviceType = STORAGE_TYPE_FDD) and (ADevice.Storage.BlockSize = MIN_SECTOR_SIZE) then
   begin
    case ADevice.Storage.BlockCount of
     720:Result:=ft360K;
     2400:Result:=ft12M;
     1440:Result:=ft720K;
     2880:Result:=ft144M;
     5760:Result:=ft288M;
    else
     Result:=ftATAPI;
    end;
   end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TUSBDiskController.Ready(ADevice:TDiskDevice):Boolean; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Ready}
  Result:=((ADevice.Storage.Device.DeviceFlags and STORAGE_FLAG_NOT_READY) = 0);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TUSBDiskController.Locked(ADevice:TDiskDevice):Boolean; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Locked}
  Result:=((ADevice.Storage.Device.DeviceFlags and STORAGE_FLAG_LOCKED) = STORAGE_FLAG_LOCKED);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TUSBDiskController.Lockable(ADevice:TDiskDevice):Boolean; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Lockable}
  Result:=((ADevice.Storage.Device.DeviceFlags and STORAGE_FLAG_LOCKABLE) = STORAGE_FLAG_LOCKABLE);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TUSBDiskController.Ejectable(ADevice:TDiskDevice):Boolean; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Ejectable}
  Result:=((ADevice.Storage.Device.DeviceFlags and STORAGE_FLAG_EJECTABLE) = STORAGE_FLAG_EJECTABLE);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TUSBDiskController.Readable(ADevice:TDiskDevice):Boolean; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Readable}
  Result:=((ADevice.Storage.Device.DeviceFlags and STORAGE_FLAG_WRITE_ONLY) = 0);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TUSBDiskController.Writeable(ADevice:TDiskDevice):Boolean; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Writeable}
  Result:=((ADevice.Storage.Device.DeviceFlags and STORAGE_FLAG_READ_ONLY) = 0);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TUSBDiskController.Removable(ADevice:TDiskDevice):Boolean; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Removable}
  Result:=((ADevice.Storage.Device.DeviceFlags and STORAGE_FLAG_REMOVABLE) <> 0);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TUSBDiskController.ChangeLine(ADevice:TDiskDevice):Boolean; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Change Line}
  Result:=((ADevice.Storage.Device.DeviceFlags and STORAGE_FLAG_CHANGABLE) = STORAGE_FLAG_CHANGABLE);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TUSBDiskController.PhysicalCylinders(ADevice:TDiskDevice):LongWord; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=0;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Physical Cylinders}
  Result:=GetCylinders(ADevice);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TUSBDiskController.PhysicalHeads(ADevice:TDiskDevice):LongWord; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=0;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Physical Heads}
  Result:=GetHeads(ADevice);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TUSBDiskController.PhysicalSectors(ADevice:TDiskDevice):LongWord; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=0;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Physical Sectors}
  Result:=GetSectors(ADevice);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TUSBDiskController.LogicalCylinders(ADevice:TDiskDevice):LongWord; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=0;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Logical Cylinders}
  Result:=((GetCylinders(ADevice) shr GetLogicalShiftCount(ADevice)) and $FFFFFFFE); {Round to even multiple}
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TUSBDiskController.LogicalHeads(ADevice:TDiskDevice):LongWord;
{Note: Caller must hold the device lock}
begin
 {}
 Result:=0;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Logical Heads}
  Result:=(GetHeads(ADevice) shl GetLogicalShiftCount(ADevice));
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TUSBDiskController.LogicalSectors(ADevice:TDiskDevice):LongWord; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=0;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Logical Sectors}
  Result:=GetSectors(ADevice);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TUSBDiskController.SectorSize(ADevice:TDiskDevice):Word; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=0;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Sector Size}
  Result:=ADevice.Storage.BlockSize;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TUSBDiskController.SectorCount(ADevice:TDiskDevice):Int64; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=0;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Sector Count}
  Result:=ADevice.Storage.BlockCount;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}
{==============================================================================}
{TMMCDiskController}
constructor TMMCDiskController.Create(ADriver:TFileSysDriver);
begin
 {}
 inherited Create(ADriver);
 FDescription:=FILESYS_MMC_CONTROLLER_DESCRIPTION;
end;

{==============================================================================}

function TMMCDiskController.ControllerInit:Boolean; 
begin
 {}
 Result:=False;
 
 if not WriterLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TMMCDiskController.ControllerInit');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                    Name = ' + Name);
  {$ENDIF}
  
  if FDriver = nil then Exit;
 
  {Nothing}
  Result:=True;
 finally  
  WriterUnlock;
 end; 
end;

{==============================================================================}

function TMMCDiskController.LocateDevices:Boolean; 
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {$IFDEF FILESYS_DEBUG}
  if FILESYS_LOG_ENABLED then FileSysLogDebug('TMMCDiskController.LocateDevices');
  if FILESYS_LOG_ENABLED then FileSysLogDebug('                     Name = ' + Name);
  {$ENDIF}

  if FDriver = nil then Exit;

  {Nothing (MMC devices are added and removed by notification}
  Result:=True;
 finally  
  ReaderUnlock;
 end; 
end; 

{==============================================================================}

function TMMCDiskController.Read(ADevice:TDiskDevice;ASector:LongWord;ACount:Word;var ABuffer):Boolean; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Count} 
  if ACount = 0 then Exit;

  {Check Readable}
  if not ADevice.Readable then Exit;
 
  {Check Storage}
  if ADevice.Storage = nil then Exit;
 
  {Read Storage}
  Result:=(StorageDeviceRead(ADevice.Storage,ASector,ACount,@ABuffer) = ERROR_SUCCESS);
 finally  
  ReaderUnlock;
 end; 
end;
 
{==============================================================================}

function TMMCDiskController.Write(ADevice:TDiskDevice;ASector:LongWord;ACount:Word;const ABuffer):Boolean; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Count} 
  if ACount = 0 then Exit;

  {Check Writeable}
  if not ADevice.Writeable then Exit;
 
  {Check Storage}
  if ADevice.Storage = nil then Exit;
 
  {Write Storage}
  Result:=(StorageDeviceWrite(ADevice.Storage,ASector,ACount,@ABuffer) = ERROR_SUCCESS);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TMMCDiskController.Erase(ADevice:TDiskDevice;ASector:LongWord;ACount:Word):Boolean; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Count} 
  if ACount = 0 then Exit;

  {Check Writeable}
  if not ADevice.Writeable then Exit;
 
  {Check Storage}
  if ADevice.Storage = nil then Exit;
 
  {Erase Storage}
  Result:=(StorageDeviceErase(ADevice.Storage,ASector,ACount) = ERROR_SUCCESS);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TMMCDiskController.Reset(ADevice:TDiskDevice):Boolean; 
{Note: Caller must hold the device lock}
var
 Argument:LongWord;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;
 
  {Reset Storage}
  Result:=(StorageDeviceControl(ADevice.Storage,STORAGE_CONTROL_RESET,Argument,Argument) = ERROR_SUCCESS);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TMMCDiskController.LockMedia(ADevice:TDiskDevice):Boolean; 
{Note: Caller must hold the device lock}
var
 Argument:LongWord;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Lock Media}
  Result:=(StorageDeviceControl(ADevice.Storage,STORAGE_CONTROL_LOCK,Argument,Argument) = ERROR_SUCCESS);
  if Result then ADevice.FLocked:=Locked(ADevice);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TMMCDiskController.UnlockMedia(ADevice:TDiskDevice):Boolean; 
{Note: Caller must hold the device lock}
var
 Argument:LongWord;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Unlock Media}
  Result:=(StorageDeviceControl(ADevice.Storage,STORAGE_CONTROL_UNLOCK,Argument,Argument) = ERROR_SUCCESS);
  if Result then ADevice.FLocked:=Locked(ADevice);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TMMCDiskController.EjectMedia(ADevice:TDiskDevice):Boolean; 
{Note: Caller must hold the device lock}
var
 Argument:LongWord;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Eject Media}
  Result:=(StorageDeviceControl(ADevice.Storage,STORAGE_CONTROL_EJECT,Argument,Argument) = ERROR_SUCCESS);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TMMCDiskController.MediaReady(ADevice:TDiskDevice):Boolean; 
{Note: Caller must hold the device lock}
var
 Argument:LongWord;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Check Ready}
  Result:=(StorageDeviceControl(ADevice.Storage,STORAGE_CONTROL_TEST_READY,Argument,Argument) = ERROR_SUCCESS);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TMMCDiskController.MediaChanged(ADevice:TDiskDevice):Boolean; 
{Note: Caller must hold the device lock}
var
 Argument:LongWord;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Check Changed}
  Result:=(StorageDeviceControl(ADevice.Storage,STORAGE_CONTROL_TEST_CHANGED,Argument,Argument) = ERROR_SUCCESS);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TMMCDiskController.MediaLocked(ADevice:TDiskDevice):Boolean; 
{Note: Caller must hold the device lock}
var
 Argument:LongWord;
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Check Locked}
  Result:=(StorageDeviceControl(ADevice.Storage,STORAGE_CONTROL_TEST_LOCKED,Argument,Argument) = ERROR_SUCCESS);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TMMCDiskController.Information(ADevice:TDiskDevice):String; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:='';

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Return Result}
  Result:=FILESYS_MMC_DEVICE_DESCRIPTION; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TMMCDiskController.VendorId(ADevice:TDiskDevice):Word; 
{Note: Caller must hold the device lock}
var
 Argument:LongWord;
begin
 {}
 Result:=0;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get VendorId}
  if StorageDeviceControl(ADevice.Storage,STORAGE_CONTROL_GET_VENDORID,Argument,Argument) = ERROR_SUCCESS then
   begin
    Result:=Argument;
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TMMCDiskController.DeviceId(ADevice:TDiskDevice):Word; 
{Note: Caller must hold the device lock}
var
 Argument:LongWord;
begin
 {}
 Result:=0;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get DeviceId}
  if StorageDeviceControl(ADevice.Storage,STORAGE_CONTROL_GET_PRODUCTID,Argument,Argument) = ERROR_SUCCESS then
   begin
    Result:=Argument;
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}
   
function TMMCDiskController.Manufacturer(ADevice:TDiskDevice):String; 
{Note: Caller must hold the device lock}
var
 Len:LongWord;
 Argument:LongWord;
begin
 {}
 Result:='';

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Manufacturer}
  if StorageDeviceControl(ADevice.Storage,STORAGE_CONTROL_GET_MANUFACTURER,Argument,Argument) = ERROR_SUCCESS then
   begin
    Len:=StrLen(PChar(Argument));
    if Len > 0 then
     begin
      SetLength(Result,Len);
      StrLCopy(PChar(Result),PChar(Argument),Len);
     end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TMMCDiskController.Product(ADevice:TDiskDevice):String; 
{Note: Caller must hold the device lock}
var
 Len:LongWord;
 Argument:LongWord;
begin
 {}
 Result:='';

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Product}
  if StorageDeviceControl(ADevice.Storage,STORAGE_CONTROL_GET_PRODUCT,Argument,Argument) = ERROR_SUCCESS then
   begin
    Len:=StrLen(PChar(Argument));
    if Len > 0 then
     begin
      SetLength(Result,Len);
      StrLCopy(PChar(Result),PChar(Argument),Len);
     end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TMMCDiskController.SerialNumber(ADevice:TDiskDevice):String; 
{Note: Caller must hold the device lock}
var
 Len:LongWord;
 Argument:LongWord;
begin
 {}
 Result:='';

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Serial Number}
  if StorageDeviceControl(ADevice.Storage,STORAGE_CONTROL_GET_SERIAL,Argument,Argument) = ERROR_SUCCESS then
   begin
    Len:=StrLen(PChar(Argument));
    if Len > 0 then
     begin
      SetLength(Result,Len);
      StrLCopy(PChar(Result),PChar(Argument),Len);
     end; 
   end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}
   
function TMMCDiskController.LogicalUnitNo(ADevice:TDiskDevice):LongWord; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=0;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Return Result}
  Result:=ADevice.Storage.TargetLUN;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}
   
function TMMCDiskController.LBA(ADevice:TDiskDevice):Boolean; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Nothing (Always support LBA)}
  Result:=True;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TMMCDiskController.MediaType(ADevice:TDiskDevice):TMediaType; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=mtUNKNOWN;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Media Type}
  case ADevice.Storage.Device.DeviceType of
   STORAGE_TYPE_HDD:Result:=mtFIXED;
   STORAGE_TYPE_FDD:Result:=mtFLOPPY;
   STORAGE_TYPE_CDROM:Result:=mtCDROM;
   STORAGE_TYPE_OPTICAL,STORAGE_TYPE_TAPE:Result:=mtOTHER;
   STORAGE_TYPE_REMOVABLE:Result:=mtREMOVABLE;
  end;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TMMCDiskController.FloppyType(ADevice:TDiskDevice):TFloppyType; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=ftUNKNOWN;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Floppy Type}
  if (ADevice.Storage.Device.DeviceType = STORAGE_TYPE_FDD) and (ADevice.Storage.BlockSize = MIN_SECTOR_SIZE) then
   begin
    case ADevice.Storage.BlockCount of
     720:Result:=ft360K;
     2400:Result:=ft12M;
     1440:Result:=ft720K;
     2880:Result:=ft144M;
     5760:Result:=ft288M;
    else
     Result:=ftATAPI;
    end;
   end; 
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TMMCDiskController.Ready(ADevice:TDiskDevice):Boolean; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Ready}
  Result:=((ADevice.Storage.Device.DeviceFlags and STORAGE_FLAG_NOT_READY) = 0);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TMMCDiskController.Locked(ADevice:TDiskDevice):Boolean; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Locked}
  Result:=((ADevice.Storage.Device.DeviceFlags and STORAGE_FLAG_LOCKED) = STORAGE_FLAG_LOCKED);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TMMCDiskController.Lockable(ADevice:TDiskDevice):Boolean; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Lockable}
  Result:=((ADevice.Storage.Device.DeviceFlags and STORAGE_FLAG_LOCKABLE) = STORAGE_FLAG_LOCKABLE);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TMMCDiskController.Ejectable(ADevice:TDiskDevice):Boolean; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Ejectable}
  Result:=((ADevice.Storage.Device.DeviceFlags and STORAGE_FLAG_EJECTABLE) = STORAGE_FLAG_EJECTABLE);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TMMCDiskController.Readable(ADevice:TDiskDevice):Boolean; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Readable}
  Result:=((ADevice.Storage.Device.DeviceFlags and STORAGE_FLAG_WRITE_ONLY) = 0);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TMMCDiskController.Writeable(ADevice:TDiskDevice):Boolean; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Writeable}
  Result:=((ADevice.Storage.Device.DeviceFlags and STORAGE_FLAG_READ_ONLY) = 0);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TMMCDiskController.Eraseable(ADevice:TDiskDevice):Boolean; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Writeable}
  Result:=((ADevice.Storage.Device.DeviceFlags and STORAGE_FLAG_ERASEABLE) = STORAGE_FLAG_ERASEABLE);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TMMCDiskController.Removable(ADevice:TDiskDevice):Boolean; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Removable}
  Result:=((ADevice.Storage.Device.DeviceFlags and STORAGE_FLAG_REMOVABLE) <> 0);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TMMCDiskController.ChangeLine(ADevice:TDiskDevice):Boolean; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=False;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Change Line}
  Result:=((ADevice.Storage.Device.DeviceFlags and STORAGE_FLAG_CHANGABLE) = STORAGE_FLAG_CHANGABLE);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TMMCDiskController.PhysicalCylinders(ADevice:TDiskDevice):LongWord; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=0;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Physical Cylinders}
  Result:=GetCylinders(ADevice);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TMMCDiskController.PhysicalHeads(ADevice:TDiskDevice):LongWord; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=0;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Physical Heads}
  Result:=GetHeads(ADevice);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TMMCDiskController.PhysicalSectors(ADevice:TDiskDevice):LongWord; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=0;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Physical Sectors}
  Result:=GetSectors(ADevice);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TMMCDiskController.LogicalCylinders(ADevice:TDiskDevice):LongWord; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=0;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Logical Cylinders}
  Result:=((GetCylinders(ADevice) shr GetLogicalShiftCount(ADevice)) and $FFFFFFFE); {Round to even multiple}
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TMMCDiskController.LogicalHeads(ADevice:TDiskDevice):LongWord; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=0;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Logical Heads}
  Result:=(GetHeads(ADevice) shl GetLogicalShiftCount(ADevice));
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TMMCDiskController.LogicalSectors(ADevice:TDiskDevice):LongWord; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=0;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Logical Sectors}
  Result:=GetSectors(ADevice);
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TMMCDiskController.SectorSize(ADevice:TDiskDevice):Word; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=0;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Sector Size}
  Result:=ADevice.Storage.BlockSize;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}

function TMMCDiskController.SectorCount(ADevice:TDiskDevice):Int64; 
{Note: Caller must hold the device lock}
begin
 {}
 Result:=0;

 if not ReaderLock then Exit;
 try
  {Check Driver}
  if FDriver = nil then Exit;

  {Check Device}
  if ADevice = nil then Exit;

  {Check Storage}
  if ADevice.Storage = nil then Exit;

  {Get Sector Count}
  Result:=ADevice.Storage.BlockCount;
 finally  
  ReaderUnlock;
 end; 
end;

{==============================================================================}
{==============================================================================}
{TFSHandleStream}
constructor TFSHandleStream.Create(AHandle:Integer);
begin
 {}
 FHandle:=AHandle;
end;

{=============================================================================}

procedure TFSHandleStream.SetSize(NewSize:LongInt);
begin
 {}
 Seek(NewSize,soFromBeginning);
 FSFileTruncate(FHandle);
end;

{=============================================================================}

function TFSHandleStream.Read(var Buffer;Count:LongInt):LongInt;
begin
 {}
 Result:=FSFileRead(FHandle,Buffer,Count);
 if Result = -1 then Result:=0;
end;

{=============================================================================}

function TFSHandleStream.Write(const Buffer;Count:LongInt):LongInt;
begin
 {}
 Result:=FSFileWrite(FHandle,Buffer,Count);
 if Result = -1 then Result:=0;
end;

{=============================================================================}

function TFSHandleStream.Seek(Offset:LongInt;Origin:Word):LongInt;
begin
 {}
 Result:=FSFileSeekEx(FHandle,Offset,Origin);
end;

{=============================================================================}
{=============================================================================}
{TFSFileStream}
constructor TFSFileStream.Create(const FileName:String;Mode:Word);
begin
 {}
 if Mode = fmCreate then
  begin
   FHandle:=FSFileCreate(FileName);
   if FHandle = Integer(INVALID_HANDLE_VALUE) then
    raise EFCreateError.CreateFmt(SFCreateError,[FileName]);
  end
 else
  begin
   FHandle:=FSFileOpen(FileName,Mode);
   if FHandle = Integer(INVALID_HANDLE_VALUE) then
    raise EFOpenError.CreateFmt(SFOpenError,[FileName]);
  end;
end;

{=============================================================================}

destructor TFSFileStream.Destroy;
begin
 {}
 if FHandle <> Integer(INVALID_HANDLE_VALUE) then FSFileClose(FHandle);
end;

{=============================================================================}
{=============================================================================}
{TFSHandleStreamEx}
constructor TFSHandleStreamEx.Create(AHandle:Integer);
begin
 {}
 FHandle:=AHandle;
end;

{=============================================================================}

procedure TFSHandleStreamEx.SetSize(NewSize:LongInt);
begin
 {}
 Seek(NewSize,soFromBeginning); 
 FSFileTruncate(FHandle);
end;

{=============================================================================}

procedure TFSHandleStreamEx.SetSizeEx(const NewSize:Int64);
begin
 {}
 SeekEx(NewSize,soFromBeginning);
 FSFileTruncate(FHandle); 
end;

{=============================================================================}

function TFSHandleStreamEx.Read(var Buffer;Count:LongInt):LongInt;
begin
 {}
 Result:=FSFileRead(FHandle,Buffer,Count);
 if Result = -1 then Result:=0;
end;

{=============================================================================}

function TFSHandleStreamEx.Write(const Buffer;Count:LongInt):LongInt;
begin
 {}
 Result:=FSFileWrite(FHandle,Buffer,Count);
 if Result = -1 then Result:=0;
end;

{=============================================================================}

function TFSHandleStreamEx.Seek(Offset:LongInt;Origin:Word):LongInt;
begin
 {}
 Result:=FSFileSeekEx(FHandle,Offset,Origin);
end;

{=============================================================================}

function TFSHandleStreamEx.SeekEx(const Offset:Int64;Origin:Word):Int64;
begin
 {}
 Result:=FSFileSeekEx(FHandle,Offset,Origin);
end;

{=============================================================================}
{=============================================================================}
{TFSFileStreamEx}
constructor TFSFileStreamEx.Create(const FileName:String;Mode:Word);
begin
 {}
 if Mode = fmCreate then
  begin
   FHandle:=FSFileCreate(FileName);
   if FHandle = Integer(INVALID_HANDLE_VALUE) then
    raise EFCreateError.CreateFmt(SFCreateError,[FileName]);
  end
 else
  begin
   FHandle:=FSFileOpen(FileName,Mode);
   if FHandle = Integer(INVALID_HANDLE_VALUE) then
    raise EFOpenError.CreateFmt(SFOpenError,[FileName]);
  end;
end;

{=============================================================================}

destructor TFSFileStreamEx.Destroy;
begin
 {}
 if FHandle <> Integer(INVALID_HANDLE_VALUE) then FSFileClose(FHandle);
end;

{==============================================================================}
{==============================================================================}
{Initialization Functions}
procedure FileSysInit;
var
 Status:LongWord;
 WorkInt:LongWord;
 WorkBuffer:String;
 Logging:PFileSysLogging;
begin
 {}
 {Check Initialized}
 if FileSysInitialized then Exit;
 
 {Initialize Logging}
 FILESYS_LOG_ENABLED:=(FILESYS_DEFAULT_LOG_LEVEL <> FILESYS_LOG_LEVEL_NONE); 
 
 {Create Lock}
 FileSysLock:=CriticalSectionCreate;
 if FileSysLock = INVALID_HANDLE_VALUE then
  begin
   if FILESYS_LOG_ENABLED then FileSysLogError('Failed to create filesystem lock');
  end;
 
 {Set Startup Defaults}
 FileSysStartupCount:=0;
 FileSysStartupError:=ERROR_NOT_READY;
 
 {Create FileSys Driver}
 FileSysDriver:=TFileSysDriver.Create;
 
 {Check ATA Enabled}
 if FILESYS_ATA_ENABLED then
  begin
   {Create ATA Disk Controller}
   FileSysATAController:=TATADiskController.Create(FileSysDriver);
   FileSysATAController.ControllerInit;
  end;

 {Check ATAPI Enabled}
 if FILESYS_ATAPI_ENABLED then
  begin
   {Create ATAPI Disk Controller}
   FileSysATAPIController:=TATAPIDiskController.Create(FileSysDriver);
   FileSysATAPIController.ControllerInit;
  end;
  
 {Check SCSI Enabled}
 if FILESYS_SCSI_ENABLED then
  begin
   {Create SCSI Disk Controller}
   FileSysSCSIController:=TSCSIDiskController.Create(FileSysDriver);
   FileSysSCSIController.ControllerInit;
  end;

 {Check USB Enabled}
 if FILESYS_USB_ENABLED then
  begin
   {Create USB Disk Controller}
   FileSysUSBController:=TUSBDiskController.Create(FileSysDriver);
   FileSysUSBController.ControllerInit;
  end;

 {Check MMC Enabled}
 if FILESYS_MMC_ENABLED then
  begin
   {Create MMC Disk Controller}
   FileSysMMCController:=TMMCDiskController.Create(FileSysDriver);
   FileSysMMCController.ControllerInit;
  end;
  
 {Setup Platform Handlers}
 {Text IO}
 {TextIOReadCharHandler:=SysTextIOReadChar;}       {Only registered when calling FileSysRedirectInput}
 {TextIOWriteCharHandler:=SysTextIOWriteChar;}     {Only registered when calling FileSysRedirectOutput}
 {TextIOWriteBufferHandler:=SysTextIOWriteBuffer;} {Only registered when calling FileSysRedirectOutput}
  
 {Setup System Handlers}
 {File Functions}
 SysDoCloseHandler:=SystemDoClose;
 SysDoEraseHandler:=SystemDoErase;
 SysDoRenameHandler:=SystemDoRename;
 SysDoWriteHandler:=SystemDoWrite;
 SysDoReadHandler:=SystemDoRead;
 SysDoFilePosHandler:=SystemDoFilePos;
 SysDoSeekHandler:=SystemDoSeek;
 SysDoSeekEndHandler:=SystemDoSeekEnd;
 SysDoFileSizeHandler:=SystemDoFileSize;
 SysDoTruncateHandler:=SystemDoTruncate;
 SysDoOpenHandler:=SystemDoOpen;
 {Directory Functions}
 SysDoMkDirHandler:=SystemDoMkDir;
 SysDoRmDirHandler:=SystemDoRmDir;
 SysDoChDirHandler:=SystemDoChDir;
 SysDoGetDirHandler:=SystemDoGetDir;
 
 {Setup Dos Handlers}
 {Disk Functions}
 DosDiskFreeHandler:=DosDiskFree;
 DosDiskSizeHandler:=DosDiskSize;
 {FindFirst/FindNext Functions}
 DosFindFirstHandler:=DosFindFirst;
 DosFindNextHandler:=DosFindNext;
 DosFindCloseHandler:=DosFindClose;
 {File Functions}
 DosGetFTimeHandler:=DosGetFTime;
 DosSetFTimeHandler:=DosSetFTime;
 DosGetFAttrHandler:=DosGetFAttr;
 DosSetFAttrHandler:=DosSetFAttr;
 DosGetShortNameHandler:=DosGetShortName;
 DosGetLongNameHandler:=DosGetLongName;
 
 {Setup SysUtils Handlers}
 {File Functions}
 SysUtilsFileOpenHandler:=SysUtilsFileOpen;
 SysUtilsFileCreateHandler:=SysUtilsFileCreate;
 SysUtilsDeleteFileHandler:=SysUtilsDeleteFile;
 SysUtilsFileCloseHandler:=SysUtilsFileClose;
 SysUtilsRenameFileHandler:=SysUtilsRenameFile;
 SysUtilsFileSeekHandler:=SysUtilsFileSeek;
 SysUtilsFileTruncateHandler:=SysUtilsFileTruncate;
 SysUtilsFileAgeHandler:=SysUtilsFileAge;
 {$IFNDEF FPC_LEGACY}
 SysUtilsFileGetSymLinkTargetHandler:=SysUtilsFileGetSymLinkTarget;
 {$ENDIF}
 SysUtilsFileExistsHandler:=SysUtilsFileExists;
 SysUtilsFileGetAttrHandler:=SysUtilsFileGetAttr;
 SysUtilsFileGetDateHandler:=SysUtilsFileGetDate;
 SysUtilsFileSetAttrHandler:=SysUtilsFileSetAttr;
 SysUtilsFileSetDateHandler:=SysUtilsFileSetDate;
 SysUtilsFileReadHandler:=SysUtilsFileRead;
 SysUtilsFileWriteHandler:=SysUtilsFileWrite;
 SysUtilsFileSeekExHandler:=SysUtilsFileSeekEx;
 
 SysUtilsInternalFindFirstHandler:=SysUtilsInternalFindFirst;
 SysUtilsInternalFindNextHandler:=SysUtilsInternalFindNext;
 SysUtilsInternalFindCloseHandler:=SysUtilsInternalFindClose;
 {Disk Functions}
 SysUtilsDiskFreeHandler:=SysUtilsDiskFree;
 SysUtilsDiskSizeHandler:=SysUtilsDiskSize;
 SysUtilsDirectoryExistsHandler:=SysUtilsDirectoryExists;
 
 {Setup Ultibo Handlers}
 {Drive Functions (Compatibility)}
 UltiboGetDriveTypeAHandler:=FSGetDiskType;
 UltiboGetLogicalDrivesHandler:=FSGetLogicalDrives;
 UltiboGetLogicalDriveStringsAHandler:=FSGetLogicalDriveStrings;
 UltiboDefineDosDeviceAHandler:=FSDefineDosDevice;
 UltiboQueryDosDeviceAHandler:=FSQueryDosDevice;
 UltiboSetVolumeLabelAHandler:=FSSetVolumeLabel;
 UltiboGetVolumeInformationAHandler:=FSGetVolumeInformation;
 UltiboGetDiskFreeSpaceAHandler:=FSGetDiskFreeSpace;
 UltiboGetDiskFreeSpaceExAHandler:=FSGetDiskFreeSpaceEx;
 {Drive Functions (Ultibo)}
 UltiboGetDriveTypeHandler:=FSGetDriveType;
 UltiboGetDriveDataHandler:=FSGetDriveData;
 UltiboGetDriveAttrHandler:=FSGetDriveAttr;
 UltiboGetDriveLabelHandler:=FSGetDriveLabel;
 UltiboSetDriveLabelHandler:=FSSetDriveLabel;
 UltiboGetDriveSerialHandler:=FSGetDriveSerial;
 UltiboSetDriveSerialHandler:=FSSetDriveSerial;
 UltiboIsDriveValidHandler:=FSIsDriveValid;
 UltiboGetValidDrivesHandler:=FSGetValidDrives;
 UltiboGetValidDriveNamesHandler:=FSGetValidDriveStrings; {Not FSGetValidDriveNames}
 UltiboGetDriveFreeSpaceHandler:=FSGetDriveFreeSpace;
 UltiboGetDriveFreeSpaceExHandler:=FSGetDriveFreeSpaceEx;
 UltiboGetDriveTotalSpaceHandler:=FSGetDriveTotalSpace;
 UltiboGetDriveTotalSpaceExHandler:=FSGetDriveTotalSpaceEx;
 UltiboGetDriveInformationHandler:=FSGetDriveInformation;
 UltiboGetCurrentDriveHandler:=FSGetCurrentDrive;
 UltiboSetCurrentDriveHandler:=FSSetCurrentDrive;
 {File Functions (Compatibility)}
 UltiboAreFileApisANSIHandler:=FSAreFileApisANSI;
 UltiboSetFileApisToOEMHandler:=FSSetFileApisToOEM;
 UltiboSetFileApisToANSIHandler:=FSSetFileApisToANSI;
 UltiboCreateFileAHandler:=FSCreateFile;
 UltiboCloseFileHandler:=FSCloseFile;
 UltiboSetFileAttributesAHandler:=FSSetFileAttributes;
 UltiboGetFileAttributesAHandler:=FSGetFileAttributes;
 UltiboDeleteFileAHandler:=FSDeleteFile;
 UltiboMoveFileAHandler:=FSMoveFile;
 UltiboFindFirstFileAHandler:=FSFindFirstFile;
 UltiboFindNextFileAHandler:=FSFindNextFile;
 UltiboFindCloseFileHandler:=FSFindCloseFile;
 UltiboGetFileSizeHandler:=FSGetFileSize;
 UltiboGetFileSizeExHandler:=FSFileSizeEx; {Not FSGetFileSizeEx}
 UltiboGetFileTimeHandler:=FSGetFileTime;
 UltiboSetFileTimeHandler:=FSSetFileTime;
 UltiboReadFileHandler:=FSReadFile;
 UltiboWriteFileHandler:=FSWriteFile;
 UltiboSetEndOfFileHandler:=FSSetEndOfFile;
 UltiboSetFilePointerHandler:=FSSetFilePointer;
 UltiboSetFilePointerExHandler:=FSSetFilePointerEx;
 UltiboFlushFileBuffersHandler:=FSFlushFileBuffers;
 UltiboCopyFileAHandler:=FSCopyFile;
 UltiboSetFileShortNameAHandler:=FSSetFileShortNameEx; {Not FSSetFileShortName}
 UltiboCreateHardLinkAHandler:=FSCreateHardLink;
 UltiboCreateSymbolicLinkAHandler:=FSCreateSymbolicLink;
 UltiboGetFileInformationByHandleHandler:=FSGetFileInformationByHandle;
 {Directory Functions (Compatibility)}
 UltiboCreateDirectoryAHandler:=FSCreateDirectory;
 UltiboRemoveDirectoryAHandler:=FSRemoveDirectory;
 UltiboSetCurrentDirectoryAHandler:=FSSetCurrentDirectory;
 UltiboGetCurrentDirectoryAHandler:=FSGetCurrentDirectory;
 UltiboGetLongPathNameAHandler:=FSGetLongPathName;
 UltiboGetShortPathNameAHandler:=FSGetShortPathName;
 UltiboGetFullPathNameAHandler:=FSGetFullPathName;
 
 {Check Environment Variables (FileSystem)}
 //To Do
 
 {Check Environment Variables (Cache)}
 {FILESYS_CACHE_SIZE}
 WorkInt:=StrToIntDef(SysUtils.GetEnvironmentVariable('FILESYS_CACHE_SIZE'),0);
 if WorkInt > 0 then FILESYS_CACHE_SIZE:=WorkInt;
 
 {FILESYS_CACHE_PAGE}
 WorkInt:=StrToIntDef(SysUtils.GetEnvironmentVariable('FILESYS_CACHE_PAGE'),0);
 if WorkInt > 0 then FILESYS_CACHE_PAGE:=WorkInt;
 
 {FILESYS_CACHE_KEYS}
 WorkInt:=StrToIntDef(SysUtils.GetEnvironmentVariable('FILESYS_CACHE_KEYS'),0);
 if WorkInt > 0 then FILESYS_CACHE_KEYS:=WorkInt;
 
 {FILESYS_CACHE_MODE}
 //To Do
 
 {Check Environment Variables (Logging)}
 {FILESYS_REGISTER_LOGGING}
 WorkInt:=StrToIntDef(SysUtils.GetEnvironmentVariable('FILESYS_REGISTER_LOGGING'),0);
 if WorkInt <> 0 then FILESYS_REGISTER_LOGGING:=True;
 
 {FILESYS_LOGGING_DEFAULT}
 WorkInt:=StrToIntDef(SysUtils.GetEnvironmentVariable('FILESYS_LOGGING_DEFAULT'),0);
 if WorkInt <> 0 then FILESYS_LOGGING_DEFAULT:=True;
 
 {FILESYS_LOGGING_FILE}
 WorkBuffer:=SysUtils.GetEnvironmentVariable('FILESYS_LOGGING_FILE');
 if Length(WorkBuffer) <> 0 then FILESYS_LOGGING_FILE:=WorkBuffer;
 
 {FILESYS_LOGGING_MAXSIZE}
 WorkInt:=StrToIntDef(SysUtils.GetEnvironmentVariable('FILESYS_LOGGING_MAXSIZE'),0);
 if WorkInt > 0 then FILESYS_LOGGING_MAXSIZE:=WorkInt;
 
 {FILESYS_LOGGING_MAXCOPIES}
 WorkInt:=StrToIntDef(SysUtils.GetEnvironmentVariable('FILESYS_LOGGING_MAXCOPIES'),0);
 if WorkInt > 0 then FILESYS_LOGGING_MAXCOPIES:=WorkInt;

 {FILESYS_LOGGING_RESET}
 WorkInt:=StrToIntDef(SysUtils.GetEnvironmentVariable('FILESYS_LOGGING_RESET'),0);
 if WorkInt <> 0 then FILESYS_LOGGING_RESET:=True;

 {Create Logging}
 if FILESYS_REGISTER_LOGGING then
  begin
   Logging:=PFileSysLogging(LoggingDeviceCreateEx(SizeOf(TFileSysLogging),FILESYS_LOGGING_DEFAULT));
   if Logging <> nil then
    begin
     {Update Logging}
     {Device}
     Logging.Logging.Device.DeviceBus:=DEVICE_BUS_NONE; 
     Logging.Logging.Device.DeviceType:=LOGGING_TYPE_FILE;
     Logging.Logging.Device.DeviceFlags:=LOGGING_FLAG_NONE;
     Logging.Logging.Device.DeviceData:=nil;
     Logging.Logging.Device.DeviceDescription:=FILESYS_LOGGING_DESCRIPTION;
     {Logging}
     Logging.Logging.LoggingState:=LOGGING_STATE_DISABLED;
     Logging.Logging.DeviceStart:=FileSysLoggingStart;
     Logging.Logging.DeviceStop:=FileSysLoggingStop;
     Logging.Logging.DeviceOutput:=FileSysLoggingOutput;
     Logging.Logging.DeviceSetTarget:=FileSysLoggingSetTarget;
     Logging.Logging.Target:=FILESYS_LOGGING_FILE;
     {FileSystem}
     
     {Register Logging}
     Status:=LoggingDeviceRegister(@Logging.Logging);
     if Status = ERROR_SUCCESS then
      begin
       {Start Logging}
       Status:=LoggingDeviceStart(@Logging.Logging);
       if Status <> ERROR_SUCCESS then
        begin
         if DEVICE_LOG_ENABLED then DeviceLogError(nil,'Logging: Failed to start new filesystem logging device: ' + ErrorToString(Status));

         {Deregister Logging}
         LoggingDeviceDeregister(@Logging.Logging);

         {Destroy Logging}
         LoggingDeviceDestroy(@Logging.Logging);
        end;
      end
     else 
      begin
       if DEVICE_LOG_ENABLED then DeviceLogError(nil,'Logging: Failed to register new filesystem logging device: ' + ErrorToString(Status));

       {Destroy Logging}
       LoggingDeviceDestroy(@Logging.Logging);
      end;
    end
   else 
    begin
     if DEVICE_LOG_ENABLED then DeviceLogError(nil,'Logging: Failed to create new filesystem logging device');
    end;
  end;
 
 FileSysInitialized:=True;
end;

{==============================================================================}

function FileSysStart:LongWord;
begin
 {}
 Result:=ERROR_INVALID_PARAMETER;

 {Check Driver}
 if FileSysDriver = nil then Exit;
 
 {Acquire the Lock}
 if CriticalSectionLock(FileSysLock) = ERROR_SUCCESS then
  begin
   try
    {Check Count}
    if FileSysStartupCount > 0 then
     begin
      {$IFDEF FILESYS_DEBUG}
      if FILESYS_LOG_ENABLED then FileSysLogDebug('FileSys: Additional start call');
      {$ENDIF}
      
      {Increment Count}
      Inc(FileSysStartupCount);
 
      {Return Result}
      Result:=FileSysStartupError; 
     end
    else
     begin
      {$IFDEF FILESYS_DEBUG}
      if FILESYS_LOG_ENABLED then FileSysLogDebug('FileSys: Initial start call');
      {$ENDIF}
 
      {Increment Count}
      Inc(FileSysStartupCount);
 
      {Initialize Components}
      Result:=ERROR_OPERATION_FAILED;
      FileSysStartupError:=ERROR_OPERATION_FAILED;
 
      {Setup Driver Options}
      FileSysDriver.AllowFloppy:=FILESYS_FLOPPY_ENABLED;
      FileSysDriver.AllowDrives:=FILESYS_DRIVES_ENABLED;
      FileSysDriver.OemConvert:=FILESYS_OEM_CONVERT;
      
      {Setup FAT Options}
      FAT_CASE_FLAGS:=FILESYS_CASE_FLAGS;
      FAT_LONG_NAMES:=FILESYS_LONG_NAMES;
      FAT_OEM_CONVERT:=FILESYS_OEM_CONVERT;
      FAT_NUMERIC_TAIL:=FILESYS_NUMERIC_TAIL;
      FAT_DIRTY_CHECK:=FILESYS_DIRTY_CHECK;
      FAT_QUICK_CHECK:=FILESYS_QUICK_CHECK;
       {See also specific FAT options in GlobalConfig unit}
      
      {Setup NTFS Options}
       {See also specific NTFS options in GlobalConfig unit}

      {Setup EXTFS Options}
       {See also specific EXTFS options in GlobalConfig unit}
       
      {Setup CDFS Options}
      CDFS_LONG_NAMES:=FILESYS_LONG_NAMES;
       {See also specific CDFS options in GlobalConfig unit}
      
      {Register Notification} 
      StorageDeviceNotification(nil,FileSysStorageDeviceNotify,nil,DEVICE_NOTIFICATION_REGISTER or DEVICE_NOTIFICATION_DEREGISTER or DEVICE_NOTIFICATION_EJECTING or DEVICE_NOTIFICATION_EJECT or DEVICE_NOTIFICATION_INSERT,NOTIFIER_FLAG_NONE);
      
      {Enumerate Storage}
      StorageDeviceEnumerate(FileSysStorageDeviceEnum,nil);
      
      {Start Cache}
      FileSysDriver.Cache.OpenCache(FILESYS_CACHE_SIZE,FILESYS_CACHE_KEYS,FILESYS_CACHE_PAGE,cmREADWRITE); //To Do //FILESYS_CACHE_MODE
      
      {Locate Devices, Partitions, Volumes, Drives}
      FileSysDriver.LocateDevices;
      FileSysDriver.LocatePartitions;
      FileSysDriver.LocateVolumes;
      FileSysDriver.LocateDrives;
      
      {Register Shutdown}
      //To Do
      
      {$IFDEF FILESYS_DEBUG}
      if FILESYS_LOG_ENABLED then FileSysLogDebug('FileSys: Start completed');
      {$ENDIF}
 
      {Return Result} 
      Result:=ERROR_SUCCESS;
      FileSysStartupError:=ERROR_SUCCESS;
     end;
   finally
    {Release the Lock}
    CriticalSectionUnlock(FileSysLock);
   end;
  end
 else
  begin
   Result:=ERROR_CAN_NOT_COMPLETE;
  end;
end;

{==============================================================================}

function FileSysStop:LongWord;
begin
 {}
 Result:=ERROR_INVALID_PARAMETER;

 {Check Driver}
 if FileSysDriver = nil then Exit;
 
 {Acquire the Lock}
 if CriticalSectionLock(FileSysLock) = ERROR_SUCCESS then
  begin
   try
    {Check Started}
    Result:=ERROR_OPERATION_FAILED;
    if FileSysStartupCount = 0 then Exit;
    
    {Decrement Count}
    Dec(FileSysStartupCount);
    Result:=ERROR_SUCCESS;
    if FileSysStartupCount > 0 then Exit;
    
    {$IFDEF FILESYS_DEBUG}
    if FILESYS_LOG_ENABLED then FileSysLogDebug('FileSys: Final stop call');
    {$ENDIF}
 
    {Shutdown and Cleanup}
    Result:=ERROR_OPERATION_FAILED;

    {Deregister Notification}
    StorageDeviceNotification(nil,FileSysStorageDeviceNotify,nil,DEVICE_NOTIFICATION_NONE,NOTIFIER_FLAG_NONE);
    
    {Deregister Shutdown}
    //To Do
 
    {Shutdown Drives, Volumes, Partitions, Devices}
    //FileSysDriver.ShutdownDrives;
    //FileSysDriver.ShutdownVolumes;
    //FileSysDriver.ShutdownPartitions;
    //FileSysDriver.ShutdownDevices;
    //To Do
 
    {Close Cache}
    FileSysDriver.Cache.CloseCache;
 
    {$IFDEF FILESYS_DEBUG}
    if FILESYS_LOG_ENABLED then FileSysLogDebug('FileSys: Stop completed');
    {$ENDIF}

    {Return Result} 
    Result:=ERROR_SUCCESS;
    FileSysStartupError:=ERROR_NOT_READY;
   finally
    {Release the Lock}
    CriticalSectionUnlock(FileSysLock);
   end;
  end
 else
  begin
   Result:=ERROR_CAN_NOT_COMPLETE;
  end;
end;

{==============================================================================}

function FileSysStartCompleted:Boolean;
{Returns True if the filesystem has been started}
begin
 {}
 Result:=FileSysStartupError = ERROR_SUCCESS;
end;

{==============================================================================}

procedure FileSysAsyncStart(Data:Pointer);
begin
 {}
 {Wait for Ready}
 while not(SysInitCompleted) do
  begin
   ThreadSleep(0);
  end;
 
 {Start FileSys}
 FileSysStart;
end;

{==============================================================================}
{==============================================================================}
{FileSystem Functions (Delphi / FreePascal RTL Equivalent)}
{Drive Functions}
function FSGetPathDrive(const APath:String):Byte; inline;
{No Volume Support}
begin
 {}
 Result:=DEFAULT_DRIVE;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Get Path Drive}
 Result:=FileSysDriver.GetPathDrive(APath);
end;

{==============================================================================}

function FSGetDriveType(ADrive:Byte):TDriveType; inline;
{No Volume Support}
begin
 {}
 Result:=dtINVALID;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;
 
 {Get Drive Type}
 Result:=FileSysDriver.GetDriveType(ADrive);
end;

{==============================================================================}

function FSGetDriveData(ADrive:Byte):TDriveData; inline;
{No Volume Support}
begin
 {}
 FillChar(Result,SizeOf(TDriveData),0);
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Get Drive Data}
 Result:=FileSysDriver.GetDriveData(ADrive);
end;

{==============================================================================}

function FSGetDriveAttr(ADrive:Byte):LongWord; inline;
{No Volume Support}
begin
 {}
 Result:=0;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Get Drive Attr}
 Result:=FileSysDriver.GetDriveAttr(ADrive);
end;

{==============================================================================}

function FSGetDriveLabel(ADrive:Byte):String; inline;
{No Volume Support}
begin
 {}
 Result:='';
 
 {Check Driver}
 if FileSysDriver = nil then Exit;
 
 {Get Drive Label}
 Result:=FileSysDriver.GetDriveLabel(ADrive);
end;

{==============================================================================}

function FSSetDriveLabel(ADrive:Byte;const ALabel:String):Boolean; inline;
{No Volume Support}
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;
 
 {Set Drive Label}
 Result:=FileSysDriver.SetDriveLabel(ADrive,ALabel);
end;

{==============================================================================}

function FSGetDriveSerial(ADrive:Byte):LongWord; inline;
{No Volume Support}
begin
 {}
 Result:=0;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;
 
 {Get Drive Serial}
 Result:=FileSysDriver.GetDriveSerial(ADrive);
end;

{==============================================================================}

function FSSetDriveSerial(ADrive:Byte;ASerial:LongWord):Boolean; inline;
{No Volume Support}
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;
 
 {Set Drive Serial}
 Result:=FileSysDriver.SetDriveSerial(ADrive,ASerial);
end;

{==============================================================================}

function FSIsDriveValid(ADrive:Byte):Boolean; inline;
{No Volume Support}
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Is Drive Valid}
 Result:=FileSysDriver.IsDriveValid(ADrive);
end;

{==============================================================================}

function FSGetValidDrives:LongWord; inline;
{No Volume Support}
begin
 {}
 Result:=0;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Get Valid Drives}
 Result:=FileSysDriver.GetValidDrives;
end;

{==============================================================================}

function FSGetValidDriveNames:TStringList; inline;
{No Volume Support}
begin
 {}
 Result:=TStringList.Create;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Get Valid Drive Names}
 Result:=FileSysDriver.GetValidDriveNames;
end;

{==============================================================================}

function FSGetValidDriveStrings:String; inline;
{No Volume Support}
begin
 {}
 Result:='';
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Get Valid Drive Strings}
 Result:=FileSysDriver.GetValidDriveStrings;
end;

{==============================================================================}

function FSGetDriveFreeSpace(ADrive:Byte):LongWord; inline;
{No Volume Support}
begin
 {}
 Result:=0;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Get Drive Free Space}
 Result:=FileSysDriver.GetDriveFreeSpace(ADrive);
end;

{==============================================================================}

function FSGetDriveFreeSpaceEx(ADrive:Byte):Int64; inline;
{No Volume Support}
begin
 {}
 Result:=0;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Get Drive Free Space Ex}
 Result:=FileSysDriver.GetDriveFreeSpaceEx(ADrive);
end;

{==============================================================================}

function FSGetDriveTotalSpace(ADrive:Byte):LongWord; inline;
{No Volume Support}
begin
 {}
 Result:=0;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Get Drive Total Space}
 Result:=FileSysDriver.GetDriveTotalSpace(ADrive);
end;

{==============================================================================}

function FSGetDriveTotalSpaceEx(ADrive:Byte):Int64; inline;
{No Volume Support}
begin
 {}
 Result:=0;

 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Get Drive Total Space Ex}
 Result:=FileSysDriver.GetDriveTotalSpaceEx(ADrive);
end;

{==============================================================================}

function FSGetDriveInformation(const APath:String;var AClusterSize:LongWord;var ATotalClusterCount,AFreeClusterCount:Int64):Boolean; inline;   
begin
 {}
 Result:=False;

 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Get Drive Information}
 Result:=FileSysDriver.GetDriveInformation(APath,AClusterSize,ATotalClusterCount,AFreeClusterCount);
end;

{==============================================================================}

function FSGetCurrentDrive:Byte; inline;
{No Volume Support}
begin
 {}
 Result:=0;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Get Current Drive}
 Result:=FileSysDriver.GetCurrentDrive;
end;

{==============================================================================}

function FSSetCurrentDrive(const ADrive:String):Boolean; inline;
{No Volume Support}
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Set Current Drive}
 Result:=FileSysDriver.SetCurrentDrive(ADrive);
end;

{==============================================================================}
{File Functions}
function FSFileOpen(const AFileName:String;AMode:Integer):THandle; inline;
begin
 {}
 Result:=INVALID_HANDLE_VALUE;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Open File}
 Result:=FileSysDriver.FileOpen(AFileName,AMode);
end;

{==============================================================================}

function FSFileCreate(const AFileName:String):THandle; inline;
begin
 {}
 Result:=INVALID_HANDLE_VALUE;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Create File}
 Result:=FileSysDriver.FileCreate(AFileName);
end;

{==============================================================================}

function FSDeleteFile(const AFileName:String):Boolean; inline;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Delete File}
 Result:=FileSysDriver.DeleteFile(AFileName);
end;

{==============================================================================}

procedure FSFileClose(AHandle:Integer); inline;
begin
 {}
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Close File}
 FileSysDriver.FileClose(AHandle);
end;

{==============================================================================}

function FSRenameFile(const AOldName,ANewName:String):Boolean; inline;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Rename File}
 Result:=FileSysDriver.RenameFile(AOldName,ANewName);
end;

{==============================================================================}

function FSFileSeek(AHandle:THandle;AOffset,AOrigin:LongInt):LongInt; inline;
begin
 {}
 Result:=-1;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Seek File}
 Result:=FileSysDriver.FileSeekEx(AHandle,AOffset,AOrigin);
end;

{==============================================================================}

function FSFileFlush(AHandle:Integer):Boolean; inline;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Flush File}
 Result:=FileSysDriver.FileFlush(AHandle);
end;

{==============================================================================}

function FSFileTruncate(AHandle:Integer):Boolean; inline;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Truncate File}
 Result:=FileSysDriver.FileTruncate(AHandle);
end;

{==============================================================================}

function FSSetEndOfFile(AHandle:THandle):Boolean; inline;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Set End Of File}
 Result:=FileSysDriver.SetEndOfFile(AHandle);
end;

{==============================================================================}

function FSEndOfFile(AHandle:Integer):Boolean; inline;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {End Of File}
 Result:=FileSysDriver.EndOfFile(AHandle);
end;

{==============================================================================}

function FSFilePos(AHandle:THandle):LongInt; inline;
begin
 {}
 Result:=-1;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {File Pos}
 Result:=FileSysDriver.FilePosEx(AHandle);
end;

{==============================================================================}

function FSFileSize(AHandle:THandle):LongInt; inline;
begin
 {}
 Result:=-1;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {File Size}
 Result:=FileSysDriver.FileSizeEx(AHandle);
end;

{==============================================================================}

function FSFileAge(const AFileName:String):Integer; inline;
begin
 {}
 Result:=-1;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {File Age}
 Result:=FileSysDriver.FileAge(AFileName);
end;

{==============================================================================}

function FSFileExists(const AFileName:String):Boolean; inline;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {File Exists}
 Result:=FileSysDriver.FileExists(AFileName);
end;

{==============================================================================}

function FSFileGetAttr(const AFileName:String):Integer; inline;
begin
 {}
 Result:=-1;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {File Get Attr}
 Result:=FileSysDriver.FileGetAttr(AFileName);
end;

{==============================================================================}

function FSFileGetDate(AHandle:Integer):Integer; inline;
begin
 {}
 Result:=-1;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {File Get Date}
 Result:=FileSysDriver.FileGetDate(AHandle);
end;

{==============================================================================}

function FSFileSetAttr(const AFileName:String;AAttr:Integer):Integer; inline;
begin
 {}
 Result:=-1;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {File Set Attr}
 Result:=FileSysDriver.FileSetAttr(AFileName,AAttr);
end;

{==============================================================================}

function FSFileSetDate(AHandle:Integer;AAge:Integer):Integer; inline;
begin
 {}
 Result:=-1;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {File Set Date}
 Result:=FileSysDriver.FileSetDate(AHandle,AAge);
end;

{==============================================================================}

function FSFileRead(AHandle:THandle;var ABuffer;ACount:LongInt):LongInt; inline;
begin
 {}
 Result:=-1;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Read File}
 Result:=FileSysDriver.FileRead(AHandle,ABuffer,ACount);
end;

{==============================================================================}

function FSFileWrite(AHandle:THandle;const ABuffer;ACount:LongInt):LongInt; inline;
begin
 {}
 Result:=-1;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Write File}
 Result:=FileSysDriver.FileWrite(AHandle,ABuffer,ACount)
end;

{==============================================================================}
{Directory Functions}
function FSCreateDir(const ADirName:String):Boolean; inline;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Create Dir}
 Result:=FileSysDriver.CreateDir(ADirName);
end;

{==============================================================================}

function FSRemoveDir(const ADirName:String):Boolean; inline;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Remove Dir}
 Result:=FileSysDriver.RemoveDir(ADirName);
end;

{==============================================================================}

function FSRenameDir(const AOldName,ANewName:String):Boolean; inline;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Rename Dir}
 Result:=FileSysDriver.RenameDir(AOldName,ANewName);
end;

{==============================================================================}

function FSGetCurrentDir:String; inline;
{No Volume Support}
begin
 {}
 Result:='';
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Get Current Dir}
 Result:=FileSysDriver.GetCurrentDir;
end;

{==============================================================================}

function FSSetCurrentDir(const ADirName:String):Boolean; inline;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Set Current Dir}
 Result:=FileSysDriver.SetCurrentDir(ADirName);
end;

{==============================================================================}

function FSDirectoryExists(const ADirName:String):Boolean; inline;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Directory Exists}
 Result:=FileSysDriver.DirectoryExists(ADirName);
end;

{==============================================================================}

procedure FSForceDirectories(ADirName:String); inline;
begin
 {}
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Force Directories}
 FileSysDriver.ForceDirectories(ADirName);
end;

{==============================================================================}

procedure FSDeleteTree(const ADirName:String); inline;
begin
 {}
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Delete Tree}
 FileSysDriver.DeleteTree(ADirName);
end;

{==============================================================================}
{Search Functions}
function FSFindFirst(const APath:String;AAttr:Integer;var ASearchRec:TSearchRec):Integer; inline;
begin
 {}
 Result:=-1;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Find First}
 Result:=FileSysDriver.FindFirst(APath,AAttr,ASearchRec);
end;

{==============================================================================}

function FSFindNext(var ASearchRec:TSearchRec):Integer; inline;
begin
 {}
 Result:=-1;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Find Next}
 Result:=FileSysDriver.FindNext(ASearchRec);
end;

{==============================================================================}

procedure FSFindClose(var ASearchRec:TSearchRec); inline;
begin
 {}
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Find Close}
 FileSysDriver.FindClose(ASearchRec);
end;

{==============================================================================}
{Additional Functions}
function FSFileCopy(const ASourceFile,ADestFile:String;AFailIfExists:Boolean):Boolean; inline;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {File Copy}
 Result:=FileSysDriver.FileCopy(ASourceFile,ADestFile,AFailIfExists);
end;

{==============================================================================}

function FSFileCopyEx(const ASourceFile,ADestFile:String;AFailIfExists:Boolean;AUseSourceDate:Boolean;ADestDate:Integer;AUseSourceAttr:Boolean;ADestAttr:Integer):Boolean; inline;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {File Copy Ex}
 Result:=FileSysDriver.FileCopyEx(ASourceFile,ADestFile,AFailIfExists,AUseSourceDate,ADestDate,AUseSourceAttr,ADestAttr);
end;

{==============================================================================}

function FSGetShortName(const AFileName:String):String; inline;
begin
 {}
 Result:=AFileName;
  
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Get Short Name}
 Result:=FileSysDriver.GetShortName(AFileName);
end;

{==============================================================================}

function FSGetLongName(const AFileName:String):String; inline;
begin
 {}
 Result:=AFileName;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Get Long Name}
 Result:=FileSysDriver.GetLongName(AFileName);
end;

{==============================================================================}

function FSGetTrueName(const AFileName:String):String; inline;
begin
 {}
 Result:=AFileName;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Get True Name}
 Result:=FileSysDriver.GetTrueName(AFileName);
end;

{==============================================================================}
{Extended Functions}
function FSFileSeekEx(AHandle:THandle;const AOffset:Int64;AOrigin:LongInt):Int64; inline;
begin
 {}
 Result:=-1;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Seek File Ex}
 Result:=FileSysDriver.FileSeekEx(AHandle,AOffset,AOrigin);
end;

{==============================================================================}

function FSEndOfFileEx(AHandle:Integer):Boolean; inline;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {End Of File Ex}
 Result:=FileSysDriver.EndOfFileEx(AHandle);
end;

{==============================================================================}

function FSFilePosEx(AHandle:THandle):Int64; inline;
begin
 {}
 Result:=-1;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {File Pos Ex}
 Result:=FileSysDriver.FilePosEx(AHandle);
end;

{==============================================================================}

function FSFileSizeEx(AHandle:THandle):Int64; inline;
begin
 {}
 Result:=-1;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {File Size Ex}
 Result:=FileSysDriver.FileSizeEx(AHandle);
end;

{==============================================================================}

function FSFileAgeEx(const AFileName:String):TFileTime; inline;
begin
 {}
 Int64(Result):=-1;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {File Age Ex}
 Result:=FileSysDriver.FileAgeEx(AFileName);
end;

{==============================================================================}

function FSFileGetAttrEx(AHandle:Integer):Integer; inline;
begin
 {}
 Result:=-1;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {File Get Attr Ex}
 Result:=FileSysDriver.FileGetAttrEx(AHandle);
end;

{==============================================================================}

function FSFileGetDateEx(AHandle:Integer):TFileTime; inline;
begin
 {}
 Int64(Result):=-1;

 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {File Get Date Ex}
 Result:=FileSysDriver.FileGetDateEx(AHandle);
end;

{==============================================================================}

function FSFileSetDateEx(AHandle:Integer;AAge:TFileTime):Integer; inline;
begin
 {}
 Result:=-1;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {File Set Date Ex}
 Result:=FileSysDriver.FileSetDateEx(AHandle,AAge);
end;

{==============================================================================}

function FSGetFileTime(AHandle:THandle;ACreateTime,AAccessTime,AWriteTime:PFileTime):Boolean; inline;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Get File Time}
 Result:=FileSysDriver.GetFileTime(AHandle,ACreateTime,AAccessTime,AWriteTime);
end;

{==============================================================================}

function FSSetFileTime(AHandle:THandle;ACreateTime,AAccessTime,AWriteTime:PFileTime):Boolean; inline;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Set File Time}
 Result:=FileSysDriver.SetFileTime(AHandle,ACreateTime,AAccessTime,AWriteTime);
end;

{==============================================================================}

function FSFindFirstEx(const APath:String;var ASearchRec:TFileSearchRec):Integer; inline;
begin
 {}
 Result:=-1;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Find First Ex}
 Result:=FileSysDriver.FindFirstEx(APath,ASearchRec);
end;

{==============================================================================}

function FSFindNextEx(var ASearchRec:TFileSearchRec):Integer; inline;
begin
 {}
 Result:=-1;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Find Next Ex}
 Result:=FileSysDriver.FindNextEx(ASearchRec);
end;

{==============================================================================}

procedure FSFindCloseEx(var ASearchRec:TFileSearchRec); inline;
begin
 {}
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Find Close Ex}
 FileSysDriver.FindCloseEx(ASearchRec);
end;

{==============================================================================}
{==============================================================================}
{FileSystem Functions (Win32 Compatibility)}
{Drive Functions}
function FSDefineDosDevice(const ADeviceName,ATargetPath:String;AFlags:LongWord):Boolean; inline;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Define Dos Device}
 Result:=FileSysDriver.DefineDosDevice(ADeviceName,ATargetPath,AFlags);
end;

{==============================================================================}

function FSGetDiskType(const ARootPath:String):LongWord; inline; {Equivalent to Win32 GetDriveType}
begin
 {}
 Result:=DRIVE_UNKNOWN;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Get Disk Type}
 Result:=FileSysDriver.GetDiskType(ARootPath);
end;

{==============================================================================}

function FSGetDiskFreeSpace(const ARootPath:String;var ASectorsPerCluster,ABytesPerSector,ANumberOfFreeClusters,ATotalNumberOfClusters:LongWord):Boolean; inline;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Get Disk Free Space}
 Result:=FileSysDriver.GetDiskFreeSpace(ARootPath,ASectorsPerCluster,ABytesPerSector,ANumberOfFreeClusters,ATotalNumberOfClusters);
end;

{==============================================================================}

function FSGetDiskFreeSpaceEx(const APathName:String;var AFreeBytesAvailableToCaller,ATotalNumberOfBytes,ATotalNumberOfFreeBytes:QWord):Boolean; inline;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Get Disk Free Space Ex}
 Result:=FileSysDriver.GetDiskFreeSpaceEx(APathName,AFreeBytesAvailableToCaller,ATotalNumberOfBytes,ATotalNumberOfFreeBytes);
end;

{==============================================================================}

function FSGetLogicalDrives:LongWord; inline;
begin
 {}
 Result:=0;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Get Logical Drives}
 Result:=FileSysDriver.GetLogicalDrives;
end;

{==============================================================================}

function FSGetLogicalDriveStrings:String; inline;
begin
 {}
 Result:='';
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Get Logical Drive Strings}
 Result:=FileSysDriver.GetLogicalDriveStrings;
end;

{==============================================================================}

function FSGetVolumeInformation(const ARootPath:String;var AVolumeName:String;var AVolumeSerialNumber,AMaximumComponentLength,AFileSystemFlags:LongWord;var ASystemName:String):Boolean; inline;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Get Volume Information}
 Result:=FileSysDriver.GetVolumeInformation(ARootPath,AVolumeName,AVolumeSerialNumber,AMaximumComponentLength,AFileSystemFlags,ASystemName);
end;

{==============================================================================}

function FSQueryDosDevice(const ARootPath:String):String; inline;
begin
 {}
 Result:='';
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Query Dos Device}
 Result:=FileSysDriver.QueryDosDevice(ARootPath);
end;

{==============================================================================}

function FSSetVolumeLabel(const AVolume:String;const ALabel:String):Boolean; inline;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Set Volume Label}
 Result:=FileSysDriver.SetVolumeLabel(AVolume,ALabel);
end;

{==============================================================================}
{File Functions}
function FSAreFileApisANSI:Boolean; inline;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Are File Apis ANSI}
 Result:=FileSysDriver.AreFileApisANSI();
end;

{==============================================================================}

function FSCloseFile(AHandle:THandle):Boolean; inline; {Equivalent to Win32 CloseHandle}
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Close File}
 Result:=FileSysDriver.CloseFile(AHandle);
end;

{==============================================================================}

function FSCopyFile(const AExistingName,ANewName:String;AFailIfExists:Boolean):Boolean; inline;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Copy File}
 Result:=FileSysDriver.CopyFile(AExistingName,ANewName,AFailIfExists);
end;

{==============================================================================}

function FSCreateFile(const AFileName:String;AAccessMode,AShareMode,ACreateFlags,AFileAttributes:LongWord):THandle; inline;
begin
 {}
 Result:=INVALID_HANDLE_VALUE;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Create File}
 Result:=FileSysDriver.CreateFile(AFileName,AAccessMode,AShareMode,ACreateFlags,AFileAttributes);
end;

{==============================================================================}

function FSFindCloseFile(AHandle:THandle):Boolean; inline; {Equivalent to Win32 FindClose}
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Find Close File}
 Result:=FileSysDriver.FindCloseFile(AHandle);
end;

{==============================================================================}

function FSFindFirstFile(const AFileName:String;var AFindData:TWin32FindData):THandle; inline;
begin
 {}
 Result:=INVALID_HANDLE_VALUE;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Find First File}
 Result:=FileSysDriver.FindFirstFile(AFileName,AFindData);
end;

{==============================================================================}

function FSFindNextFile(AHandle:THandle;var AFindData:TWin32FindData):Boolean; inline;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Find Next File}
 Result:=FileSysDriver.FindNextFile(AHandle,AFindData);
end;

{==============================================================================}

function FSFlushFileBuffers(AHandle:THandle):Boolean; inline;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Flush File Buffers}
 Result:=FileSysDriver.FlushFileBuffers(AHandle);
end;

{==============================================================================}

function FSGetFileAttributes(const AFileName:String):LongWord; inline;
begin
 {}
 Result:=INVALID_FILE_ATTRIBUTES;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Get File Attributes}
 Result:=FileSysDriver.GetFileAttributes(AFileName);
end;

{==============================================================================}

function FSGetFileInformationByHandle(AHandle:THandle;var AFileInformation:TByHandleFileInformation):Boolean; inline;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Get File Information By Handle}
 Result:=FileSysDriver.GetFileInformationByHandle(AHandle,AFileInformation);
end;

{==============================================================================}

function FSGetFileSize(AHandle:THandle;var AFileSizeHigh:LongWord):LongWord; inline;
begin
 {}
 Result:=INVALID_FILE_SIZE;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Get File Size}
 Result:=FileSysDriver.GetFileSize(AHandle,AFileSizeHigh);
end;

{==============================================================================}

function FSGetFullPathName(const AFileName:String):String; inline;
begin
 {}
 Result:='';
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Get Full Path Name}
 Result:=FileSysDriver.GetFullPathName(AFileName);
end;

{==============================================================================}

function FSGetShortPathName(const ALongPath:String):String; inline;
begin
 {}
 Result:='';
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Get Short Path Name}
 Result:=FileSysDriver.GetShortPathName(ALongPath);
end;

{==============================================================================}

function FSMoveFile(const AExistingName,ANewName:String):Boolean; inline;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Move File}
 Result:=FileSysDriver.MoveFile(AExistingName,ANewName);
end;

{==============================================================================}

function FSReadFile(AHandle:THandle;var ABuffer;ABytesToRead:LongWord;var ABytesRead:LongWord):Boolean; inline;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Read File}
 Result:=FileSysDriver.ReadFile(AHandle,ABuffer,ABytesToRead,ABytesRead);
end;

{==============================================================================}

function FSSetFileApisToANSI:Boolean; inline;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Set File Apis To ANSI}
 Result:=FileSysDriver.SetFileApisToANSI;
end;

{==============================================================================}

function FSSetFileApisToOEM:Boolean; inline;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Set File Apis To OEM}
 Result:=FileSysDriver.SetFileApisToOEM;
end;

{==============================================================================}

function FSSetFileAttributes(const AFileName:String;AFileAttributes:LongWord):Boolean; inline;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Set File Attributes}
 Result:=FileSysDriver.SetFileAttributes(AFileName,AFileAttributes);
end;

{==============================================================================}

function FSSetFilePointer(AHandle:THandle;ADistanceToMove:LongInt;var ADistanceToMoveHigh:LongInt;AMoveMethod:LongWord):LongWord; inline;
begin
 {}
 Result:=INVALID_SET_FILE_POINTER;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Set File Pointer}
 Result:=FileSysDriver.SetFilePointer(AHandle,ADistanceToMove,ADistanceToMoveHigh,AMoveMethod);
end;

{==============================================================================}

function FSSetFilePointerEx(AHandle:THandle;const ADistanceToMove:Int64;var ANewFilePointer:Int64;AMoveMethod:LongWord):Boolean; inline;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Set File Pointer Ex}
 Result:=FileSysDriver.SetFilePointerEx(AHandle,ADistanceToMove,ANewFilePointer,AMoveMethod);
end;

{==============================================================================}

function FSWriteFile(AHandle:THandle;const ABuffer;ABytesToWrite:LongWord;var ABytesWritten:LongWord):Boolean; inline;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Write File}
 Result:=FileSysDriver.WriteFile(AHandle,ABuffer,ABytesToWrite,ABytesWritten);
end;

{==============================================================================}

function FSGetLongPathName(const AShortPath:String):String; inline;
begin
 {}
 Result:='';
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Get Long Path Name}
 Result:=FileSysDriver.GetLongPathName(AShortPath);
end;

{==============================================================================}

function FSSetFileShortName(const AFileName,AShortName:String):Boolean; inline;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Set File Short Name}
 Result:=FileSysDriver.SetFileShortName(AFileName,AShortName);
end;

{==============================================================================}

function FSSetFileShortNameEx(AHandle:THandle;const AShortName:String):Boolean; inline;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Set File Short Name Ex}
 Result:=FileSysDriver.SetFileShortNameEx(AHandle,AShortName);
end;

{==============================================================================}

function FSCreateHardLink(const ALinkName,AFileName:String):Boolean; inline;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Create Hard Link}
 Result:=FileSysDriver.CreateHardLink(ALinkName,AFileName);
end;

{==============================================================================}

function FSCreateSymbolicLink(const ALinkName,ATargetName:String;ADirectory:Boolean):Boolean; inline;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Create Symbolic Link}
 Result:=FileSysDriver.CreateSymbolicLink(ALinkName,ATargetName,ADirectory);
end;
 
{==============================================================================}
{Directory Functions}
function FSCreateDirectory(const APathName:String):Boolean; inline;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Create Directory}
 Result:=FileSysDriver.CreateDirectory(APathName);
end;

{==============================================================================}

function FSGetCurrentDirectory:String; inline;
begin
 {}
 Result:='';
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Get Current Directory}
 Result:=FileSysDriver.GetCurrentDirectory;
end;

{==============================================================================}

function FSRemoveDirectory(const APathName:String):Boolean; inline;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Remove Directory}
 Result:=FileSysDriver.RemoveDirectory(APathName);
end;

{==============================================================================}

function FSSetCurrentDirectory(const APathName:String):Boolean; inline;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Set Current Directory}
 Result:=FileSysDriver.SetCurrentDirectory(APathName);
end;

{==============================================================================}
{==============================================================================}
{RTL Text IO Functions}
function SysTextIOReadChar(var ACh:Char;AUserData:Pointer):Boolean;
{Handler for platform TextIOReadChar function}

{Note: Not intended to be called directly by applications}
begin
 {}
 Result:=(FSFileRead(FileSysTextIOInputHandle,ACh,SizeOf(Char)) <> -1);
end;

{==============================================================================}

function SysTextIOWriteChar(ACh:Char;AUserData:Pointer):Boolean;
{Handler for platform TextIOWriteChar function}

{Note: Not intended to be called directly by applications}
begin
 {}
 Result:=(FSFileWrite(FileSysTextIOOutputHandle,ACh,SizeOf(Char)) <> -1);
end;

{==============================================================================}

function SysTextIOWriteBuffer(ABuffer:PChar;ACount:LongInt;AUserData:Pointer):LongInt;
{Handler for platform TextIOWriteBuffer function}

{Note: Not intended to be called directly by applications}
begin
 {}
 Result:=FSFileWrite(FileSysTextIOOutputHandle,ABuffer^,ACount);
end;

{==============================================================================}
{==============================================================================}
{RTL FileSystem Functions}
{System File Functions}
procedure SystemDoClose(Handle:THandle);
begin
 {}
 {Check Driver}
 if FileSysDriver = nil then
  begin
   InOutRes:=103;
   Exit;
  end; 

 {Close File}
 FileSysDriver.FileClose(Handle);
end;

{==============================================================================}

procedure SystemDoErase(Name:PChar;NameChangeable:Boolean);
begin
 {}
 {Check Driver}
 if FileSysDriver = nil then
  begin
   InOutRes:=2;
   Exit;
  end; 
 
 {Delete File}
 if not FileSysDriver.DeleteFile(Name) then
  begin
   InOutRes:=2;
  end;
end;

{==============================================================================}

procedure SystemDoRename(Name1,Name2:PChar;Name1Changeable,Name2Changeable:Boolean);
begin
 {}
 {Check Driver}
 if FileSysDriver = nil then
  begin
   InOutRes:=2;
   Exit;
  end; 

 {Rename File}
 if not FileSysDriver.RenameFile(Name1,Name2) then
  begin
   InOutRes:=2;
  end;
end;

{==============================================================================}

function SystemDoWrite(Handle:THandle;Address:Pointer;Len:LongInt):LongInt;
begin
 {}
 Result:=-1;
 
 {Check Driver}
 if FileSysDriver = nil then
  begin
   InOutRes:=6;
   Exit;
  end; 

 {Write File}
 Result:=FileSysDriver.FileWrite(Handle,Address^,Len);
 if Result = -1 then
  begin
   InOutRes:=6;
  end;
end;

{==============================================================================}

function SystemDoRead(Handle:THandle;Address:Pointer;Len:LongInt):LongInt;
begin
 {}
 Result:=-1;
 
 {Check Driver}
 if FileSysDriver = nil then
  begin
   InOutRes:=6;
   Exit;
  end; 

 {Read File}
 Result:=FileSysDriver.FileRead(Handle,Address^,Len);
 if Result = -1 then
  begin
   InOutRes:=6;
  end;
end;

{==============================================================================}

function SystemDoFilePos(Handle:THandle):LongInt;
begin
 {}
 Result:=-1;
 
 {Check Driver}
 if FileSysDriver = nil then
  begin
   InOutRes:=6;
   Exit;
  end; 

 {File Pos}
 Result:=FileSysDriver.FilePosEx(Handle);
 if Result = -1 then
  begin
   InOutRes:=6;
  end;
end;

{==============================================================================}

procedure SystemDoSeek(Handle:THandle;Pos:LongInt);
begin
 {}
 {Check Driver}
 if FileSysDriver = nil then
  begin
   InOutRes:=6;
   Exit;
  end; 

 {Seek File}
 if FileSysDriver.FileSeekEx(Handle,Pos,soFromBeginning) = -1 then
  begin
   InOutRes:=6;
  end;
end;

{==============================================================================}

function SystemDoSeekEnd(Handle:THandle):LongInt;
begin
 {}
 Result:=-1;
 
 {Check Driver}
 if FileSysDriver = nil then
  begin
   InOutRes:=6;
   Exit;
  end; 

 {Seek File}
 Result:=FileSysDriver.FileSeekEx(Handle,0,soFromEnd);
 if Result = -1 then
  begin
   InOutRes:=6;
  end;
end;

{==============================================================================}

function SystemDoFileSize(Handle:THandle):LongInt;
begin
 {}
 Result:=-1;
 
 {Check Driver}
 if FileSysDriver = nil then
  begin
   InOutRes:=6;
   Exit;
  end; 

 {File Size}
 Result:=FileSysDriver.FileSizeEx(Handle);
 if Result = -1 then
  begin
   InOutRes:=6;
  end;
end;

{==============================================================================}

procedure SystemDoTruncate(Handle:THandle;Pos:LongInt);
begin
 {}
 {Check Driver}
 if FileSysDriver = nil then
  begin
   InOutRes:=6;
   Exit;
  end; 

 {Seek File}
 if FileSysDriver.FileSeekEx(Handle,Pos,soFromBeginning) = -1 then
  begin
   InOutRes:=6;
   Exit;
  end;
 
 {Truncate File}
 if not FileSysDriver.FileTruncate(Handle) then
  begin
   InOutRes:=6;
  end;
end;

{==============================================================================}

procedure SystemDoOpen(var F;Name:PFileTextRecChar;Flags:LongInt;NameChangeable:Boolean);
{FileRec and TextRec have both Handle and Mode as the first items so they could use the same routine for opening/creating.
 When (Flags and $00100) The file will be Appended
 When (Flags and $01000) The file will be Truncated/Rewritten
 When (Flags and $10000) There is no check for Close (needed for TextFiles)
}
begin
 {}
 {Check Driver}
 if FileSysDriver = nil then Exit;
 
 {Close if Open}
 if ((Flags and $10000) = 0) then
  begin
   case FileRec(F).mode of
    fmInput,fmOutput,fmInOut:begin
      {Close File}
      FileSysDriver.FileClose(FileRec(F).Handle);
     end; 
    fmClosed:begin
      {Nothing}
     end;
    else
     begin
      {Not assigned}
      InOutRes:=102;
      Exit;
     end;
   end;
  end;
 
 {Reset handle}
 FileRec(F).Handle:=UnusedHandle;
  
 {Convert Flags to FileRec Mode}
 case (Flags and $03) of
  fmOpenRead:FileRec(f).Mode:=fmInput;
  fmOpenWrite:FileRec(f).Mode:=fmOutput;
  fmOpenReadWrite:FileRec(f).Mode:=fmInOut;
 end;
  
 {Check Name}
 if Name[0] = #0 then
  begin
   case FileRec(F).Mode of
    fmInput:begin
      FileRec(F).Handle:=StdInputHandle;
     end; 
    fmInOut,fmOutput:begin
      FileRec(F).Handle:=StdOutputHandle;
     end; 
    fmAppend:begin
      FileRec(F).Handle:=StdOutputHandle;
      FileRec(F).Mode:=fmOutput;
     end;
   end;
    
   Exit;
  end;
  
 {Check for Create}
 if (Flags and $1000) <> 0 then
  begin
   {Check Exists}
   if FileSysDriver.FileExists(Name) then
    begin
     {Open File}
     FileRec(F).Handle:=FileSysDriver.FileOpen(Name,Flags and $000000FF);
     
     {Check Handle}
     if (FileRec(F).Handle <> INVALID_HANDLE_VALUE) and (FileRec(F).Handle <> UnusedHandle) then
      begin
       {Seek File}
       FileSysDriver.FileSeekEx(FileRec(F).Handle,0,soFromBeginning);
       
       {Truncate File}
       if not FileSysDriver.FileTruncate(FileRec(F).Handle) then
        begin
         {Close File}
         FileSysDriver.FileClose(FileRec(F).Handle);
         FileRec(F).Handle:=UnusedHandle;
        end;
      end;  
    end
   else
    begin   
     {Create File}
     FileRec(F).Handle:=FileSysDriver.FileCreate(Name);
    end; 
  end
 else
  begin
   {Open File}
   FileRec(F).Handle:=FileSysDriver.FileOpen(Name,Flags and $000000FF);
   
   {Check Append}
   if ((Flags and $100) <> 0) and (FileRec(F).Handle <> INVALID_HANDLE_VALUE) and (FileRec(F).Handle <> UnusedHandle) then
    begin
     {Seek File}
     FileSysDriver.FileSeekEx(FileRec(F).Handle,0,soFromEnd);
     FileRec(F).Mode:=fmOutput;
    end;
  end;
  
 {Check Handle}
 if (FileRec(F).Handle = INVALID_HANDLE_VALUE) or (FileRec(F).Handle = UnusedHandle) then
  begin
   InOutRes:=5;
   FileRec(F).Mode:=fmClosed;
  end;
end;

{==============================================================================}
{System Directory Functions}
procedure SystemDoMkDir(const Dir:RawByteString);
begin
 {}
 {Check Driver}
 if FileSysDriver = nil then
  begin
   InOutRes:=3;
   Exit;
  end; 

 {Create Dir}
 if not FileSysDriver.CreateDir(Dir) then
  begin
   InOutRes:=3;
  end;
end;

{==============================================================================}

procedure SystemDoRmDir(const Dir:RawByteString);
begin
 {}
 {Check Driver}
 if FileSysDriver = nil then
  begin
   InOutRes:=3;
   Exit;
  end; 
 
 {Remove Dir}
 if not FileSysDriver.RemoveDir(Dir) then
  begin
   InOutRes:=3;
  end;
end;

{==============================================================================}

procedure SystemDoChDir(const Dir:RawByteString);
begin
 {}
 {Check Driver}
 if FileSysDriver = nil then
  begin
   InOutRes:=3;
   Exit;
  end; 

 {Set Current Dir}
 if not FileSysDriver.SetCurrentDir(Dir) then
  begin
   InOutRes:=3;
  end;
end;

{==============================================================================}

procedure SystemDoGetDir(Drive:Byte;var Dir:RawByteString);
begin
 {}
 {Check Driver}
 if FileSysDriver = nil then
  begin
   InOutRes:=3;
   Exit;
  end; 

 {Get Current Dir}
 Dir:=FileSysDriver.GetCurrentDirEx(Drive);
end;

{==============================================================================}
{Dos Disk Functions}
function DosDiskFree(Drive:Byte):Int64;
{No Volume Support}
begin
 {}
 Result:=-1;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Get Drive Free Space Ex}
 Result:=FileSysDriver.GetDriveFreeSpaceEx(Drive);
end;

{==============================================================================}

function DosDiskSize(Drive:Byte):Int64;
{No Volume Support}
begin
 {}
 Result:=-1;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Get Drive Total Space Ex}
 Result:=FileSysDriver.GetDriveTotalSpaceEx(Drive);
end;

{==============================================================================}
{Dos FindFirst/FindNext Functions}
function DosFindMatchingFile(var f:SearchRec):Integer;
{Internal Only}
var
 LocalFileTime:TFileTime;
 FileSearchRec:TFileSearchRec;
begin
 {}
 Result:=18; {Dos Error 18 (Not Found)}
 
 {Check Driver}
 if FileSysDriver = nil then Exit;
 
 while (f.FindData.dwFileAttributes and f.ExcludeAttr) <> 0 do
  begin
   {Get Handle}
   FileSearchRec.FindHandle:=f.FindHandle;
  
   {Find Next}
   if FileSysDriver.FindNextEx(FileSearchRec) = 0 then
    begin
     {Save SearchRec}
     SysUtils.TWin32FindDataA(f.FindData):=FileSearchRec.FindData;
    end
   else
    begin
     Exit;
    end;    
  end;
 
 {Update the SearchRec from the FindData record}
 Ultibo.FileTimeToLocalFileTime(SysUtils.FILETIME(f.FindData.ftLastWriteTime),LocalFileTime);
 Ultibo.FileTimeToDosDateTime(LocalFileTime,LongRec(f.Time).Hi,LongRec(f.Time).Lo);
 f.Size:=f.FindData.nFileSizeLow;
 f.Attr:=f.FindData.dwFileAttributes;
 f.Name:=StrPas(@f.FindData.cFileName);
 
 Result:=0;
end;

{==============================================================================}

function DosFindFirst(const Path:PathStr;Attr:Word;var f:SearchRec):Integer;
{Notes: FindFirst/FindNext/FindClose - To be compatible with the DOS
FindFirst/FindNext we always allow faReadOnly and faArchive but only
allow other attributes if requested. This is done by matching all
files and filtering with FindMatchingFile}

{Apparently there is an oddity with faVolumeId where you shouldn't
allow any other attributes at all, this needs to be tested and added}
const
 faSpecial = faHidden or faSysFile or faVolumeID or faDirectory;
var
 FileSearchRec:TFileSearchRec;
begin
 {}
 Result:=18; {Dos Error 18 (Not Found)}
 
 {Check Driver}
 if FileSysDriver = nil then Exit;
 
 {Find First}
 if FileSysDriver.FindFirstEx(Path,FileSearchRec) = 0 then
  begin
   {Save SearchRec}
   f.ExcludeAttr:=not(Attr) and faSpecial;
   f.FindHandle:=FileSearchRec.FindHandle;
   SysUtils.TWin32FindDataA(f.FindData):=FileSearchRec.FindData;
   
   {Find Matching}
   Result:=DosFindMatchingFile(f);
   if Result <> 0 then DosFindClose(f);
  end; 
end;

{==============================================================================}

function DosFindNext(var f:SearchRec):Integer;
var
 FileSearchRec:TFileSearchRec;
begin
 {}
 Result:=18; {Dos Error 18 (Not Found)}
 
 {Check Driver}
 if FileSysDriver = nil then Exit;
 
 {Get Handle}
 FileSearchRec.FindHandle:=f.FindHandle;
 
 {Find Next}
 if FileSysDriver.FindNextEx(FileSearchRec) = 0 then
  begin
   {Save SearchRec}
   SysUtils.TWin32FindDataA(f.FindData):=FileSearchRec.FindData;
   
   {Find Matching}
   Result:=DosFindMatchingFile(f);
  end;
end;

{==============================================================================}

procedure DosFindClose(var f:SearchRec);
var
 FileSearchRec:TFileSearchRec;
begin
 {}
 {Check Driver}
 if FileSysDriver = nil then Exit;
 
 {Get Handle}
 FileSearchRec.FindHandle:=f.FindHandle;
 
 {Find Close}
 FileSysDriver.FindCloseEx(FileSearchRec);
end;

{==============================================================================}
{Dos File Functions}
function DosGetFTime(var f;var Time:LongInt):Integer;
var
 WriteTime:TFileTime;
 LocalTime:TFileTime;
begin
 {}
 Time:=0;
 Result:=18; {Dos Error 18 (Not Found)}
 
 {Check Driver}
 if FileSysDriver = nil then Exit;
 
 {Get File Time}
 if not FileSysDriver.GetFileTime(FileRec(f).Handle,nil,nil,@WriteTime) then Exit;
 
 {Convert to Local Time}
 if not Ultibo.FileTimeToLocalFileTime(WriteTime,LocalTime) then Exit;
 
 {Convert to DOS Date and Time}
 if not Ultibo.FileTimeToDosDateTime(LocalTime,LongRec(Time).Hi,LongRec(Time).Lo) then Exit;
 
 Result:=0;
end;

{==============================================================================}

function DosSetFTime(var f;Time:LongInt):Integer;
var
 WriteTime:TFileTime;
 LocalTime:TFileTime;
begin
 {}
 Result:=18; {Dos Error 18 (Not Found)}
 
 {Check Driver}
 if FileSysDriver = nil then Exit;
 
 {Convert to File Time}
 if not Ultibo.DosDateTimeToFileTime(LongRec(Time).Hi,LongRec(Time).Lo,LocalTime) then Exit;
 
 {Convert to System Time}
 if not Ultibo.LocalFileTimeToFileTime(LocalTime,WriteTime) then Exit;
 
 {Set File Time}
 if not FileSysDriver.SetFileTime(FileRec(f).Handle,nil,nil,@WriteTime) then Exit;
 
 Result:=0;
end;

{==============================================================================}

function DosGetFAttr(var f;var Attr:Word):Integer;
var
 Name:String;
 Attributes:Integer;
begin
 {}
 Result:=18; {Dos Error 18 (Not Found)}
 
 {Check Driver}
 if FileSysDriver = nil then Exit;
 
 {Get Name}
 Name:=ToSingleByteFileSystemEncodedFileName(FileRec(f).Name);
 
 {Get File Attributes}
 Attributes:=FileGetAttr(Name);
 if Attributes = -1 then Exit;
 
 {Return Attributes}
 Attr:=Attributes and $FFFF;
 
 Result:=0;
end;

{==============================================================================}

function DosSetFAttr(var f;Attr:Word):Integer;
var
 Name:String;
begin
 {}
 Result:=18; {Dos Error 18 (Not Found)}
 
 {Check Driver}
 if FileSysDriver = nil then Exit;
 
 {Get Name}
 Name:=ToSingleByteFileSystemEncodedFileName(FileRec(f).Name);
 
 {Set File Attributes}
 if FileSetAttr(Name,Attr) = -1 then Exit;
 
 Result:=0;
end;

{==============================================================================}

function DosGetShortName(var p:ShortString):Boolean;
var
 Name:String;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;
 
 {Get Short Name}
 Name:=FileSysDriver.GetShortName(p);
 p:=Name;
 
 Result:=True;
end;

{==============================================================================}

function DosGetLongName(var p:ShortString):Boolean;
var
 Name:String;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;
 
 {Get Long Name}
 Name:=FileSysDriver.GetLongName(p);
 p:=Name;
 
 Result:=True;
end;

{==============================================================================}
{SysUtils File Functions}
function SysUtilsFileOpen(const FileName:RawByteString;Mode:Integer):THandle;
begin
 {}
 Result:=INVALID_HANDLE_VALUE;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Open File}
 Result:=FileSysDriver.FileOpen(FileName,Mode);
end;

{==============================================================================}

function SysUtilsFileCreate(const FileName:RawByteString;ShareMode:Integer):THandle;
begin
 {}
 Result:=INVALID_HANDLE_VALUE;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Create File}
 Result:=FileSysDriver.FileCreate(FileName,fmOpenReadWrite or ShareMode);
end;

{==============================================================================}

function SysUtilsDeleteFile(const FileName:RawByteString):Boolean;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Delete File}
 Result:=FileSysDriver.DeleteFile(FileName);
end;

{==============================================================================}

procedure SysUtilsFileClose(Handle:THandle);
begin
 {}
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Close File}
 FileSysDriver.FileClose(Handle);
end;

{==============================================================================}

function SysUtilsRenameFile(const OldName,NewName:RawByteString):Boolean;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Rename File}
 Result:=FileSysDriver.RenameFile(OldName,NewName);
end;

{==============================================================================}

function SysUtilsFileSeek(Handle:THandle;Offset,Origin:LongInt):LongInt;
begin
 {}
 Result:=-1;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Seek File}
 Result:=FileSysDriver.FileSeekEx(Handle,Offset,Origin);
end;

{==============================================================================}

function SysUtilsFileTruncate(Handle:THandle;Size:Int64):Boolean;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Seek File}
 FileSysDriver.FileSeekEx(Handle,Size,soFromBeginning);
 
 {Truncate File}
 Result:=FileSysDriver.FileTruncate(Handle);
end;

{==============================================================================}

function SysUtilsFileAge(const FileName:RawByteString):LongInt;
begin
 {}
 Result:=-1;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {File Age}
 Result:=FileSysDriver.FileAge(FileName);
end;

{==============================================================================}
{$IFNDEF FPC_LEGACY}
function SysUtilsFileGetSymLinkTarget(const FileName:RawByteString;out SymLinkRec:TRawbyteSymLinkRec):Boolean;
begin
 {}
 Result:=False;

 {Not currently supported - See: FileGetSymLinkTargetInt in rtl\win\sysutils.pp}
end;
{$ENDIF}
{==============================================================================}

function SysUtilsFileExists(const FileName:RawByteString;FollowLink:Boolean):Boolean;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {File Exists}
 Result:=FileSysDriver.FileExists(FileName);

 {Note: FollowLink not currently supported - See: FileOrDirExists in rtl\win\sysutils.pp}
end;

{==============================================================================}

function SysUtilsFileGetAttr(const FileName:RawByteString):LongInt;
begin
 {}
 Result:=-1;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {File Get Attr}
 Result:=FileSysDriver.FileGetAttr(FileName);
end;

{==============================================================================}

function SysUtilsFileGetDate(Handle:THandle):LongInt;
begin
 {}
 Result:=-1;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {File Get Date}
 Result:=FileSysDriver.FileGetDate(Handle);
end;

{==============================================================================}

function SysUtilsFileSetAttr(const FileName:RawByteString;Attr:LongInt):LongInt;
begin
 {}
 Result:=-1;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {File Set Attr}
 Result:=FileSysDriver.FileSetAttr(FileName,Attr);
end;

{==============================================================================}

function SysUtilsFileSetDate(Handle:THandle;Age:LongInt):LongInt;
begin
 {}
 Result:=-1;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {File Set Date}
 Result:=FileSysDriver.FileSetDate(Handle,Age);
end;

{==============================================================================}

function SysUtilsFileRead(Handle:THandle;out Buffer;Count:LongInt):LongInt;
begin
 {}
 Result:=-1;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Read File}
 Result:=FileSysDriver.FileRead(Handle,Buffer,Count);
end;

{==============================================================================}

function SysUtilsFileWrite(Handle:THandle;const Buffer;Count:LongInt):LongInt;
begin
 {}
 Result:=-1;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Write File}
 Result:=FileSysDriver.FileWrite(Handle,Buffer,Count)
end;

{==============================================================================}

function SysUtilsFileSeekEx(Handle:THandle;Offset:Int64;Origin:LongInt):Int64;
begin
 {}
 Result:=-1;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Seek File Ex}
 Result:=FileSysDriver.FileSeekEx(Handle,Offset,Origin);
end;

{==============================================================================}

function SysUtilsInternalFindFirst(const Path:RawByteString;Attr:LongInt;out SearchRec:TSearchRec;var Name:RawByteString):LongInt;
begin
 {}
 Result:=-1;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;
 
 {Find First}
 Result:=FileSysDriver.FindFirst(Path,Attr,SearchRec);
 if Result = 0 then Name:=SearchRec.FindData.cFileName;
end;

{==============================================================================}

function SysUtilsInternalFindNext(var SearchRec:TSearchRec;var Name:RawByteString):LongInt;
begin
 {}
 Result:=-1;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Find Next}
 Result:=FileSysDriver.FindNext(SearchRec);
 if Result = 0 then Name:=SearchRec.FindData.cFileName;
end;

{==============================================================================}

procedure SysUtilsInternalFindClose(var Handle:THandle);
begin
 {}
 {Check Driver}
 if FileSysDriver = nil then Exit;
 
 {Find Close File}
 FileSysDriver.FindCloseFile(Handle);
end;

{==============================================================================}
{SysUtils Disk Functions}
function SysUtilsDiskFree(Drive:Byte):Int64;
{No Volume Support}
begin
 {}
 Result:=-1;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Get Drive Free Space Ex}
 Result:=FileSysDriver.GetDriveFreeSpaceEx(Drive);
end;

{==============================================================================}

function SysUtilsDiskSize(Drive:Byte):Int64;
{No Volume Support}
begin
 {}
 Result:=-1;

 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Get Drive Total Space Ex}
 Result:=FileSysDriver.GetDriveTotalSpaceEx(Drive);
end;

{==============================================================================}

function SysUtilsDirectoryExists(const Directory:RawByteString;FollowLink:Boolean):Boolean;
begin
 {}
 Result:=False;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Directory Exists}
 Result:=FileSysDriver.DirectoryExists(Directory);

 {Note: FollowLink not currently supported - See: FileOrDirExists in rtl\win\sysutils.pp}
end;

{==============================================================================}
{==============================================================================}
{FileSystem Logging Functions}
function FileSysLoggingStart(Logging:PLoggingDevice):LongWord;
{Implementation of LoggingDeviceStart API for FileSystem Logging}
{Note: Not intended to be called directly by applications, use LoggingDeviceStart instead}
begin
 {}
 Result:=ERROR_INVALID_PARAMETER;
 
 {Check Logging}
 if Logging = nil then Exit;
 if Logging.Device.Signature <> DEVICE_SIGNATURE then Exit; 

 if MutexLock(Logging.Lock) = ERROR_SUCCESS then 
  begin
   try
    {Check Logging}
    if Logging.Device.Signature <> DEVICE_SIGNATURE then Exit;

    {Check Target (Do not fail device start)}
    if Length(Logging.Target) <> 0 then 
     begin
      {Check Handle}
      if Logging.Handle = INVALID_HANDLE_VALUE then
       begin
        Result:=ERROR_OPERATION_FAILED;
        
        {Check File}
        if FSFileExists(Logging.Target) then
         begin
          {Open File}
          Logging.Handle:=FSFileOpen(Logging.Target,fmOpenReadWrite or fmShareDenyNone);
          {if Logging.Handle = INVALID_HANDLE_VALUE then Exit;} {Do not fail device start}

          if Logging.Handle <> INVALID_HANDLE_VALUE then
           begin
            {Check Reset}
            if FILESYS_LOGGING_RESET then
             begin
              {Reset File}
              FSFileSeekEx(Logging.Handle,0,soFromBeginning);
              FSFileTruncate(Logging.Handle);
             end
            else
             begin
              {Continue File}
              FSFileSeekEx(Logging.Handle,0,soFromEnd);
             end;
           end;
         end
        else
         begin
          {Create File}
          Logging.Handle:=FSFileCreate(Logging.Target);
          {if Logging.Handle = INVALID_HANDLE_VALUE then Exit;} {Do not fail device start}

          if Logging.Handle <> INVALID_HANDLE_VALUE then
           begin
            {Close File}
            FSFileClose(Logging.Handle);
            
            {Open File}
            Logging.Handle:=FSFileOpen(Logging.Target,fmOpenReadWrite or fmShareDenyNone);
            {if Logging.Handle = INVALID_HANDLE_VALUE then Exit;} {Do not fail device start}
           end; 
         end;     
       end;  
     end;
    
    {Return Result}
    Result:=ERROR_SUCCESS;
   finally
    MutexUnlock(Logging.Lock);
   end; 
  end
 else
  begin
   Result:=ERROR_CAN_NOT_COMPLETE;
  end;
end;

{==============================================================================}

function FileSysLoggingStop(Logging:PLoggingDevice):LongWord;
{Implementation of LoggingDeviceStop API for FileSystem Logging}
{Note: Not intended to be called directly by applications, use LoggingDeviceStop instead}
begin
 {}
 Result:=ERROR_INVALID_PARAMETER;
 
 {Check Logging}
 if Logging = nil then Exit;
 if Logging.Device.Signature <> DEVICE_SIGNATURE then Exit; 

 if MutexLock(Logging.Lock) = ERROR_SUCCESS then 
  begin
   try
    {Check Logging}
    if Logging.Device.Signature <> DEVICE_SIGNATURE then Exit;

    {Check Handle}
    if Logging.Handle <> INVALID_HANDLE_VALUE then
     begin
      {Close File}
      FSFileClose(Logging.Handle);
      Logging.Handle:=INVALID_HANDLE_VALUE;
     end; 
    
    {Return Result}
    Result:=ERROR_SUCCESS;
   finally
    MutexUnlock(Logging.Lock);
   end; 
  end
 else
  begin
   Result:=ERROR_CAN_NOT_COMPLETE;
  end;
end;

{==============================================================================}

function FileSysLoggingOutput(Logging:PLoggingDevice;const Data:String):LongWord;
{Implementation of LoggingDeviceOutput API for FileSystem Logging}
{Note: Not intended to be called directly by applications, use LoggingDeviceOutput instead}
var
 Count:LongWord;
 WorkBuffer:String;
begin
 {}
 Result:=ERROR_INVALID_PARAMETER;
 
 {Check Logging}
 if Logging = nil then Exit;
 if Logging.Device.Signature <> DEVICE_SIGNATURE then Exit; 

 if MutexLock(Logging.Lock) = ERROR_SUCCESS then 
  begin
   try
    {Check Logging}
    if Logging.Device.Signature <> DEVICE_SIGNATURE then Exit;

    {Check Target}
    if Length(Logging.Target) = 0 then Exit;
    
    Result:=ERROR_OPERATION_FAILED;
    
    {Check Handle}
    if Logging.Handle = INVALID_HANDLE_VALUE then
     begin
      {Check File}
      if FSFileExists(Logging.Target) then
       begin
        {Open File}
        Logging.Handle:=FSFileOpen(Logging.Target,fmOpenReadWrite or fmShareDenyNone);
        if Logging.Handle = INVALID_HANDLE_VALUE then Exit;

        {Check Reset}
        if FILESYS_LOGGING_RESET then
         begin
          {Reset File}
          FSFileSeekEx(Logging.Handle,0,soFromBeginning);
          FSFileTruncate(Logging.Handle);
         end
        else
         begin
          {Continue File}
          FSFileSeekEx(Logging.Handle,0,soFromEnd);
         end;
       end
      else
       begin
        {Create File}
        Logging.Handle:=FSFileCreate(Logging.Target);
        if Logging.Handle = INVALID_HANDLE_VALUE then Exit;
        
        {Close File}
        FSFileClose(Logging.Handle);
        
        {Open File}
        Logging.Handle:=FSFileOpen(Logging.Target,fmOpenReadWrite or fmShareDenyNone);
        if Logging.Handle = INVALID_HANDLE_VALUE then Exit;
       end;     
     end;

    {Write File}
    WorkBuffer:=Data + Chr(13) + Chr(10);
    if FSFileWrite(Logging.Handle,PChar(WorkBuffer)^,Length(WorkBuffer)) <> Length(WorkBuffer) then Exit;
    
    {Check Size}
    if FILESYS_LOGGING_MAXSIZE > 0 then
     begin
      if FSFileSizeEx(Logging.Handle) > FILESYS_LOGGING_MAXSIZE then
       begin
        if FILESYS_LOGGING_MAXCOPIES = 0 then
         begin
          {Reset File}
          FSFileSeekEx(Logging.Handle,0,soFromBeginning);
          FSFileTruncate(Logging.Handle);
         end
        else
         begin
          {Check Oldest}
          WorkBuffer:=Logging.Target + IntToStr(FILESYS_LOGGING_MAXCOPIES);
          if FSFileExists(WorkBuffer) then
           begin
            {Delete File}
            FSFileSetAttr(WorkBuffer,faArchive);
            if not FSDeleteFile(WorkBuffer) then Exit;
           end;
           
          {Check Copies}
          if FILESYS_LOGGING_MAXCOPIES > 1 then
           begin
            for Count:=FILESYS_LOGGING_MAXCOPIES - 1 downto 1 do
             begin
              WorkBuffer:=Logging.Target + IntToStr(Count);
              if FSFileExists(WorkBuffer) then
               begin
                {Rename File}
                FSFileSetAttr(WorkBuffer,faArchive);
                if not FSRenameFile(WorkBuffer,Logging.Target + IntToStr(Count + 1)) then Exit;
               end;
             end;
           end;
           
          {Close File}
          FSFileClose(Logging.Handle);
          Logging.Handle:=INVALID_HANDLE_VALUE;
          
          {Rename File}
          if not FSRenameFile(Logging.Target,Logging.Target + IntToStr(1)) then Exit;
         end;
       end; 
     end; 
    
    {Update Statistics}
    Inc(Logging.OutputCount);
    
    {Return Result}
    Result:=ERROR_SUCCESS;
   finally
    MutexUnlock(Logging.Lock);
   end; 
  end
 else
  begin
   Result:=ERROR_CAN_NOT_COMPLETE;
  end;
end;

{==============================================================================}

function FileSysLoggingSetTarget(Logging:PLoggingDevice;const Target:String):LongWord;
{Implementation of LoggingDeviceSetTarget API for FileSystem Logging}
{Note: Not intended to be called directly by applications, use LoggingDeviceSetTarget instead}
begin
 {}
 Result:=ERROR_INVALID_PARAMETER;
 
 {Check Logging}
 if Logging = nil then Exit;
 if Logging.Device.Signature <> DEVICE_SIGNATURE then Exit; 

 if MutexLock(Logging.Lock) = ERROR_SUCCESS then 
  begin
   try
    {Check Logging}
    if Logging.Device.Signature <> DEVICE_SIGNATURE then Exit;

    {Check Target}
    if Logging.Target <> Target then
     begin
      {Check Handle}
      if Logging.Handle <> INVALID_HANDLE_VALUE then
       begin
        {Close File}
        FSFileClose(Logging.Handle);
        Logging.Handle:=INVALID_HANDLE_VALUE;
       end;
      
      {Set Target}
      Logging.Target:=Target;
      UniqueString(Logging.Target);
      
      Result:=ERROR_OPERATION_FAILED;
      
      {Check File}
      if FSFileExists(Logging.Target) then
       begin
        {Open File}
        Logging.Handle:=FSFileOpen(Logging.Target,fmOpenReadWrite or fmShareDenyNone);
        {if Logging.Handle = INVALID_HANDLE_VALUE then Exit;} {Do not fail set target}

        if Logging.Handle <> INVALID_HANDLE_VALUE then
         begin
          {Check Reset}
          if FILESYS_LOGGING_RESET then
           begin
            {Reset File}
            FSFileSeekEx(Logging.Handle,0,soFromBeginning);
            FSFileTruncate(Logging.Handle);
           end
          else
           begin
            {Continue File}
            FSFileSeekEx(Logging.Handle,0,soFromEnd);
           end;
         end;
       end
      else
       begin
        {Create File}
        Logging.Handle:=FSFileCreate(Logging.Target);
        {if Logging.Handle = INVALID_HANDLE_VALUE then Exit;} {Do not fail set target}

        if Logging.Handle <> INVALID_HANDLE_VALUE then
         begin
          {Close File}
          FSFileClose(Logging.Handle);
          
          {Open File}
          Logging.Handle:=FSFileOpen(Logging.Target,fmOpenReadWrite or fmShareDenyNone);
          {if Logging.Handle = INVALID_HANDLE_VALUE then Exit;} {Do not fail set target}
         end; 
       end;     
     end;
    
    {Return Result}
    Result:=ERROR_SUCCESS;
   finally
    MutexUnlock(Logging.Lock);
   end; 
  end
 else
  begin
   Result:=ERROR_CAN_NOT_COMPLETE;
  end;
end;

{==============================================================================}
{==============================================================================}
{FileSystem Helper Functions}
function FileSysRedirectInput(Handle:THandle):Boolean;
{Redirect standard input to the file specified by Handle}
{Handle: The file handle to redirect input to (or INVALID_HANDLE_VALUE to stop redirection)}
{Return: True if completed successfully or False if an error occurred}

{Note: Redirects the input of the text file Input which also
       redirects the input of Read, ReadLn and the standard C library}
begin
 {}
 Result:=True;
 
 if Handle = INVALID_HANDLE_VALUE then
  begin
   {Stop Redirection}
   TextIOReadCharHandler:=nil;
   
   FileSysTextIOInputHandle:=INVALID_HANDLE_VALUE;
  end
 else
  begin
   {Start Redirection}
   TextIOReadCharHandler:=SysTextIOReadChar;
  
   FileSysTextIOInputHandle:=Handle;
  end;  
end;

{==============================================================================}

function FileSysRedirectOutput(Handle:THandle):Boolean;
{Redirect standard output to the file specified by Handle}
{Handle: The file handle to redirect output to (or INVALID_HANDLE_VALUE to stop redirection)}
{Return: True if completed successfully or False if an error occurred}

{Note: Redirects the output of the text files Output, ErrOutput, StdOut and StdErr
       which also redirects the output of Write, WriteLn and the standard C library}
begin
 {}
 Result:=True;
 
 if Handle = INVALID_HANDLE_VALUE then
  begin
   {Stop Redirection}
   TextIOWriteCharHandler:=nil;
   TextIOWriteBufferHandler:=nil;
   
   FileSysTextIOOutputHandle:=INVALID_HANDLE_VALUE;
  end
 else
  begin
   {Start Redirection}
   TextIOWriteCharHandler:=SysTextIOWriteChar;
   TextIOWriteBufferHandler:=SysTextIOWriteBuffer;
  
   FileSysTextIOOutputHandle:=Handle;
  end;  
end;

{==============================================================================}

function FileSysStorageGetMediaType(Storage:PStorageDevice):TMediaType;
begin
 {}
 Result:=mtUNKNOWN;
 
 {Check Storage}
 if Storage = nil then Exit;
 
 {Check Storage Type}
 case Storage.Device.DeviceType of
  STORAGE_TYPE_HDD:Result:=mtFIXED;
  STORAGE_TYPE_FDD:Result:=mtFLOPPY;
  STORAGE_TYPE_CDROM:Result:=mtCDROM;
  STORAGE_TYPE_OPTICAL,STORAGE_TYPE_TAPE:Result:=mtOTHER;
  STORAGE_TYPE_REMOVABLE:Result:=mtREMOVABLE;
 end;
end;

{==============================================================================}

function FileSysStorageGetController(Storage:PStorageDevice):TDiskController;
begin
 {}
 Result:=nil;
 
 {Check Storage}
 if Storage = nil then Exit;
 
 {Check Device Bus}
 case Storage.Device.DeviceBus of
  DEVICE_BUS_IDE,DEVICE_BUS_ATA,DEVICE_BUS_SATA:begin
    if FILESYS_ATA_ENABLED then Result:=FileSysATAController;
   end; 
  DEVICE_BUS_ATAPI:begin
    if FILESYS_ATAPI_ENABLED then Result:=FileSysATAPIController;
   end; 
  DEVICE_BUS_SCSI:begin
    if FILESYS_SCSI_ENABLED then Result:=FileSysSCSIController;
   end; 
  DEVICE_BUS_USB:begin
    if FILESYS_USB_ENABLED then Result:=FileSysUSBController;
   end; 
  DEVICE_BUS_MMC,DEVICE_BUS_SD:begin
    if FILESYS_MMC_ENABLED then Result:=FileSysMMCController;
   end; 
 end;
end;

{==============================================================================}

procedure FileSysStorageDeviceAdd(Event:PStorageDeviceEvent);
var
 MediaType:TMediaType;
 DiskDevice:TDiskDevice;
 DiskController:TDiskController;
begin
 {}
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('FileSys: Storage device add');
 {$ENDIF}
 
 {Check Event}
 if Event = nil then Exit;
 if Event.Device = nil then Exit;
 
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('FileSys:  Device = ' + DeviceGetName(@Event.Device.Device));
 {$ENDIF}
 
 {Destroy Timer}
 if Event.Timer <> INVALID_HANDLE_VALUE then
  begin
   TimerDestroy(Event.Timer);
   Event.Timer:=INVALID_HANDLE_VALUE;
  end;

 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Acquire the Lock}
 if CriticalSectionLock(FileSysLock) = ERROR_SUCCESS then
  begin
   try
    {Check Started and Ready}
    if (FileSysStartupCount > 0) and (FileSysStartupError = ERROR_SUCCESS) then
     begin
      {Get Controller}
      DiskController:=FileSysStorageGetController(Event.Device);
      if DiskController <> nil then
       begin
        {Get Media Type}
        MediaType:=FileSysStorageGetMediaType(Event.Device);
        if MediaType <> mtUNKNOWN then
         begin
          {Check Device}
          DiskDevice:=FileSysDriver.GetDeviceByStorage(Event.Device,False,FILESYS_LOCK_NONE); {Do not lock}
          if DiskDevice = nil then
           begin
            {Create Device}
            DiskDevice:=TDiskDevice.Create(FileSysDriver,DiskController,nil,Event.Device,FileSysDriver.GetNextDeviceNo(MediaType),DeviceGetName(@Event.Device.Device));
            
            {Init Device}
            DiskDevice.DeviceInit;
            
            {Locate Partitions}
            DiskDevice.LocatePartitions;
            
            {Locate Volumes and Drives}
            FileSysDriver.LocateVolumes;
            FileSysDriver.LocateDrives;
           end;
         end;
       end;
     end;  
   finally
    {Release the Lock}
    CriticalSectionUnlock(FileSysLock);
   end;
  end;
  
 {Destroy Event}
 FreeMem(Event); 
end;
 
{==============================================================================}

procedure FileSysStorageDeviceInsert(Event:PStorageDeviceEvent);
var
 DiskDevice:TDiskDevice;
begin
 {}
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('FileSys: Storage device insert');
 {$ENDIF}

 {Check Event}
 if Event = nil then Exit;
 if Event.Device = nil then Exit;
 
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('FileSys:  Device = ' + DeviceGetName(@Event.Device.Device));
 {$ENDIF}
 
 {Destroy Timer}
 if Event.Timer <> INVALID_HANDLE_VALUE then
  begin
   TimerDestroy(Event.Timer);
   Event.Timer:=INVALID_HANDLE_VALUE;
  end;

 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Acquire the Lock}
 if CriticalSectionLock(FileSysLock) = ERROR_SUCCESS then
  begin
   try
    {Check Started and Ready}
    if (FileSysStartupCount > 0) and (FileSysStartupError = ERROR_SUCCESS) then
     begin
      {Check Device}
      DiskDevice:=FileSysDriver.GetDeviceByStorage(Event.Device,True,FILESYS_LOCK_WRITE);
      if DiskDevice <> nil then
       begin
        {Insert Device}
        DiskDevice.InsertDevice;
        
        {Unlock Device}
        DiskDevice.WriterUnlock;
       end; 
     end;  
   finally
    {Release the Lock}
    CriticalSectionUnlock(FileSysLock);
   end;
  end;
  
 {Destroy Event}
 FreeMem(Event); 
end;

{==============================================================================}

function FileSysStorageDeviceRemove(Storage:PStorageDevice):LongWord;
var
 DiskDevice:TDiskDevice;
begin
 {}
 Result:=ERROR_INVALID_PARAMETER;
 
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('FileSys: Storage device remove');
 {$ENDIF}
 
 {Check Storage}
 if Storage = nil then Exit;

 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('FileSys:  Device = ' + DeviceGetName(@Storage.Device));
 {$ENDIF}
 
 {Check Driver}
 if FileSysDriver = nil then Exit;
 
 {Acquire the Lock}
 if CriticalSectionLock(FileSysLock) = ERROR_SUCCESS then
  begin
   try
    {Check Started and Ready}
    if (FileSysStartupCount > 0) and (FileSysStartupError = ERROR_SUCCESS) then
     begin
      {Check Device}
      DiskDevice:=FileSysDriver.GetDeviceByStorage(Storage,True,FILESYS_LOCK_WRITE);
      if DiskDevice <> nil then
       begin
        {Destroy Device}
        DiskDevice.Free;
       end; 
     end;  
     
    {Return Result}
    Result:=ERROR_SUCCESS;    
   finally
    {Release the Lock}
    CriticalSectionUnlock(FileSysLock);
   end;
  end;
end;
      
{==============================================================================}
      
function FileSysStorageDeviceEject(Storage:PStorageDevice):LongWord;
var
 DiskDevice:TDiskDevice;
begin
 {}
 Result:=ERROR_INVALID_PARAMETER;
 
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('FileSys: Storage device eject');
 {$ENDIF}
 
 {Check Storage}
 if Storage = nil then Exit;

 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('FileSys:  Device = ' + DeviceGetName(@Storage.Device));
 {$ENDIF}
 
 {Check Driver}
 if FileSysDriver = nil then Exit;
 
 {Acquire the Lock}
 if CriticalSectionLock(FileSysLock) = ERROR_SUCCESS then
  begin
   try
    {Check Started and Ready}
    if (FileSysStartupCount > 0) and (FileSysStartupError = ERROR_SUCCESS) then
     begin
      {Check Device}
      DiskDevice:=FileSysDriver.GetDeviceByStorage(Storage,True,FILESYS_LOCK_WRITE);
      if DiskDevice <> nil then
       begin
        {Eject Device}
        DiskDevice.EjectDevice;
        
        {Unlock Device}
        DiskDevice.WriterUnlock;
       end; 
     end;  
     
    {Return Result}
    Result:=ERROR_SUCCESS;    
   finally
    {Release the Lock}
    CriticalSectionUnlock(FileSysLock);
   end;
  end;
end;
      
{==============================================================================}

function FileSysStorageDeviceEnum(Storage:PStorageDevice;Data:Pointer):LongWord;
var
 MediaType:TMediaType;
 DiskDevice:TDiskDevice;
 DiskController:TDiskController;
begin
 {}
 Result:=ERROR_SUCCESS;
 
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('FileSys: Storage device enumeration');
 {$ENDIF}

 {Check Storage}
 if Storage = nil then Exit;
 
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('FileSys:  Device = ' + DeviceGetName(@Storage.Device));
 {$ENDIF}
 
 {Check Driver}
 if FileSysDriver = nil then Exit;
 
 {Acquire the Lock}
 if CriticalSectionLock(FileSysLock) = ERROR_SUCCESS then
  begin
   try
    {Check Started}
    if FileSysStartupCount > 0 then
     begin
      {Get Controller}
      DiskController:=FileSysStorageGetController(Storage);
      if DiskController <> nil then
       begin
        {Get Media Type}
        MediaType:=FileSysStorageGetMediaType(Storage);
        if MediaType <> mtUNKNOWN then
         begin
          {Check Device}
          DiskDevice:=FileSysDriver.GetDeviceByStorage(Storage,False,FILESYS_LOCK_NONE); {Do not lock}
          if DiskDevice = nil then
           begin
            {Create Device}
            DiskDevice:=TDiskDevice.Create(FileSysDriver,DiskController,nil,Storage,FileSysDriver.GetNextDeviceNo(MediaType),DeviceGetName(@Storage.Device));
            
            {Init Device}
            DiskDevice.DeviceInit;
           end;
         end;
       end;
     end;  
   finally
    {Release the Lock}
    CriticalSectionUnlock(FileSysLock);
   end;
  end;
end;
      
{==============================================================================}

function FileSysStorageDeviceNotify(Device:PDevice;Data:Pointer;Notification:LongWord):LongWord;
var
 DiskDevice:TDiskDevice;
 Event:PStorageDeviceEvent;
begin
 {}
 Result:=ERROR_SUCCESS;
 
 {$IFDEF FILESYS_DEBUG}
 if FILESYS_LOG_ENABLED then FileSysLogDebug('FileSys: Storage device notification (Notification=' + NotificationToString(Notification) + ')');
 {$ENDIF}
 
 {Check Device}
 if Device = nil then Exit;
 
 {Check Driver}
 if FileSysDriver = nil then Exit;
 
 {Check Notification}
 if (Notification and DEVICE_NOTIFICATION_REGISTER) <> 0 then
  begin
   {Acquire the Lock}
   if CriticalSectionLock(FileSysLock) = ERROR_SUCCESS then
    begin
     try
      {Check Started}
      if FileSysStartupCount > 0 then
       begin
        {Check Device}
        DiskDevice:=FileSysDriver.GetDeviceByStorage(PStorageDevice(Device),False,FILESYS_LOCK_NONE); {Do not lock}
        if DiskDevice = nil then
         begin
          {Create Event}
          Event:=AllocMem(SizeOf(TStorageDeviceEvent));
          if Event = nil then Exit;
          
          {Setup Event}
          Event.Timer:=INVALID_HANDLE_VALUE;
          Event.Device:=PStorageDevice(Device);
          
          {Create Timer}
          Event.Timer:=TimerCreateEx(FILESYS_STORAGE_TIMER_INTERVAL,TIMER_STATE_ENABLED,TIMER_FLAG_WORKER,TTimerEvent(FileSysStorageDeviceAdd),Event);
          if Event.Timer = INVALID_HANDLE_VALUE then
           begin
            {Destroy Event}
            FreeMem(Event);
           end;
         end;
       end;
     finally
      {Release the Lock}
      CriticalSectionUnlock(FileSysLock);
     end;
    end;
  end
 else if (Notification and DEVICE_NOTIFICATION_INSERT) <> 0 then
  begin
   {Acquire the Lock}
   if CriticalSectionLock(FileSysLock) = ERROR_SUCCESS then
    begin
     try
      {Check Started}
      if FileSysStartupCount > 0 then
       begin
        {Check Device}
        DiskDevice:=FileSysDriver.GetDeviceByStorage(PStorageDevice(Device),False,FILESYS_LOCK_NONE); {Do not lock}
        if DiskDevice <> nil then
         begin
          {Create Event}
          Event:=AllocMem(SizeOf(TStorageDeviceEvent));
          if Event = nil then Exit;
          
          {Setup Event}
          Event.Timer:=INVALID_HANDLE_VALUE;
          Event.Device:=PStorageDevice(Device);
          
          {Create Timer}
          Event.Timer:=TimerCreateEx(FILESYS_STORAGE_TIMER_INTERVAL,TIMER_STATE_ENABLED,TIMER_FLAG_WORKER,TTimerEvent(FileSysStorageDeviceInsert),Event);
          if Event.Timer = INVALID_HANDLE_VALUE then
           begin
            {Destroy Event}
            FreeMem(Event);
           end;
         end;
       end;
     finally
      {Release the Lock}
      CriticalSectionUnlock(FileSysLock);
     end;
    end;
  end
 else if (Notification and (DEVICE_NOTIFICATION_EJECTING or DEVICE_NOTIFICATION_EJECT)) <> 0 then
  begin
   {Acquire the Lock}
   if CriticalSectionLock(FileSysLock) = ERROR_SUCCESS then
    begin
     try
      {Check Started}
      if FileSysStartupCount > 0 then
       begin
        {Check Device}
        DiskDevice:=FileSysDriver.GetDeviceByStorage(PStorageDevice(Device),False,FILESYS_LOCK_NONE); {Do not lock}
        if DiskDevice <> nil then
         begin
          {Eject Device}
          FileSysStorageDeviceEject(PStorageDevice(Device));
         end; 
       end;
     finally
      {Release the Lock}
      CriticalSectionUnlock(FileSysLock);
     end;
    end;
  end
 else if (Notification and DEVICE_NOTIFICATION_DEREGISTER) <> 0 then
  begin
   {Acquire the Lock}
   if CriticalSectionLock(FileSysLock) = ERROR_SUCCESS then
    begin
     try
      {Check Started}
      if FileSysStartupCount > 0 then
       begin
        {Check Device}
        DiskDevice:=FileSysDriver.GetDeviceByStorage(PStorageDevice(Device),False,FILESYS_LOCK_NONE); {Do not lock}
        if DiskDevice <> nil then
         begin
          {Remove Device}
          FileSysStorageDeviceRemove(PStorageDevice(Device));
         end; 
       end;
     finally
      {Release the Lock}
      CriticalSectionUnlock(FileSysLock);
     end;
    end;
  end;
end;
        
{==============================================================================}

function ComparePartitions(APartition1,APartition2:Pointer):Integer;
{Sort partitions in order of start sector}
begin
 {}
 Result:=0;
 
 if APartition1 = nil then Exit;
 if APartition2 = nil then Exit;
 
 {Compare Sector Offset}
 if TDiskPartition(APartition1).StartSector < TDiskPartition(APartition2).StartSector then
  begin
   Result:=-1;
  end
 else if TDiskPartition(APartition1).StartSector > TDiskPartition(APartition2).StartSector then
  begin
   Result:=1;
  end;
end;

{==============================================================================}

procedure FileSysLog(Level:Integer;const AText:String);
var
 WorkBuffer:String;
begin
 {}
 {Check Level}
 if Level < FILESYS_DEFAULT_LOG_LEVEL then Exit;
 
 WorkBuffer:='';
 {Check Level}
 if Level = FILESYS_LOG_LEVEL_DEBUG then
  begin
   WorkBuffer:=WorkBuffer + '[DEBUG] ';
  end
 else if Level = FILESYS_LOG_LEVEL_WARN then
  begin
   WorkBuffer:=WorkBuffer + '[WARN] ';
  end
 else if Level = FILESYS_LOG_LEVEL_ERROR then
  begin
   WorkBuffer:=WorkBuffer + '[ERROR] ';
  end;
  
 {Add Prefix}
 WorkBuffer:=WorkBuffer + 'FileSys: ';

 {Output Logging} 
 LoggingOutputEx(LOGGING_FACILITY_FILESYSTEM,LogLevelToLoggingSeverity(Level),'FileSys',WorkBuffer + AText);
end;

{==============================================================================}

procedure FileSysLogInfo(const AText:String); inline;
begin
 {}
 FileSysLog(FILESYS_LOG_LEVEL_INFO,AText);
end;

{==============================================================================}

procedure FileSysLogWarn(const AText:String); inline;
begin
 {}
 FileSysLog(FILESYS_LOG_LEVEL_WARN,AText);
end;

{==============================================================================}

procedure FileSysLogError(const AText:String); inline;
begin
 {}
 FileSysLog(FILESYS_LOG_LEVEL_ERROR,AText);
end;

{==============================================================================}

procedure FileSysLogDebug(const AText:String); inline;
begin
 {}
 FileSysLog(FILESYS_LOG_LEVEL_DEBUG,AText);
end;

{==============================================================================}

procedure CacheCheckTimer(Data:Pointer);
var
 Cache:THashCache;
begin
 {}
 {Check Data}
 if Data = nil then Exit;
 
 {Get Cache}
 Cache:=THashCache(Data);
 
 {Check Timer}
 Cache.CheckTimer;
end;

{==============================================================================}

procedure EntryCheckTimer(Data:Pointer);
begin
 {}
 {Check Data}
 if Data = nil then Exit;
 
 {Check Driver}
 if Data <> FileSysDriver then Exit;
 
 {Check Timer}
 FileSysDriver.CheckTimer;
end;

{==============================================================================}

procedure EntryProcessTimer(Data:Pointer);
begin
 {}
 {Check Data}
 if Data = nil then Exit;
  
 {Check Driver}
 if Data <> FileSysDriver then Exit;
  
 {Process Timer}
 FileSysDriver.ProcessTimer;
end;

{==============================================================================}

function MediaTypeToString(AType:TMediaType):String;
begin
 {}
 Result:='mtUNKNOWN';
 
 {Check Type}
 case AType of
  mtINVALID:Result:='mtINVALID';
  mtFLOPPY:Result:='mtFLOPPY';
  mtFIXED:Result:='mtFIXED';
  mtREMOVABLE:Result:='mtREMOVABLE';
  mtCDROM:Result:='mtCDROM';
  mtDVD:Result:='mtDVD';
  mtOTHER:Result:='mtOTHER';
 end;
end;

{==============================================================================}

function FloppyTypeToString(AType:TFloppyType):String;
begin
 {}
 Result:='ftUNKNOWN';
 
 {Check Type}
 case AType of
  ftINVALID:Result:='ftINVALID';
  ft360K:Result:='ft360K';
  ft12M:Result:='ft12M';
  ft720K:Result:='ft720K';
  ft144M:Result:='ft144M';
  ft288M:Result:='ft288M';
  ftATAPI:Result:='ftATAPI';
 end;
end;

{==============================================================================}

function ImageTypeToString(AType:TImageType):String;
begin
 {}
 Result:='itUNKNOWN';
 
 {Check Type}
 case AType of
  itINVALID:Result:='itINVALID';
  itMEMORY:Result:='itMEMORY';
  itFILE:Result:='itFILE';
  itDEVICE:Result:='itDEVICE';
  itISO:Result:='itISO';
  itBOCHS:Result:='itBOCHS';
  itVMWARE:Result:='itVMWARE';
  itVPC:Result:='itVPC';
  itVBOX:Result:='itVBOX';
 end;
end;

{==============================================================================}

function DriveTypeToString(AType:TDriveType):String;
begin
 {}
 Result:='dtUNKNOWN';
 
 {Check Type}
 case AType of
  dtINVALID:Result:='dtINVALID';
  dtFIXED:Result:='dtFIXED';
  dtFLOPPY:Result:='dtFLOPPY';
  dtREMOVABLE:Result:='dtREMOVABLE';
  dtNETWORK:Result:='dtNETWORK';
  dtSUBSTITUTED:Result:='dtSUBSTITUTED';
  dtRAMDRIVE:Result:='dtRAMDRIVE';
  dtCDROM:Result:='dtCDROM';
 end;
end;

{==============================================================================}

function FileSysTypeToString(AType:TFileSysType):String;
begin
 {}
 Result:='fsUNKNOWN';
 
 {Check Type}
 case AType of
  fsINVALID:Result:='fsINVALID';
  fsFAT12:Result:='fsFAT12';
  fsFAT16:Result:='fsFAT16';
  fsFAT32:Result:='fsFAT32';
  fsEXFAT:Result:='fsEXFAT';
  fsHPFS:Result:='fsHPFS';
  fsNTFS:Result:='fsNTFS';
  fsNTFS5:Result:='fsNTFS5';
  fsNTFS51:Result:='fsNTFS51';
  fsCDFS:Result:='fsCDFS';
  fsUDF:Result:='fsUDF';
  fsEXT2:Result:='fsEXT2';
  fsEXT3:Result:='fsEXT3';
  fsEXT4:Result:='fsEXT4';
 end;
end;

{==============================================================================}

function StringToFileSysType(const AFileSysType:String):TFileSysType;
begin
 {}
 Result:=fsUNKNOWN;
 
 if Trim(AFileSysType) = '' then Exit;
 
 if Uppercase(Trim(AFileSysType)) = 'FAT' then
  begin
   Result:=fsFAT32; {Default to FAT32}
  end
 else if Uppercase(Trim(AFileSysType)) = 'FAT12' then
  begin
   Result:=fsFAT12;
  end
 else if Uppercase(Trim(AFileSysType)) = 'FAT16' then
  begin
   Result:=fsFAT16;
  end
 else if Uppercase(Trim(AFileSysType)) = 'FAT32' then
  begin
   Result:=fsFAT32;
  end
 else if Uppercase(Trim(AFileSysType)) = 'EXFAT' then
  begin
   Result:=fsEXFAT;
  end
 else if Uppercase(Trim(AFileSysType)) = 'HPFS' then
  begin
   Result:=fsHPFS;
  end
 else if Uppercase(Trim(AFileSysType)) = 'NTFS' then
  begin
   Result:=fsNTFS51; {Default to NTFS51}
  end
 else if Uppercase(Trim(AFileSysType)) = 'NTFS4' then
  begin
   Result:=fsNTFS;
  end
 else if Uppercase(Trim(AFileSysType)) = 'NTFS5' then
  begin
   Result:=fsNTFS5;
  end
 else if Uppercase(Trim(AFileSysType)) = 'NTFS51' then
  begin
   Result:=fsNTFS51;
  end
 else if Uppercase(Trim(AFileSysType)) = 'CDFS' then
  begin
   Result:=fsCDFS;
  end
 else if Uppercase(Trim(AFileSysType)) = 'UDF' then
  begin
   Result:=fsUDF;
  end
 else if Uppercase(Trim(AFileSysType)) = 'EXT' then
  begin
   Result:=fsEXT3; {Default to EXT3}
  end
 else if Uppercase(Trim(AFileSysType)) = 'EXT2' then
  begin
   Result:=fsEXT2;
  end
 else if Uppercase(Trim(AFileSysType)) = 'EXT3' then
  begin
   Result:=fsEXT3;
  end
 else if Uppercase(Trim(AFileSysType)) = 'EXT4' then
  begin
   Result:=fsEXT4;
  end;
end;

{==============================================================================}

function PartitionIdToString(AId:Byte):String;
begin
 {}
 Result:=PARTITION_NAMES[AId];
end;

{==============================================================================}

function StringToPartitionId(const APartitionId:String):Byte;
begin
 {}
 Result:=pidUnused;
 
 if Trim(APartitionId) = '' then Exit;
 
 if Uppercase(Trim(APartitionId)) = 'FAT' then
  begin
   Result:=pidFAT32; {Default to FAT32}
  end
 else if Uppercase(Trim(APartitionId)) = 'FAT12' then
  begin
   Result:=pidFAT12;
  end
 else if Uppercase(Trim(APartitionId)) = 'FAT16' then
  begin
   Result:=pidFAT16;
  end
 else if Uppercase(Trim(APartitionId)) = 'FAT32' then
  begin
   Result:=pidFAT32;
  end
 else if Uppercase(Trim(APartitionId)) = 'NTFS' then
  begin
   Result:=pidHPFSNTFS;
  end
 else if Uppercase(Trim(APartitionId)) = 'HPFS' then
  begin
   Result:=pidHPFSNTFS;
  end
 else if Uppercase(Trim(APartitionId)) = 'LINUX' then
  begin
   Result:=pidLinuxNative;
  end
 else if Uppercase(Trim(APartitionId)) = 'SWAP' then
  begin
   Result:=pidLinuxSwap;
  end
 else if Uppercase(Trim(APartitionId)) = 'NWFS' then
  begin
   Result:=pidNWFS;
  end
 else if Uppercase(Trim(APartitionId)) = 'EXTENDED' then
  begin
   Result:=pidExtended;
  end
 else
  begin
   Result:=StrToIntDef(APartitionId,0);
  end;
end;

{==============================================================================}

function CacheModeToString(ACacheMode:TCacheMode):String;
begin
 {}
 Result:='NONE';
 
 case ACacheMode of
  cmNONE:Result:='NONE';
  cmREADONLY:Result:='READONLY';
  cmREADWRITE:Result:='READWRITE';
 end;
end;

{==============================================================================}

function CacheStateToString(ACacheState:TCacheState):String;
begin
 {}
 Result:='CLEAN';
 
 case ACacheState of
  csCLEAN:Result:='CLEAN';
  csDIRTY:Result:='DIRTY';
 end;
end;

{==============================================================================}

function CachePageTimeToDateTime(const APageTime:Int64):TDateTime;
var
 Seconds:LongWord;
begin
 {}
 Result:=0;
 
 {Get Seconds}
 Seconds:=APageTime div MILLISECONDS_PER_SECOND;
 
 {Get DateTime}
 Result:=(Seconds div UNIX_TIME_SECONDS_PER_DAY) + ((Seconds mod UNIX_TIME_SECONDS_PER_DAY) / UNIX_TIME_SECONDS_PER_DAY);
end;

{==============================================================================}
{==============================================================================}

initialization
 FileSysInit;
 if FILESYS_AUTOSTART then
  begin
   if not FILESYS_ASYNCSTART then
    begin
     {Start FileSys}
     FileSysStart;
    end
   else
    begin
     {Schedule Worker}
     WorkerSchedule(FILESYS_STARTDELAY,TWorkerTask(FileSysAsyncStart),nil,nil); {Delay start to allow device initialization}
    end;
  end; 

{==============================================================================}
 
finalization
 FileSysStop;

{==============================================================================}
{==============================================================================}

end.
