{
Ultibo Newlib C Library Syscalls interface unit.

Copyright (C) 2016 - Paul Jervois.
Copyright (C) 2024 - SoftOz Pty Ltd.

Arch
====

 <All>

Boards
======

 <All>

Licence
=======

 LGPLv2.1 with static linking exception (See COPYING.modifiedLGPL.txt)
 
Credits
=======

 Information for this unit was obtained from:
 
References
==========

  Newlib - http://www.sourceware.org/newlib/

  Libc - https://www.sourceware.org/newlib/libc.html
  
  Libm - https://www.sourceware.org/newlib/libm.html
  
  POSIX Threads (pthreads) - http://pubs.opengroup.org/onlinepubs/7908799/xsh/pthread.h.html
                             http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html
  
  POSIX Sockets - http://pubs.opengroup.org/onlinepubs/009695399/basedefs/sys/socket.h.html
  
Syscalls
========

 This unit provides the system calls (syscalls) interface for the Newlib C library implementation
 to allow code compiled with GCC to be linked with Ultibo applications.
 
 The Newlib C library is a portable C library designed to be used in embedded environments as well
 as many other situations. It is made available by RedHat from the sourceware.org website, new
 releases are made at least yearly and this unit has been developed using 2.4.0 but should 
 work mostly unchanged with future releases.
 
 The build process below creates the libc.a, libm.a and libg.a static libraries, in addition
 to those GCC also requires the libgcc.a support library which is built at the same time as
 the compiler and provided in the distribution. 
 
 The build process is documented for Debian but should be translatable to other platforms. As
 documented this will produce a version of Newlib that has support for recursive library calls,
 has dynamic support for multiple threads and is compiled for the specific architectures that
 are supported by Ultibo.
 
 Note that Newlib supports code compiled with other C compilers so it should be completely 
 possible to link code generated by other C compilers with Ultibo applications. At this
 stage it has only been tested with GCC.
  
 Building Newlib:
 
  Flags: REENTRANT_SYSCALLS_PROVIDED
         __DYNAMIC_REENT__
         __LARGE64_FILES (Note: Not currently supported by Newlib, need to modify \newlib\configure.host to enable stdio64 support for arm-none-eabi or aarch64-none-elf)
      
  Options: 
  
   Raspberry Pi
   
    -mabi=aapcs
    -marm
    -march=armv6
    -mcpu=arm1176jzf-s
    -mfpu=vfp
    -mfloat-abi=hard
   
   Raspberry Pi2/3 and QEMU VersatilePB (32-bit)

    -mabi=aapcs
    -marm
    -march=armv7-a
    -mfpu=vfpv3-d16
    -mfloat-abi=hard
   
   Raspberry Pi3 and QEMU VersatilePB (64-bit)
   
    -mabi=lp64 (Note: Supported only by later versions of GCC)
    -march=armv8-a
    
  Build:
  
   Download Newlib (currently 2.4.0) from ftp://sourceware.org/pub/newlib/index.html
   
   Unpack to folder $HOME/newlib-2.4.0
  
  Build ARMv6: 
   
   cd
   
   mkdir build-newlib-armv6
   
   cd build-newlib-armv6
   
   export PATH=$HOME/gcc-arm-none-eabi-5_4-2016q2/bin:$PATH
   
   ../newlib-2.4.0/configure --disable-multilib --target=arm-none-eabi CFLAGS_FOR_TARGET="-O2 -mabi=aapcs -marm -march=armv6 -mfpu=vfp -mfloat-abi=hard -DREENTRANT_SYSCALLS_PROVIDED -D__DYNAMIC_REENT__"
   
   make all
   
   Dump:
    
    cd arm-none-eabi/newlib
    arm-none-eabi-objdump -d libc.a > libc.list
    arm-none-eabi-objdump -d libg.a > libg.list
    arm-none-eabi-objdump -d libm.a > libm.list
    
  Build ARMv7: 
   
   cd
 
   mkdir build-newlib-armv7
 
   cd build-newlib-armv7
 
   export PATH=$HOME/gcc-arm-none-eabi-5_4-2016q2/bin:$PATH
 
   ../newlib-2.4.0/configure --disable-multilib --target=arm-none-eabi CFLAGS_FOR_TARGET="-O2 -mabi=aapcs -marm -march=armv7-a -mfpu=vfpv3-d16 -mfloat-abi=hard -DREENTRANT_SYSCALLS_PROVIDED -D__DYNAMIC_REENT__"
   
   make all
   
   Dump:
   
    cd arm-none-eabi/newlib
    arm-none-eabi-objdump -d libc.a > libc.list
    arm-none-eabi-objdump -d libg.a > libg.list
    arm-none-eabi-objdump -d libm.a > libm.list
   
  Build ARMv8: 
       
   cd
 
   mkdir build-newlib-armv8
 
   cd build-newlib-armv8
  
   export PATH=$HOME/gcc-linaro-aarch64-none-elf-4.8-2014.04_linux/bin:$PATH
  
   ../newlib-2.4.0/configure --disable-multilib --target=aarch64-none-elf CFLAGS_FOR_TARGET="-O2 -march=armv8-a -DREENTRANT_SYSCALLS_PROVIDED -D__DYNAMIC_REENT__"
  
   make all
  
   Dump:
   
    cd aarch64-none-elf/newlib
    aarch64-none-elf-objdump -d libc.a > libc.list
    aarch64-none-elf-objdump -d libg.a > libg.list
    aarch64-none-elf-objdump -d libm.a > libm.list
  
 Notes:
 
  File handles (fd) passed to and returned from this unit are int values which are 32-bit
  however internally Newlib stores these into the _file member of a _FILE structure (see
  below) and this is defined as short which is only 16-bit. Because of this we have to map
  each Ultibo handle to a TSyscallsEntry and use the functions SyscallsAddEntry, 
  SyscallsRemoveEntry and SyscallsGetEntry which start at zero and increment to 65535.
  
  The global errno variable (not used for reentrant version ) is defined in 
  \newlib\libc\reent\reent.c 
   
   int errno;
   
  The global environ variable is defined in  
  \newlib\libc\stdlib\environ.c 
  
   char **environ = &initial_env[0];
   
  The TZ environment variable is used by a number of functions in Newlib including tzset and
  strftime. This variable can be set on the command line or using the SetEnvironmentVariable()
  function in the Ultibo unit. See the GNU C library reference for details of the format and
  value of the TZ environment variable:
  
   https://www.gnu.org/software/libc/manual/html_node/TZ-Variable.html
  
  Memory management for the C library and code compiled to use it is handled by Newlib itself
  which provides a complete implementation of malloc(), free(), calloc(), realloc() and others.
  
  This implementation relies on the underlying platform to implement sbrk() (_sbrk_r for the
  reentrant build of the library) and this unit provides all of the necessary details of this
  to allow full functionality of the memory management within the C library.
  
  Because sbrk() expects a contiguous heap space that grows upward in response to each request
  the Ultibo implementation uses the virtual memory functionality of the processor to map
  blocks of (possibly not contiguous) memory allocated from the Ultibo heap manager into 
  an address space dedicated to supporting the C library. 
  
  There are a number of parameters in the GlobalConfig unit which can be used to adjust the
  default behaviour of this as follows:
  
   SYSCALLS_HEAP_BASE - The starting point (bottom) of the virtual heap provided by sbrk() (Default: $C0000000)
   SYSCALLS_HEAP_MIN - The minimum (initial) allocation made to the virtual heap during startup (Default: 2MB)
   SYSCALLS_HEAP_MAX - The maximum size the virtual heap will be allowed to grow to (Default: 1GB)
   SYSCALLS_HEAP_BLOCKSIZE - The size of each block added to the virtual heap (Default: 1MB)
  
  Under normal usage these parameters should not need to be changed but they are available for
  advanced use cases which may require them.
  
}

{--$mode delphi} {Default to Delphi compatible syntax} {Not compatible with external definitions below}
{$mode objfpc} 
{$H+}          {Default to AnsiString}
{$inline on}   {Allow use of Inline procedures}

unit Syscalls;

interface

uses GlobalConfig,GlobalConst,GlobalTypes,GlobalSock,Platform,Threads,HeapManager,Devices,FileSystem,Sockets,SysUtils;

//To Do //Libstdc++ support
        
//To Do //Which Pthreads functions are cancellation points? (Find a list)
        //See: http://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_09_05

//To Do //Implementation (dummy / wrapper) for pthread_kill() and others from later specifications (barrier, spinlock etc) ?
        //See: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html
        
//To Do //statfs / fstatfs / statfs64 / fstatfs64      

//To Do //lseek64 etc

//To Do //statvfs / fstatvfs

{==============================================================================}
{Global definitions}
{$INCLUDE GlobalDefines.inc}

{$packrecords C} 

{==============================================================================}
{Local definitions}
{$DEFINE SYSCALLS_WARN_UNINITIALIZED}       {Log use of uninitialized mutex, condition and rwlock variables as a warning (Default: On)}
{$DEFINE SYSCALLS_CREATE_UNINITIALIZED}     {Allow uninitialized mutex, condition and rwlock variables to be created on first use (Default: On)}

{--$DEFINE SYSCALLS_FILE_OFFSET64}          {Enable 64-bit file offsets for Libc calls (Default: Off)}
{--$DEFINE SYSCALLS_LARGE64_FILES}          {Enable 64-bit file support for Libc calls (Default: Off)}

{--$DEFINE _POSIX_THREAD_GUARDSIZE}         {Enable Pthread Guard Size attribute (Default: Off) (Not used by Ultibo}
{--$DEFINE _POSIX_THREAD_CPUTIME}           {Enable Pthread CPU Time Clock Allowed attribute (Default: Off) (Not used by Ultibo}

{--$DEFINE _POSIX_THREAD_SPORADIC_SERVER}   {Enable Pthread Scheduling for Sporadic server (Default: Off) (Not used by Ultibo}

{--$DEFINE _POSIX_THREAD_PROCESS_SHARED}    {Enable Pthread Mutex Process Shared attribute (Default: Off) (Not used by Ultibo}
{--$DEFINE _POSIX_THREAD_PRIO_PROTECT}      {Enable Pthread Mutex Priority Ceiling Shared attribute (Default: Off) (Not used by Ultibo}
{$DEFINE _UNIX98_THREAD_MUTEX_ATTRIBUTES}   {Enable Pthread Mutex Type attribute (Default: On)}

{==============================================================================}
const
 {Syscalls specific constants}
 
 {Basic constants}
 {From limits.h}
 INT_MAX  = 2147483647;
 INT_MIN  = -INT_MAX - 1;
 UINT_MAX = (INT_MAX * 2) + 1;
 
 LONG_MAX  = {$ifdef CPU64}9223372036854775807{$else CPU64}2147483647{$endif CPU64};
 LONG_MIN  = -LONG_MAX - 1;
 ULONG_MAX = (LONG_MAX * 2) + 1; 
 
 ARG_MAX = 4096;
 PATH_MAX = 4096;
 
const
 {From sys/syslimits.h} 
 {ARG_MAX = 65536;} {max bytes for an exec function}
 NAME_MAX = 255; {max bytes in a file name}
 {PATH_MAX = 1024;} {max bytes in pathname}
 
const 
 {Newlib constants from sys/errno.h}
 EPERM             = 1;       // Not owner
 ENOENT            = 2;       // No such file or directory
 ESRCH             = 3;       // No such process
 EINTR             = 4;       // Interrupted system call
 EIO               = 5;       // I/O error
 ENXIO             = 6;       // No such device or address
 E2BIG             = 7;       // Arg list too long
 ENOEXEC           = 8;       // Exec format error
 EBADF             = 9;       // Bad file number
 ECHILD            = 10;      // No children
 EAGAIN            = 11;      // No more processes
 ENOMEM            = 12;      // Not enough space
 EACCES            = 13;      // Permission denied
 EFAULT            = 14;      // Bad address
 ENOTBLK           = 15;      // Block device required
 EBUSY             = 16;      // Device or resource busy
 EEXIST            = 17;      // File exists
 EXDEV             = 18;      // Cross-device link
 ENODEV            = 19;      // No such device
 ENOTDIR           = 20;      // Not a directory
 EISDIR            = 21;      // Is a directory
 EINVAL            = 22;      // Invalid argument
 ENFILE            = 23;      // Too many open files in system
 EMFILE            = 24;      // File descriptor value too large
 ENOTTY            = 25;      // Not a character device
 ETXTBSY           = 26;      // Text file busy
 EFBIG             = 27;      // File too large
 ENOSPC            = 28;      // No space left on device
 ESPIPE            = 29;      // Illegal seek
 EROFS             = 30;      // Read-only file system
 EMLINK            = 31;      // Too many links
 EPIPE             = 32;      // Broken pipe
 EDOM              = 33;      // Mathematics argument out of domain of function
 ERANGE            = 34;      // Result too large
 ENOMSG            = 35;      // No message of desired type
 EIDRM             = 36;      // Identifier removed
 ECHRNG            = 37;      // Channel number out of range
 EL2NSYNC          = 38;      // Level 2 not synchronized
 EL3HLT            = 39;      // Level 3 halted
 EL3RST            = 40;      // Level 3 reset
 ELNRNG            = 41;      // Link number out of range
 EUNATCH           = 42;      // Protocol driver not attached
 ENOCSI            = 43;      // No CSI structure available
 EL2HLT            = 44;      // Level 2 halted
 EDEADLK           = 45;      // Deadlock
 ENOLCK            = 46;      // No lock
 EBADE             = 50;      // Invalid exchange
 EBADR             = 51;      // Invalid request descriptor
 EXFULL            = 52;      // Exchange full
 ENOANO            = 53;      // No anode
 EBADRQC           = 54;      // Invalid request code
 EBADSLT           = 55;      // Invalid slot
 EDEADLOCK         = 56;      // File locking deadlock error
 EBFONT            = 57;      // Bad font file fmt
 ENOSTR            = 60;      // Not a stream
 ENODATA           = 61;      // No data (for no delay io)
 ETIME             = 62;      // Stream ioctl timeout
 ENOSR             = 63;      // No stream resources
 ENONET            = 64;      // Machine is not on the network
 ENOPKG            = 65;      // Package not installed
 EREMOTE           = 66;      // The object is remote
 ENOLINK           = 67;      // Virtual circuit is gone
 EADV              = 68;      // Advertise error
 ESRMNT            = 69;      // Srmount error
 ECOMM             = 70;      // Communication error on send
 EPROTO            = 71;      // Protocol error
 EMULTIHOP         = 74;      // Multihop attempted
 ELBIN             = 75;      // Inode is remote (not really error)
 EDOTDOT           = 76;      // Cross mount point (not really error)
 EBADMSG           = 77;      // Bad message
 EFTYPE            = 79;      // Inappropriate file type or format
 ENOTUNIQ          = 80;      // Given log. name not unique
 EBADFD            = 81;      // f.d. invalid for this operation
 EREMCHG           = 82;      // Remote address changed
 ELIBACC           = 83;      // Can't access a needed shared lib
 ELIBBAD           = 84;      // Accessing a corrupted shared lib
 ELIBSCN           = 85;      // .lib section in a.out corrupted
 ELIBMAX           = 86;      // Attempting to link in too many libs
 ELIBEXEC          = 87;      // Attempting to exec a shared library
 ENOSYS            = 88;      // Function not implemented
 ENMFILE           = 89;      // No more files
 ENOTEMPTY         = 90;      // Directory not empty
 ENAMETOOLONG      = 91;      // File or path name too long
 ELOOP             = 92;      // Too many symbolic links
 EOPNOTSUPP        = 95;      // Operation not supported on socket
 EPFNOSUPPORT      = 96;      // Protocol family not supported
 ECONNRESET        = 104;     // Connection reset by peer
 ENOBUFS           = 105;     // No buffer space available
 EAFNOSUPPORT      = 106;     // Address family not supported by protocol family
 EPROTOTYPE        = 107;     // Protocol wrong type for socket
 ENOTSOCK          = 108;     // Socket operation on non-socket
 ENOPROTOOPT       = 109;     // Protocol not available
 ESHUTDOWN         = 110;     // Can't send after socket shutdown
 ECONNREFUSED      = 111;     // Connection refused
 EADDRINUSE        = 112;     // Address already in use
 ECONNABORTED      = 113;     // Software caused connection abort
 ENETUNREACH       = 114;     // Network is unreachable
 ENETDOWN          = 115;     // Network interface is not configured
 ETIMEDOUT         = 116;     // Connection timed out
 EHOSTDOWN         = 117;     // Host is down
 EHOSTUNREACH      = 118;     // Host is unreachable
 EINPROGRESS       = 119;     // Connection already in progress
 EALREADY          = 120;     // Socket already connected
 EDESTADDRREQ      = 121;     // Destination address required
 EMSGSIZE          = 122;     // Message too long
 EPROTONOSUPPORT   = 123;     // Unknown protocol
 ESOCKTNOSUPPORT   = 124;     // Socket type not supported
 EADDRNOTAVAIL     = 125;     // Address not available
 ENETRESET         = 126;     // Connection aborted by network
 EISCONN           = 127;     // Socket is already connected
 ENOTCONN          = 128;     // Socket is not connected
 ETOOMANYREFS      = 129;
 EPROCLIM          = 130;
 EUSERS            = 131;
 EDQUOT            = 132;
 ESTALE            = 133;
 ENOTSUP           = 134;     // Not supported
 ENOMEDIUM         = 135;     // No medium (in tape drive)
 ENOSHARE          = 136;     // No such host or network path
 ECASECLASH        = 137;     // Filename exists with different case
 EILSEQ            = 138;     // Illegal byte sequence
 EOVERFLOW         = 139;     // Value too large for defined data type
 ECANCELED         = 140;     // Operation canceled
 ENOTRECOVERABLE   = 141;     // State not recoverable
 EOWNERDEAD        = 142;     // Previous owner died
 ESTRPIPE          = 143;     // Streams pipe error
 EWOULDBLOCK       = EAGAIN;  // Operation would block

 __ELASTERROR      = 2000;    // Users can add values starting here
 
const 
 {Newlib constants from sys/stat.h}
 _IFMT             = $0170000; // type of file
 _IFDIR            = $0040000; // directory
 _IFCHR            = $0020000; // character special
 _IFBLK            = $0060000; // block special
 _IFREG            = $0100000; // regular
 _IFLNK            = $0120000; // symbolic link
 _IFSOCK           = $0140000; // socket
 _IFIFO            = $0010000; // fifo

 S_BLKSIZE         = 1024;     // size of a block

 S_ISUID           = $0004000; // set user id on execution
 S_ISGID           = $0002000; // set group id on execution
 S_ISVTX           = $0001000; // save swapped text even after use

 S_IREAD           = $0000400; // read permission, owner
 S_IWRITE          = $0000200; // write permission, owner
 S_IEXEC           = $0000100; // execute/search permission, owner
 S_ENFMT           = $0002000; // enforcement-mode locking

 S_IFMT            = _IFMT;
 S_IFDIR           = _IFDIR;
 S_IFCHR           = _IFCHR;
 S_IFBLK           = _IFBLK;
 S_IFREG           = _IFREG;
 S_IFLNK           = _IFLNK;
 S_IFSOCK          = _IFSOCK;
 S_IFIFO           = _IFIFO;

 _S_IFMT           = _IFMT;
 _S_IFDIR          = _IFDIR;
 _S_IFCHR          = _IFCHR;
 _S_IFIFO          = _IFIFO;
 _S_IFREG          = _IFREG;
 _S_IREAD          = $0000400;
 _S_IWRITE         = $0000200;
 {Open modes}
 S_IRUSR           = $0000400; // read permission, owner
 S_IWUSR           = $0000200; // write permission, owner
 S_IXUSR           = $0000100; // execute / search permission, owner
 S_IRWXU           = S_IRUSR or S_IWUSR or S_IXUSR;
 S_IRGRP           = $0000040; // read permission, group
 S_IWGRP           = $0000020; // write permission, grougroup
 S_IXGRP           = $0000010; // execute / search permission, group
 S_IRWXG           = S_IRGRP or S_IWGRP or S_IXGRP;
 S_IROTH           = $0000004; // read permission, other
 S_IWOTH           = $0000002; // write permission, other
 S_IXOTH           = $0000001; // execute / search permission, other
 S_IRWXO           = S_IROTH or S_IWOTH or S_IXOTH;
 
const 
 {File constants from default_fcntl.h}
 {Open flags}
 O_RDONLY          = 0;
 O_WRONLY          = 1;
 O_RDWR            = 2;
 O_APPEND          = $0008;    {append (writes guaranteed at the end)}
 O_CREAT           = $0200;    {If set, the file will be created if it doesn’t already exist}
 O_EXCL            = $0800;    {If both O_CREAT and O_EXCL are set, then open fails if the specified file already exists. This is guaranteed to never clobber an existing file}

 O_SYNC            = $2000;
 O_NONBLOCK        = $4000;    {This prevents open from blocking for a “long time” to open the file. This is only meaningful for some kinds of files, usually devices such as serial ports; when it is not meaningful, it is harmless and ignored. Often opening a port to a modem blocks until the modem reports carrier detection; if O_NONBLOCK is specified, open will return immediately without a carrier}
 O_NOCTTY          = $8000;    {If the named file is a terminal device, don’t make it the controlling terminal for the process. See Job Control, for information about what it means to be the controlling terminal}
                               {On GNU/Hurd systems and 4.4 BSD, opening a file never makes it the controlling terminal and O_NOCTTY is zero. However, GNU/Linux systems and some other systems use a nonzero value for O_NOCTTY and set the controlling terminal when you open a file that is a terminal device; so to be portable, use O_NOCTTY when it is important to avoid this}

 {The open-time action flags tell open to do additional operations which are not really related to opening the file. The reason to do them as part of open instead of in separate calls is that open can do them atomically}
 O_TRUNC           = $0400;    {Truncate the file to zero length. This option is only useful for regular files, not special files such as directories or FIFOs. POSIX.1 requires that you open the file for writing to use O_TRUNC. In BSD and GNU you must have permission to write the file to truncate it, but you need not open for write access}
                               {This is the only open-time action flag specified by POSIX.1. There is no good reason for truncation to be done by open, instead of by calling ftruncate afterwards. The O_TRUNC flag existed in Unix before ftruncate was invented, and is retained for backward compatibility}

 {The remaining operating modes are BSD extensions. They exist only on some systems. On other systems, these macros are not defined}
 O_SHLOCK          = $0080;    {Acquire a shared lock on the file, as with flock. See File Locks}
                               {If O_CREAT is specified, the locking is done atomically when creating the file. You are guaranteed that no other process will get the lock on the new file first}
 O_EXLOCK          = $0100;    {Acquire an exclusive lock on the file, as with flock. See File Locks. This is atomic like O_SHLOCK}

 O_BINARY          = $0001000;
 O_TEXT            = $0002000;
 O_CLOEXEC         = $0040000;
 O_DIRECT          = $0080000;
 O_NOFOLLOW        = $0100000;
 O_DSYNC           = $0002000;
 O_RSYNC           = $0002000;
 O_DIRECTORY       = $0200000;
 O_EXEC            = $0400000;
 O_SEARCH          = $0400000;
 
const 
 {Handle constants from sys/unistd.h}
 STDIN_FILENO  = 0;       {standard input file descriptor}
 STDOUT_FILENO = 1;       {standard output file descriptor}
 STDERR_FILENO = 2;       {standard error file descriptor}
 
const 
 {Sysconf values per IEEE Std 1003.1, 2008 Edition}
 _SC_ARG_MAX                       = 0;
 _SC_CHILD_MAX                     = 1;
 _SC_CLK_TCK                       = 2;
 _SC_NGROUPS_MAX                   = 3;
 _SC_OPEN_MAX                      = 4;
 _SC_JOB_CONTROL                   = 5;
 _SC_SAVED_IDS                     = 6;
 _SC_VERSION                       = 7;
 _SC_PAGESIZE                      = 8;
 _SC_PAGE_SIZE                     = _SC_PAGESIZE;

 _SC_NPROCESSORS_CONF              = 9;
 _SC_NPROCESSORS_ONLN              = 10;
 _SC_PHYS_PAGES                    = 11;
 _SC_AVPHYS_PAGES                  = 12;
 // End of non-POSIX values.
 _SC_MQ_OPEN_MAX                   = 13;
 _SC_MQ_PRIO_MAX                   = 14;
 _SC_RTSIG_MAX                     = 15;
 _SC_SEM_NSEMS_MAX                 = 16;
 _SC_SEM_VALUE_MAX                 = 17;
 _SC_SIGQUEUE_MAX                  = 18;
 _SC_TIMER_MAX                     = 19;
 _SC_TZNAME_MAX                    = 20;
 _SC_ASYNCHRONOUS_IO               = 21;
 _SC_FSYNC                         = 22;
 _SC_MAPPED_FILES                  = 23;
 _SC_MEMLOCK                       = 24;
 _SC_MEMLOCK_RANGE                 = 25;
 _SC_MEMORY_PROTECTION             = 26;
 _SC_MESSAGE_PASSING               = 27;
 _SC_PRIORITIZED_IO                = 28;
 _SC_REALTIME_SIGNALS              = 29;
 _SC_SEMAPHORES                    = 30;
 _SC_SHARED_MEMORY_OBJECTS         = 31;
 _SC_SYNCHRONIZED_IO               = 32;
 _SC_TIMERS                        = 33;
 _SC_AIO_LISTIO_MAX                = 34;
 _SC_AIO_MAX                       = 35;
 _SC_AIO_PRIO_DELTA_MAX            = 36;
 _SC_DELAYTIMER_MAX                = 37;
 _SC_THREAD_KEYS_MAX               = 38;
 _SC_THREAD_STACK_MIN              = 39;
 _SC_THREAD_THREADS_MAX            = 40;
 _SC_TTY_NAME_MAX                  = 41;
 _SC_THREADS                       = 42;
 _SC_THREAD_ATTR_STACKADDR         = 43;
 _SC_THREAD_ATTR_STACKSIZE         = 44;
 _SC_THREAD_PRIORITY_SCHEDULING    = 45;
 _SC_THREAD_PRIO_INHERIT           = 46;
 // _SC_THREAD_PRIO_PROTECT was _SC_THREAD_PRIO_CEILING in early drafts
 _SC_THREAD_PRIO_PROTECT           = 47;
 _SC_THREAD_PRIO_CEILING           = _SC_THREAD_PRIO_PROTECT;
 _SC_THREAD_PROCESS_SHARED         = 48;
 _SC_THREAD_SAFE_FUNCTIONS         = 49;
 _SC_GETGR_R_SIZE_MAX              = 50;
 _SC_GETPW_R_SIZE_MAX              = 51;
 _SC_LOGIN_NAME_MAX                = 52;
 _SC_THREAD_DESTRUCTOR_ITERATIONS  = 53;
 _SC_ADVISORY_INFO                 = 54;
 _SC_ATEXIT_MAX                    = 55;
 _SC_BARRIERS                      = 56;
 _SC_BC_BASE_MAX                   = 57;
 _SC_BC_DIM_MAX                    = 58;
 _SC_BC_SCALE_MAX                  = 59;
 _SC_BC_STRING_MAX                 = 60;
 _SC_CLOCK_SELECTION               = 61;
 _SC_COLL_WEIGHTS_MAX              = 62;
 _SC_CPUTIME                       = 63;
 _SC_EXPR_NEST_MAX                 = 64;
 _SC_HOST_NAME_MAX                 = 65;
 _SC_IOV_MAX                       = 66;
 _SC_IPV6                          = 67;
 _SC_LINE_MAX                      = 68;
 _SC_MONOTONIC_CLOCK               = 69;
 _SC_RAW_SOCKETS                   = 70;
 _SC_READER_WRITER_LOCKS           = 71;
 _SC_REGEXP                        = 72;
 _SC_RE_DUP_MAX                    = 73;
 _SC_SHELL                         = 74;
 _SC_SPAWN                         = 75;
 _SC_SPIN_LOCKS                    = 76;
 _SC_SPORADIC_SERVER               = 77;
 _SC_SS_REPL_MAX                   = 78;
 _SC_SYMLOOP_MAX                   = 79;
 _SC_THREAD_CPUTIME                = 80;
 _SC_THREAD_SPORADIC_SERVER        = 81;
 _SC_TIMEOUTS                      = 82;
 _SC_TRACE                         = 83;
 _SC_TRACE_EVENT_FILTER            = 84;
 _SC_TRACE_EVENT_NAME_MAX          = 85;
 _SC_TRACE_INHERIT                 = 86;
 _SC_TRACE_LOG                     = 87;
 _SC_TRACE_NAME_MAX                = 88;
 _SC_TRACE_SYS_MAX                 = 89;
 _SC_TRACE_USER_EVENT_MAX          = 90;
 _SC_TYPED_MEMORY_OBJECTS          = 91;
 _SC_V7_ILP32_OFF32                = 92;
 _SC_V6_ILP32_OFF32                = _SC_V7_ILP32_OFF32;
 _SC_XBS5_ILP32_OFF32              = _SC_V7_ILP32_OFF32;
 _SC_V7_ILP32_OFFBIG               = 93;
 _SC_V6_ILP32_OFFBIG               = _SC_V7_ILP32_OFFBIG;
 _SC_XBS5_ILP32_OFFBIG             = _SC_V7_ILP32_OFFBIG;
 _SC_V7_LP64_OFF64                 = 94;
 _SC_V6_LP64_OFF64                 = _SC_V7_LP64_OFF64;
 _SC_XBS5_LP64_OFF64               = _SC_V7_LP64_OFF64;
 _SC_V7_LPBIG_OFFBIG               = 95;
 _SC_V6_LPBIG_OFFBIG               = _SC_V7_LPBIG_OFFBIG;
 _SC_XBS5_LPBIG_OFFBIG             = _SC_V7_LPBIG_OFFBIG;
 _SC_XOPEN_CRYPT                   = 96;
 _SC_XOPEN_ENH_I18N                = 97;
 _SC_XOPEN_LEGACY                  = 98;
 _SC_XOPEN_REALTIME                = 99;
 _SC_STREAM_MAX                    = 100;
 _SC_PRIORITY_SCHEDULING           = 101;
 _SC_XOPEN_REALTIME_THREADS        = 102;
 _SC_XOPEN_SHM                     = 103;
 _SC_XOPEN_STREAMS                 = 104;
 _SC_XOPEN_UNIX                    = 105;
 _SC_XOPEN_VERSION                 = 106;
 _SC_2_CHAR_TERM                   = 107;
 _SC_2_C_BIND                      = 108;
 _SC_2_C_DEV                       = 109;
 _SC_2_FORT_DEV                    = 110;
 _SC_2_FORT_RUN                    = 111;
 _SC_2_LOCALEDEF                   = 112;
 _SC_2_PBS                         = 113;
 _SC_2_PBS_ACCOUNTING              = 114;
 _SC_2_PBS_CHECKPOINT              = 115;
 _SC_2_PBS_LOCATE                  = 116;
 _SC_2_PBS_MESSAGE                 = 117;
 _SC_2_PBS_TRACK                   = 118;
 _SC_2_SW_DEV                      = 119;
 _SC_2_UPE                         = 120;
 _SC_2_VERSION                     = 121;
 _SC_THREAD_ROBUST_PRIO_INHERIT    = 122;
 _SC_THREAD_ROBUST_PRIO_PROTECT    = 123;
 _SC_XOPEN_UUCP                    = 124;
 
const
 {Reentrant constants from sys/reent.h}
 {rand48 family support}
 _RAND48_SEED_0 = $330e;
 _RAND48_SEED_1 = $abcd;
 _RAND48_SEED_2 = $1234;
 _RAND48_MULT_0 = $e66d;
 _RAND48_MULT_1 = $deec;
 _RAND48_MULT_2 = $0005;
 _RAND48_ADD    = $000b;
 
 {How big the some arrays are}
 _REENT_EMERGENCY_SIZE = 25;
 _REENT_ASCTIME_SIZE = 26;
 _REENT_SIGNAL_SIZE = 24;

 _N_LISTS = 30;
 
 _ATEXIT_SIZE = 32;  {Must be at least 32 to guarantee ANSI conformance}
 
const
 {Scheduler constants from sched.h}
 {Scheduling Policies}
 SCHED_OTHER    = 0;
 SCHED_FIFO     = 1;
 SCHED_RR       = 2;
 {$IFDEF _POSIX_THREAD_SPORADIC_SERVER}
 SCHED_SPORADIC = 4;
 {$ENDIF}
 
const
 {Directory constants from dirent.h} 
 DT_UNKNOWN     = 0;  {The file type could not be determined} 
 DT_FIFO        = 1;  {A named pipe (FIFO)}
 DT_CHR         = 2;  {A character device}
 DT_DIR         = 4;  {A directory}
 DT_BLK         = 6;  {A block device} 
 DT_REG         = 8;  {A regular file}  
 DT_LNK         = 10; {A symbolic link} 
 DT_SOCK        = 12; {A UNIX domain socket} 
  
const
 {Pthread constants from sys/types.h}
 {Values for contention scope}
 PTHREAD_SCOPE_PROCESS = 0;
 PTHREAD_SCOPE_SYSTEM  = 1;
 
 {Values for inherit schedule}
 PTHREAD_INHERIT_SCHED  = 1; {Scheduling policy and associated attributes are inherited from the calling thread}
 PTHREAD_EXPLICIT_SCHED = 2; {Set from provided attribute object}

 {Values for detach state}
 PTHREAD_CREATE_DETACHED = 0;
 PTHREAD_CREATE_JOINABLE = 1; {Default}
 
 {Values for process shared}
 PTHREAD_PROCESS_PRIVATE = 0; {Visible within only the creating process}
 PTHREAD_PROCESS_SHARED  = 1; {Visible too all processes with access to the memory where the resource is located}
 
 {Values for blocking protocol}
 PTHREAD_PRIO_NONE    = 0;
 PTHREAD_PRIO_INHERIT = 1;
 PTHREAD_PRIO_PROTECT = 2;
 
 {Values for mutex type}
 PTHREAD_MUTEX_NORMAL     = 0; {This type of mutex does not detect deadlock. A thread attempting to relock this mutex without first unlocking it shall deadlock}
 PTHREAD_MUTEX_RECURSIVE  = 1; {A thread attempting to relock this mutex without first unlocking it shall succeed in locking the mutex}
 PTHREAD_MUTEX_ERRORCHECK = 2; {This type of mutex provides error checking. A thread attempting to relock this mutex without first unlocking it shall return with an error}
 PTHREAD_MUTEX_DEFAULT    = 3; {Attempting to recursively lock a mutex of this type results in undefined behavior}
 
 {Pthread constants from pthread.h} 
 PTHREAD_CANCEL_ENABLE  = 0; {Default}
 PTHREAD_CANCEL_DISABLE = 1;

 PTHREAD_CANCEL_DEFERRED = 0; {Default}
 PTHREAD_CANCEL_ASYNCHRONOUS = 1;

 PTHREAD_CANCELED = Pointer(-1);
 
const
 {Clock constants from time.h}
 CLOCK_REALTIME           = 1;
 CLOCK_PROCESS_CPUTIME_ID = 2; {The CPU_time clock associated with the PROCESS making the function call}
 CLOCK_THREAD_CPUTIME_ID  = 3; {The CPU_time clock associated with the THREAD making the function call}
 CLOCK_MONOTONIC          = 4; {A clock whose value cannot be set via clock_settime() and which cannot have backward clock jumps}
 
const
 {Semaphore constants from /linux/semahore.h}
 SEM_FAILED = nil; {Value returned if `sem_open' failed.}
 SEM_VALUE_MAX = $7FFFFFFF; {Maximum value the semaphore can have}
 
const
 {Ioctl constants from /linux/ioctl.h}
 _IOC_NRBITS = 8;
 _IOC_TYPEBITS = 8;

 _IOC_SIZEBITS = 14;
 _IOC_DIRBITS = 2;
 
 _IOC_NRMASK = ((1 shl _IOC_NRBITS) - 1);
 _IOC_TYPEMASK = ((1 shl _IOC_TYPEBITS) - 1);
 _IOC_SIZEMASK = ((1 shl _IOC_SIZEBITS) - 1);
 _IOC_DIRMASK = ((1 shl _IOC_DIRBITS) - 1);

 _IOC_NRSHIFT = 0;
 _IOC_TYPESHIFT = (_IOC_NRSHIFT + _IOC_NRBITS);
 _IOC_SIZESHIFT = (_IOC_TYPESHIFT + _IOC_TYPEBITS);
 _IOC_DIRSHIFT = (_IOC_SIZESHIFT + _IOC_SIZEBITS);

 {Direction bits}
 _IOC_NONE = 0;
 _IOC_WRITE = 1;
 _IOC_READ = 2;

const
 {Library names}
 libc = 'c';
 
{==============================================================================}
type
 {Syscalls specific types}
 
 {Basic Types} {Note: These should match (Except for case) with those from GlobalTypes unit}
 int = Integer; {INT_MAX}
 Pint = ^int;
 long = PtrInt; {LONG_MAX}
 Plong = ^long;
 short = Smallint;
 Pshort = ^short;
 uint = Cardinal; {unsigned int}
 Puint = ^uint;
 
type
 {From stddef.h}
 ptrdiff_t = PtrInt; {LONG_MAX}
 size_t = PtrUInt;
 Psize_t = ^size_t;
 ssize_t = PtrInt;
 wint_t = Cardinal; {unsigned int}          
 
type
 {From sys/types.h}
 dev_t = Smallint;  {short}              
 mode_t = Cardinal; {unsigned int}          
 ino_t = Word;      {unsigned short}
 ino64_t = Qword;   {unsigned long long} 
 nlink_t = Word;    {unsigned short}           
 gid_t = Word;      {unsigned short}             
 uid_t = Word;      {unsigned short}
 {$IFDEF SYSCALLS_USE_LONG_TIME_T}
 {time_t = PtrInt;} {long} {time_t is now defined in GlobalTypes}
 {$ELSE}
 {time_t = Int64;}  {int64_t} {time_t is now defined in GlobalTypes}
 {$ENDIF}
 off_t = PtrInt;    {long}
 off64_t = Int64;   {long long} 
 clock_t = PtrUInt; {_CLOCK_T_ in machine/types.h}{unsigned long}
 clockid_t = PtrUInt; {_CLOCK_T_ in machine/types.h}{unsigned long}
 useconds_t = PtrUInt; {unsigned long}

 fsblkcnt_t = uint64_t;
 fsfilcnt_t = uint32_t;
 
 fsblkcnt64_t = uint64_t;
 fsfilcnt64_t = uint64_t;
 
type
 {From sys/lock.h}
 _LOCK_T = int;
 _LOCK_RECURSIVE_T = int;
 
type 
 {From sys/_types.h}
 _ssize_t = PtrInt; {int or long}
 _fpos_t = PtrInt;  {long}
 _off_t  = PtrInt;  {long}
 _flock_t = int;    {_LOCK_RECURSIVE_T in lock.h}
 _fpos64_t = Int64; {long long}
 _off64_t = Int64;  {long long}
 
 {Conversion state information}
 P_mbstate_value = ^T_mbstate_value;
 T_mbstate_value = record
  case Integer of
   0:(__wch:wint_t;
     );
   1:(__wchb:array[0..3] of Char;
     ); 
  end;
  
 P_mbstate_t = ^T_mbstate_t;
 T_mbstate_t = record
  __count:int;
  __value:T_mbstate_value; {Value so far}
 end;
 
type
 {From _ansi.h} 
 _PTR = Pointer;
 
type
 {From sys/config.h}
 _READ_WRITE_RETURN_TYPE = int; {See note in \newlib\libc\include\sys\config.h may be ssize_t in some implementations}
 _READ_WRITE_BUFSIZE_TYPE = int; {See note in \newlib\libc\include\sys\config.h may be ssize_t in some implementations}
 
type
 {From sys/reent.h} {Types required for T_reent below}
 P_reent = ^T_reent;
 
 __ULong = long;
 
 P_Bigint = ^T_Bigint;
 T_Bigint = record
  _next:P_Bigint;
  _k:int;
  _maxwds:int;
  _sign:int;
  _wds:int;
  _x:array[0..0] of __ULong;
 end;
 PP_Bigint = ^P_Bigint;
 
 P__tm = ^T__tm;
 T__tm = record
  __tm_sec:int;
  __tm_min:int;
  __tm_hour:int;
  __tm_mday:int;
  __tm_mon:int;
  __tm_year:int;
  __tm_wday:int;
  __tm_yday:int;
  __tm_isdst:int;
 end; 
 
 {Stdio buffers}
 P__sbuf = ^T__sbuf; 
 T__sbuf = record
  _base:PChar;
  _size:int;
 end;
 
 P__sFILE = ^T__sFILE;
 T__sFILE = record
  _p:PChar;        {current position in (some) buffer}
  _r:int;          {read space left for getc()}
  _w:int;          {write space left for putc()}
  _flags:short;    {flags, below; this FILE is free if 0}
  _file:short;     {fileno, if Unix descriptor, else -1}
  _bf:T__sbuf;     {the buffer (at least 1 byte, if !NULL)}
  _lbfsize:int;    {0 or -_bf._size, for inline putc}
  
  {operations}
  _cookie:_PTR;    {cookie passed to io functions}
  _read:function(ptr: P_reent; cookie: _PTR; buf: PChar; size: _READ_WRITE_BUFSIZE_TYPE):_READ_WRITE_RETURN_TYPE; cdecl;
  _write:function(ptr: P_reent; cookie: _PTR; buf: PChar; size: _READ_WRITE_BUFSIZE_TYPE):_READ_WRITE_RETURN_TYPE; cdecl;
  _seek:function(ptr: P_reent; cookie: _PTR; pos: _fpos_t; dir: int):_fpos_t; cdecl; 
  _close:function(ptr: P_reent; cookie: _PTR):int; cdecl; 
  
  {separate buffer for long sequences of ungetc()}
  _ub:T__sbuf; {ungetc buffer}
  _up:PChar;   {saved _p when _p is doing ungetc data}
  _ur:int;     {saved _r when _r is counting ungetc data}
  
  {tricks to meet minimum requirements even when malloc() fails}
  _ubuf:array[0..2] of Char; {guarantee an ungetc() buffer}
  _nbuf:array[0..0] of Char; {guarantee a getc() buffer}
  
  {separate buffer for fgetline() when line crosses buffer boundary}
  _lb:T__sbuf; {buffer for fgetline()}
  
  {Unix stdio files get aligned to block boundaries on fseek()}
  _blksize:int;     {stat.st_blksize (may be != _bf._size)}
  _offset:_off_t;   {current lseek offset}
  
  _data:P_reent;    {Here for binary compatibility? Remove?}
  
  _lock:_flock_t;   {for thread-safety locking}
  
  _mbstate:T_mbstate_t; {for wide char stdio functions}
  _flags2:int;          {for future use}
 end;
 
 {$IFDEF SYSCALLS_LARGE64_FILES}
 P__sFILE64 = ^T__sFILE64;
 T__sFILE64 = record
  _p:PChar;        {current position in (some) buffer}
  _r:int;          {read space left for getc()}
  _w:int;          {write space left for putc()}
  _flags:short;    {flags, below; this FILE is free if 0}
  _file:short;     {fileno, if Unix descriptor, else -1}
  _bf:T__sbuf;     {the buffer (at least 1 byte, if !NULL)}
  _lbfsize:int;    {0 or -_bf._size, for inline putc}

  _data:P_reent;   
  
  {operations}
  _cookie:_PTR;    {cookie passed to io functions}
  _read:function(ptr: P_reent; cookie: _PTR; buf: PChar; size: _READ_WRITE_BUFSIZE_TYPE):_READ_WRITE_RETURN_TYPE; cdecl;
  _write:function(ptr: P_reent; cookie: _PTR; buf: PChar; size: _READ_WRITE_BUFSIZE_TYPE):_READ_WRITE_RETURN_TYPE; cdecl;
  _seek:function(ptr: P_reent; cookie: _PTR; pos: _fpos_t; dir: int):_fpos_t; cdecl; 
  _close:function(ptr: P_reent; cookie: _PTR):int; cdecl; 

  {separate buffer for long sequences of ungetc()}
  _ub:T__sbuf; {ungetc buffer}
  _up:PChar;   {saved _p when _p is doing ungetc data}
  _ur:int;     {saved _r when _r is counting ungetc data}
  
  {tricks to meet minimum requirements even when malloc() fails}
  _ubuf:array[0..2] of Char; {guarantee an ungetc() buffer}
  _nbuf:array[0..0] of Char; {guarantee a getc() buffer}

  {separate buffer for fgetline() when line crosses buffer boundary}
  _lb:T__sbuf; {buffer for fgetline()}

  {Unix stdio files get aligned to block boundaries on fseek()}
  _blksize:int;     {stat.st_blksize (may be != _bf._size)}
  _flags2:int;          {for future use}

  _offset:_off64_t;   {current lseek offset}
  _seek64:function(ptr: P_reent; cookie: _PTR; pos: _fpos64_t; dir: int):_fpos64_t; cdecl; 

  _lock:_flock_t;   {for thread-safety locking}
  _mbstate:T_mbstate_t; {for wide char stdio functions}
 end;
 {$ENDIF}
 
 {$IFDEF SYSCALLS_LARGE64_FILES}
 T__FILE = T__sFILE64;
 P__FILE = P__sFILE64;
 {$ELSE}
 T__FILE = T__sFILE;
 P__FILE = P__sFILE;
 {$ENDIF}
 
 P_glue = ^T_glue;
 T_glue = record
  _next:P_glue;
  _niobs:int;
  _iobs:P__FILE;
 end;
 
 P_rand48 = ^T_rand48;
 T_rand48 = record
  _seed:array[0..2] of Word; {unsigned short}
  _mult:array[0..2]of Word;  {unsigned short}
  _add:Word;                 {unsigned short}
 end;
 
 P_on_exit_args = ^T_on_exit_args;
 T_on_exit_args = record
  _fnargs:array[0.._ATEXIT_SIZE - 1] of Pointer;         {user fn args}
  _dso_handle:array[0.._ATEXIT_SIZE - 1] of Pointer;
  {Bitmask is set if user function takes arguments}
  _fntypes:__ULong;   {type of exit routine - Must have at least _ATEXIT_SIZE bits}
  {Bitmask is set if function was registered via __cxa_atexit.}
  _is_cxa:__ULong;
 end;
 
 P_atexit = ^T_atexit;
 T_atexit = record
  _next:P_atexit;   {next in list}
  _ind:int;         {next index in this table}
  {Some entries may already have been called, and will be NULL.}
  _fns:array[0.._ATEXIT_SIZE - 1] of procedure; {the table itself}
  _on_exit_args:T_on_exit_args;
 end;
 
 {From sys/reent.h} {Note that reent.h uses an alternate version of this if _REENT_SMALL if defined however that version is not supported}
 T_reent_new = record
  case Integer of
   0:(_unused_rand:Cardinal; {unsigned int}
      _strtok_last:PChar;
      _asctime_buf:array[0.._REENT_ASCTIME_SIZE - 1] of Char;
      _localtime_buf:T__tm;
      _gamma_signgam:int;
      _rand_next:Int64; {unsigned long long}
      _r48:T_rand48;
      _mblen_state:T_mbstate_t;
      _mbtowc_state:T_mbstate_t;
      _wctomb_state:T_mbstate_t;
      _l64a_buf:array[0..7] of Char;
      _signal_buf:array[0.._REENT_SIGNAL_SIZE - 1] of Char;
      _getdate_err:int;
      _mbrlen_state:T_mbstate_t;
      _mbrtowc_state:T_mbstate_t;
      _mbsrtowcs_state:T_mbstate_t;
      _wcrtomb_state:T_mbstate_t;
      _wcsrtombs_state:T_mbstate_t;
   _h_errno:int;
     ); {_reent}
   {Two next two fields were once used by malloc.  They are no longer used. They are used to preserve the space used before so as to allow addition of new reent fields and keep binary compatibility}
   1:(_nextf:array[0.._N_LISTS - 1] of PChar;
      _nmalloc:array[0.._N_LISTS - 1] of Cardinal; {unsigned int}
     ); {_unused}
 end;

 T_reent = record
  _errno:int;                    {local copy of errno}
  _stdin:P__FILE;                {FILE is a big struct and may change over time.  To try to achieve binary}
  _stdout:P__FILE;               {compatibility with future versions, put stdin,stdout,stderr here.}
  _stderr:P__FILE;               {These are pointers into member __sf defined below.}
  _inc:int;                      {used by tmpnam}
  _emergency:array[0.._REENT_EMERGENCY_SIZE - 1] of Char;
  _current_category:int;         {used by setlocale}
  _current_locale:PChar;
  __sdidinit:int;                {1 means stdio has been init'd}
  __cleanup:procedure(ptr: P_reent); cdecl;

  {used by mprec routines}
  _result:P_Bigint;
  _result_k:int;
  _p5s:P_Bigint;
  _freelist:PP_Bigint;

  {used by some fp conversion routines}
  _cvtlen:int;   {should be size_t}
  _cvtbuf:PChar;

  _new:T_reent_new;
  
  {atexit stuff}
  _atexit:P_atexit;  {points to head of LIFO stack}
  _atexit0:T_atexit; {one guaranteed table, required by ANSI}
  
  {signal info}
  _sig_func:function(param: int): PPointer; cdecl;
  
  {These are here last so that __FILE can grow without changing the offsets  of the above members (on the off chance that future binary compatibility  would be broken otherwise)}
  __sglue:T_glue;             {root of glue chain}
  __sf:array[0..2] of T__FILE;   {first three file descriptors}
 end;

type 
 {From sys/stat.h}
 Pstat = ^Tstat;
 Tstat = record
  st_dev:dev_t;            // ID of device containing file
  st_ino:ino_t;            // inode number
  st_mode:mode_t;          // protection
  st_nlink:nlink_t;        // number of hard links
  st_uid:uid_t;            // user ID of owner
  st_gid:gid_t;            // group ID of owner
  st_rdev:dev_t;           // device ID (if special file)
  st_size:off_t;           // total size, in bytes
  st_atime:time_t;         // time of last access
  st_spare1:long;          // spare - access nsecs
  st_mtime:time_t;         // time of last modification
  st_spare2:long;          // spare - mod nsecs
  st_ctime:time_t;         // time of last status change
  st_spare3:long;          // spare - change nsecs
  st_blksize:long;         // blocksize for file system I/O
  st_blocks:long;          // number of 512B blocks allocated
  st_spare4:array [0..1] of long;
 end;

 Pstat64 = ^Tstat64;
 Tstat64 = Tstat;
 
type 
 {From sys/times.h}
 Ptms = ^Ttms;
 Ttms = record
  tms_utime: clock_t;  {user time}
  tms_stime: clock_t;  {system time}
  tms_cutime: clock_t; {user time, children}
  tms_cstime: clock_t; {system time, children}
 end;
 
type
 {From machine/types.h}
 __suseconds_t = long;
 
type
 {From sys/_timeval.h}
 suseconds_t = __suseconds_t;
 
{$IFNDEF SYSCALLS_EXPORT_SOCKETS} 
 Ptimeval = ^Ttimeval;
 Ttimeval = record
  tv_sec: time_t;       {seconds}
  tv_usec: suseconds_t; {and microseconds}
 end;
{$ELSE}
 Ptimeval = Sockets.PTimeVal;
 Ttimeval = Sockets.TTimeVal;
{$ENDIF}

{$IFDEF SYSCALLS_EXPORT_SOCKETS} 
type
 {From sys/select.h}
 Tfd_set = Sockets.TFDSet;
 Pfd_set = Sockets.PFDSet;
{$ENDIF}
 
type
 {From sys/_timespec.h} 
 Ptimespec = ^Ttimespec;
 Ttimespec = record
  tv_sec: time_t; {seconds}
  tv_nsec: long;  {and nanoseconds}
 end;
 
type 
 {From sys/statfs.h}
 fsid_t = record
  val: array[0..1] of int;
 end; 

 Pstatfs = ^Tstatfs;
 Tstatfs = record
  f_type: uint32_t;
  f_bsize: uint32_t;
  f_blocks: uint32_t;
  f_bfree: uint32_t;
  f_bavail: uint32_t;
  f_files: uint32_t;
  f_ffree: uint32_t;
  f_fsid: fsid_t;
  f_namelen: uint32_t;
  f_frsize: uint32_t;
  f_flags: uint32_t;
  f_spare: array[0..3] of uint32_t;
 end;

 Pstatfs64 = ^Tstatfs64;
 Tstatfs64 = record
  f_type: uint64_t;
  f_bsize: uint64_t;
  f_blocks: uint64_t;
  f_bfree: uint64_t;
  f_bavail: uint64_t;
  f_files: uint64_t;
  f_ffree: uint64_t;
  f_fsid: fsid_t;
  f_namelen: uint32_t;
  f_frsize: uint32_t;
  f_flags: uint32_t;
  f_spare: array[0..3] of uint32_t;
 end;
 
type 
 {From sys/statvfs.h}
 Pstatvfs = ^Tstatvfs;
 Tstatvfs = record
  f_bsize: PtrUInt;
  f_frsize: PtrUInt;
  {$IFNDEF SYSCALLS_FILE_OFFSET64}  
  f_blocks: fsblkcnt_t;
  f_bfree: fsblkcnt_t;
  f_bavail: fsblkcnt_t;
  f_files: fsfilcnt_t;
  f_ffree: fsfilcnt_t;
  f_favail: fsfilcnt_t;
  {$ELSE}
  f_blocks: fsblkcnt64_t;
  f_bfree: fsblkcnt64_t;
  f_bavail: fsblkcnt64_t;
  f_files: fsfilcnt64_t;
  f_ffree: fsfilcnt64_t;
  f_favail: fsfilcnt64_t;
  {$ENDIF}
  f_fsid: PtrUInt;
  f_flag: PtrUInt;
  f_namemax: PtrUInt;
  __f_spare: array[0..5] of int;
 end;
 
 {$IFDEF SYSCALLS_LARGE64_FILES}  
 Pstatvfs64 = ^Tstatvfs64;
 Tstatvfs64 = record
  f_bsize: PtrUInt;
  f_frsize: PtrUInt;
  f_blocks: fsblkcnt64_t;
  f_bfree: fsblkcnt64_t;
  f_bavail: fsblkcnt64_t;
  f_files: fsfilcnt64_t;
  f_ffree: fsfilcnt64_t;
  f_favail: fsfilcnt64_t;
  f_fsid: PtrUInt;
  f_flag: PtrUInt;
  f_namemax: PtrUInt;
  __f_spare[6]: array[0..5] of int;
 end;
 {$ENDIF}
 
type
 {From sched.h}
 Psched_param = ^Tsched_param;
 Tsched_param = record
  sched_priority: int;             {Process execution scheduling priority}
  {$IFDEF _POSIX_THREAD_SPORADIC_SERVER}
  sched_ss_low_priority: int;      {Low scheduling priority for sporadic server}
  sched_ss_repl_period: Ttimespec; {Replenishment period for sporadic server}
  sched_ss_init_budget: Ttimespec; {Initial budget for sporadic server}
  sched_ss_max_repl: int;          {Maximum pending replenishments for sporadic server}
  {$ENDIF}
 end;

type
 {From dirent.h}
 PPdirent = ^Pdirent;
 Pdirent = ^Tdirent;
 Tdirent = record
  {$IFNDEF SYSCALLS_FILE_OFFSET64}  
  d_ino: ino_t;
  d_off: off_t;
  {$ELSE}
  d_ino: ino64_t;
  d_off: off64_t;
  {$ENDIF}
  d_reclen: Word;
  d_type: Byte;
  d_name:array[0..255] of Char;
 end;
 
 {$IFDEF SYSCALLS_LARGE64_FILES}  
 PPdirent64 = ^Pdirent64;
 Pdirent64 = ^Tdirent64;
 Tdirent64 = record
  d_ino: ino64_t;
  d_off: off64_t;
  d_reclen: Word;
  d_type: Byte;
  d_name:array[0..255] of Char;
 end;
 {$ENDIF}

 PDIR = ^DIR;
 DIR = record
  dd_fd: int;    {directory file}
  dd_loc: int;   {position in buffer}
  dd_seek: int;
  dd_buf: PByte; {buffer}
  dd_len: int;   {buffer length}
  dd_size: int;  {amount of data in buffer}
  dd_lock: _LOCK_RECURSIVE_T;
 end;
 
type
 {From sys/types.h}
 {Pthread types}
 pthread_t = Cardinal; {uint32_t}
 Ppthread_t = ^pthread_t;
 
 Ppthread_attr_t = ^Tpthread_attr_t;
 Tpthread_attr_t = record
  is_initialized: int;
  stackaddr: Pointer;
  stacksize: int;
  contentionscope: int;
  inheritsched: int;
  schedpolicy: int;
  schedparam: Tsched_param;
  {$IFDEF _POSIX_THREAD_GUARDSIZE}
  guardsize: size_t; {Note: This is defined in the Linux version of pthread_attr_t but not for other platforms. Ultibo uses THREAD_STACK_GUARD_ENABLED from GlobalConfig}
  {$ENDIF}
  {$IFDEF _POSIX_THREAD_CPUTIME}
  cputime_clock_allowed: int;  {See time.h}
  {$ENDIF}
  detachstate: int;
 end;
 
 {Pthread Mutex types}
 pthread_mutex_t = Cardinal; {uint32_t}
 Ppthread_mutex_t = ^pthread_mutex_t;
 
 Ppthread_mutexattr_t = ^Tpthread_mutexattr_t;
 Tpthread_mutexattr_t = record
  is_initialized: int;
  {$IFDEF _POSIX_THREAD_PROCESS_SHARED}
  process_shared: int;  {Allow mutex to be shared amongst processes (Not applicable to Ultibo)}
  {$ENDIF}
  {$IFDEF _POSIX_THREAD_PRIO_PROTECT}
  prio_ceiling: int;
  protocol: int;
  {$ENDIF}
  {$IFDEF _UNIX98_THREAD_MUTEX_ATTRIBUTES}
  _type: int;
  {$ENDIF}
  recursive: int;
 end;  
 
 {Pthread Condition Variable types}
 pthread_cond_t = Cardinal; {uint32_t}
 Ppthread_cond_t = ^pthread_cond_t;
 
 Ppthread_condattr_t = ^Tpthread_condattr_t;
 Tpthread_condattr_t = record
  is_initialized: int;
  clock: clock_t;       {Specifiy clock for timeouts}
  {$IFDEF _POSIX_THREAD_PROCESS_SHARED}
  process_shared: int;  {Allow this to be shared amongst processes (Not applicable to Ultibo)}
  {$ENDIF}
 end;
 
 {Pthread Key types}
 pthread_key_t = Cardinal; {uint32_t}
 Ppthread_key_t = ^pthread_key_t;
 
 Ppthread_once_t = ^Tpthread_once_t;
 Tpthread_once_t = record
  is_initialized: int;  {Is this structure initialized}
  init_executed: int;   {Has the initialization routine been run}
 end;
 
 {Pthread Barrier types}
 pthread_barrier_t = Cardinal; {uint32_t}
 Ppthread_barrier_t = ^pthread_barrier_t;
 
 Ppthread_barrierattr_t = ^Tpthread_barrierattr_t;
 Tpthread_barrierattr_t = record
  is_initialized: int;  {Is this structure initialized}
  {$IFDEF _POSIX_THREAD_PROCESS_SHARED}
  process_shared: int;  {Allow this to be shared amongst processes (Not applicable to Ultibo)}
  {$ENDIF}
 end; 
 
 {Pthread Spin Lock types}
 pthread_spinlock_t = Cardinal; {uint32_t}
 Ppthread_spinlock_t = ^pthread_spinlock_t;
 
 {Pthread Reader/Writer Lock types}
 pthread_rwlock_t = Cardinal; {uint32_t}
 Ppthread_rwlock_t = ^pthread_rwlock_t;
 
 Ppthread_rwlockattr_t = ^Tpthread_rwlockattr_t;
 Tpthread_rwlockattr_t = record
  is_initialized: int;  {Is this structure initialized}
  {$IFDEF _POSIX_THREAD_PROCESS_SHARED}
  process_shared: int;  {Allow this to be shared amongst processes (Not applicable to Ultibo)}
  {$ENDIF}
 end; 
 
 {Pthread Function types}
 Tpthread_cleanup_routine = procedure(arg: Pointer); cdecl;
 Tpthread_destructor_routine = procedure(value: Pointer); cdecl; 
 Tpthread_start_routine = function(arg: Pointer): Pointer; cdecl;
 Tpthread_init_routine = procedure; cdecl;
 
type
 {From semahore.h} 
 sem_t = Cardinal; {uint32_t} {sem_t should be opaque to the user}
 Psem_t = ^sem_t;
 
type
 {From linux/netdb.h} 
 {Socket types}
 Psocklen_t = ^socklen_t;
 socklen_t = uint;
 
 {From linux/arpa/inet.h}
 in_addr_t = Cardinal; {uint32_t}
 
{==============================================================================}
var
 {Syscalls specific variables}
 environ:PPChar; external;  {Pointer to the global environment block in the C library}
 
var
 {Static initialization variables}
 PTHREAD_MUTEX_INITIALIZER:pthread_mutex_t = $FFFFFFFF; {This is used to statically initialize a pthread_mutex_t}
 PTHREAD_COND_INITIALIZER:pthread_cond_t = $FFFFFFFF; {This is used to statically initialize a pthread_cond_t}
 PTHREAD_RWLOCK_INITIALIZER:pthread_rwlock_t = $FFFFFFFF; {This is used to statically initialize a pthread_rwlock_t}
 
 PTHREAD_ONCE_INIT:Tpthread_once_t = (  {This is used to statically initialize a Tpthread_once_t (Is initialized and not run)}
  is_initialized:1;
  init_executed:0);
 
{==============================================================================}
{Initialization Functions}
procedure SyscallsInit;
procedure SyscallsQuit;

{==============================================================================}
{Syscalls Functions (Standard)}
procedure _exit; cdecl; public name '_exit';

{==============================================================================}
{Syscalls Functions (Recursive)}
function _close_r(ptr: P_reent; fd: int): int; cdecl; public name '_close_r';

function _execve_r(ptr: P_reent; name: PChar; argv: PPChar; env: PPChar): int; cdecl; public name '_execve_r';
function _fork_r(ptr: P_reent): int; cdecl; public name '_fork_r';
function _wait_r(ptr: P_reent; status: Pint): int; cdecl; public name '_wait_r';

function _fcntl_r(ptr: P_reent; fd: int; cmd:int; arg:int): int; cdecl; public name '_fcntl_r';

{$IFDEF SYSCALLS_LARGE64_FILES}
function _fstat64_r(ptr: P_reent; fd: int; stat: Pstat64): int; cdecl; public name '_fstat64_r';
{$ENDIF}

function _fstat_r(ptr: P_reent; fd: int; stat: Pstat): int; cdecl; public name '_fstat_r';

function __getreent: P_reent; cdecl; public name '__getreent';

function _gettimeofday_r(ptr: P_reent; timeval: Ptimeval; timezone: Pointer): int; cdecl; public name '_gettimeofday_r';

function _isatty_r(ptr: P_reent; fd: int): int; cdecl; public name '_isatty_r';

function _link_r(ptr: P_reent; old: PChar; new: PChar): int; cdecl; public name '_link_r';

{$IFDEF SYSCALLS_LARGE64_FILES}
function _lseek64_r(ptr: P_reent;  fd: int; pos: off64_t; whence: int): off64_t; cdecl; public name '_lseek64_r';
{$ENDIF}

function _lseek_r(ptr: P_reent; fd: int; pos: off_t; whence: int): off_t; cdecl; public name '_lseek_r';

function _mkdir_r(ptr: P_reent; path: PChar; mode: int): int; cdecl; public name '_mkdir_r';
  
{$IFDEF SYSCALLS_LARGE64_FILES}  
function _open64_r(ptr: P_reent; name: PChar; flags: int; mode: int): int; cdecl; public name '_open64_r';
{$ENDIF}

function _open_r(ptr: P_reent; name: PChar; flags: int; mode: int): int; cdecl; public name '_open_r';

function _read_r(ptr: P_reent; fd: int; buf: Pointer; cnt: size_t): _ssize_t; cdecl; public name '_read_r';

function _rename_r(ptr: P_reent; old: PChar; new: PChar): int; cdecl; public name '_rename_r';

function _sbrk_r(ptr: P_reent; incr: ptrdiff_t): Pointer; cdecl; public name '_sbrk_r';

function _kill_r(ptr: P_reent; pid: int; sig: int): int; cdecl; public name '_kill_r';
function _getpid_r(ptr: P_reent): int; cdecl; public name '_getpid_r';

{$IFDEF SYSCALLS_LARGE64_FILES}  
function _stat64_r(ptr: P_reent; name: PChar; stat: Pstat64): int; cdecl; public name '_stat64_r';
{$ENDIF}

function _stat_r(ptr: P_reent; name: PChar; stat: Pstat): int; cdecl; public name '_stat_r';

function _times_r(ptr: P_reent; tms: Ptms): clock_t; cdecl; public name '_times_r';

function _unlink_r(ptr: P_reent; name: PChar): int; cdecl; public name '_unlink_r';

function _write_r(ptr: P_reent; fd: int; buf: Pointer; cnt: size_t): _ssize_t; cdecl; public name '_write_r';
       
{==============================================================================}
{Syscalls Functions (Stat)}
function mkdir(path: PChar; mode: mode_t): int; cdecl; public name 'mkdir';
function chmod(path: PChar; mode: mode_t): int; cdecl; public name 'chmod';
     
{==============================================================================}
{Syscalls Functions (Stdlib)}
function malloc(size: size_t): Pointer; cdecl; external libc name 'malloc';
function memalign(alignment, size: size_t): Pointer; cdecl; external libc name 'memalign';

function posix_memalign(memptr: PPointer; alignment, size: size_t): int; cdecl; public name 'posix_memalign';

function realpath(path, resolved_path: PChar): PChar; cdecl; public name 'realpath';

{==============================================================================}
{Syscalls Functions (Unistd)}
function dup(oldfd: int): int; cdecl; public name 'dup';
function dup2(oldfd, newfd: int): int; cdecl; public name 'dup2';
function dup3(oldfd, newfd, flags: int): int; cdecl; public name 'dup3';
 
function sysconf(name: int): int; cdecl; public name 'sysconf';

function getpagesize: int; cdecl; public name 'getpagesize';

function ssleep(seconds: uint): uint; cdecl; public name 'sleep'; 
function usleep(useconds: useconds_t): int; cdecl; public name 'usleep';

function symlink(path1, path2: PChar): int; cdecl; public name 'symlink';

function ftruncate(fd: int; length: off_t): int; cdecl; public name 'ftruncate';
function truncate(path: PChar; length: off_t): int; cdecl; public name 'truncate';

function fsync(fd: int): int; cdecl; public name 'fsync';
function fdatasync(fd: int): int; cdecl; public name 'fdatasync';

{==============================================================================}
{Syscalls Functions (Mman)}
function mmap(addr: Pointer; length: size_t; prot, flags, fd: int; offset: off_t): Pointer; cdecl; public name 'mmap';
function munmap(addr: Pointer; length: size_t): int; cdecl; public name 'munmap';
    
{==============================================================================}
{Syscalls Functions (Time)}
function settimeofday(tv: Ptimeval; tz: Pointer): int; cdecl; public name 'settimeofday';

function clock_getres(clk_id: clockid_t; res: Ptimespec): int; cdecl; public name 'clock_getres';
function clock_gettime(clk_id: clockid_t; tp: Ptimespec): int; cdecl; public name 'clock_gettime';
function clock_settime(clk_id: clockid_t; tp: Ptimespec): int; cdecl; public name 'clock_settime';

function nanosleep(req, rem: Ptimespec): int; cdecl; public name 'nanosleep';
    
{==============================================================================}
{Syscalls Functions (Statfs)}
function statfs(path: PChar; buf: Pstatfs): int; cdecl; public name 'statfs';
function fstatfs(fd: int; buf: Pstatfs): int; cdecl; public name 'fstatfs';

function statfs64(path: PChar; buf: Pstatfs64): int; cdecl; public name 'statfs64';
function fstatfs64(fd: int; buf: Pstatfs64): int; cdecl; public name 'fstatfs64';
    
{==============================================================================}
{Syscalls Functions (Statvfs)}
function statvfs(path: PChar; buf: Pstatvfs): int; cdecl; public name 'statvfs';
function fstatvfs(fd: int; buf: Pstatvfs): int; cdecl; public name 'fstatvfs';
    
{==============================================================================}
{Syscalls Functions (Sched)}
//To Do //http://man7.org/linux/man-pages/man2/sched_setaffinity.2.html
//int sched_getaffinity(pid_t pid, size_t cpusetsize, cpu_set_t *mask);
//int sched_setaffinity(pid_t pid, size_t cpusetsize, const cpu_set_t *mask);

function sched_get_priority_max(policy: int): int; cdecl; public name 'sched_get_priority_max'; 
function sched_get_priority_min(policy: int): int; cdecl; public name 'sched_get_priority_min';  

{==============================================================================}
{Syscalls Functions (Dirent)}
function opendir(name: PChar): PDIR; cdecl; public name 'opendir'; 
function readdir(dirp: PDIR): Pdirent; cdecl; public name 'readdir'; 
function readdir_r(dirp: PDIR; entry: Pdirent; _result: PPdirent): int; cdecl; public name 'readdir_r'; 
function closedir(dirp: PDIR): int; cdecl; public name 'closedir'; 

{$IFDEF SYSCALLS_LARGE64_FILES}  
function readdir64(dirp: PDIR): Pdirent64; cdecl; public name 'readdir64'; 
function readdir64_r(dirp: PDIR; entry: Pdirent64; _result: PPdirent64): int; cdecl; public name 'readdir64_r'; 
{$ENDIF}

procedure seekdir(dirp: PDIR; loc: long); cdecl; public name 'seekdir'; 
procedure rewinddir(dirp: PDIR); cdecl; public name 'rewinddir'; 
function telldir(dirp: PDIR): long; cdecl; public name 'telldir'; 

{==============================================================================}
{Syscalls Functions (Pthread) (http://pubs.opengroup.org/onlinepubs/7908799/xsh/pthread.h.html)}
function pthread_attr_init(attr: Ppthread_attr_t): int; cdecl; public name 'pthread_attr_init';
function pthread_attr_destroy(attr: Ppthread_attr_t): int; cdecl; public name 'pthread_attr_destroy';
function pthread_attr_getdetachstate(attr: Ppthread_attr_t; detachstate: Pint): int; cdecl; public name 'pthread_attr_getdetachstate';
function pthread_attr_setdetachstate(attr: Ppthread_attr_t; detachstate: int): int; cdecl; public name 'pthread_attr_setdetachstate';
function pthread_attr_getguardsize(attr: Ppthread_attr_t; guardsize: Psize_t): int; cdecl; public name 'pthread_attr_getguardsize';
function pthread_attr_setguardsize(attr: Ppthread_attr_t; guardsize: size_t): int; cdecl; public name 'pthread_attr_setguardsize';
function pthread_attr_getinheritsched(attr: Ppthread_attr_t; inheritsched: Pint): int; cdecl; public name 'pthread_attr_getinheritsched';
function pthread_attr_setinheritsched(attr: Ppthread_attr_t; inheritsched: int): int; cdecl; public name 'pthread_attr_setinheritsched';
function pthread_attr_getschedparam(attr: Ppthread_attr_t; param: Psched_param): int; cdecl; public name 'pthread_attr_getschedparam';
function pthread_attr_setschedparam(attr: Ppthread_attr_t; param: Psched_param): int; cdecl; public name 'pthread_attr_setschedparam';
function pthread_attr_getschedpolicy(attr: Ppthread_attr_t; policy: Pint): int; cdecl; public name 'pthread_attr_getschedpolicy';
function pthread_attr_setschedpolicy(attr: Ppthread_attr_t; policy: int): int; cdecl; public name 'pthread_attr_setschedpolicy';
function pthread_attr_getscope(attr: Ppthread_attr_t; contentionscope: Pint): int; cdecl; public name 'pthread_attr_getscope';
function pthread_attr_setscope(attr: Ppthread_attr_t; contentionscope: int): int; cdecl; public name 'pthread_attr_setscope';
function pthread_attr_getstackaddr(attr: Ppthread_attr_t; stackaddr: PPointer): int; cdecl; public name 'pthread_attr_getstackaddr';
function pthread_attr_setstackaddr(attr: Ppthread_attr_t; stackaddr: Pointer): int; cdecl; public name 'pthread_attr_setstackaddr';
function pthread_attr_getstacksize(attr: Ppthread_attr_t; stacksize: Psize_t): int; cdecl; public name 'pthread_attr_getstacksize';
function pthread_attr_setstacksize(attr: Ppthread_attr_t; stacksize: size_t): int; cdecl; public name 'pthread_attr_setstacksize';

procedure pthread_cleanup_push(routine: Tpthread_cleanup_routine; arg: Pointer); cdecl; public name 'pthread_cleanup_push';
procedure pthread_cleanup_pop(execute: int); cdecl; public name 'pthread_cleanup_pop';

function pthread_cond_init(cond: Ppthread_cond_t; attr: Ppthread_condattr_t): int; cdecl; public name 'pthread_cond_init';
function pthread_cond_destroy(cond: Ppthread_cond_t): int; cdecl; public name 'pthread_cond_destroy';
function pthread_cond_broadcast(cond: Ppthread_cond_t): int; cdecl; public name 'pthread_cond_broadcast';
function pthread_cond_signal(cond: Ppthread_cond_t): int; cdecl; public name 'pthread_cond_signal';
function pthread_cond_wait(cond: Ppthread_cond_t; mutex: Ppthread_mutex_t): int; cdecl; public name 'pthread_cond_wait';
function pthread_cond_timedwait(cond: Ppthread_cond_t; mutex: Ppthread_mutex_t; abstime: Ptimespec): int; cdecl; public name 'pthread_cond_timedwait';

function pthread_condattr_init(attr: Ppthread_condattr_t): int; cdecl; public name 'pthread_condattr_init';
function pthread_condattr_destroy(attr: Ppthread_condattr_t): int; cdecl; public name 'pthread_condattr_destroy';
function pthread_condattr_getpshared(attr: Ppthread_condattr_t; pshared: Pint): int; cdecl; public name 'pthread_condattr_getpshared';
function pthread_condattr_setpshared(attr: Ppthread_condattr_t; pshared: int): int; cdecl; public name 'pthread_condattr_setpshared';

function pthread_create(thread: Ppthread_t; attr: Ppthread_attr_t; start_routine: Tpthread_start_routine; arg: Pointer): int; cdecl; public name 'pthread_create';
function pthread_cancel(thread: pthread_t): int; cdecl; public name 'pthread_cancel';
function pthread_detach(thread: pthread_t): int; cdecl; public name 'pthread_detach';
procedure pthread_exit(value_ptr: Pointer); cdecl; public name 'pthread_exit';
function pthread_equal(t1: pthread_t; t2: pthread_t): int; cdecl; public name 'pthread_equal';
function pthread_join(thread: pthread_t; value_ptr: PPointer): int; cdecl; public name 'pthread_join';
function pthread_self: pthread_t; cdecl; public name 'pthread_self';
function pthread_getconcurrency: int; cdecl; public name 'pthread_getconcurrency';
function pthread_setconcurrency(new_level: int): int; cdecl; public name 'pthread_setconcurrency';
function pthread_getschedparam(thread: pthread_t; policy: Pint; param: Psched_param): int; cdecl; public name 'pthread_getschedparam';
function pthread_setschedparam(thread: pthread_t; policy: int; param: Psched_param): int; cdecl; public name 'pthread_setschedparam';

function pthread_key_create(key: Ppthread_key_t; destructor_routine: Tpthread_destructor_routine): int; cdecl; public name 'pthread_key_create';
function pthread_key_delete(key: pthread_key_t): int; cdecl; public name 'pthread_key_delete';
function pthread_getspecific(key: pthread_key_t): Pointer; cdecl; public name 'pthread_getspecific';
function pthread_setspecific(key: pthread_key_t; value: Pointer): int; cdecl; public name 'pthread_setspecific';

function pthread_mutex_init(mutex: Ppthread_mutex_t; attr: Ppthread_mutexattr_t): int; cdecl; public name 'pthread_mutex_init';
function pthread_mutex_destroy(mutex: Ppthread_mutex_t): int; cdecl; public name 'pthread_mutex_destroy';    
function pthread_mutex_lock(mutex: Ppthread_mutex_t): int; cdecl; public name 'pthread_mutex_lock';    
function pthread_mutex_trylock(mutex: Ppthread_mutex_t): int; cdecl; public name 'pthread_mutex_trylock';    
function pthread_mutex_unlock(mutex: Ppthread_mutex_t): int; cdecl; public name 'pthread_mutex_unlock';    
function pthread_mutex_getprioceiling(mutex: Ppthread_mutex_t; prioceiling: Pint): int; cdecl; public name 'pthread_mutex_getprioceiling';    
function pthread_mutex_setprioceiling(mutex: Ppthread_mutex_t; prioceiling: int; old_ceiling: Pint): int; cdecl; public name 'pthread_mutex_setprioceiling';    

function pthread_mutexattr_init(attr: Ppthread_mutexattr_t): int; cdecl; public name 'pthread_mutexattr_init';
function pthread_mutexattr_destroy(attr: Ppthread_mutexattr_t): int; cdecl; public name 'pthread_mutexattr_destroy';
function pthread_mutexattr_getprioceiling(attr: Ppthread_mutexattr_t; prioceiling: Pint): int; cdecl; public name 'pthread_mutexattr_getprioceiling';
function pthread_mutexattr_setprioceiling(attr: Ppthread_mutexattr_t; prioceiling: int): int; cdecl; public name 'pthread_mutexattr_setprioceiling';
function pthread_mutexattr_getprotocol(attr: Ppthread_mutexattr_t; protocol: Pint): int; cdecl; public name 'pthread_mutexattr_getprotocol';
function pthread_mutexattr_setprotocol(attr: Ppthread_mutexattr_t; protocol: int): int; cdecl; public name 'pthread_mutexattr_setprotocol';
function pthread_mutexattr_getpshared(attr: Ppthread_mutexattr_t; pshared: Pint): int; cdecl; public name 'pthread_mutexattr_getpshared';
function pthread_mutexattr_setpshared(attr: Ppthread_mutexattr_t; pshared: int): int; cdecl; public name 'pthread_mutexattr_setpshared';
function pthread_mutexattr_gettype(attr: Ppthread_mutexattr_t; _type: Pint): int; cdecl; public name 'pthread_mutexattr_gettype';
function pthread_mutexattr_settype(attr: Ppthread_mutexattr_t; _type: int): int; cdecl; public name 'pthread_mutexattr_settype';

function pthread_once(once_control: Ppthread_once_t; init_routine: Tpthread_init_routine): int; cdecl; public name 'pthread_once';

function pthread_rwlock_init(rwlock: Ppthread_rwlock_t ; attr: Ppthread_rwlockattr_t): int; cdecl; public name 'pthread_rwlock_init';
function pthread_rwlock_destroy(rwlock: Ppthread_rwlock_t): int; cdecl; public name 'pthread_rwlock_destroy';
function pthread_rwlock_rdlock(rwlock: Ppthread_rwlock_t): int; cdecl; public name 'pthread_rwlock_rdlock';
function pthread_rwlock_wrlock(rwlock: Ppthread_rwlock_t): int; cdecl; public name 'pthread_rwlock_wrlock';
function pthread_rwlock_tryrdlock(rwlock: Ppthread_rwlock_t): int; cdecl; public name 'pthread_rwlock_tryrdlock';
function pthread_rwlock_trywrlock(rwlock: Ppthread_rwlock_t): int; cdecl; public name 'pthread_rwlock_trywrlock';
function pthread_rwlock_unlock(rwlock: Ppthread_rwlock_t): int; cdecl; public name 'pthread_rwlock_unlock';

function pthread_rwlockattr_init(attr: Ppthread_rwlockattr_t): int; cdecl; public name 'pthread_rwlockattr_init';
function pthread_rwlockattr_destroy(attr: Ppthread_rwlockattr_t): int; cdecl; public name 'pthread_rwlockattr_destroy';
function pthread_rwlockattr_getpshared(attr: Ppthread_rwlockattr_t; pshared: Pint): int; cdecl; public name 'pthread_rwlockattr_getpshared';
function pthread_rwlockattr_setpshared(attr: Ppthread_rwlockattr_t; pshared: int): int; cdecl; public name 'pthread_rwlockattr_setpshared';

function pthread_setcancelstate(state: int; oldstate: Pint): int; cdecl; public name 'pthread_setcancelstate';
function pthread_setcanceltype(_type: int; oldtype: Pint): int; cdecl; public name 'pthread_setcanceltype';
procedure pthread_testcancel; cdecl; public name 'pthread_testcancel';    

{==============================================================================}
{Syscalls Functions (Semaphore)}
function sem_close(sem: Psem_t): int; cdecl; public name 'sem_close';    
function sem_destroy(sem: Psem_t): int; cdecl; public name 'sem_destroy';    

function sem_getvalue(sem: Psem_t; sval: Pint): int; cdecl; public name 'sem_getvalue';
function sem_init(sem: Psem_t; pshared: int; value: uint): int; cdecl; public name 'sem_init';

function sem_open(name: PChar; oflag: int): Psem_t; cdecl; public name 'sem_open';
function sem_open_ext(name: PChar; oflag: int; mode: mode_t; value: uint): Psem_t; cdecl; public name 'sem_open_ext';

function sem_post(sem: Psem_t): int; cdecl; public name 'sem_post';
function sem_timedwait(sem: Psem_t; abs_timeout: Ptimespec): int; cdecl; public name 'sem_timedwait';
function sem_trywait(sem: Psem_t): int; cdecl; public name 'sem_trywait';
function sem_unlink(name: PChar): int; cdecl; public name 'sem_unlink';
function sem_wait(sem: Psem_t): int; cdecl; public name 'sem_wait';
     
{==============================================================================}
{Syscalls Functions (Sockets)}
{$IFDEF SYSCALLS_EXPORT_SOCKETS}
{From sys/socket.h}
function socket_accept(socket: int; address: psockaddr; address_len: Psocklen_t): int; cdecl; public name 'accept';
function socket_bind(socket: int; address: psockaddr; address_len: socklen_t): int; cdecl; public name 'bind';
function socket_connect(socket: int; address: psockaddr; address_len: socklen_t): int; cdecl; public name 'connect';
function socket_getpeername(socket: int; address: psockaddr; address_len: Psocklen_t): int; cdecl; public name 'getpeername';
function socket_getsockname(socket: int; address: psockaddr; address_len: Psocklen_t): int; cdecl; public name 'getsockname';
function socket_getsockopt(socket: int; level, option_name: int; option_value: Pointer; option_len: Psocklen_t): int; cdecl; public name 'getsockopt';
function socket_listen(socket: int; backlog: int): int; cdecl; public name 'listen';
function socket_recv(socket: int; buffer: Pointer; len: size_t; flags: int): ssize_t; cdecl; public name 'recv';
function socket_recvfrom(socket: int; buffer: Pointer; len: size_t; flags: int; address: psockaddr; address_len: Psocklen_t): ssize_t; cdecl; public name 'recvfrom';
//function socket_recvmsg //ssize_t recvmsg(int socket, struct msghdr *message, int flags); //To Do
function socket_send(socket: int; buffer: Pointer; len: size_t; flags: int): ssize_t; cdecl; public name 'send';
function socket_sendto(socket: int; buffer: Pointer; len: size_t; flags: int; dest_addr: psockaddr; dest_len: socklen_t): ssize_t; cdecl; public name 'sendto';
//function socket_sendmsg //ssize_t sendmsg(int socket, const struct msghdr *message, int flags); //To Do
function socket_setsockopt(socket: int; level, option_name: int; option_value: Pointer; option_len: socklen_t): int; cdecl; public name 'setsockopt';
function socket_shutdown(socket: int; how: int): int; cdecl; public name 'shutdown';
function socket_socket(domain, sockettype, protocol: int): int; cdecl; public name 'socket';
function socket_socketpair(domain, sockettype, protocol: int; socket_vector: Pint): int; cdecl; public name 'socketpair';

{From sys/select.h}
function socket_select(nfds: int; readfds, writefds, exceptfds: Pfd_set; timeout: Ptimeval): int; cdecl; public name 'select';

{From arpa/inet.h}
function socket_htonl(hostlong: uint32_t): uint32_t; cdecl; public name 'htonl';
function socket_htons(hostshort: uint16_t): uint16_t; cdecl; public name 'htons';
function socket_ntohl(netlong: uint32_t): uint32_t; cdecl; public name 'ntohl';
function socket_ntohs(netshort: uint16_t): uint16_t; cdecl; public name 'ntohs';
       
function socket_inet_addr(cp: PChar): in_addr_t; cdecl; public name '__inet_addr'; {Note: Linux has defines that remap to these names}
function socket_inet_ntoa(inaddr: TInAddr): PChar; cdecl; public name '__inet_ntoa';
function socket_inet_aton(cp: PChar; inaddr: PInAddr): int; cdecl; public name '__inet_aton';  

function socket_inet_pton(af: int; src: PChar; dst: Pointer): int; cdecl; public name '__inet_pton';  
function socket_inet_ntop(af: int; src: Pointer; dst: PChar; size: socklen_t): PChar; cdecl; public name '__inet_ntop';  

{From netdb.h}
function socket_gethostbyaddr(addr: Pointer; len: socklen_t; family: int): PHostEnt; cdecl; public name 'gethostbyaddr';
function socket_gethostbyname(name: PChar): PHostEnt; cdecl; public name 'gethostbyname';

function socket_getnetbyaddr(net: uint32_t; family: int): PNetEnt; cdecl; public name 'getnetbyaddr';
function socket_getnetbyname(name: PChar): PNetEnt; cdecl; public name 'getnetbyname';

function socket_getservbyport(port: int; proto: PChar): PServEnt; cdecl; public name 'getservbyport';
function socket_getservbyname(name, proto: PChar): PServEnt; cdecl; public name 'getservbyname';

function socket_getprotobynumber(proto: int): PProtoEnt; cdecl; public name 'getprotobynumber';
function socket_getprotobyname(name: PChar): PProtoEnt; cdecl; public name 'getprotobyname';
       
function socket_getaddrinfo(node: PChar; service: PChar; hints: PAddrInfo; var res: PAddrInfo): int; cdecl; public name 'getaddrinfo';   
function socket_getnameinfo(addr: PSockAddr; addrlen: socklen_t; host: PChar; hostlen: socklen_t; serv: PChar; servlen: socklen_t; flags: int): int; cdecl; public name 'getnameinfo';   
procedure socket_freeaddrinfo(res: PAddrInfo); cdecl; public name 'freeaddrinfo';   
{$ENDIF}
{==============================================================================}
{Syscalls Functions (Setjmp)}
function _setjmp(var env: jmp_buf): int; cdecl; public name '_setjmp';
procedure _longjmp(var env: jmp_buf; val: int); cdecl; public name '_longjmp';
       
{==============================================================================}
{Syscalls Functions (Non Standard)}
procedure msleep(msecs: uint); cdecl; public name 'msleep';

{==============================================================================}
{Syscalls Helper Functions}
procedure __malloc_lock(ptr: P_reent); cdecl; public name '__malloc_lock';
procedure __malloc_unlock(ptr: P_reent); cdecl; public name '__malloc_unlock';

procedure __env_lock(ptr: P_reent); cdecl; public name '__env_lock';
procedure __env_unlock(ptr: P_reent); cdecl; public name '__env_unlock';
  
{==============================================================================}
{Syscalls Macro Functions (Ioctl)}
{Creating Ioctl numbers}
function _IO(_type,nr: LongWord): LongWord;
function _IOR(_type,nr,size: LongWord): LongWord; 
function _IOW(_type,nr,size: LongWord): LongWord;
function _IOWR(_type,nr,size: LongWord): LongWord;

{Decoding Ioctl numbers}
function _IOC_DIR(nr: LongWord): LongWord;
function _IOC_TYPE(nr: LongWord): LongWord;
function _IOC_NR(nr: LongWord): LongWord;
function _IOC_SIZE(nr: LongWord): LongWord;
  
{==============================================================================}
{==============================================================================}
{Syscalls Libraries}
{$linklib c}
{$linklib gcc}

{==============================================================================}
{==============================================================================}

implementation

{==============================================================================}
{==============================================================================}
const
 {Syscalls specific constants}
 SYSCALLS_THREAD_NAME = 'POSIX Thread'; {Name of a Posix Thread}
 
 SYSCALLS_TABLE_MIN = 3;     {Skip Stdin, Stdout, Stderr}
 SYSCALLS_TABLE_MAX = 65535; {Only support 16-bit handles}
 SYSCALLS_TABLE_MASK = $F;   {16 buckets for handle lookups}
 
{==============================================================================}
{==============================================================================}
type
 {Syscalls specific types}
 PSyscallsEntry = ^TSyscallsEntry;
 
 PSyscallsTable = ^TSyscallsTable;
 TSyscallsTable = record
  Next:LongWord;
  Count:LongWord;
  Entries:array of PSyscallsEntry;
 end;
 
 TSyscallsEntry = record
  Number:LongWord;
  Handle:THandle;
  Prev:PSyscallsEntry;
  Next:PSyscallsEntry;
 end;
 
 PSyscallsHeapBlock = ^TSyscallsHeapBlock;
 TSyscallsHeapBlock = record
  VirtualAddress:PtrUInt;
  PhysicalAddress:PtrUInt;
  Size:LongWord;
  Used:LongWord;
  Prev:PSyscallsHeapBlock;
  Next:PSyscallsHeapBlock;
 end;
 
 PSyscallsPthreadCleanup = ^TSyscallsPthreadCleanup;
 
 PSyscallsPthread = ^TSyscallsPthread;
 TSyscallsPthread = record
  {Cleanup Handlers}
  Cleanup:PSyscallsPthreadCleanup;
 end;
 
 TSyscallsPthreadCleanup = record
  Routine:Tpthread_cleanup_routine;
  Arg:Pointer;
  Next:PSyscallsPthreadCleanup; 
 end;

 PSyscallsPthreadData = ^TSyscallsPthreadData;
 TSyscallsPthreadData = record
  Routine:Tpthread_start_routine;
  Arg:Pointer;
 end;
 
 TSyscallsPreinit = procedure; cdecl;
 TSyscallsInit = procedure; cdecl;
 TSyscallsFini = procedure; cdecl;
 TSyscallsCtor = procedure; cdecl;
 TSyscallsDtor = procedure; cdecl;
 
 PFileSearchRec = ^TFileSearchRec;
 
{==============================================================================}
{==============================================================================}
var
 {Syscalls specific variables}
 SyscallsInitialized:Boolean;

 SyscallsReentSize:LongWord;
 SyscallsReentIndex:LongWord;     {Newlib reent structure TLS index} 
 
 SyscallsMallocLock:TMutexHandle = INVALID_HANDLE_VALUE;
 SyscallsEnvLock:TMutexHandle = INVALID_HANDLE_VALUE;

 SyscallsTable:TSyscallsTable;
 SyscallsTableLock:TMutexHandle = INVALID_HANDLE_VALUE;
 
 SyscallsHeapFirst:PSyscallsHeapBlock;
 SyscallsHeapLast:PSyscallsHeapBlock;
 SyscallsHeapEnd:Pointer;
 SyscallsHeapSize:UInt64;
 SyscallsHeapLock:TMutexHandle = INVALID_HANDLE_VALUE;
 
 SyscallsPthreadSize:LongWord;
 SyscallsPthreadIndex:LongWord;                           {Pthread TLS index (For Cleanup handlers)}
 SyscallsPthreadLock:TMutexHandle = INVALID_HANDLE_VALUE;
 SyscallsPthreadConcurrency:Integer;                      {Pthread concurrency level (Not used by Ultibo)}
 
 SyscallsKeyDestructor:array[0..THREAD_TLS_MAXIMUM - 1] of Tpthread_destructor_routine;
 
 //To Do //Continuing 
 
 //__exidx_end //__exidx_start //__dso_handle //TestingLIBSTDC++ //Possibly not required, used internally by Libgcc etc?
 
{==============================================================================}
{==============================================================================}
{Forward Declarations}
function SyscallsGetStat(Handle:THandle;stat:Pstat):Boolean; forward;
function SyscallsGetStat64(Handle:THandle;stat64:Pstat64):Boolean; forward;

function SyscallsGetEntry(Number:LongWord):PSyscallsEntry; forward;
function SyscallsAddEntry(Handle:THandle):PSyscallsEntry; forward;
function SyscallsRemoveEntry(Entry:PSyscallsEntry):Boolean; forward;

function SyscallsInitializeHeap:Boolean; forward;
function SyscallsIncreaseHeap(Size:LongWord):Pointer; forward;
function SyscallsDecreaseHeap(Size:LongWord):Pointer; forward;
 
function SyscallsGetPthread:PSyscallsPthread; forward;

function SyscallsPthreadStart(Data:PSyscallsPthreadData):PtrInt; forward;
procedure SyscallsPthreadEnd(Value:Pointer); forward;

{==============================================================================}
{==============================================================================}
{Initialization Functions}
procedure SyscallsInit;
{Initialize the Syscalls unit and Syscalls handle table}

{Note: Called only during system startup}
var
 Count:LongWord;
 TableStart:PPointer;
 TableEnd:PPointer;
 TableProc:procedure; cdecl;
begin
 {}
 {Check Initialized}
 if SyscallsInitialized then Exit;

 {Set Reent TLS Size}
 SyscallsReentSize:=SizeOf(T_reent);
 
 {Allocate Reent TLS Index}
 SyscallsReentIndex:=ThreadAllocTlsIndexEx(THREAD_TLS_FLAG_FREE);
 if SyscallsReentIndex = TLS_OUT_OF_INDEXES then
  begin
   if PLATFORM_LOG_ENABLED then PlatformLogError('Failed to allocate Syscalls Reent TLS index');
  end;
 
 {Set Pthread TLS Size}
 SyscallsPthreadSize:=SizeOf(TSyscallsPthread);
 
 {Allocate Pthread TLS Index}
 SyscallsPthreadIndex:=ThreadAllocTlsIndexEx(THREAD_TLS_FLAG_NONE);
 if SyscallsPthreadIndex = TLS_OUT_OF_INDEXES then
  begin
   if PLATFORM_LOG_ENABLED then PlatformLogError('Failed to allocate Syscalls Pthread TLS index');
  end;
 
 {Initialize Malloc Lock}
 SyscallsMallocLock:=MutexCreateEx(False,MUTEX_DEFAULT_SPINCOUNT,MUTEX_FLAG_RECURSIVE);
 if SyscallsMallocLock = INVALID_HANDLE_VALUE then
  begin
   if PLATFORM_LOG_ENABLED then PlatformLogError('Failed to create Syscalls Malloc lock');
  end;
 
 {Initialize Env Lock}
 SyscallsEnvLock:=MutexCreateEx(False,MUTEX_DEFAULT_SPINCOUNT,MUTEX_FLAG_RECURSIVE);
 if SyscallsEnvLock = INVALID_HANDLE_VALUE then
  begin
   if PLATFORM_LOG_ENABLED then PlatformLogError('Failed to create Syscalls Env lock');
  end;
  
 {Initialize Pthread Lock}
 SyscallsPthreadLock:=MutexCreateEx(False,MUTEX_DEFAULT_SPINCOUNT,MUTEX_FLAG_RECURSIVE);
 if SyscallsPthreadLock = INVALID_HANDLE_VALUE then
  begin
   if PLATFORM_LOG_ENABLED then PlatformLogError('Failed to create Syscalls Pthread lock');
  end;
 
 {Initialize Handles}
 SyscallsTable.Next:=SYSCALLS_TABLE_MIN;
 SyscallsTable.Count:=0;
 SetLength(SyscallsTable.Entries,SYSCALLS_TABLE_MASK + 1);
 for Count:=0 to SYSCALLS_TABLE_MASK do
  begin
   SyscallsTable.Entries[Count]:=nil;
  end;
 SyscallsTableLock:=MutexCreateEx(False,MUTEX_DEFAULT_SPINCOUNT,MUTEX_FLAG_RECURSIVE);
 if SyscallsTableLock = INVALID_HANDLE_VALUE then
  begin
   if PLATFORM_LOG_ENABLED then PlatformLogError('Failed to create Syscalls Table lock');
  end;
 
 {Allocate Heap}
 if not SyscallsInitializeHeap then
  begin
   if PLATFORM_LOG_ENABLED then PlatformLogError('Failed to initialize Syscalls heap');
  end;

 {Allocate Environment}
 environ:=AllocMem(SizeOf(PChar) * (ENVIRONMENT_STRING_COUNT + 1)); {Add one for terminating null}
 if environ = nil then
  begin
   if PLATFORM_LOG_ENABLED then PlatformLogError('Failed to allocate Syscalls environment');
  end;
  
 {Copy Environment}
 for Count:=0 to (ENVIRONMENT_STRING_COUNT + 1) - 1 do
  begin
   environ[Count]:=StrNew(envp[Count]);
  end;

 {Execute Preinit functions}
 TableStart:=@__preinit_array_start;
 TableEnd:=@__preinit_array_end;
 while TableStart < TableEnd do
  begin
   {Call Preinit}
   TableProc:=TSyscallsPreinit(TableStart^);
   TableProc();
   
   {Update Start}
   Inc(TableStart); {Increment PPointer increments by SizeOf(Pointer)}
  end;
 
 {Execute Init functions}
 TableStart:=@__init_array_start;
 TableEnd:=@__init_array_end;
 while TableStart < TableEnd do
  begin
   {Call Init}
   TableProc:=TSyscallsInit(TableStart^);
   TableProc();
   
   {Update Start}
   Inc(TableStart); {Increment PPointer increments by SizeOf(Pointer)}
  end;
 
 {Execute Constructor (ctor) functions}
 TableStart:=@__ctors_start;
 TableEnd:=@__ctors_end;
 while TableStart < TableEnd do
  begin
   {Call Constructor}
   TableProc:=TSyscallsCtor(TableStart^);
   TableProc();
   
   {Update Start}
   Inc(TableStart); {Increment PPointer increments by SizeOf(Pointer)}
  end;
 
 //To Do //Register SyscallsQuit as a Shutdown handler
 
 SyscallsInitialized:=True;
end; 
 
{==============================================================================}

procedure SyscallsQuit;
{Terminate the Syscalls unit and Syscalls handle table}

{Note: Called only during system shutdown}
var
 TableStart:PPointer;
 TableEnd:PPointer;
 TableProc:procedure; cdecl;
begin
 {}
 {Check Initialized}
 if not SyscallsInitialized then Exit;
 
 {Execute Destructor (dtor) functions}
 TableStart:=@__dtors_start;
 TableEnd:=@__dtors_end;
 while TableStart < TableEnd do
  begin
   {Call Destructor}
   TableProc:=TSyscallsDtor(TableStart^);
   TableProc();
   
   {Update Start}
   Inc(TableStart); {Increment PPointer increments by SizeOf(Pointer)}
  end;
 
 {Execute Fini functions}
 TableStart:=@__fini_array_start;
 TableEnd:=@__fini_array_end;
 while TableStart < TableEnd do
  begin
   {Call Fini}
   TableProc:=TSyscallsFini(TableStart^);
   TableProc();
   
   {Update Start}
   Inc(TableStart); {Increment PPointer increments by SizeOf(Pointer)}
  end;
 
 SyscallsInitialized:=False;
end;

{==============================================================================}
{==============================================================================}
{Syscalls Functions (Standard)}
procedure _exit; cdecl;
{Exit the program without cleaning up files}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _exit');
 {$ENDIF}

 {Halt the thread} 
 HaltThread(0);
end;
 
{==============================================================================}
{==============================================================================}
{Syscalls Functions (Recursive)}
function _close_r(ptr: P_reent; fd: int): int; cdecl;
{Close a file}
{See: \newlib\libc\reent\closer.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Entry:PSyscallsEntry;
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _close_r (ptr=' + PtrToHex(ptr) + ' fd=' + IntToStr(fd) + ')');
 {$ENDIF}
 
 {Check descriptor}
 if (fd = STDIN_FILENO) or (fd = STDOUT_FILENO) or (fd = STDERR_FILENO) then
  begin
   {Stdin, Stdout, Stderr}
   Result:=0;
  end
 else
  begin
   {Normal file}
   Entry:=SyscallsGetEntry(fd);
   if Entry <> nil then
    begin
     {Close file}
     FSFileClose(Entry^.Handle);
     
     {Remove Entry}
     SyscallsRemoveEntry(Entry); 
     
     {Return Result}
     Result:=0;
    end
   else
    begin
     {Return Error}
     ptr^._errno:=EBADF;
    end;
  end;
  
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _close_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _execve_r(ptr: P_reent; name: PChar; argv: PPChar; env: PPChar): int; cdecl;
{Transfer control to a new process}
{See: \newlib\libc\reent\execr.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _execve_r (ptr=' + PtrToHex(ptr) + ')');
 {$ENDIF}
 
 {Return Error}
 ptr^._errno:=ENOMEM;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _execve_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _fork_r(ptr: P_reent): int; cdecl;
{Create a new process}
{See: \newlib\libc\reent\execr.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _fork_r (ptr=' + PtrToHex(ptr) + ')');
 {$ENDIF}
 
 {Return Error}
 ptr^._errno:=EAGAIN;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _fork_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _wait_r(ptr: P_reent; status: Pint): int; cdecl;
{Wait for a child process}
{See: \newlib\libc\reent\execr.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _wait_r (ptr=' + PtrToHex(ptr) + ')');
 {$ENDIF}
 
 {Return Error}
 ptr^._errno:=ECHILD;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _wait_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _fcntl_r(ptr: P_reent; fd: int; cmd:int; arg:int): int; cdecl;
{Control an open file}
{See: \newlib\libc\reent\fcntlr.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Entry:PSyscallsEntry;
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _fcntl_r (ptr=' + PtrToHex(ptr) + ' cmd=' + IntToStr(cmd) + ' arg=' + IntToStr(arg) + ')');
 {$ENDIF}
 
 {Get Entry}
 Entry:=SyscallsGetEntry(fd);
 if Entry <> nil then
  begin
  
   //To Do //Implement any that are required
   
   {Return Error}
   ptr^._errno:=EINVAL;
  end
 else 
  begin
   {Return Error}
   ptr^._errno:=EBADF;
  end;  
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _fcntl_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}
{$IFDEF SYSCALLS_LARGE64_FILES}
function _fstat64_r(ptr: P_reent; fd: int; stat: Pstat64): int; cdecl;
{Status of an open file}
{See: \newlib\libc\reent\fstat64r.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Entry:PSyscallsEntry;
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _fstat64_r (ptr=' + PtrToHex(ptr) + ' fd=' + IntToStr(fd) + ')');
 {$ENDIF}
 
 {Check stat}
 if stat = nil then Exit;
 
 {Check descriptor}
 if (fd = STDIN_FILENO) or (fd = STDOUT_FILENO) or (fd = STDERR_FILENO) then
  begin
   {Stdin, Stdout, Stderr}
   FillChar(stat^,SizeOf(Tstat64),0);
   stat^.st_mode:=_S_IFCHR;
   Result:=0;
  end
 else
  begin
   {Normal file}
   Entry:=SyscallsGetEntry(fd);
   if Entry <> nil then
    begin
     {Get Stat}
     if not SyscallsGetStat64(Entry^.Handle,stat) then Exit;
     
     {Return Result}
     Result:=0;
    end
   else
    begin
     {Return Error}
     ptr^._errno:=EBADF;
    end;    
  end;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _fstat64_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;
{$ENDIF}
{==============================================================================}

function _fstat_r(ptr: P_reent; fd: int; stat: Pstat): int; cdecl;
{Status of an open file}
{See: \newlib\libc\reent\fstatr.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Entry:PSyscallsEntry;
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _fstat_r (ptr=' + PtrToHex(ptr) + ' fd=' + IntToStr(fd) + ')');
 {$ENDIF}
 
 {Check stat}
 if stat = nil then Exit;
 
 {Check descriptor}
 if (fd = STDIN_FILENO) or (fd = STDOUT_FILENO) or (fd = STDERR_FILENO) then
  begin
   {Stdin, Stdout, Stderr}
   FillChar(stat^,SizeOf(Tstat),0);
   stat^.st_mode:=_S_IFCHR;
   Result:=0;
  end
 else
  begin
   {Normal file}
   Entry:=SyscallsGetEntry(fd);
   if Entry <> nil then
    begin
     {Get Stat}
     if not SyscallsGetStat(Entry^.Handle,stat) then Exit;
     
     {Return Result}
     Result:=0;
    end
   else
    begin
     {Return Error}
     ptr^._errno:=EBADF;
    end;    
  end;
  
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _fstat_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function __getreent: P_reent; cdecl;
{Return the _reent structure for the calling thread or allocate a new one if not found}
{See: \newlib\libc\reent\getreent.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 reent:P_reent;
begin
 {}
 Result:=nil;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls __getreent');
 {$ENDIF}
 
 {Get TLS Value}
 reent:=ThreadGetTlsValue(SyscallsReentIndex);
 if reent = nil then
  begin
   {Allocate TLS Value}
   reent:=AllocMem(SyscallsReentSize);
   if reent = nil then Exit;

   {$IFDEF SYSCALLS_DEBUG}
   if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls __getreent (Allocated reent=' + PtrToHex(reent) + ')');
   {$ENDIF}
   
   {Set TLS Value}
   if ThreadSetTlsValue(SyscallsReentIndex,reent) <> ERROR_SUCCESS then Exit;

   {Initialize reent structure} 
   {See: _REENT_INIT_PTR_ZEROED in \newlib\libc\include\sys\reent.h}
   reent^._stdin:=@reent^.__sf[0];
   reent^._stdout:=@reent^.__sf[1];
   reent^._stderr:=@reent^.__sf[2];
   reent^._current_locale:='C';
   reent^._new._rand_next:=1;
   reent^._new._r48._seed[0]:=_RAND48_SEED_0;
   reent^._new._r48._seed[1]:=_RAND48_SEED_1; 
   reent^._new._r48._seed[2]:=_RAND48_SEED_2; 
   reent^._new._r48._mult[0]:=_RAND48_MULT_0; 
   reent^._new._r48._mult[1]:=_RAND48_MULT_1; 
   reent^._new._r48._mult[2]:=_RAND48_MULT_2; 
   reent^._new._r48._add:=_RAND48_ADD; 
  end;
 
 {Return Result}
 Result:=reent;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls __getreent (Result=' + PtrToHex(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _gettimeofday_r(ptr: P_reent; timeval: Ptimeval; timezone: Pointer): int; cdecl;
{Get the date and time}
{See: \newlib\libc\reent\gettimeofdayr.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ClockTime:Int64;
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _gettimeofday_r (ptr=' + PtrToHex(ptr) + ' timeval=' + PtrToHex(timeval) + ')');
 {$ENDIF}
 
 {Check timeval}
 if timeval = nil then
  begin
   {Return Error}
   ptr^._errno:=EFAULT;
  end
 else
  begin
   {Get Time}
   ClockTime:=ClockGetTime;
   
   {Convert to timeval}
   if Int64(ClockTime) < TIME_TICKS_TO_1970 then Exit;
   timeval^.tv_sec:=(Int64(ClockTime) - TIME_TICKS_TO_1970) div TIME_TICKS_PER_SECOND;
   timeval^.tv_usec:=((Int64(ClockTime) - TIME_TICKS_TO_1970) mod TIME_TICKS_PER_SECOND) div TIME_TICKS_PER_MICROSECOND;
   
   {Return Result}
   Result:=0;
   
   {$IFDEF SYSCALLS_DEBUG}
   if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _gettimeofday_r (Result=' + IntToStr(Result) + ')');
   {$ENDIF}
  end; 
end;

{==============================================================================}

function _isatty_r(ptr: P_reent; fd: int): int; cdecl;
{Query whether output stream is a terminal}
{See: \newlib\libc\reent\isattyr.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _isatty_r (ptr=' + PtrToHex(ptr) + ' fd=' + IntToStr(fd) + ')');
 {$ENDIF}
 
 {Check descriptor}
 if (fd = STDOUT_FILENO) or (fd = STDERR_FILENO) then
  begin
   {Stdout, Stderr}
   Result:=1;
  end;
  
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _isatty_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _link_r(ptr: P_reent; old: PChar; new: PChar): int; cdecl;
{Establish a new name for an existing file}
{See: \newlib\libc\reent\linkr.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
  OldName:String;
  NewName:String;
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _link_r (ptr=' + PtrToHex(ptr) + ' old=' + StrPas(old) + ' new=' + StrPas(new) + ')');
 {$ENDIF}
 
 {Get Names}
 OldName:=StrPas(old);
 NewName:=StrPas(new);

 {Check Names}
 if (Length(OldName) = 0) or (Length(NewName) = 0) then
  begin
   {Return Error}
   ptr^._errno:=ENOENT;
   Exit;
  end;

 {Check Old}
 if not FSFileExists(OldName) and not FSDirectoryExists(OldName) then
  begin
   {Return Error}
   ptr^._errno:=ENOENT;
   Exit;
  end;

 {Check New}
 if FSFileExists(NewName) or FSDirectoryExists(NewName) then
  begin
   {Return Error}
   ptr^._errno:=EEXIST;
   Exit;
  end;

 {Create Link}
 if FSCreateSymbolicLink(NewName,OldName,FSDirectoryExists(OldName)) then
  begin
   {Return Result}
   Result:=0;
  end
 else
  begin
   {Return Error}
   ptr^._errno:=EINVAL;
  end;  
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _link_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}
{$IFDEF SYSCALLS_LARGE64_FILES}
function _lseek64_r(ptr: P_reent;  fd: int; pos: off64_t; whence: int): off64_t; cdecl;
{Set position in a file}
{See: \newlib\libc\reent\lseek64r.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Entry:PSyscallsEntry;
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _lseek64_r (ptr=' + PtrToHex(ptr) + ' fd=' + IntToStr(fd) + ' pos=' + IntToStr(pos) + ' whence=' + IntToStr(whence) + ')');
 {$ENDIF}
 
 {Get Entry}
 Entry:=SyscallsGetEntry(fd);
 if Entry <> nil then
  begin
   {Seek file}
   Result:=FSFileSeekEx(Entry^.Handle,pos,whence);
  end
 else
  begin
   {Return Error}
   ptr^._errno:=EBADF;
  end;    
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _lseek64_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;
{$ENDIF}
{==============================================================================}

function _lseek_r(ptr: P_reent; fd: int; pos: off_t; whence: int): off_t; cdecl;
{Set position in a file}
{See: \newlib\libc\reent\lseekr.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Entry:PSyscallsEntry;
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _lseek_r (ptr=' + PtrToHex(ptr) + ' fd=' + IntToStr(fd) + ' pos=' + IntToStr(pos) + ' whence=' + IntToStr(whence) + ')');
 {$ENDIF}
 
 {Get Entry}
 Entry:=SyscallsGetEntry(fd);
 if Entry <> nil then
  begin
   {Seek file}
   Result:=FSFileSeek(Entry^.Handle,pos,whence);
  end
 else
  begin
   {Return Error}
   ptr^._errno:=EBADF;
  end;    
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _lseek_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _mkdir_r(ptr: P_reent; path: PChar; mode: int): int; cdecl;
{Make a directory}
{See: \newlib\libc\reent\mkdirr.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 PathName:String;
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _mkdir_r (ptr=' + PtrToHex(ptr) + ' path=' + StrPas(path) + ' mode=' + IntToStr(mode) + ')');
 {$ENDIF}
 
 {Get Name}
 PathName:=StrPas(path);
 
 {Check Name}
 if Length(PathName) = 0 then
  begin
   {Return Error}
   ptr^._errno:=ENOENT;
   Exit;
  end;
 
 {Check Path}
 if FSFileExists(PathName) or FSDirectoryExists(PathName) then
  begin
   {Return Error}
   ptr^._errno:=EEXIST;
   Exit;
  end;

 {Create Directory}
 if FSCreateDir(PathName) then
  begin
   {Return Result}
   Result:=0;
  end
 else
  begin
   {Return Error}
   ptr^._errno:=EINVAL;
  end;  
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _mkdir_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}
{$IFDEF SYSCALLS_LARGE64_FILES}
function _open64_r(ptr: P_reent; name: PChar; flags: int; mode: int): int; cdecl;
{Open a file}
{See: \newlib\libc\reent\open64r.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Handle:THandle;
 Entry:PSyscallsEntry;
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _open64_r (ptr=' + PtrToHex(ptr) + ' name=' + StrPas(name) + ' flags=' + IntToStr(flags) + ' mode=' + IntToStr(mode) + ')');
 {$ENDIF}
 
 {Call Open}
 Result:=_open_r(ptr,name,flags,mode);
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _open64_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;
{$ENDIF}
{==============================================================================}

function _open_r(ptr: P_reent; name: PChar; flags: int; mode: int): int; cdecl;
{Open a file}
{See: \newlib\libc\reent\openr.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Handle:THandle;
 FileName:String;
 AccessMode:LongWord;
 ShareMode:LongWord;
 CreateFlags:LongWord;
 Entry:PSyscallsEntry;
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _open_r (ptr=' + PtrToHex(ptr) + ' name=' + StrPas(name) + ' flags=' + IntToStr(flags) + ' mode=' + IntToStr(mode) + ')');
 {$ENDIF}

 {Get Name}
 FileName:=StrPas(name);

 {Check Name}
 if Length(FileName) = 0 then
  begin
   {Return Error}
   ptr^._errno:=ENOENT;
   Exit;
  end;

 {Check Flags}
 if (flags and O_DIRECTORY) = O_DIRECTORY then
  begin
   {Return Error}
   ptr^._errno:=EINVAL;
   Exit;
  end;
  
 {Get Access Mode} 
 if (flags and (O_RDONLY or O_WRONLY or O_RDWR)) = O_RDONLY then
  begin
   AccessMode:=GENERIC_READ;
  end
 else if (flags and (O_RDONLY or O_WRONLY or O_RDWR)) = O_WRONLY then  
  begin
   AccessMode:=GENERIC_WRITE;
  end
 else if (flags and (O_RDONLY or O_WRONLY or O_RDWR)) = O_RDWR then   
  begin
   AccessMode:=GENERIC_READ or GENERIC_WRITE;
  end
 else
  begin
   {Return Error}
   ptr^._errno:=EINVAL;
   Exit;
  end;
  
 {Get Share Mode}
 ShareMode:=FILE_SHARE_READ or FILE_SHARE_WRITE;
 
 {Get Create Flags} 
 if (flags and (O_CREAT or O_EXCL)) = (O_CREAT or O_EXCL) then
  begin
   CreateFlags:=CREATE_NEW;
   
   {Check File}
   if FSFileExists(FileName) or FSDirectoryExists(FileName) then
    begin
     {Return Error}
     ptr^._errno:=EEXIST;
     Exit;
    end;
  end
 else if (flags and O_CREAT) = O_CREAT then  
  begin
   CreateFlags:=OPEN_ALWAYS;
  end
 else
  begin
   CreateFlags:=OPEN_EXISTING;

   {Check File}
   if not FSFileExists(FileName) then
    begin
     {Return Error}
     ptr^._errno:=ENOENT;
     Exit;
    end;
  end;
 
 {Create File}
 Handle:=FSCreateFile(FileName,AccessMode,ShareMode,CreateFlags,FILE_ATTRIBUTE_NORMAL);
 if Handle = INVALID_HANDLE_VALUE then
  begin
   {Return Error}
   ptr^._errno:=EINVAL;
   Exit;
  end;

 {Add Entry}  
 Entry:=SyscallsAddEntry(Handle);
 if Entry = nil then
  begin
   {Return Error}
   ptr^._errno:=ENOMEM;
   Exit;
  end;
  
 {Check Append}
 if (flags and O_APPEND) = O_APPEND then    
  begin
   FSFileSeekEx(Handle,0,FILE_END);
  end; 
 
 {Check Truncate}
 if (flags and O_TRUNC) = O_TRUNC then   
  begin
   FSFileSeekEx(Handle,0,FILE_BEGIN);
   FSFileTruncate(Handle);
  end;
 
 {Return Result}
 Result:=Entry^.Number;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _open_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _read_r(ptr: P_reent; fd: int; buf: Pointer; cnt: size_t): _ssize_t; cdecl;
{Read from a file}
{See: \newlib\libc\reent\readr.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Ch:Char;
 Next:PChar;
 Count:LongInt;
 EndChar:Boolean;
 Entry:PSyscallsEntry;
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _read_r (ptr=' + PtrToHex(ptr) + ' fd=' + IntToStr(fd) + ' buf=' + PtrToHex(buf) + ' cnt=' + IntToStr(cnt) + ')');
 {$ENDIF}
 
 {Check descriptor}
 if fd = STDIN_FILENO then
  begin
   {Stdin}
   Count:=0;
   EndChar:=False;
   Next:=PChar(buf);
   while (Count < cnt) and not(EndChar) do
    begin
     if TextIOReadChar(Ch,nil) then
      begin
       if Ch = #13 then EndChar:=True;
       
       Next^:=Ch;
       
       Inc(Next);
       Inc(Count);
       
       if EndChar and (Count < cnt) then
        begin
         Next^:=#10;
         
         Inc(Next);
         Inc(Count);
        end;
      end;
    end;
   
   Result:=Count;   
  end
 else
  begin
   {Normal file}
   Entry:=SyscallsGetEntry(fd);
   if Entry <> nil then
    begin
     {Read file}
     Result:=FSFileRead(Entry^.Handle,buf^,cnt);
    end
   else
    begin
     {Return Error}
     ptr^._errno:=EBADF;
    end;    
  end;
  
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _read_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _rename_r(ptr: P_reent; old: PChar; new: PChar): int; cdecl;
{Rename a file}
{See: \newlib\libc\reent\renamer.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
  OldName:String;
  NewName:String;
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _rename_r (ptr=' + PtrToHex(ptr) + ' old=' + StrPas(old) + ' new=' + StrPas(new) + ')');
 {$ENDIF}
 
 {Get Names}
 OldName:=StrPas(old);
 NewName:=StrPas(new);

 {Check Names}
 if (Length(OldName) = 0) or (Length(NewName) = 0) then
  begin
   {Return Error}
   ptr^._errno:=ENOENT;
   Exit;
  end;

 {Check File}
 if not FSFileExists(OldName) then
  begin
   {Return Error}
   ptr^._errno:=ENOENT;
   Exit;
  end;

 {Check File}
 if FSFileExists(NewName) then
  begin
   {Return Error}
   ptr^._errno:=EEXIST;
   Exit;
  end;

 {Rename File}
 if FSRenameFile(OldName,NewName) then
  begin
   {Return Result}
   Result:=0;
  end
 else
  begin
   {Return Error}
   ptr^._errno:=EINVAL;
  end;  
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _rename_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _sbrk_r(ptr: P_reent; incr: ptrdiff_t): Pointer; cdecl;
{Increase program data space}
{See: \newlib\libc\reent\sbrkr.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Value:Pointer;
begin
 {}
 Result:=Pointer(-1);
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _sbrk_r (ptr=' + PtrToHex(ptr) + ' incr=' + IntToStr(incr) + ')');
 {$ENDIF}
 
 {Check incr}
 if incr > 0 then
  begin
   {Increase Heap}
   Value:=SyscallsIncreaseHeap(incr);
  end
 else
  begin
   {Note: incr 0 can be used to determine the current heap end}
   Value:=SyscallsDecreaseHeap(-incr);
  end; 
  
 if Value <> nil then
  begin
   {Return Result}
   Result:=Value;
  end
 else
  begin
   {Return Error}
   ptr^._errno:=ENOMEM;
   Result:=Pointer(-1);
  end;  
  
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _sbrk_r (Result=' + PtrToHex(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _kill_r(ptr: P_reent; pid: int; sig: int): int; cdecl;
{Send a signal}
{See: \newlib\libc\reent\signalr.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _kill_r (ptr=' + PtrToHex(ptr) + ' pid=' + IntToStr(pid) + ' sig=' + IntToStr(sig) + ')');
 {$ENDIF}
 
 {Return Error}
 ptr^._errno:=EINVAL;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _kill_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _getpid_r(ptr: P_reent): int; cdecl;
{Process-ID; this is sometimes used to generate strings unlikely to conflict with other processes}
{See: \newlib\libc\reent\signalr.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _getpid_r (ptr=' + PtrToHex(ptr) + ')');
 {$ENDIF}
 
 {Get Current Thread}
 Result:=ThreadGetCurrent;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _getpid_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}
{$IFDEF SYSCALLS_LARGE64_FILES}
function _stat64_r(ptr: P_reent; name: PChar; stat: Pstat64): int; cdecl;
{Status of a file (by name)}
{See: \newlib\libc\reent\stat64r.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Handle:THandle;
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _stat64_r (ptr=' + PtrToHex(ptr) + ' name=' + StrPas(name) + ')');
 {$ENDIF}
 
 {Check stat}
 if stat = nil then Exit;
 
 {Open file}
 Handle:=FSCreateFile(name,GENERIC_READ,0,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL);
 if Handle = INVALID_HANDLE_VALUE then
  begin
   {Return Error}
   ptr^._errno:=ENOENT;
   Exit;
  end;
  
 {Get Stat}
 if SyscallsGetStat64(Handle,stat) then
  begin
   {Return Result}
   Result:=0;
  end
 else
  begin
   {Return Error}
   ptr^._errno:=EINVAL;
  end;  
 
 {Close File}
 FSFileClose(Handle);
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _stat64_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;
{$ENDIF}
{==============================================================================}

function _stat_r(ptr: P_reent; name: PChar; stat: Pstat): int; cdecl;
{Status of a file (by name)}
{See: \newlib\libc\reent\statr.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Handle:THandle;
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _stat_r (ptr=' + PtrToHex(ptr) + ' name=' + StrPas(name) + ')');
 {$ENDIF}
 
 {Check stat}
 if stat = nil then Exit;
 
 {Open file}
 Handle:=FSCreateFile(name,GENERIC_READ,0,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL);
 if Handle = INVALID_HANDLE_VALUE then
  begin
   {Return Error}
   ptr^._errno:=ENOENT;
   Exit;
  end;
  
 {Get Stat}
 if SyscallsGetStat(Handle,stat) then
  begin
   {Return Result}
   Result:=0;
  end
 else
  begin
   {Return Error}
   ptr^._errno:=EINVAL;
  end;  
 
 {Close File}
 FSFileClose(Handle);
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _stat_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _times_r(ptr: P_reent; tms: Ptms): clock_t; cdecl;
{Timing information for current process}
{See: \newlib\libc\reent\timesr.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 SysTime:Int64;
 CreateTime:Int64;
 ExitTime:Int64;
 KernelTime:Int64;
begin
 {}
 Result:=clock_t(-1);
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _times_r (ptr=' + PtrToHex(ptr) + ')');
 {$ENDIF}
 
 {Check tms}
 if tms = nil then Exit;
 
 {Get Thread Times}
 if ThreadGetTimes(ThreadGetCurrent,CreateTime,ExitTime,KernelTime) = ERROR_SUCCESS then
  begin
   {$IFDEF SYSCALLS_DEBUG}
   if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  CreateTime=' + IntToHex(CreateTime,16));
   if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  ExitTime=' + IntToHex(ExitTime,16));
   if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  KernelTime=' + IntToHex(KernelTime,16));
   {$ENDIF}
  
   {Return tms}
   tms^.tms_utime:=0;
   if TIME_TICKS_PER_SCHEDULER_INTERRUPT > 0 then
    SysTime:=(KernelTime - TIME_TICKS_TO_1899) div TIME_TICKS_PER_SCHEDULER_INTERRUPT {Avoid 32-bit overflow}
   else
    SysTime:=0;
   tms^.tms_stime:=SysTime;
   tms^.tms_cutime:=0;
   tms^.tms_cstime:=0;
   
   {$IFDEF SYSCALLS_DEBUG}
   if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  SysTime=' + IntToHex(SysTime,16));
   if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  tms_stime=' + IntToStr(tms^.tms_stime));
   {$ENDIF}
   
   {Return Result}
   Result:=GetTickCount64;
  end
 else
  begin
   {Return Error}
   ptr^._errno:=EINVAL;
  end;  
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _times_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _unlink_r(ptr: P_reent; name: PChar): int; cdecl;
{Remove a file’s directory entry}
{See: \newlib\libc\reent\unlinkr.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 FileName:String;
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _unlink_r (ptr=' + PtrToHex(ptr) + ' name=' + StrPas(name) + ')');
 {$ENDIF}
 
 {Get Name}
 FileName:=StrPas(name);

 {Check Name}
 if Length(FileName) = 0 then
  begin
   {Return Error}
   ptr^._errno:=ENOENT;
   Exit;
  end;

 {Check File}
 if not FSFileExists(FileName) then
  begin
   {Return Error}
   ptr^._errno:=ENOENT;
   Exit;
  end;

 {Delete File}
 if FSDeleteFile(FileName) then
  begin
   {Return Result}
   Result:=0;
  end
 else
  begin
   {Return Error}
   ptr^._errno:=EINVAL;
  end;  
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _unlink_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _write_r(ptr: P_reent; fd: int; buf: Pointer; cnt: size_t): _ssize_t; cdecl;
{Write to a file}
{See: \newlib\libc\reent\writer.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Entry:PSyscallsEntry;
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _write_r (ptr=' + PtrToHex(ptr) + ' fd=' + IntToStr(fd) + ' buf=' + PtrToHex(buf) + ' cnt=' + IntToStr(cnt) + ')');
 {$ENDIF}
 
 {Check descriptor}
 if fd = STDOUT_FILENO then
  begin
   {Stdout}
   Result:=TextIOWriteBuffer(PChar(buf),cnt,nil);
  end
 else if fd = STDERR_FILENO then
  begin
   {Stderr}
   Result:=TextIOWriteBuffer(PChar(buf),cnt,nil);
  end
 else
  begin
   {Normal file}
   Entry:=SyscallsGetEntry(fd);
   if Entry <> nil then
    begin
     {Write file}
     Result:=FSFileWrite(Entry^.Handle,buf^,cnt);
    end
   else
    begin
     {Return Error}
     ptr^._errno:=EBADF;
    end;    
  end;  
  
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _write_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}
{==============================================================================}
{Syscalls Functions (Stat)}
function mkdir(path: PChar; mode: mode_t): int; cdecl;
{Create a directory}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls mkdir (path=' + StrPas(path) + ' mode=' + IntToStr(mode) + ')');
 {$ENDIF}

 Result:=_mkdir_r(__getreent,path,mode);
end;

{==============================================================================}

function chmod(path: PChar; mode: mode_t): int; cdecl;
{Change mode of a file}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls chmod (path=' + StrPas(path) + ' mode=' + IntToStr(mode) + ')');
 {$ENDIF}

 Result:=0;
end;

{==============================================================================}
{==============================================================================}
{Syscalls Functions (Stdlib)}
function posix_memalign(memptr: PPointer; alignment, size: size_t): int; cdecl;
{Aligned memory allocation}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 mem:Pointer;
begin
 {}
 Result:=EINVAL;
 
 {Check memptr}
 if memptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls posix_memalign (alignment=' + IntToStr(alignment) + ' size=' + IntToStr(size) + ')');
 {$ENDIF}
 
 {Test whether the ALIGNMENT argument is valid}
 if ((alignment mod SizeOf(Pointer)) <> 0) or (alignment and (alignment - 1) <> 0) then Exit;
 
 Result:=ENOMEM;
 
 mem:=memalign(alignment,size);
 if mem = nil then Exit;
 
 memptr^:=mem;
 
 Result:=0;
end;

{==============================================================================}

function realpath(path, resolved_path: PChar): PChar; cdecl;
{Return the canonicalized absolute pathname}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Buffer:PChar;
 Fullpath:String;
begin
 {}
 Result:=nil;

 {Check path}
 if path = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
   Exit;
  end;
  
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls realpath (path=' + StrPas(path) + ' resolved_path=' + StrPas(resolved_path) + ')');
 {$ENDIF}

 {Get resolved path}
 Buffer:=resolved_path;
 if Buffer = nil then
  begin
   {Allocate buffer (Must use malloc)}
   Buffer:=malloc(PATH_MAX);
  end;

 {Check Buffer}
 if Buffer = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=ENOMEM;
   Exit;
  end;  
 
 {Get Full Path}
 Fullpath:=FSGetLongName(path);
 
 {Copy Full Path}
 StrLCopy(Buffer,PChar(Fullpath),PATH_MAX);
 
 {Return Result}
 Result:=Buffer;
end;
 
{==============================================================================}
{==============================================================================}
{Syscalls Functions (Unistd)}
function dup(oldfd: int): int; cdecl;
{Duplicate a file descriptor}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin 
 {}
 Result:=-1;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls dup (oldfd=' + IntToStr(oldfd) + ')');
 {$ENDIF}
 
 //To Do //Continuing //Add DuplicateHandle to FileSystem
         //http://man7.org/linux/man-pages/man2/dup.2.html
         
         //Also fcntl() F_DUPFD
end;

{==============================================================================}

function dup2(oldfd, newfd: int): int; cdecl;
{Duplicate a file descriptor}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin 
 {}
 Result:=-1;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls dup2 (oldfd=' + IntToStr(oldfd) + ' newfd=' + IntToStr(newfd) + ')');
 {$ENDIF}
 
 //To Do //Continuing //Add DuplicateHandle to FileSystem
         //http://man7.org/linux/man-pages/man2/dup.2.html
         
         //Also fcntl() F_DUPFD
end;

{==============================================================================}

function dup3(oldfd, newfd, flags: int): int; cdecl;
{Duplicate a file descriptor}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin 
 {}
 Result:=-1;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls dup3 (oldfd=' + IntToStr(oldfd) + ' newfd=' + IntToStr(newfd) + ' flags=' + IntToHex(flags,8) + ')');
 {$ENDIF}
 
 //To Do //Continuing //Add DuplicateHandle to FileSystem
         //http://man7.org/linux/man-pages/man2/dup.2.html
end;

{==============================================================================}

function sysconf(name: int):int; cdecl;
{Get configurable system variables}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls sysconf (name=' + IntToStr(name) + ')');
 {$ENDIF}
 
 {Check name}
 case name of
  _SC_CLK_TCK:begin
    {Clock ticks per second (Scheduler ticks)}
    Result:=SCHEDULER_INTERRUPTS_PER_SECOND;
   end;
  _SC_PAGESIZE:begin
    {Size of a page in bytes}
    Result:=MEMORY_PAGE_SIZE;
   end;
   
  //To Do //Implement any others that are required
  
 else
  begin
   {Return Error}
   Result:=-1;
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
  end; 
 end; 
end;

{==============================================================================}

function getpagesize: int; cdecl;
{Return the number of bytes in a memory page}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=sysconf(_SC_PAGESIZE); 

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls getpagesize (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function ssleep(seconds: uint): uint; cdecl;
{Sleep for a specified number of seconds}

{Note: Does not support interruption by signal}
{Note: Declared as ssleep to avoid conflict with Pascal Sleep() function}
{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=0;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls sleep (seconds=' + IntToStr(seconds) + ')');
 {$ENDIF}
 
 ThreadSleep(seconds * 1000);
end;

{==============================================================================}

function usleep(useconds: useconds_t): int; cdecl;
{Suspend execution for microsecond intervals}

{Note: Does not support interruption by signal}
{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Remain: PtrUInt;
begin
 {}
 Result:=0;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls usleep (useconds=' + IntToStr(useconds) + ')');
 {$ENDIF}
 
 Remain:=useconds;
 
 if useconds > 1000 then
  begin
   ThreadSleep(useconds div 1000);
   Remain:=useconds mod 1000;
  end;
 
 if Remain > 0 then
  begin
   MicrosecondDelay(Remain);
  end;
end;

{==============================================================================}

function symlink(path1, path2: PChar): int; cdecl;
{Make a symbolic link to a file}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls symlink (path1=' + StrPas(path1) + ' path2=' + StrPas(path2) + ')');
 {$ENDIF}

 Result:=_link_r(__getreent,path1,path2);
end;

{==============================================================================}

function ftruncate(fd: int; length: off_t): int; cdecl;
{Truncate a file to a specified length}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Entry:PSyscallsEntry;
begin
 {}
 Result:=-1;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls ftruncate (fd=' + IntToStr(fd) + ' length=' + IntToStr(length) + ')');
 {$ENDIF}
 
 {Check Length}
 if length < 0 then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
   Exit;
  end;
  
 {Check descriptor}
 if (fd = STDIN_FILENO) or (fd = STDOUT_FILENO) or (fd = STDERR_FILENO) then
  begin
   {Stdin, Stdout, Stderr}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EBADF;
   Exit;
  end
 else
  begin
   {Normal file}
   Entry:=SyscallsGetEntry(fd);
   if Entry <> nil then
    begin
     {Truncate}
     FSFileSeekEx(Entry^.Handle,length,FILE_BEGIN);
     if not FSFileTruncate(Entry^.Handle) then
      begin
       {Return Error}
       ptr:=__getreent;
       if ptr <> nil then ptr^._errno:=EIO;
       Exit;
      end;
     
     {Return Result}
     Result:=0;
    end
   else
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EBADF;
    end;    
  end;  
end;

{==============================================================================}

function truncate(path: PChar; length: off_t): int; cdecl;
{Truncate a file to a specified length}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Handle:THandle;
begin
 {}
 Result:=-1;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls truncate (path=' + StrPas(path) + ' length=' + IntToStr(length) + ')');
 {$ENDIF}
 
 {Check Length}
 if length < 0 then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
   Exit;
  end;
 
 {Open file}
 Handle:=FSCreateFile(path,GENERIC_READ or GENERIC_WRITE,0,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL);
 if Handle = INVALID_HANDLE_VALUE then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=ENOENT;
   Exit;
  end;
 
 {Truncate}
 FSFileSeekEx(Handle,length,FILE_BEGIN);
 if FSFileTruncate(Handle) then
  begin
   {Return Result}
   Result:=0;
  end
 else
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EIO;
   Exit;
  end;
 
 {Close File}
 FSFileClose(Handle);
end;

{==============================================================================}

function fsync(fd: int): int; cdecl;
{Synchronize a file's state with storage}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Entry:PSyscallsEntry;
begin 
 {}
 Result:=-1;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls fsync (fd=' + IntToStr(fd) + ')');
 {$ENDIF}

 {Check descriptor}
 if (fd = STDIN_FILENO) or (fd = STDOUT_FILENO) or (fd = STDERR_FILENO) then
  begin
   {Stdin, Stdout, Stderr}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
   Exit;
  end
 else
  begin
   {Normal file}
   Entry:=SyscallsGetEntry(fd);
   if Entry <> nil then
    begin
     {Flush}
     if not FSFileFlush(Entry^.Handle) then
      begin
       {Return Error}
       ptr:=__getreent;
       if ptr <> nil then ptr^._errno:=EIO;
       Exit;
      end;
     
     {Return Result}
     Result:=0;
    end
   else
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EBADF;
    end;    
  end;  
end; 

{==============================================================================}

function fdatasync(fd: int): int; cdecl;
{Synchronize a file's state with storage}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Entry:PSyscallsEntry;
begin 
 {}
 Result:=-1;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls fdatasync (fd=' + IntToStr(fd) + ')');
 {$ENDIF}

 {Check descriptor}
 if (fd = STDIN_FILENO) or (fd = STDOUT_FILENO) or (fd = STDERR_FILENO) then
  begin
   {Stdin, Stdout, Stderr}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
   Exit;
  end
 else
  begin
   {Normal file}
   Entry:=SyscallsGetEntry(fd);
   if Entry <> nil then
    begin
     {Flush}
     if not FSFileFlush(Entry^.Handle) then
      begin
       {Return Error}
       ptr:=__getreent;
       if ptr <> nil then ptr^._errno:=EIO;
       Exit;
      end;
     
     {Return Result}
     Result:=0;
    end
   else
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EBADF;
    end;    
  end;  
end; 

{==============================================================================}
{==============================================================================}
{Syscalls Functions (Mman)}
function mmap(addr: Pointer; length: size_t; prot, flags, fd: int; offset: off_t): Pointer; cdecl;
{Map files or devices into memory}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls mmap (addr=' + PtrToHex(addr) + ' length=' + IntToStr(length) + ')');
 {$ENDIF}
 
 {Return Error}
 Result:=Pointer(-1); {MAP_FAILED}
 ptr:=__getreent;
 if ptr <> nil then ptr^._errno:=EINVAL;
end;

{==============================================================================}

function munmap(addr: Pointer; length: size_t): int; cdecl;
{Unmap files or devices into memory}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls munmap (addr=' + PtrToHex(addr) + ' length=' + IntToStr(length) + ')');
 {$ENDIF}
 
 {Return Error}
 Result:=-1;
 ptr:=__getreent;
 if ptr <> nil then ptr^._errno:=EINVAL;
end;

{==============================================================================}
{==============================================================================}
{Syscalls Functions (Time)}
function settimeofday(tv: Ptimeval; tz: Pointer): int; cdecl;
{Set the date and time}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 ClockTime:Int64;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls settimeofday (tv=' + PtrToHex(tv) + ' tz=' + PtrToHex(tz) + ')');
 {$ENDIF}

 {Check tv}
 if tv = nil then
  begin
   {Return Error}
   Result:=-1;
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EFAULT;
  end
 else
  begin
   {Convert timeval}
   ClockTime:=TIME_TICKS_TO_1970 + (tv^.tv_sec * TIME_TICKS_PER_SECOND) + (tv^.tv_usec * TIME_TICKS_PER_MICROSECOND);
   
   {Set time}
   ClockSetTime(ClockTime,True);
   
   {Return Result}
   Result:=0;
  end;  
end;

{==============================================================================}

function clock_getres(clk_id: clockid_t; res: Ptimespec): int; cdecl;
{Return the resolution of the requested clock}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 {Check res}
 {if res = nil then Exit;} {May be nil}
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls clock_getres (clk_id=' + IntToStr(clk_id) + ')');
 {$ENDIF}
 
 {Check Clock}
 case clk_id of
  CLOCK_REALTIME:begin
    if res <> nil then
     begin
      res^.tv_sec:=0;
      res^.tv_nsec:=100; {Ultibo time is in 100ns intervals}
     end;
     
    Result:=0;
   end;
  CLOCK_MONOTONIC,CLOCK_PROCESS_CPUTIME_ID,CLOCK_THREAD_CPUTIME_ID:begin
    if res <> nil then
     begin
      res^.tv_sec:=0;
      if CLOCK_CYCLES_PER_NANOSECOND > 0 then
       begin
        res^.tv_nsec:=1; 
       end
      else if CLOCK_CYCLES_PER_MICROSECOND > 0 then
       begin
        res^.tv_nsec:=1000; 
       end
      else if CLOCK_CYCLES_PER_MILLISECOND > 0 then       
       begin
        res^.tv_nsec:=1000000; 
       end
      else
       begin
        res^.tv_sec:=1;
        res^.tv_nsec:=0;
       end;       
     end;
  
    Result:=0;
   end; 
  else
   begin
    {Return Error}
    Result:=-1;
    ptr:=__getreent;
    if ptr <> nil then ptr^._errno:=EINVAL;
   end;   
 end;
end;

{==============================================================================}

function clock_gettime(clk_id: clockid_t; tp: Ptimespec): int; cdecl;
{Get the time from the requested clock}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Value:Int64;
begin
 {}
 {Check tp}
 if tp = nil then
  begin
   {Return Error}
   Result:=-1;
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EFAULT;
   
   Exit;
  end; 
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls clock_gettime (clk_id=' + IntToStr(clk_id) + ')');
 {$ENDIF}
 
 {Check Clock}
 case clk_id of
  CLOCK_REALTIME:begin
    {Get Time}
    Value:=ClockGetTime;
    if Value <  TIME_TICKS_TO_1970 then
     begin
      tp^.tv_sec:=0;
      tp^.tv_nsec:=0;
     end
    else
     begin
      {Convert to timespec}
      Value:=Value - TIME_TICKS_TO_1970;
      
      tp^.tv_sec:=Value div TIME_TICKS_PER_SECOND;
      tp^.tv_nsec:=(Value mod TIME_TICKS_PER_SECOND) * 100;
     end; 
    
    {$IFDEF SYSCALLS_DEBUG}
    if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls clock_gettime (tv_sec=' + IntToStr(tp^.tv_sec) + ' tv_nsec=' + IntToStr(tp^.tv_nsec) + ')');
    {$ENDIF}
    
    Result:=0;
   end;
  CLOCK_MONOTONIC,CLOCK_PROCESS_CPUTIME_ID,CLOCK_THREAD_CPUTIME_ID:begin
    if CLOCK_FREQUENCY = 0 then
     begin
      tp^.tv_sec:=0;
      tp^.tv_nsec:=0;
     end
    else
     begin    
      Value:=ClockGetTotal;
      
      tp^.tv_sec:=Value div CLOCK_FREQUENCY;
      if CLOCK_CYCLES_PER_NANOSECOND > 0 then
       begin
        tp^.tv_nsec:=(Value mod CLOCK_FREQUENCY) div CLOCK_CYCLES_PER_NANOSECOND;
       end
      else if CLOCK_CYCLES_PER_MICROSECOND > 0 then
       begin
        tp^.tv_nsec:=((Value mod CLOCK_FREQUENCY) div CLOCK_CYCLES_PER_MICROSECOND) * 1000;
       end
      else if CLOCK_CYCLES_PER_MILLISECOND > 0 then       
       begin
        tp^.tv_nsec:=((Value mod CLOCK_FREQUENCY) div CLOCK_CYCLES_PER_MILLISECOND) * 1000000;
       end;
     end;
     
    {$IFDEF SYSCALLS_DEBUG}
    if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls clock_gettime (tv_sec=' + IntToStr(tp^.tv_sec) + ' tv_nsec=' + IntToStr(tp^.tv_nsec) + ')');
    {$ENDIF}
     
    Result:=0;
   end;
  else
   begin
    {Return Error}
    Result:=-1;
    ptr:=__getreent;
    if ptr <> nil then ptr^._errno:=EINVAL;
   end;   
 end;
end;

{==============================================================================}

function clock_settime(clk_id: clockid_t; tp: Ptimespec): int; cdecl;
{Set the time of the requested clock}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Value:Int64;
begin
 {}
 {Check tp}
 if tp = nil then
  begin
   {Return Error}
   Result:=-1;
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EFAULT;
   
   Exit;
  end; 
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls clock_settime (clk_id=' + IntToStr(clk_id) + ' tv_sec=' + IntToStr(tp^.tv_sec) + ' tv_nsec=' + IntToStr(tp^.tv_nsec) + ')');
 {$ENDIF}
 
 {Check Clock}
 case clk_id of
  CLOCK_REALTIME:begin
    {Convert timespec}
    Value:=TIME_TICKS_TO_1970 + (tp^.tv_sec * TIME_TICKS_PER_SECOND) + (tp^.tv_nsec div 100);
    
    {Set Time}
    ClockSetTime(Value,True);
    
    Result:=0;
   end;
  else
   begin
    {Return Error}
    Result:=-1;
    ptr:=__getreent;
    if ptr <> nil then ptr^._errno:=EINVAL;
   end;   
 end;
end;

{==============================================================================}

function nanosleep(req, rem: Ptimespec): int; cdecl;
{High-resolution sleep}

{Note: Does not support interruption by signal}
{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=0;
 
 {Check req}
 if req = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls nanosleep (tv_sec=' + IntToStr(req^.tv_sec) + ' tv_nsec=' + IntToStr(req^.tv_nsec) + ')');
 {$ENDIF}
 
 ThreadSleep((req^.tv_sec * 1000) + (req^.tv_nsec div 1000000));

 {Check rem} 
 if rem <> nil then 
  begin
   rem^.tv_sec:=0;
   rem^.tv_nsec:=0;
  end;
end;

{==============================================================================}
{==============================================================================}
{Syscalls Functions (Statfs)}
function statfs(path: PChar; buf: Pstatfs): int; cdecl;
{Get filesystem statistics}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 Result:=-1;
 
 ptr:=__getreent;
 if ptr <> nil then ptr^._errno:=ENOSYS;
 
 {Not yet implemented}
end;

{==============================================================================}

function fstatfs(fd: int; buf: Pstatfs): int; cdecl;
{Get filesystem statistics}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 Result:=-1;
 
 ptr:=__getreent;
 if ptr <> nil then ptr^._errno:=ENOSYS;
 
 {Not yet implemented}
end;

{==============================================================================}

function statfs64(path: PChar; buf: Pstatfs64): int; cdecl;
{Get filesystem statistics}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 Result:=-1;
 
 ptr:=__getreent;
 if ptr <> nil then ptr^._errno:=ENOSYS;
 
 {Not yet implemented}
end;

{==============================================================================}

function fstatfs64(fd: int; buf: Pstatfs64): int; cdecl;
{Get filesystem statistics}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 Result:=-1;
 
 ptr:=__getreent;
 if ptr <> nil then ptr^._errno:=ENOSYS;
 
 {Not yet implemented}
end;

{==============================================================================}
{==============================================================================}
{Syscalls Functions (Statvfs)}
function statvfs(path: PChar; buf: Pstatvfs): int; cdecl;
{Get file system information}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 Result:=-1;
 
 ptr:=__getreent;
 if ptr <> nil then ptr^._errno:=ENOSYS;
 
 {Not yet implemented}
end;

{==============================================================================}

function fstatvfs(fd: int; buf: Pstatvfs): int; cdecl;
{Get file system information}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 Result:=-1;
 
 ptr:=__getreent;
 if ptr <> nil then ptr^._errno:=ENOSYS;
 
 {Not yet implemented}
end;

{==============================================================================}
{==============================================================================}
{Syscalls Functions (Sched)}
function sched_get_priority_max(policy: int): int; cdecl;
{Get scheduler priority range maximum}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls sched_get_priority_max (policy=' + IntToHex(policy,8) + ')');
 {$ENDIF}
 
 {Check policy}
 if (policy < SCHED_OTHER) or (policy > SCHED_RR) then
  begin
   {Return Error}
   Result:=-1;
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
   Exit;
  end; 
 
 Result:=THREAD_PRIORITY_CRITICAL;
end;

{==============================================================================}

function sched_get_priority_min(policy: int): int; cdecl;
{Get scheduler priority range minimum}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls sched_get_priority_min (policy=' + IntToHex(policy,8) + ')');
 {$ENDIF}
 
 {Check policy}
 if (policy < SCHED_OTHER) or (policy > SCHED_RR) then
  begin
   {Return Error}
   Result:=-1;
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
   Exit;
  end; 
 
 Result:=THREAD_PRIORITY_IDLE;
end;

{==============================================================================}
{==============================================================================}
{Syscalls Functions (Dirent)}
function opendir(name: PChar): PDIR; cdecl;
{Open a directory}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Path:String;
 Buffer:PDIR;
 NameBuffer:PChar;
 SearchRec:PFileSearchRec;
begin
 {}
 Result:=nil;
 
 {Check name}
 if name = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
   Exit;
  end;
  
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls opendir (name=' + StrPas(name) + ')');
 {$ENDIF}
 
 {Get name}
 Path:=StrPas(name);

 {Check Path} 
 if Length(Path) = 0 then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=ENOENT;
   Exit;
  end;
 if FSFileExists(Path) then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=ENOTDIR;
   Exit;
  end;
 if not FSDirectoryExists(Path) then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=ENOENT;
   Exit;
  end;
 
 {Allocate Buffer}
 Buffer:=AllocMem(SizeOf(DIR) + SizeOf(Tdirent){$IFDEF SYSCALLS_LARGE64_FILES} + SizeOf(Tdirent64){$ENDIF} + ((Length(Path) + 1) * SizeOf(Char)));
 if Buffer = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=ENOMEM;
   Exit;
  end;
 
 {Allocate Search Record} 
 SearchRec:=AllocMem(SizeOf(TFileSearchRec));
 if SearchRec = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=ENOMEM;
   Exit;
  end;
  
 {Save Path}
 NameBuffer:=PChar(PtrUInt(Buffer) + SizeOf(DIR) + SizeOf(Tdirent){$IFDEF SYSCALLS_LARGE64_FILES} + SizeOf(Tdirent64){$ENDIF});
 StrLCopy(NameBuffer,PChar(Path),Length(Path));
 
 {Check Path}
 if Path[Length(Path)] <> '\' then 
  begin
   Path:=Path + '\'; //To Do //Add a new FSAddSlash function to provide the correct delimiter
  end;
  
 {Find First File} 
 if FSFindFirstEx(Path + '*.*',SearchRec^) <> 0 then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=ENOENT;
   
   {Close Find}
   FSFindCloseEx(SearchRec^);
   
   {Free Search Record}
   FreeMem(SearchRec);
   
   {Free Buffer}
   FreeMem(Buffer);
   Exit;
  end;
 
 {Update Buffer}
 Buffer^.dd_loc:=-1;
 Buffer^.dd_buf:=PByte(SearchRec);
 
 {Return Buffer}
 Result:=Buffer;
end;

{==============================================================================}

function readdir(dirp: PDIR): Pdirent; cdecl;
{Read a directory}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 dirent:Pdirent;
 SearchRec:PFileSearchRec;
begin
 {}
 Result:=nil;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls readdir (dirp=' + PtrToHex(dirp) + ')');
 {$ENDIF}

 {Check dirp}
 if dirp = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EBADF;
   Exit;
  end;
 
 {Get Search Record}
 SearchRec:=PFileSearchRec(dirp^.dd_buf);
 if SearchRec = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EBADF;
   Exit;
  end;
 
 {Check Location}
 if dirp^.dd_loc = -1 then
  begin
   {Get First File}
   dirp^.dd_loc:=0;
  end
 else 
  begin
   {Find Next File}
   if FSFindNextEx(SearchRec^) <> 0 then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=ENOENT;
     Exit;
    end;
   
   Inc(dirp^.dd_loc);
  end; 
  
 {Update dirent} 
 dirent:=Pdirent(PtrUInt(dirp) + SizeOf(DIR));
 dirent^.d_ino:=1;
 dirent^.d_off:=dirp^.dd_loc;
 dirent^.d_reclen:=SizeOf(Tdirent);
 if (SearchRec^.FindData.dwFileAttributes and faDirectory) = faDirectory then
  begin
   dirent^.d_type:=DT_DIR;
  end
 else
  begin
   dirent^.d_type:=DT_REG;
  end;
 StrLCopy(dirent^.d_name,SearchRec^.FindData.cFileName,NAME_MAX);
 
 {Return dirent}
 Result:=dirent;
end;

{==============================================================================}

function readdir_r(dirp: PDIR; entry: Pdirent; _result: PPdirent): int; cdecl;
{Read a directory}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 SearchRec:PFileSearchRec;
begin
 {}
 Result:=EBADF;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls readdir_r (dirp=' + PtrToHex(dirp) + ' entry=' + PtrToHex(entry) + ' _result=' + PtrToHex(_result) + ')');
 {$ENDIF}
 
 {Check dirp}
 if dirp = nil then Exit;
 
 {Check entry}
 if entry = nil then Exit;

 {Check _result}  
 if _result = nil then Exit;
 
 {Clear _result}
 _result^:=nil;
 
 {Get Search Record}
 SearchRec:=PFileSearchRec(dirp^.dd_buf);
 if SearchRec = nil then Exit;
 
 {Check Location}
 if dirp^.dd_loc = -1 then
  begin
   {Get First File}
   dirp^.dd_loc:=0;
  end
 else 
  begin
   {Find Next File}
   if FSFindNextEx(SearchRec^) <> 0 then
    begin
     {Return Error}
     Result:=ENOENT;
     Exit;
    end;
   
   Inc(dirp^.dd_loc);
  end; 
  
 {Update entry} 
 entry^.d_ino:=1;
 entry^.d_off:=dirp^.dd_loc;
 entry^.d_reclen:=SizeOf(Tdirent);
 if (SearchRec^.FindData.dwFileAttributes and faDirectory) = faDirectory then
  begin
   entry^.d_type:=DT_DIR;
  end
 else
  begin
   entry^.d_type:=DT_REG;
  end;
 StrLCopy(entry^.d_name,SearchRec^.FindData.cFileName,NAME_MAX);
 
 {Update _result}
 _result^:=@entry;
 
 {Return success}
 Result:=0;
end;

{==============================================================================}

function closedir(dirp: PDIR): int; cdecl;
{Close a directory}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 SearchRec:PFileSearchRec;
begin
 {}
 Result:=-1;
  
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls closedir (dirp=' + PtrToHex(dirp) + ')');
 {$ENDIF}
 
 {Check dirp}
 if dirp = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EBADF;
   Exit;
  end;
 
 {Get Search Record}
 SearchRec:=PFileSearchRec(dirp^.dd_buf);
 if SearchRec = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EBADF;
   Exit;
  end;
 
 {Close Find}
 FSFindCloseEx(SearchRec^);
 
 {Free Search Record}
 FreeMem(SearchRec);
 
 {Free Buffer}
 FreeMem(dirp);
 
 {Return success}
 Result:=0;
end;

{==============================================================================}
{$IFDEF SYSCALLS_LARGE64_FILES}  
function readdir64(dirp: PDIR): Pdirent64; cdecl;
{Read a directory}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 dirent:Pdirent64;
 SearchRec:PFileSearchRec;
begin
 {}
 Result:=nil;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls readdir64 (dirp=' + PtrToHex(dirp) + ')');
 {$ENDIF}
 
 {Check dirp}
 if dirp = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EBADF;
   Exit;
  end;
  
 {Get Search Record}
 SearchRec:=PFileSearchRec(dirp^.dd_buf);
 if SearchRec = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EBADF;
   Exit;
  end;
 
 {Check Location}
 if dirp^.dd_loc = -1 then
  begin
   {Get First File}
   dirp^.dd_loc:=0;
  end
 else 
  begin
   {Find Next File}
   if FSFindNextEx(SearchRec^) <> 0 then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=ENOENT;
     Exit;
    end;
   
   Inc(dirp^.dd_loc);
  end; 
  
 {Update dirent} 
 dirent:=Pdirent64(PtrUInt(dirp) + SizeOf(DIR) + SizeOf(Tdirent));
 dirent^.d_ino:=1;
 dirent^.d_off:=dirp^.dd_loc;
 dirent^.d_reclen:=SizeOf(Tdirent64);
 if (SearchRec^.FindData.dwFileAttributes and faDirectory) = faDirectory then
  begin
   dirent^.d_type:=DT_DIR;
  end
 else
  begin
   dirent^.d_type:=DT_REG;
  end;
 StrLCopy(dirent^.d_name,SearchRec^.FindData.cFileName,NAME_MAX);
 
 {Return dirent}
 Result:=dirent;
end;

{==============================================================================}

function readdir64_r(dirp: PDIR; entry: Pdirent64; _result: PPdirent64): int; cdecl;
{Read a directory}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 SearchRec:PFileSearchRec;
begin
 {}
 Result:=EBADF;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls readdir64_r (dirp=' + PtrToHex(dirp) + ' entry=' + PtrToHex(entry) + ' _result=' + PtrToHex(_result) + ')');
 {$ENDIF}

 {Check dirp}
 if dirp = nil then Exit;
 
 {Check entry}
 if entry = nil then Exit;

 {Check _result}  
 if _result = nil then Exit;
 
 {Clear _result}
 _result^:=nil;
 
 {Get Search Record}
 SearchRec:=PFileSearchRec(dirp^.dd_buf);
 if SearchRec = nil then Exit;
 
 {Check Location}
 if dirp^.dd_loc = -1 then
  begin
   {Get First File}
   dirp^.dd_loc:=0;
  end
 else 
  begin
   {Find Next File}
   if FSFindNextEx(SearchRec^) <> 0 then
    begin
     {Return Error}
     Result:=ENOENT;
     Exit;
    end;
   
   Inc(dirp^.dd_loc);
  end;

 {Update entry} 
 entry^.d_ino:=1;
 entry^.d_off:=dirp^.dd_loc;
 entry^.d_reclen:=SizeOf(Tdirent64);
 if (SearchRec^.FindData.dwFileAttributes and faDirectory) = faDirectory then
  begin
   entry^.d_type:=DT_DIR;
  end
 else
  begin
   entry^.d_type:=DT_REG;
  end;
 StrLCopy(entry^.d_name,SearchRec^.FindData.cFileName,NAME_MAX);
 
 {Update _result}
 _result^:=@entry;
 
 {Return success}
 Result:=0;
end;
{$ENDIF}
{==============================================================================}

procedure seekdir(dirp: PDIR; loc: long); cdecl;
{Set the position of the next readdir call in the directory stream}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Path:String;
 NameBuffer:PChar;
 SearchRec:PFileSearchRec;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls seekdir (dirp=' + PtrToHex(dirp) + ')');
 {$ENDIF}
 
 {Check dirp}
 if dirp = nil then Exit;
 
 {Get Search Record}
 SearchRec:=PFileSearchRec(dirp^.dd_buf);
 if SearchRec = nil then Exit;
 
 {Close Find}
 FSFindCloseEx(SearchRec^);
 
 {Reset Buffer}
 dirp^.dd_loc:=-1;
 
 {Get Path}
 NameBuffer:=PChar(PtrUInt(dirp) + SizeOf(DIR) + SizeOf(Tdirent){$IFDEF SYSCALLS_LARGE64_FILES} + SizeOf(Tdirent64){$ENDIF});
 Path:=StrPas(NameBuffer);
 
 {Check Path}
 if Path[Length(Path)] <> '\' then 
  begin
   Path:=Path + '\'; //To Do //Add a new FSAddSlash function to provide the correct delimiter
  end;
  
 {Find First File} 
 if FSFindFirstEx(Path + '*.*',SearchRec^) <> 0 then Exit;

 {Find location}
 while dirp^.dd_loc + 1 < loc do
  begin
   if FSFindNextEx(SearchRec^) <> 0 then Exit;
    
   Inc(dirp^.dd_loc);
  end;
end;

{==============================================================================}

procedure rewinddir(dirp: PDIR); cdecl;
{Reset directory stream}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin 
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls rewinddir (dirp=' + PtrToHex(dirp) + ')');
 {$ENDIF}
 
 {Seek to location zero}
 seekdir(dirp,0);
end;

{==============================================================================}

function telldir(dirp: PDIR): long; cdecl;
{Return current location in directory stream}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 Result:=-1;
  
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls telldir (dirp=' + PtrToHex(dirp) + ')');
 {$ENDIF}
 
 {Check dirp}
 if dirp = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EBADF;
   Exit;
  end;
 
 {Get location}
 if dirp^.dd_loc = -1 then
  begin
   Result:=0;
  end
 else
  begin
   Result:=dirp^.dd_loc;
  end;  
end;

{==============================================================================}
{==============================================================================}
{Syscalls Functions (Pthread)}
function pthread_attr_init(attr: Ppthread_attr_t): int; cdecl;
{Initialize a thread attributes entry}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check attr}
 if attr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_attr_init (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}
 
 {Init attr}
 attr^.is_initialized:=1;
 attr^.stackaddr:=nil;
 attr^.stacksize:=THREAD_STACK_DEFAULT_SIZE;
 attr^.contentionscope:=PTHREAD_SCOPE_SYSTEM;
 attr^.inheritsched:=PTHREAD_EXPLICIT_SCHED;
 attr^.schedpolicy:=SCHED_OTHER;
 attr^.schedparam.sched_priority:=THREAD_PRIORITY_DEFAULT;
 {$IFDEF _POSIX_THREAD_GUARDSIZE}
 attr^.guardsize:=MEMORY_PAGE_SIZE;
 {$ENDIF}
 {$IFDEF _POSIX_THREAD_CPUTIME}
 attr^.cputime_clock_allowed:=0;
 {$ENDIF}
 attr^.detachstate:=PTHREAD_CREATE_JOINABLE;
 
 Result:=0;
end;

{==============================================================================}

function pthread_attr_destroy(attr: Ppthread_attr_t): int; cdecl;
{Destroy a thread attributes entry}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check attr}
 if attr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_attr_destroy (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}
 
 {Destroy attr}
 attr^.is_initialized:=0;
 
 Result:=0;
end;

{==============================================================================}

function pthread_attr_getdetachstate(attr: Ppthread_attr_t; detachstate: Pint): int; cdecl;
{Get the detachstate attribute}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check attr}
 if attr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_attr_getdetachstate (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}
 
 {Check detachstate}
 if detachstate = nil then Exit;
 
 {Get detachstate}
 detachstate^:=attr^.detachstate;
 
 Result:=0;
end;
 
{==============================================================================}

function pthread_attr_setdetachstate(attr: Ppthread_attr_t; detachstate: int): int; cdecl;
{Set the detachstate attribute}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check attr}
 if attr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_attr_setdetachstate (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}
 
 {Check detachstate}
 if (detachstate < PTHREAD_CREATE_JOINABLE) or (detachstate > PTHREAD_CREATE_DETACHED) then Exit;

 {Set detachstate}
 attr^.detachstate:=detachstate;
 
 Result:=0;
end;

{==============================================================================}

function pthread_attr_getguardsize(attr: Ppthread_attr_t; guardsize: Psize_t): int; cdecl;
{Get the guardsize attribute}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check attr}
 if attr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_attr_getguardsize (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}
 
 {$IFDEF _POSIX_THREAD_GUARDSIZE}
 {Check guardsize}
 if guardsize = nil then Exit;
 
 {Get guardsize}
 guardsize^:=attr^.guardsize;
 
 Result:=0;
 {$ELSE}
 {Not supported}
 Result:=ENOSYS;
 {$ENDIF}
end;

{==============================================================================}

function pthread_attr_setguardsize(attr: Ppthread_attr_t; guardsize: size_t): int; cdecl; 
{Set the guardsize attribute}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check attr}
 if attr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_attr_setguardsize (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}
 
 {$IFDEF _POSIX_THREAD_GUARDSIZE}
 {Check guardsize}
 if (guardsize > attr^.stacksize) then Exit;

 {Set guardsize}
 attr^.guardsize:=guardsize;
 
 Result:=0;
 {$ELSE}
 {Not supported}
 Result:=ENOSYS;
 {$ENDIF}
end;

{==============================================================================}

function pthread_attr_getinheritsched(attr: Ppthread_attr_t; inheritsched: Pint): int; cdecl;
{Get the inheritsched attribute}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check attr}
 if attr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_attr_getinheritsched (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}

 {Check inheritsched}
 if inheritsched = nil then Exit;
 
 {Get inheritsched}
 inheritsched^:=attr^.inheritsched;
 
 Result:=0;
end;

{==============================================================================}

function pthread_attr_setinheritsched(attr: Ppthread_attr_t; inheritsched: int): int; cdecl;
{Set the inheritsched attribute}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check attr}
 if attr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_attr_setinheritsched (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}
 
 {Check inheritsched}
 if (inheritsched <> PTHREAD_INHERIT_SCHED) and (inheritsched <> PTHREAD_EXPLICIT_SCHED) then Exit;

 {Set inheritsched}
 attr^.inheritsched:=inheritsched;
 
 Result:=0;
end;

{==============================================================================}

function pthread_attr_getschedparam(attr: Ppthread_attr_t; param: Psched_param): int; cdecl; 
{Get the scheduler param attribute}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check attr}
 if attr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_attr_getschedparam (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}
 
 {Check param}
 if param = nil then Exit;
 
 {Get param}
 System.Move(attr^.schedparam,param^,SizeOf(Tsched_param));
 
 Result:=0;
end;

{==============================================================================}

function pthread_attr_setschedparam(attr: Ppthread_attr_t; param: Psched_param): int; cdecl; 
{Set the scheduler param attribute}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 MaxPriority:int;
 MinPriority:int;
begin
 {}
 Result:=EINVAL;
 
 {Check attr}
 if attr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_attr_setschedparam (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}
 
 {Check param}
 if param = nil then Exit;
 
 {Get Min/Max}
 MaxPriority:=sched_get_priority_max(attr^.schedpolicy);
 MinPriority:=sched_get_priority_min(attr^.schedpolicy);
 
 {Check Priority}
 if (param^.sched_priority < MinPriority) or (param^.sched_priority > MaxPriority) then Exit;
 
 {Set param}
 System.Move(param^,attr^.schedparam,SizeOf(Tsched_param));
 
 Result:=0;
end;

{==============================================================================}

function pthread_attr_getschedpolicy(attr: Ppthread_attr_t; policy: Pint): int; cdecl;
{Get the scheduler policy attribute}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check attr}
 if attr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_attr_getschedpolicy (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}
 
 {Check policy}
 if policy = nil then Exit;
 
 {Get policy}
 policy^:=attr^.schedpolicy;
 
 Result:=0;
end;

{==============================================================================}

function pthread_attr_setschedpolicy(attr: Ppthread_attr_t; policy: int): int; cdecl;
{Set the scheduler policy attribute}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check attr}
 if attr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_attr_setschedpolicy (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}
 
 {Check policy}
 if (policy < SCHED_OTHER) or (policy > SCHED_RR) then Exit;

 {Set policy}
 attr^.schedpolicy:=policy;
 
 Result:=0;
end;

{==============================================================================}

function pthread_attr_getscope(attr: Ppthread_attr_t; contentionscope: Pint): int; cdecl;
{Get the contentionscope attribute}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check attr}
 if attr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_attr_getscope (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}
 
 {Check contentionscope}
 if contentionscope = nil then Exit;
 
 {Get contentionscope}
 contentionscope^:=attr^.contentionscope;
 
 Result:=0;
end;

{==============================================================================}

function pthread_attr_setscope(attr: Ppthread_attr_t; contentionscope: int): int; cdecl;
{Set the contentionscope attribute}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check attr}
 if attr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_attr_setscope (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}

 {Check contentionscope}
 case contentionscope of  
  PTHREAD_SCOPE_SYSTEM:begin
    {Set contentionscope}
    attr^.contentionscope:=contentionscope;
  
    Result:=0;
   end;
  PTHREAD_SCOPE_PROCESS:begin
    Result:=ENOTSUP;
   end;
 end;
end;

{==============================================================================}

function pthread_attr_getstackaddr(attr: Ppthread_attr_t; stackaddr: PPointer): int; cdecl;
{Get the stackaddr attribute}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check attr}
 if attr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_attr_getstackaddr (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}
 
 {Check stackaddr}
 if stackaddr = nil then Exit;
 
 {Get stackaddr}
 stackaddr^:=attr^.stackaddr;
 
 Result:=0;
end;

{==============================================================================}

function pthread_attr_setstackaddr(attr: Ppthread_attr_t; stackaddr: Pointer): int; cdecl; 
{Set the stackaddr attribute}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check attr}
 if attr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_attr_setstackaddr (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}

 {Set stackaddr}
 attr^.stackaddr:=stackaddr;
 
 Result:=0;
end;

{==============================================================================}

function pthread_attr_getstacksize(attr: Ppthread_attr_t; stacksize: Psize_t): int; cdecl;
{Get the stacksize attribute}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check attr}
 if attr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_attr_getstacksize (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}
 
 {Check stacksize}
 if stacksize = nil then Exit;
 
 {Get stacksize}
 stacksize^:=attr^.stacksize;
 
 Result:=0;
end;

{==============================================================================}

function pthread_attr_setstacksize(attr: Ppthread_attr_t; stacksize: size_t): int; cdecl;
{Set the stacksize attribute}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check attr}
 if attr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_attr_setstacksize (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}
 
 {Check stacksize}
 if stacksize < THREAD_STACK_MINIMUM_SIZE then Exit; {Note this should be PTHREAD_STACK_MIN but that is too small}
 if stacksize > THREAD_STACK_MAXIMUM_SIZE then Exit;
 
 {Set stacksize}
 attr^.stacksize:=stacksize;
 
 Result:=0;
end;

{==============================================================================}

procedure pthread_cleanup_push(routine: Tpthread_cleanup_routine; arg: Pointer); cdecl;
{Push thread cancellation clean-up handlers}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Pthread:PSyscallsPthread;
 Cleanup:PSyscallsPthreadCleanup;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_cleanup_push (routine=' + PtrToHex(routine) + ' arg=' + PtrToHex(arg) + ')');
 {$ENDIF}
 
 {Get Pthread}
 Pthread:=SyscallsGetPthread;
 if Pthread = nil then Exit;
 
 {Allocate Cleanup}
 Cleanup:=GetMem(SizeOf(TSyscallsPthreadCleanup));
 if Cleanup = nil then Exit;
 
 {Install Cleanup}
 Cleanup^.Routine:=routine;
 Cleanup^.Arg:=arg;
 Cleanup^.Next:=Pthread^.Cleanup;
 Pthread^.Cleanup:=Cleanup;
end;

{==============================================================================}

procedure pthread_cleanup_pop(execute: int); cdecl;
{Pop thread cancellation clean-up handlers}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Pthread:PSyscallsPthread;
 Cleanup:PSyscallsPthreadCleanup;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_cleanup_pop (execute=' + IntToStr(execute) + ')');
 {$ENDIF}

 {Get Pthread}
 Pthread:=SyscallsGetPthread;
 if Pthread = nil then Exit;

 {Get Cleanup}
 Cleanup:=Pthread^.Cleanup;
 if Cleanup <> nil then
  begin
   {Check Execute and Routine}
   if (execute <> 0) and Assigned(Cleanup^.Routine) then
    begin
     {Call Routine}
     Cleanup^.Routine(Cleanup^.Arg);
    end;
    
   {Remove Cleanup}
   Pthread^.Cleanup:=Cleanup^.Next;
   
   {Free Cleanup} 
   FreeMem(Cleanup);
  end; 
end;

{==============================================================================}

function pthread_cond_init(cond: Ppthread_cond_t; attr: Ppthread_condattr_t): int; cdecl;
{Initialize a condition variable}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Handle:TConditionHandle;
begin
 {}
 Result:=EINVAL;
 
 {Check cond}
 if cond = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_cond_init (cond=' + IntToHex(cond^,8) + ')');
 {$ENDIF}
 
 Result:=EAGAIN;
 
 {Note: attr not used}
 
 {Create Condition}
 Handle:=ConditionCreate;
 if Handle = INVALID_HANDLE_VALUE then Exit;
 
 {Return cond}
 cond^:=Handle;
 
 Result:=0;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_cond_init (Result=' + IntToStr(Result) + ' cond=' + IntToHex(cond^,8) + ')');
 {$ENDIF}
end;

{==============================================================================}

function pthread_cond_destroy(cond: Ppthread_cond_t): int; cdecl;
{Destroy a condition variable}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check cond}
 if cond = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_cond_destroy (cond=' + IntToHex(cond^,8) + ')');
 {$ENDIF}
 
 {Destroy Condition}
 if ConditionDestroy(TConditionHandle(cond^)) <> ERROR_SUCCESS then Exit;
 
 {Invalidate cond}
 cond^:=0; {Not INVALID_HANDLE_VALUE to allow detection of PTHREAD_COND_INITIALIZER}
 
 Result:=0;
end;

{==============================================================================}

function pthread_cond_broadcast(cond: Ppthread_cond_t): int; cdecl;
{Broadcast (Signal all) a condition variable}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check cond}
 if cond = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_cond_broadcast (cond=' + IntToHex(cond^,8) + ')');
 {$ENDIF}

 {Check cond}
 if cond^ = PTHREAD_COND_INITIALIZER then
  begin
   {Initialize cond}
   Result:=pthread_cond_init(cond,nil);
   if Result <> 0 then Exit;
  end;
 
 {Check cond}
 if cond^ = 0 then
  begin
   {$IFDEF SYSCALLS_WARN_UNINITIALIZED}
   {Uninitialized cond}
   if PLATFORM_LOG_ENABLED then PlatformLogWarn('Uninitialized condition in call to pthread_cond_broadcast');
   {$ENDIF}
   
   {$IFDEF SYSCALLS_CREATE_UNINITIALIZED}  
   {Initialize cond}
   Result:=pthread_cond_init(cond,nil);
   if Result <> 0 then Exit;
   {$ENDIF}  
  end;
 
 {Wake All Condition} 
 if ConditionWakeAll(TConditionHandle(cond^)) <> ERROR_SUCCESS then Exit;
 
 Result:=0;
end;

{==============================================================================}

function pthread_cond_signal(cond: Ppthread_cond_t): int; cdecl;
{Signal a condition variable}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check cond}
 if cond = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_cond_signal (cond=' + IntToHex(cond^,8) + ')');
 {$ENDIF}
 
 {Check cond}
 if cond^ = PTHREAD_COND_INITIALIZER then
  begin
   {Initialize cond}
   Result:=pthread_cond_init(cond,nil);
   if Result <> 0 then Exit;
  end;
 
 {Check cond}
 if cond^ = 0 then
  begin
   {$IFDEF SYSCALLS_WARN_UNINITIALIZED}  
   {Uninitialized cond}
   if PLATFORM_LOG_ENABLED then PlatformLogWarn('Uninitialized condition in call to pthread_cond_signal');
   {$ENDIF}
   
   {$IFDEF SYSCALLS_CREATE_UNINITIALIZED}  
   {Initialize cond}
   Result:=pthread_cond_init(cond,nil);
   if Result <> 0 then Exit;
   {$ENDIF}  
  end;
 
 {Wake Condition} 
 if ConditionWake(TConditionHandle(cond^)) <> ERROR_SUCCESS then Exit;
 
 Result:=0;
end;

{==============================================================================}

function pthread_cond_wait(cond: Ppthread_cond_t; mutex: Ppthread_mutex_t): int; cdecl;
{Wait on a condition variable}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Flags:LongWord;
 ResultCode:LongWord;
begin
 {}
 Result:=EINVAL;
 
 {Check cond}
 if cond = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_cond_wait (cond=' + IntToHex(cond^,8) + ' mutex=' + IntToHex(mutex^,8) + ')');
 {$ENDIF}
 
 {Check cond}
 if cond^ = PTHREAD_COND_INITIALIZER then
  begin
   {Initialize cond}
   Result:=pthread_cond_init(cond,nil);
   if Result <> 0 then Exit;
  end;
 
 {Check cond}
 if cond^ = 0 then
  begin
   {$IFDEF SYSCALLS_WARN_UNINITIALIZED}  
   {Uninitialized cond}
   if PLATFORM_LOG_ENABLED then PlatformLogWarn('Uninitialized condition in call to pthread_cond_wait');
   {$ENDIF}
   
   {$IFDEF SYSCALLS_CREATE_UNINITIALIZED}  
   {Initialize cond}
   Result:=pthread_cond_init(cond,nil);
   if Result <> 0 then Exit;
   {$ENDIF}  
  end;
 
 {Wait Condition Mutex}
 ResultCode:=ConditionWaitMutex(TConditionHandle(cond^),TMutexHandle(mutex^),INFINITE);
 if ResultCode = ERROR_SUCCESS then
  begin
   Result:=0;
  end
 else if ResultCode = ERROR_WAIT_TIMEOUT then 
  begin
   Result:=ETIMEDOUT;
  end;
 
 {Check Cancellation} 
 Flags:=ThreadGetFlags(ThreadGetCurrent);
 if (Flags and (THREAD_FLAG_CANCELLED or THREAD_FLAG_CANCEL_DISABLE)) = (THREAD_FLAG_CANCELLED) then
  begin
   SyscallsPthreadEnd(PTHREAD_CANCELED);
  end;
end;

{==============================================================================}

function pthread_cond_timedwait(cond: Ppthread_cond_t; mutex: Ppthread_mutex_t; abstime: Ptimespec): int; cdecl;
{Wait on a condition variable with timeout}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Flags:LongWord;
 Timeout:LongWord;
 Current:Ttimespec;
 Relative:Ttimespec;
 ResultCode:LongWord;
begin
 {}
 Result:=EINVAL;
 
 {Check cond}
 if cond = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_cond_timedwait (cond=' + IntToHex(cond^,8) + ' mutex=' + IntToHex(mutex^,8) + ')');
 {$ENDIF}
 
 {Check mutex}
 if mutex = nil then Exit;
 
 {Check abstime}
 if abstime = nil then Exit;
 
 {Get Timeout}
 Timeout:=INFINITE;
 if clock_gettime(CLOCK_REALTIME,@Current) = 0 then
  begin
   Relative.tv_nsec:=abstime^.tv_nsec - Current.tv_nsec;
   Relative.tv_sec:=abstime^.tv_sec - Current.tv_sec;
   if Relative.tv_nsec < 0 then
    begin
     Relative.tv_nsec:=Relative.tv_nsec + 1000000000;
     Relative.tv_sec:=Relative.tv_sec - 1;
    end;
    
   if Relative.tv_sec < 0 then Exit;
   
   Timeout:=(Relative.tv_sec * 1000) + (Relative.tv_nsec div 1000000);
  end;
 
 {Check cond}
 if cond^ = PTHREAD_COND_INITIALIZER then
  begin
   {Initialize cond}
   Result:=pthread_cond_init(cond,nil);
   if Result <> 0 then Exit;
  end;
 
 {Check cond}
 if cond^ = 0 then
  begin
   {$IFDEF SYSCALLS_WARN_UNINITIALIZED}  
   {Uninitialized cond}
   if PLATFORM_LOG_ENABLED then PlatformLogWarn('Uninitialized condition in call to pthread_cond_timedwait');
   {$ENDIF}
   
   {$IFDEF SYSCALLS_CREATE_UNINITIALIZED}  
   {Initialize cond}
   Result:=pthread_cond_init(cond,nil);
   if Result <> 0 then Exit;
   {$ENDIF}  
  end;
 
 {Wait Condition Mutex}
 ResultCode:=ConditionWaitMutex(TConditionHandle(cond^),TMutexHandle(mutex^),Timeout);
 if ResultCode = ERROR_SUCCESS then
  begin
   Result:=0;
  end
 else if ResultCode = ERROR_WAIT_TIMEOUT then 
  begin
   Result:=ETIMEDOUT;
  end;
  
 {Check Cancellation} 
 Flags:=ThreadGetFlags(ThreadGetCurrent);
 if (Flags and (THREAD_FLAG_CANCELLED or THREAD_FLAG_CANCEL_DISABLE)) = (THREAD_FLAG_CANCELLED) then
  begin
   SyscallsPthreadEnd(PTHREAD_CANCELED);
  end;
end;

{==============================================================================}

function pthread_condattr_init(attr: Ppthread_condattr_t): int; cdecl;
{Initialize a condition variable attributes entry}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check attr}
 if attr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_condattr_init (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}
 
 {Init attr}
 attr^.is_initialized:=1;
 attr^.clock:=0;
 {$IFDEF _POSIX_THREAD_PROCESS_SHARED}
 attr^.process_shared:=PTHREAD_PROCESS_PRIVATE;
 {$ENDIF}
 
 Result:=0;
end;

{==============================================================================}

function pthread_condattr_destroy(attr: Ppthread_condattr_t): int; cdecl;
{Destroy a condition variable attributes entry}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check attr}
 if attr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_condattr_destroy (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}
 
 {Destroy attr}
 attr^.is_initialized:=0;
 
 Result:=0;
end;

{==============================================================================}

function pthread_condattr_getpshared(attr: Ppthread_condattr_t; pshared: Pint): int; cdecl;
{Get the process-shared condition variable attribute}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check attr}
 if attr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_condattr_getpshared (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}
 
 {Check pshared}
 if pshared = nil then Exit;
 
 {$IFDEF _POSIX_THREAD_PROCESS_SHARED}
 {Get pshared}
 pshared^:=attr^.process_shared;
 
 Result:=0;
 {$ELSE}
 
 Result:=ENOSYS;
 {$ENDIF}
end;

{==============================================================================}

function pthread_condattr_setpshared(attr: Ppthread_condattr_t; pshared: int): int; cdecl;
{Set the process-shared condition variable attribute}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check attr}
 if attr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_condattr_setpshared (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}
 
 {Check pshared}
 if (pshared <> PTHREAD_PROCESS_PRIVATE) and (pshared <> PTHREAD_PROCESS_SHARED) then Exit;
 
 {$IFDEF _POSIX_THREAD_PROCESS_SHARED}
 {Set pshared}
 attr^.process_shared:=pshared;
 
 Result:=0;
 {$ELSE}
 
 Result:=ENOSYS;
 {$ENDIF}
end;

{==============================================================================}

function pthread_create(thread: Ppthread_t; attr: Ppthread_attr_t; start_routine: Tpthread_start_routine; arg: Pointer): int; cdecl;
{Create a new thread}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Flags:LongWord;
 Priority:LongWord;
 StackSize:LongWord;
 ThreadID:TThreadID;
 Data:PSyscallsPthreadData;
begin
 {}
 Result:=EINVAL;
 
 {Check thread}
 if thread = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_create (thread=' + IntToHex(thread^,8) + ' attr=' + PtrToHex(attr) + ' start_routine=' + PtrToHex(start_routine) + ' arg=' + PtrToHex(arg) + ')');
 {$ENDIF}
 
 {Check attr}
 if attr = nil then
  begin
   Flags:=THREAD_FLAG_PERSIST;
   Priority:=THREAD_PRIORITY_DEFAULT;
   StackSize:=THREAD_STACK_DEFAULT_SIZE;
  end
 else
  begin
   StackSize:=attr^.stacksize;
   Priority:=attr^.schedparam.sched_priority;
   Flags:=THREAD_FLAG_NONE;
   if attr^.detachstate = PTHREAD_CREATE_JOINABLE then
    begin
     Flags:=THREAD_FLAG_PERSIST;
    end;
  end;  
  
 {Allocate Data}
 Data:=GetMem(SizeOf(TSyscallsPthreadData));
 Data^.Routine:=start_routine;
 Data^.Arg:=arg;
 
 Result:=EAGAIN;
 
 {Create Thread}
 thread^:=SysBeginThreadEx(nil,StackSize,TThreadFunc(@SyscallsPthreadStart),Data,THREAD_CREATE_SUSPENDED,Priority,CPU_AFFINITY_ALL,CPU_ID_ALL,SYSCALLS_THREAD_NAME,ThreadID);
 if thread^ = pthread_t(INVALID_HANDLE_VALUE) then Exit;
 
 {Update Thread}
 ThreadSetFlags(TThreadHandle(thread^),Flags);
 
 {Resume Thread}
 ThreadResume(TThreadHandle(thread^));
 
 Result:=0;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_create (Result=' + IntToStr(Result) + ' thread=' + IntToHex(thread^,8) + ')');
 {$ENDIF}
end;

{==============================================================================}

function pthread_cancel(thread: pthread_t): int; cdecl;
{Send a cancellation request to a thread}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Flags:LongWord;
 State:LongWord;
begin
 {}
 Result:=ESRCH;
 
 {Check thread}
 if thread = pthread_t(INVALID_HANDLE_VALUE) then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_cancel (thread=' + IntToHex(thread,8) + ')');
 {$ENDIF}
 
 Result:=EINVAL;
 
 {Get Flags}
 Flags:=ThreadGetFlags(TThreadHandle(thread));
 if Flags = LongWord(INVALID_HANDLE_VALUE) then Exit;
 
 {Check Flags}
 if (Flags and THREAD_FLAG_CANCELLED) = 0 then
  begin
   {Not Cancelled}
   {Update Flags}
   if ThreadAddFlags(TThreadHandle(thread),THREAD_FLAG_CANCELLED) <> ERROR_SUCCESS then Exit;
   
   {Check Flags}
   if (Flags and THREAD_FLAG_CANCEL_DISABLE) = 0 then
    begin
     {Not Disabled}
     {Get State}
     State:=ThreadGetState(TThreadHandle(thread));
     case State of
      THREAD_STATE_SUSPENDED:begin
        {Resume Thread}
        if ThreadResume(TThreadHandle(thread)) <> ERROR_SUCCESS then Exit;
       end;
      THREAD_STATE_SLEEP,THREAD_STATE_WAIT,THREAD_STATE_WAIT_TIMEOUT,THREAD_STATE_RECEIVE,THREAD_STATE_RECEIVE_TIMEOUT:begin
        {Wake Thread}
        if ThreadWake(TThreadHandle(thread)) <> ERROR_SUCCESS then Exit;
       end;      
     end;
    end;
  end;
 
 Result:=0;
end;

{==============================================================================}

function pthread_detach(thread: pthread_t): int; cdecl;
{Detach a thread}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Flags:LongWord;
 State:LongWord;
begin
 {}
 Result:=ESRCH;
 
 {Check thread}
 if thread = pthread_t(INVALID_HANDLE_VALUE) then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_detach (thread=' + IntToHex(thread,8) + ')');
 {$ENDIF}

 Result:=EINVAL;
 
 {Get Flags} 
 Flags:=ThreadGetFlags(TThreadHandle(thread));
 if Flags = LongWord(INVALID_HANDLE_VALUE) then Exit;
 
 {Check Flags}
 if (Flags and THREAD_FLAG_PERSIST) = 0 then Exit;
 
 {Update Flags}
 if ThreadRemoveFlags(TThreadHandle(thread),THREAD_FLAG_PERSIST) <> ERROR_SUCCESS then Exit;
 
 {Get State}
 State:=ThreadGetState(TThreadHandle(thread));
 if State = THREAD_STATE_TERMINATED then
  begin
   {Destroy Thread}
   ThreadDestroy(TThreadHandle(thread));  
  end;
 
 Result:=0;
end;

{==============================================================================}

procedure pthread_exit(value_ptr: Pointer); cdecl;
{Terminate calling thread}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_exit (value_ptr=' + PtrToHex(value_ptr) + ')');
 {$ENDIF}
  
 {Call Thread End}
 SyscallsPthreadEnd(value_ptr);
end;

{==============================================================================}

function pthread_equal(t1: pthread_t; t2: pthread_t): int; cdecl;
{Compare thread IDs}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=0;
 
 {Check t1}
 if t1 = pthread_t(INVALID_HANDLE_VALUE) then Exit;

 {Check t2}
 if t2 = pthread_t(INVALID_HANDLE_VALUE) then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_equal (t1=' + IntToHex(t1,8) + ' t2=' + IntToHex(t2,8) + ')');
 {$ENDIF}
 
 {Compare t1 and t2}
 if t1 <> t2 then Exit;
 
 Result:=1;
end;

{==============================================================================}

function pthread_join(thread: pthread_t; value_ptr: PPointer): int; cdecl; 
{Join with a terminated thread}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Flags:LongWord;
 State:LongWord;
begin
 {}
 Result:=ESRCH;
 
 {Check thread}
 if thread = pthread_t(INVALID_HANDLE_VALUE) then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_join (thread=' + IntToHex(thread,8) + ')');
 {$ENDIF}
 
 Result:=EINVAL;
 
 {Get Flags} 
 Flags:=ThreadGetFlags(TThreadHandle(thread));
 if Flags = LongWord(INVALID_HANDLE_VALUE) then Exit;
 
 {Check Flags}
 if (Flags and THREAD_FLAG_PERSIST) = 0 then Exit;

 {Check Cancellation}
 Flags:=ThreadGetFlags(ThreadGetCurrent);
 if (Flags and (THREAD_FLAG_CANCELLED or THREAD_FLAG_CANCEL_DISABLE)) = (THREAD_FLAG_CANCELLED) then
  begin
   SyscallsPthreadEnd(PTHREAD_CANCELED);
  end;
 
 {Wait Terminate}
 if ThreadWaitTerminate(TThreadHandle(thread),INFINITE) <> ERROR_SUCCESS then
  begin
   {Check Cancellation}
   Flags:=ThreadGetFlags(ThreadGetCurrent);
   if (Flags and (THREAD_FLAG_CANCELLED or THREAD_FLAG_CANCEL_DISABLE)) = (THREAD_FLAG_CANCELLED) then
    begin
     SyscallsPthreadEnd(PTHREAD_CANCELED);
    end;
   
   Exit;
  end;
 
 {Check value_ptr}
 if value_ptr <> nil then 
  begin
   {Get ExitCode}
   value_ptr^:=Pointer(ThreadGetExitCode(TThreadHandle(thread)));
  end; 

 {Update Flags}
 if ThreadRemoveFlags(TThreadHandle(thread),THREAD_FLAG_PERSIST) <> ERROR_SUCCESS then Exit;
  
 {Get State}
 State:=ThreadGetState(TThreadHandle(thread));
 if State = THREAD_STATE_TERMINATED then
  begin
   {Destroy Thread}
   ThreadDestroy(TThreadHandle(thread));
  end; 
 
 Result:=0; 
end;

{==============================================================================}

function pthread_self: pthread_t; cdecl;
{Get calling thread's ID}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=pthread_t(ThreadGetCurrent);
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_self (Result=' + IntToHex(Result,8) + ')');
 {$ENDIF}
end;

{==============================================================================}

function pthread_getconcurrency: int; cdecl;
{Get the level of concurrency}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=SyscallsPthreadConcurrency;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_getconcurrency (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function pthread_setconcurrency(new_level: int): int; cdecl;
{Set the level of concurrency}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=0;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_setconcurrency (new_level=' + IntToStr(new_level) + ')');
 {$ENDIF}
 
 SyscallsPthreadConcurrency:=new_level;
end;

{==============================================================================}

function pthread_getschedparam(thread: pthread_t; policy: Pint; param: Psched_param): int; cdecl;
{Get scheduling policy and parameters of a thread}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Priority:LongWord;
 Pthread:PSyscallsPthread;
begin
 {}
 Result:=ESRCH;
 
 {Check thread}
 if thread = pthread_t(INVALID_HANDLE_VALUE) then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_getschedparam (thread=' + IntToHex(thread,8) + ')');
 {$ENDIF}
 
 Result:=EINVAL;

 {Check policy}
 if policy = nil then Exit;
 
 {Check param}
 if param = nil then Exit;
 
 {Get Priority}
 Priority:=ThreadGetPriority(TThreadHandle(thread));
 
 {Return policy}
 policy^:=SCHED_OTHER;
 
 {Return param}
 param^.sched_priority:=Priority;
 
 Result:=0;
end;

{==============================================================================}

function pthread_setschedparam(thread: pthread_t; policy: int; param: Psched_param): int; cdecl;
{Set scheduling policy and parameters of a thread}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 MaxPriority:int;
 MinPriority:int;
 Pthread:PSyscallsPthread;
begin
 {}
 Result:=ESRCH;
 
 {Check thread}
 if thread = pthread_t(INVALID_HANDLE_VALUE) then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_setschedparam (thread=' + IntToHex(thread,8) + ')');
 {$ENDIF}
 
 Result:=EINVAL;
 
 {Check param}
 if param = nil then Exit;
 
 {Get Min/Max}
 MaxPriority:=sched_get_priority_max(SCHED_OTHER);
 MinPriority:=sched_get_priority_min(SCHED_OTHER);
 
 {Check Priority}
 if (param^.sched_priority < MinPriority) or (param^.sched_priority > MaxPriority) then Exit;
 
 {Set Priority}
 if ThreadSetPriority(TThreadHandle(thread),param^.sched_priority) = LongWord(INVALID_HANDLE_VALUE) then Exit;
 
 Result:=0;
end;

{==============================================================================}

function pthread_key_create(key: Ppthread_key_t; destructor_routine: Tpthread_destructor_routine): int; cdecl;
{Create a thread-specific data key (TLS Index)}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check key}
 if key = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_key_create (key=' + IntToHex(key^,8) + ' destructor_routine=' + PtrToHex(destructor_routine) + ')');
 {$ENDIF}
 
 Result:=EAGAIN;
 
 if MutexLock(SyscallsPthreadLock) <> ERROR_SUCCESS then Exit;
 try
  {Create TLS Index}
  key^:=ThreadAllocTlsIndex;
  if key^ = TLS_OUT_OF_INDEXES then Exit;
  
  {Save Destructor}
  SyscallsKeyDestructor[key^]:=destructor_routine;
  
  Result:=0;
  
  {$IFDEF SYSCALLS_DEBUG}
  if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_key_create (Result=' + IntToStr(Result) + ' key=' + IntToHex(key^,8) + ')');
  {$ENDIF}
 finally
  MutexUnlock(SyscallsPthreadLock);
 end; 
end;

{==============================================================================}

function pthread_key_delete(key: pthread_key_t): int; cdecl;
{Delete a thread-specific data key (TLS Index)}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_key_delete (key=' + IntToHex(key,8) + ')');
 {$ENDIF}
 
 if MutexLock(SyscallsPthreadLock) <> ERROR_SUCCESS then Exit;
 try
  {Destroy TLS Index}
  if ThreadReleaseTlsIndex(key) <> ERROR_SUCCESS then Exit;
 
  {Clear Destructor}
  SyscallsKeyDestructor[key]:=nil;
 
  Result:=0;
 finally
  MutexUnlock(SyscallsPthreadLock);
 end; 
end;

{==============================================================================}

function pthread_getspecific(key: pthread_key_t): Pointer; cdecl;
{Get a thread-specific data value (TLS Value)}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=nil;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_getspecific (key=' + IntToHex(key,8) + ')');
 {$ENDIF}
 
 {Get TLS Value}
 Result:=ThreadGetTlsValue(key);
end;

{==============================================================================}

function pthread_setspecific(key: pthread_key_t; value: Pointer): int; cdecl;
{Set a thread-specific data value (TLS Value)}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_setspecific (key=' + IntToHex(key,8) + ' value=' + PtrToHex(value) + ')');
 {$ENDIF}
 
 {Set TLS Value}
 if ThreadSetTlsValue(key,value) <> ERROR_SUCCESS then Exit;
 
 Result:=0;
end;

{==============================================================================}

function pthread_mutex_init(mutex: Ppthread_mutex_t; attr: Ppthread_mutexattr_t): int; cdecl;
{Initialize a mutex}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Flags:LongWord;
 Handle:TMutexHandle;
begin
 {}
 Result:=EINVAL;
 
 {Check mutex}
 if mutex = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_mutex_init (mutex=' + IntToHex(mutex^,8) + ')');
 {$ENDIF}
 
 Result:=EAGAIN;
 
 {Check attr}
 if attr = nil then
  begin
   Flags:=MUTEX_FLAG_NONE;
  end
 else
  begin
   Flags:=MUTEX_FLAG_NONE;
   {$IFDEF _UNIX98_THREAD_MUTEX_ATTRIBUTES}
   if attr^._type = PTHREAD_MUTEX_RECURSIVE then
    begin
     Flags:=MUTEX_FLAG_RECURSIVE;
    end
   else if attr^._type = PTHREAD_MUTEX_ERRORCHECK then 
    begin
     Flags:=MUTEX_FLAG_ERRORCHECK;
    end;
   {$ENDIF}
  end;  
 
 {Create Mutex}
 Handle:=MutexCreateEx(False,MUTEX_DEFAULT_SPINCOUNT,Flags);
 if Handle = INVALID_HANDLE_VALUE then Exit;
 
 {Return mutex}
 mutex^:=Handle;
 
 Result:=0;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_mutex_init (Result=' + IntToStr(Result) + ' mutex=' + IntToHex(mutex^,8) + ')');
 {$ENDIF}
end;

{==============================================================================}

function pthread_mutex_destroy(mutex: Ppthread_mutex_t): int; cdecl;
{Destroy a mutex}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check mutex}
 if mutex = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_mutex_destroy (mutex=' + IntToHex(mutex^,8) + ')');
 {$ENDIF}
 
 {Destroy Mutex}
 if MutexDestroy(TMutexHandle(mutex^)) <> ERROR_SUCCESS then Exit;
 
 {Invalidate mutex}
 mutex^:=0; {Not INVALID_HANDLE_VALUE to allow detection of PTHREAD_MUTEX_INITIALIZER}
 
 Result:=0;
end;

{==============================================================================}

function pthread_mutex_lock(mutex: Ppthread_mutex_t): int; cdecl;
{Lock a mutex}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ResultCode:LongWord;
begin
 {}
 Result:=EINVAL;
 
 {Check mutex}
 if mutex = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_mutex_lock (mutex=' + IntToHex(mutex^,8) + ')');
 {$ENDIF}
 
 {Check mutex}
 if mutex^ = PTHREAD_MUTEX_INITIALIZER then
  begin
   {Initialize mutex}
   Result:=pthread_mutex_init(mutex,nil);
   if Result <> 0 then Exit;
  end;
 
 {Check mutex}
 if mutex^ = 0 then
  begin
   {$IFDEF SYSCALLS_WARN_UNINITIALIZED}  
   {Uninitialized mutex}
   if PLATFORM_LOG_ENABLED then PlatformLogWarn('Uninitialized mutex in call to pthread_mutex_lock');
   {$ENDIF}  
   
   {$IFDEF SYSCALLS_CREATE_UNINITIALIZED}  
   {Initialize mutex}
   Result:=pthread_mutex_init(mutex,nil);
   if Result <> 0 then Exit;
   {$ENDIF}  
  end;
 
 {Lock Mutex}
 ResultCode:=MutexLock(TMutexHandle(mutex^));
 if ResultCode = ERROR_SUCCESS then
  begin
   Result:=0;
  end
 else if ResultCode = ERROR_ALREADY_OWNER then //To do //Implement this in MutexLock if flags is MUTEX_FLAG_ERRORCHECK
  begin
   Result:=EDEADLK;
  end;
end;

{==============================================================================}

function pthread_mutex_trylock(mutex: Ppthread_mutex_t): int; cdecl;
{Try to lock a mutex}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ResultCode:LongWord;
begin
 {}
 Result:=EINVAL;
 
 {Check mutex}
 if mutex = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_mutex_trylock (mutex=' + IntToHex(mutex^,8) + ')');
 {$ENDIF}
 
 {Check mutex}
 if mutex^ = PTHREAD_MUTEX_INITIALIZER then
  begin
   {Initialize mutex}
   Result:=pthread_mutex_init(mutex,nil);
   if Result <> 0 then Exit;
  end;
 
 {Check mutex}
 if mutex^ = 0 then
  begin
   {$IFDEF SYSCALLS_WARN_UNINITIALIZED}  
   {Uninitialized mutex}
   if PLATFORM_LOG_ENABLED then PlatformLogWarn('Uninitialized mutex in call to pthread_mutex_trylock');
   {$ENDIF}  
   
   {$IFDEF SYSCALLS_CREATE_UNINITIALIZED}  
   {Initialize mutex}
   Result:=pthread_mutex_init(mutex,nil);
   if Result <> 0 then Exit;
   {$ENDIF}  
  end;
 
 {Try Lock Mutex}
 ResultCode:=MutexTryLock(TMutexHandle(mutex^));
 if ResultCode = ERROR_SUCCESS then
  begin
   Result:=0;
  end
 else if ResultCode = ERROR_LOCKED then
  begin
   Result:=EBUSY;
  end;
end;

{==============================================================================}

function pthread_mutex_unlock(mutex: Ppthread_mutex_t): int; cdecl;
{Unlock a mutex}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ResultCode:LongWord;
begin
 {}
 Result:=EINVAL;
 
 {Check mutex}
 if mutex = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_mutex_unlock (mutex=' + IntToHex(mutex^,8) + ')');
 {$ENDIF}
 
 {Check mutex}
 if mutex^ = PTHREAD_MUTEX_INITIALIZER then
  begin
   {Initialize mutex}
   Result:=pthread_mutex_init(mutex,nil);
   if Result <> 0 then Exit;
  end;
 
 {Check mutex}
 if mutex^ = 0 then
  begin
   {$IFDEF SYSCALLS_WARN_UNINITIALIZED}  
   {Uninitialized mutex}
   if PLATFORM_LOG_ENABLED then PlatformLogWarn('Uninitialized mutex in call to pthread_mutex_unlock');
   {$ENDIF}  
   
   {$IFDEF SYSCALLS_CREATE_UNINITIALIZED}  
   {Initialize mutex}
   Result:=pthread_mutex_init(mutex,nil);
   if Result <> 0 then Exit;
   {$ENDIF}  
  end;
 
 {Unlock Mutex}
 ResultCode:=MutexUnlock(TMutexHandle(mutex^));
 if ResultCode = ERROR_SUCCESS then
  begin
   Result:=0;
  end
 else if ResultCode = ERROR_NOT_LOCKED then
  begin
   Result:=EPERM;
  end
 else if ResultCode = ERROR_NOT_OWNER then
  begin
   Result:=EPERM;
  end;
end;

{==============================================================================}

function pthread_mutex_setprioceiling(mutex: Ppthread_mutex_t; prioceiling: int; old_ceiling: Pint): int; cdecl;
{Set the priority ceiling of a mutex}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check mutex}
 if mutex = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_mutex_setprioceiling (mutex=' + IntToHex(mutex^,8) + ')');
 {$ENDIF}
 
 {Check mutex}
 if mutex^ = PTHREAD_MUTEX_INITIALIZER then
  begin
   {Initialize mutex}
   Result:=pthread_mutex_init(mutex,nil);
   if Result <> 0 then Exit;
  end;
 
 {Check mutex}
 if mutex^ = 0 then
  begin
   {$IFDEF SYSCALLS_WARN_UNINITIALIZED}  
   {Uninitialized mutex}
   if PLATFORM_LOG_ENABLED then PlatformLogWarn('Uninitialized mutex in call to pthread_mutex_setprioceiling');
   {$ENDIF}  
   
   {$IFDEF SYSCALLS_CREATE_UNINITIALIZED}  
   {Initialize mutex}
   Result:=pthread_mutex_init(mutex,nil);
   if Result <> 0 then Exit;
   {$ENDIF}  
  end;
 
 {$IFDEF _POSIX_THREAD_PRIO_PROTECT}
 {Not supported}
 Result:=ENOSYS;
 {$ELSE}         
 
 Result:=ENOSYS;
 {$ENDIF}         
end;

{==============================================================================}

function pthread_mutex_getprioceiling(mutex: Ppthread_mutex_t; prioceiling: Pint): int; cdecl;
{Get the priority ceiling of a mutex}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check mutex}
 if mutex = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_mutex_getprioceiling (mutex=' + IntToHex(mutex^,8) + ')');
 {$ENDIF}
 
 {Check mutex}
 if mutex^ = PTHREAD_MUTEX_INITIALIZER then
  begin
   {Initialize mutex}
   Result:=pthread_mutex_init(mutex,nil);
   if Result <> 0 then Exit;
  end;
 
 {Check mutex}
 if mutex^ = 0 then
  begin
   {$IFDEF SYSCALLS_WARN_UNINITIALIZED}  
   {Uninitialized mutex}
   if PLATFORM_LOG_ENABLED then PlatformLogWarn('Uninitialized mutex in call to pthread_mutex_getprioceiling');
   {$ENDIF}  
   
   {$IFDEF SYSCALLS_CREATE_UNINITIALIZED}  
   {Initialize mutex}
   Result:=pthread_mutex_init(mutex,nil);
   if Result <> 0 then Exit;
   {$ENDIF}  
  end;
 
 {$IFDEF _POSIX_THREAD_PRIO_PROTECT}
 {Not supported}
 Result:=ENOSYS;
 {$ELSE}         
 
 Result:=ENOSYS;
 {$ENDIF}         
end;

{==============================================================================}

procedure pthread_mutex_unlock_internal(mutex: Ppthread_mutex_t); cdecl;
{Unlock a mutex (Compatible with Tpthread_cleanup_routine)}

{Note: Internal function, not intended to be called by applications}
begin
 {}
 pthread_mutex_unlock(mutex);
end;

{==============================================================================}

function pthread_mutexattr_init(attr: Ppthread_mutexattr_t): int; cdecl;
{Initialize a mutex attributes entry}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check attr}
 if attr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_mutexattr_init (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}
 
 {Init attr}
 attr^.is_initialized:=1;
 {$IFDEF _POSIX_THREAD_PROCESS_SHARED}
 attr^.process_shared:=PTHREAD_PROCESS_PRIVATE; 
 {$ENDIF}
 {$IFDEF _POSIX_THREAD_PRIO_PROTECT}
 attr^.prio_ceiling:=0;
 attr^.protocol:=0;
 {$ENDIF}
 {$IFDEF _UNIX98_THREAD_MUTEX_ATTRIBUTES}
 attr^._type:=PTHREAD_MUTEX_DEFAULT;
 {$ENDIF}
 attr^.recursive:=0;
 
 Result:=0;
end;

{==============================================================================}

function pthread_mutexattr_destroy(attr: Ppthread_mutexattr_t): int; cdecl;
{Destroy a mutex attributes entry}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check attr}
 if attr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_mutexattr_destroy (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}
 
 {Destroy attr}
 attr^.is_initialized:=0;
 
 Result:=0;
end;

{==============================================================================}

function pthread_mutexattr_getprioceiling(attr: Ppthread_mutexattr_t; prioceiling: Pint): int; cdecl;
{Get the prioceiling attribute of the mutex attributes entry}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check attr}
 if attr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_mutexattr_getprioceiling (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}
 
 {Check prioceiling}
 if prioceiling = nil then Exit;
 
 {$IFDEF _POSIX_THREAD_PRIO_PROTECT}
 {Get prioceiling}
 prioceiling^:=attr^.prio_ceiling;
 
 Result:=0;
 {$ELSE}
 
 Result:=ENOSYS;
 {$ENDIF}
end;

{==============================================================================}

function pthread_mutexattr_setprioceiling(attr: Ppthread_mutexattr_t; prioceiling: int): int; cdecl;
{Set the prioceiling attribute of the mutex attributes entry}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check attr}
 if attr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_mutexattr_setprioceiling (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}
 
 {$IFDEF _POSIX_THREAD_PRIO_PROTECT}
 {Set prioceiling}
 attr^.prio_ceiling:=prioceiling;
 
 Result:=0;
 {$ELSE}
 
 Result:=ENOSYS;
 {$ENDIF}
end;

{==============================================================================}

function pthread_mutexattr_getprotocol(attr: Ppthread_mutexattr_t; protocol: Pint): int; cdecl;
{Get the protocol attribute of the mutex attributes entry}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check attr}
 if attr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_mutexattr_getprotocol (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}
 
 {Check protocol}
 if protocol = nil then Exit;
 
 {$IFDEF _POSIX_THREAD_PRIO_PROTECT}
 {Get protocol}
 protocol^:=attr^.protocol;
 
 Result:=0;
 {$ELSE}
 
 Result:=ENOSYS;
 {$ENDIF}
end;

{==============================================================================}

function pthread_mutexattr_setprotocol(attr: Ppthread_mutexattr_t; protocol: int): int; cdecl;
{Set the protocol attribute of the mutex attributes entry}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check attr}
 if attr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_mutexattr_setprotocol (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}
 
 {$IFDEF _POSIX_THREAD_PRIO_PROTECT}
 {Set protocol}
 attr^.protocol:=protocol;
 
 Result:=0;
 {$ELSE}
 
 Result:=ENOSYS;
 {$ENDIF}
end;

{==============================================================================}

function pthread_mutexattr_getpshared(attr: Ppthread_mutexattr_t; pshared: Pint): int; cdecl;
{Get the process-shared attribute of the mutex attributes entry}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check attr}
 if attr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_mutexattr_getpshared (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}
 
 {Check pshared}
 if pshared = nil then Exit;
 
 {$IFDEF _POSIX_THREAD_PROCESS_SHARED}
 {Get pshared}
 pshared^:=attr^.process_shared;
 
 Result:=0;
 {$ELSE}
 
 Result:=ENOSYS;
 {$ENDIF}
end;

{==============================================================================}

function pthread_mutexattr_setpshared(attr: Ppthread_mutexattr_t; pshared: int): int; cdecl;
{Set the process-shared attribute of the mutex attributes entry}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check attr}
 if attr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_mutexattr_setpshared (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}
 
 {Check pshared}
 if (pshared <> PTHREAD_PROCESS_PRIVATE) and (pshared <> PTHREAD_PROCESS_SHARED) then Exit;
 
 {$IFDEF _POSIX_THREAD_PROCESS_SHARED}
 {Set pshared}
 attr^.process_shared:=pshared;
 
 Result:=0;
 {$ELSE}
 
 Result:=ENOSYS;
 {$ENDIF}
end;

{==============================================================================}

function pthread_mutexattr_gettype(attr: Ppthread_mutexattr_t; _type: Pint): int; cdecl;
{Get the type attribute of the mutex attributes entry}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check attr}
 if attr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_mutexattr_gettype (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}
 
 {Check _type}
 if _type = nil then Exit;
 
 {$IFDEF _UNIX98_THREAD_MUTEX_ATTRIBUTES}
 {Get _type}
 _type^:=attr^._type;
 
 Result:=0;
 {$ELSE}
 
 Result:=ENOSYS;
 {$ENDIF}
end;

{==============================================================================}

function pthread_mutexattr_settype(attr: Ppthread_mutexattr_t; _type: int): int; cdecl;
{Set the type attribute of the mutex attributes entry}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check attr}
 if attr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_mutexattr_settype (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}
 
 {Check _type}
 if (_type <> PTHREAD_MUTEX_NORMAL) and (_type <> PTHREAD_MUTEX_RECURSIVE) and (_type <> PTHREAD_MUTEX_ERRORCHECK) and (_type <> PTHREAD_MUTEX_DEFAULT) then Exit;
 
 {$IFDEF _UNIX98_THREAD_MUTEX_ATTRIBUTES}
 {Set _type}
 attr^._type:=_type;
 
 Result:=0;
 {$ELSE}
 
 Result:=ENOSYS;
 {$ENDIF}
end;

{==============================================================================}

function pthread_once(once_control: Ppthread_once_t; init_routine: Tpthread_init_routine): int; cdecl;
{Dynamic package initialisation}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 Result:=EINVAL;
 
 {Check once_control and init_routine}
 if (once_control = nil) or not Assigned(init_routine) then
  begin
   {Return Error (Some callers incorrectly check errno on failure)}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
   
   Exit;
  end;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_once (once_control=' + PtrToHex(once_control) + ' init_routine=' + PtrToHex(init_routine) + ')');
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_once (is_initialized=' + IntToStr(once_control^.is_initialized) + ' init_executed=' + IntToStr(once_control^.init_executed) + ')');
 {$ENDIF}
 
 {Update is_initialized}
 once_control^.is_initialized:=1;
 
 {Check init_executed}
 if once_control^.init_executed = 0 then
  begin
   if MutexLock(SyscallsPthreadLock) <> ERROR_SUCCESS then Exit;
 
   {Recheck init_executed (Must be after lock)}
   if once_control^.init_executed = 0 then
    begin
     {Add mutex unlock cleanup}
     pthread_cleanup_push(Tpthread_cleanup_routine(@pthread_mutex_unlock_internal),@SyscallsPthreadLock);
     
     {Call init_routine}
     init_routine();
   
     {Update is_initialized (Must be after init_routine)}
     once_control^.init_executed:=1;
  
     {Remove mutex unlock cleanup}
     pthread_cleanup_pop(0);
    end; 

   MutexUnlock(SyscallsPthreadLock);
  end;
 
 Result:=0;
end;

{==============================================================================}

function pthread_rwlock_init(rwlock: Ppthread_rwlock_t ; attr: Ppthread_rwlockattr_t): int; cdecl;
{Initialize a read-write lock}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Handle:TSynchronizerHandle;
begin
 {}
 Result:=EINVAL;
 
 {Check rwlock}
 if rwlock = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_rwlock_init (rwlock=' + IntToHex(rwlock^,8) + ')');
 {$ENDIF}
 
 Result:=EAGAIN;
 
 {Note: attr not used}
 
 {Create Synchronizer}
 Handle:=SynchronizerCreate;
 if Handle = INVALID_HANDLE_VALUE then Exit;
 
 {Return rwlock}
 rwlock^:=Handle;
 
 Result:=0;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_rwlock_init (Result=' + IntToStr(Result) + ' rwlock=' + IntToHex(rwlock^,8) + ')');
 {$ENDIF}
end;

{==============================================================================}

function pthread_rwlock_destroy(rwlock: Ppthread_rwlock_t): int; cdecl;
{Destroy a read-write lock}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check rwlock}
 if rwlock = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_rwlock_destroy (rwlock=' + IntToHex(rwlock^,8) + ')');
 {$ENDIF}
 
 {Destroy Synchronizer}
 if SynchronizerDestroy(TSynchronizerHandle(rwlock^)) <> ERROR_SUCCESS then Exit;
 
 {Invalidate rwlock}
 rwlock^:=0; {Not INVALID_HANDLE_VALUE to allow detection of PTHREAD_RWLOCK_INITIALIZER}
 
 Result:=0;
end;

{==============================================================================}

function pthread_rwlock_rdlock(rwlock: Ppthread_rwlock_t): int; cdecl;
{Lock a read-write lock for reading}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ResultCode:LongWord;
begin
 {}
 Result:=EINVAL;
 
 {Check rwlock}
 if rwlock = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_rwlock_rdlock (rwlock=' + IntToHex(rwlock^,8) + ')');
 {$ENDIF}
 
 {Check rwlock}
 if rwlock^ = PTHREAD_RWLOCK_INITIALIZER then
  begin
   {Initialize rwlock}
   Result:=pthread_rwlock_init(rwlock,nil);
   if Result <> 0 then Exit;
  end;
 
 {Check rwlock}
 if rwlock^ = 0 then
  begin
   {$IFDEF SYSCALLS_WARN_UNINITIALIZED}
   {Uninitialized rwlock}
   if PLATFORM_LOG_ENABLED then PlatformLogWarn('Uninitialized rwlock in call to pthread_rwlock_rdlock');
   {$ENDIF}
   
   {$IFDEF SYSCALLS_CREATE_UNINITIALIZED}  
   {Initialize rwlock}
   Result:=pthread_rwlock_init(rwlock,nil);
   if Result <> 0 then Exit;
   {$ENDIF}  
  end;
 
 {Check Owner}
 if SynchronizerWriterOwner(TSynchronizerHandle(rwlock^)) = ThreadGetCurrent then
  begin
   Result:=EDEADLK;
  end
 else
  begin 
   {Lock Synchronizer}
   ResultCode:=SynchronizerReaderLock(TSynchronizerHandle(rwlock^));
   if ResultCode = ERROR_SUCCESS then
    begin
     Result:=0;
    end;
  end;
end;

{==============================================================================}

function pthread_rwlock_wrlock(rwlock: Ppthread_rwlock_t): int; cdecl;
{Lock a read-write lock for writing}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ResultCode:LongWord;
begin
 {}
 Result:=EINVAL;
 
 {Check rwlock}
 if rwlock = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_rwlock_wrlock (rwlock=' + IntToHex(rwlock^,8) + ')');
 {$ENDIF}
 
 {Check rwlock}
 if rwlock^ = PTHREAD_RWLOCK_INITIALIZER then
  begin
   {Initialize rwlock}
   Result:=pthread_rwlock_init(rwlock,nil);
   if Result <> 0 then Exit;
  end;
 
 {Check rwlock}
 if rwlock^ = 0 then
  begin
   {$IFDEF SYSCALLS_WARN_UNINITIALIZED}
   {Uninitialized rwlock}
   if PLATFORM_LOG_ENABLED then PlatformLogWarn('Uninitialized rwlock in call to pthread_rwlock_wrlock');
   {$ENDIF}
   
   {$IFDEF SYSCALLS_CREATE_UNINITIALIZED}  
   {Initialize rwlock}
   Result:=pthread_rwlock_init(rwlock,nil);
   if Result <> 0 then Exit;
   {$ENDIF}  
  end;
 
 {Check Last}
 if SynchronizerReaderLast(TSynchronizerHandle(rwlock^)) = ThreadGetCurrent then
  begin
   Result:=EDEADLK;
  end
 else
  begin 
   {Lock Synchronizer}
   ResultCode:=SynchronizerWriterLock(TSynchronizerHandle(rwlock^));
   if ResultCode = ERROR_SUCCESS then
    begin
     Result:=0;
    end;
  end;
end;

{==============================================================================}

function pthread_rwlock_tryrdlock(rwlock: Ppthread_rwlock_t): int; cdecl;
{Try to lock a read-write lock for reading}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ResultCode:LongWord;
begin
 {}
 Result:=EINVAL;
 
 {Check rwlock}
 if rwlock = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_rwlock_tryrdlock (rwlock=' + IntToHex(rwlock^,8) + ')');
 {$ENDIF}

 {Check rwlock}
 if rwlock^ = PTHREAD_RWLOCK_INITIALIZER then
  begin
   {Initialize rwlock}
   Result:=pthread_rwlock_init(rwlock,nil);
   if Result <> 0 then Exit;
  end;
 
 {Check rwlock}
 if rwlock^ = 0 then
  begin
   {$IFDEF SYSCALLS_WARN_UNINITIALIZED}
   {Uninitialized rwlock}
   if PLATFORM_LOG_ENABLED then PlatformLogWarn('Uninitialized rwlock in call to pthread_rwlock_tryrdlock');
   {$ENDIF}
   
   {$IFDEF SYSCALLS_CREATE_UNINITIALIZED}  
   {Initialize rwlock}
   Result:=pthread_rwlock_init(rwlock,nil);
   if Result <> 0 then Exit;
   {$ENDIF}  
  end;
 
 {Check Owner}
 if SynchronizerWriterOwner(TSynchronizerHandle(rwlock^)) = ThreadGetCurrent then
  begin
   Result:=EDEADLK;
  end
 else
  begin 
   {Try Lock Synchronizer}
   ResultCode:=SynchronizerReaderLockEx(TSynchronizerHandle(rwlock^),0);
   if ResultCode = ERROR_SUCCESS then
    begin
     Result:=0;
    end
   else if ResultCode = ERROR_WAIT_TIMEOUT then
    begin
     Result:=EBUSY;
    end;    
  end;
end;

{==============================================================================}

function pthread_rwlock_trywrlock(rwlock: Ppthread_rwlock_t): int; cdecl;
{Try to lock a read-write lock for writing}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ResultCode:LongWord;
begin
 {}
 Result:=EINVAL;
 
 {Check rwlock}
 if rwlock = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_rwlock_trywrlock (rwlock=' + IntToHex(rwlock^,8) + ')');
 {$ENDIF}
 
 {Check rwlock}
 if rwlock^ = PTHREAD_RWLOCK_INITIALIZER then
  begin
   {Initialize rwlock}
   Result:=pthread_rwlock_init(rwlock,nil);
   if Result <> 0 then Exit;
  end;
 
 {Check rwlock}
 if rwlock^ = 0 then
  begin
   {$IFDEF SYSCALLS_WARN_UNINITIALIZED}
   {Uninitialized rwlock}
   if PLATFORM_LOG_ENABLED then PlatformLogWarn('Uninitialized rwlock in call to pthread_rwlock_trywrlock');
   {$ENDIF}
   
   {$IFDEF SYSCALLS_CREATE_UNINITIALIZED}  
   {Initialize rwlock}
   Result:=pthread_rwlock_init(rwlock,nil);
   if Result <> 0 then Exit;
   {$ENDIF}  
  end;
 
 {Check Last}
 if SynchronizerReaderLast(TSynchronizerHandle(rwlock^)) = ThreadGetCurrent then
  begin
   Result:=EDEADLK;
  end
 else
  begin 
   {Try Lock Synchronizer}
   ResultCode:=SynchronizerWriterLockEx(TSynchronizerHandle(rwlock^),0);
   if ResultCode = ERROR_SUCCESS then
    begin
     Result:=0;
    end
   else if ResultCode = ERROR_WAIT_TIMEOUT then
    begin
     Result:=EBUSY;
    end;
  end;
end;

{==============================================================================}

function pthread_rwlock_unlock(rwlock: Ppthread_rwlock_t): int; cdecl;
{Unlock a read-write lock}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ResultCode:LongWord;
begin
 {}
 Result:=EINVAL;
 
 {Check rwlock}
 if rwlock = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_rwlock_unlock (rwlock=' + IntToHex(rwlock^,8) + ')');
 {$ENDIF}
 
 {Check rwlock}
 if rwlock^ = PTHREAD_RWLOCK_INITIALIZER then
  begin
   {Initialize rwlock}
   Result:=pthread_rwlock_init(rwlock,nil);
   if Result <> 0 then Exit;
  end;
 
 {Check rwlock}
 if rwlock^ = 0 then
  begin
   {$IFDEF SYSCALLS_WARN_UNINITIALIZED}
   {Uninitialized rwlock}
   if PLATFORM_LOG_ENABLED then PlatformLogWarn('Uninitialized rwlock in call to pthread_rwlock_unlock');
   {$ENDIF}
   
   {$IFDEF SYSCALLS_CREATE_UNINITIALIZED}  
   {Initialize rwlock}
   Result:=pthread_rwlock_init(rwlock,nil);
   if Result <> 0 then Exit;
   {$ENDIF}  
  end;
 
 {Check Owner}
 if SynchronizerWriterOwner(TSynchronizerHandle(rwlock^)) = ThreadGetCurrent then
  begin
   {Unlock Synchronizer}
   ResultCode:=SynchronizerWriterUnlock(TSynchronizerHandle(rwlock^));
   if ResultCode = ERROR_SUCCESS then
    begin
     Result:=0;
    end
   else if ResultCode = ERROR_NOT_LOCKED then
    begin
     Result:=EPERM;
    end    
   else if ResultCode = ERROR_NOT_OWNER then
    begin
     Result:=EPERM;
    end;
  end
 else
  begin
   {Unlock Synchronizer}
   ResultCode:=SynchronizerReaderUnlock(TSynchronizerHandle(rwlock^));
   if ResultCode = ERROR_SUCCESS then
    begin
     Result:=0;
    end
   else if ResultCode = ERROR_NOT_LOCKED then
    begin
     Result:=EPERM;
    end;
  end;  
end;

{==============================================================================}

function pthread_rwlockattr_init(attr: Ppthread_rwlockattr_t): int; cdecl;
{Initialize a read-write lock attributes entry}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check attr}
 if attr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_rwlockattr_init (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}
 
 {Init attr}
 attr^.is_initialized:=1;
 {$IFDEF _POSIX_THREAD_PROCESS_SHARED}
 attr^.process_shared:=PTHREAD_PROCESS_PRIVATE; 
 {$ENDIF}
 
 Result:=0;
end;

{==============================================================================}

function pthread_rwlockattr_destroy(attr: Ppthread_rwlockattr_t): int; cdecl;
{Destroy a read-write lock attributes entry}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check attr}
 if attr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_rwlockattr_destroy (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}
 
 {Destroy attr}
 attr^.is_initialized:=0;
 
 Result:=0;
end;

{==============================================================================}

function pthread_rwlockattr_getpshared(attr: Ppthread_rwlockattr_t; pshared: Pint): int; cdecl;
{Get the process-shared attribute of the read-write lock attributes entry}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check attr}
 if attr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_mutexattr_getpshared (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}
 
 {Check pshared}
 if pshared = nil then Exit;
 
 {$IFDEF _POSIX_THREAD_PROCESS_SHARED}
 {Get pshared}
 pshared^:=attr^.process_shared;
 
 Result:=0;
 {$ELSE}
 
 Result:=ENOSYS;
 {$ENDIF}
end;

{==============================================================================}

function pthread_rwlockattr_setpshared(attr: Ppthread_rwlockattr_t; pshared: int): int; cdecl;
{Set the process-shared attribute of the read-write lock attributes entry}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 {Check attr}
 if attr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_mutexattr_setpshared (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}
 
 {Check pshared}
 if (pshared <> PTHREAD_PROCESS_PRIVATE) and (pshared <> PTHREAD_PROCESS_SHARED) then Exit;
 
 {$IFDEF _POSIX_THREAD_PROCESS_SHARED}
 {Set pshared}
 attr^.process_shared:=pshared;
 
 Result:=0;
 {$ELSE}
 
 Result:=ENOSYS;
 {$ENDIF}
end;

{==============================================================================}

function pthread_setcancelstate(state: int; oldstate: Pint): int; cdecl;
{Set cancelability state for the current thread}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Flags:LongWord;
begin
 {}
 Result:=EINVAL;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_setcancelstate (state=' + IntToStr(state) + ')');
 {$ENDIF}
 
 {Check state}
 if (state < PTHREAD_CANCEL_ENABLE) or (state > PTHREAD_CANCEL_DISABLE) then Exit;
 
 {Get Flags}
 Flags:=ThreadGetFlags(ThreadGetCurrent);
 if (Flags and THREAD_FLAG_CANCEL_DISABLE) = 0 then
  begin
   {Cancel Enabled}
   {Get oldstate}
   if oldstate <> nil then oldstate^:=PTHREAD_CANCEL_ENABLE;
  
   {Check State}
   if state = PTHREAD_CANCEL_DISABLE then
    begin
     ThreadAddFlags(ThreadGetCurrent,THREAD_FLAG_CANCEL_DISABLE);
    end;
  end
 else
  begin
   {Cancel Disabled}
   {Get oldstate}
   if oldstate <> nil then oldstate^:=PTHREAD_CANCEL_DISABLE;

   {Check State}
   if state = PTHREAD_CANCEL_ENABLE then
    begin
     ThreadRemoveFlags(ThreadGetCurrent,THREAD_FLAG_CANCEL_DISABLE);
    end;
  end;  

 {Check Cancelled/Enabled/Asynchronous}
 Flags:=ThreadGetFlags(ThreadGetCurrent);
 if (Flags and (THREAD_FLAG_CANCELLED or THREAD_FLAG_CANCEL_DISABLE or THREAD_FLAG_CANCEL_ASYNCHRONOUS)) = (THREAD_FLAG_CANCELLED or THREAD_FLAG_CANCEL_ASYNCHRONOUS) then
  begin
   SyscallsPthreadEnd(PTHREAD_CANCELED);
  end;
  
 Result:=0; 
end;

{==============================================================================}

function pthread_setcanceltype(_type: int; oldtype: Pint): int; cdecl;
{Set cancelability type for the current thread}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Flags:LongWord;
begin
 {}
 Result:=EINVAL;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_setcanceltype (type=' + IntToStr(_type) + ')');
 {$ENDIF}
 
 {Check type}
 if (_type < PTHREAD_CANCEL_DEFERRED) or (_type > PTHREAD_CANCEL_ASYNCHRONOUS) then Exit;
 
 {Get Flags}
 Flags:=ThreadGetFlags(ThreadGetCurrent);
 if (Flags and THREAD_FLAG_CANCEL_ASYNCHRONOUS) = 0 then
  begin
   {Cancel Deferred}
   {Get oldtype}
   if oldtype <> nil then oldtype^:=PTHREAD_CANCEL_DEFERRED;
  
   {Check Type}
   if _type = PTHREAD_CANCEL_ASYNCHRONOUS then
    begin
     ThreadAddFlags(ThreadGetCurrent,THREAD_FLAG_CANCEL_ASYNCHRONOUS);
    end;
  end
 else
  begin
   {Cancel Asynchronous}
   {Get oldtype}
   if oldtype <> nil then oldtype^:=PTHREAD_CANCEL_ASYNCHRONOUS;

   {Check Type}
   if _type = PTHREAD_CANCEL_DEFERRED then
    begin
     ThreadRemoveFlags(ThreadGetCurrent,THREAD_FLAG_CANCEL_ASYNCHRONOUS);
    end;
  end;  

 {Check Cancelled/Enabled/Asynchronous}
 Flags:=ThreadGetFlags(ThreadGetCurrent);
 if (Flags and (THREAD_FLAG_CANCELLED or THREAD_FLAG_CANCEL_DISABLE or THREAD_FLAG_CANCEL_ASYNCHRONOUS)) = (THREAD_FLAG_CANCELLED or THREAD_FLAG_CANCEL_ASYNCHRONOUS) then
  begin
   SyscallsPthreadEnd(PTHREAD_CANCELED);
  end;
  
 Result:=0; 
end;

{==============================================================================}

procedure pthread_testcancel; cdecl;
{Test if the current thread is cancelled}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Flags:LongWord;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_testcancel');
 {$ENDIF}
 
 {Check Cancelled/Enabled}
 Flags:=ThreadGetFlags(ThreadGetCurrent);
 if (Flags and (THREAD_FLAG_CANCELLED or THREAD_FLAG_CANCEL_DISABLE)) = (THREAD_FLAG_CANCELLED) then
  begin
   SyscallsPthreadEnd(PTHREAD_CANCELED);
  end;
end;

{==============================================================================}
{==============================================================================}
{Syscalls Functions (Semaphore)}
function sem_close(sem: Psem_t): int; cdecl; 
{Close a named semaphore}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Entry:PHandleEntry;
 Handle:TSemaphoreHandle;
 ResultCode:LongWord;
begin
 {}
 Result:=-1;
 
 {Check sem}
 if sem = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls sem_close (sem=' + IntToHex(sem^,8) + ')');
 {$ENDIF}

 {Get Handle}
 Entry:=HandleGet(sem^);
 if Entry = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
   
   Exit;
  end;
 
 {Get Semaphore}
 Handle:=Entry^.Data;
 
 {Destroy Handle}
 ResultCode:=HandleDestroy(sem^);
 if ResultCode = ERROR_SUCCESS then
  begin
   {Destroy Semaphore}
   SemaphoreDestroy(Handle);
   
   {Update sem}
   sem^:=0;
   
   {Return Result}
   Result:=0;
  end
 else if ResultCode = ERROR_IN_USE then
  begin
   {Update sem}
   sem^:=0;
   
   {Return Result}
   Result:=0;
  end
 else
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
  end;
end;

{==============================================================================}

function sem_destroy(sem: Psem_t): int; cdecl;
{Destroy an unnamed semaphore}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Entry:PHandleEntry;
 Handle:TSemaphoreHandle;
 ResultCode:LongWord;
begin
 {}
 Result:=-1;
 
 {Check sem}
 if sem = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls sem_destroy (sem=' + IntToHex(sem^,8) + ')');
 {$ENDIF}
 
 {Get Handle}
 Entry:=HandleGet(sem^);
 if Entry = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
   
   Exit;
  end;
 
 {Get Semaphore}
 Handle:=Entry^.Data;
 
 {Destroy Handle}
 ResultCode:=HandleDestroy(sem^);
 if ResultCode = ERROR_SUCCESS then
  begin
   {Destroy Semaphore}
   SemaphoreDestroy(Handle);

   {Update sem}
   sem^:=0;
   
   {Return Result}
   Result:=0;
  end
 else if ResultCode = ERROR_IN_USE then
  begin
   {Update sem}
   sem^:=0;
   
   {Return Result}
   Result:=0;
  end
 else
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
  end;
end;

{==============================================================================}

function sem_getvalue(sem: Psem_t; sval: Pint): int; cdecl;
{Get the value of a semaphore}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Entry:PHandleEntry;
begin
 {}
 Result:=-1;
 
 {Check sem}
 if sem = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls sem_getvalue (sem=' + IntToHex(sem^,8) + ')');
 {$ENDIF}
 
 {Check sval}
 if sval = nil then Exit;

 {Get Handle}
 Entry:=HandleGet(sem^);
 if Entry = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
   
   Exit;
  end;
 
 {Get Semaphore Count}
 sval^:=SemaphoreCount(Entry^.Data);
 
 Result:=0;
end;

{==============================================================================}

function sem_init(sem: Psem_t; pshared: int; value: uint): int; cdecl;
{Initialize an unnamed semaphore}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Entry:PHandleEntry;
 Handle:TSemaphoreHandle;
begin
 {}
 Result:=-1;
 
 {Check sem}
 if sem = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls sem_init (sem=' + IntToHex(sem^,8) + ' value=' + IntToStr(value) + ')');
 {$ENDIF}
 
 {Note: pshared not used}
 
 {Check value}
 if value > SEM_VALUE_MAX then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
   
   Exit;
  end;
  
 {Create Semaphore}
 Handle:=SemaphoreCreate(value);
 if Handle = INVALID_HANDLE_VALUE then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
   
   Exit;
  end;
  
 {Create Handle}
 Entry:=HandleCreateEx('',HANDLE_FLAG_NONE,Handle,HANDLE_TYPE_SEMAPHORE);
 if Entry = nil then 
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
   
   Exit;
  end;
  
 {Return sem}
 sem^:=Entry^.Handle;
          
 Result:=0;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls sem_init (Result=' + IntToStr(Result) + ' sem=' + IntToHex(sem^,8) + ')');
 {$ENDIF}
end;

{==============================================================================}

function sem_open(name: PChar; oflag: int): Psem_t; cdecl;
{Initialize and open a named semaphore}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=sem_open_ext(name,oflag,0,0);
end;

{==============================================================================}

function sem_open_ext(name: PChar; oflag: int; mode: mode_t; value: uint): Psem_t; cdecl;
{Initialize and open a named semaphore}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Current:THandle;
 Entry:PHandleEntry;
 Handle:TSemaphoreHandle;
begin
 {}
 Result:=SEM_FAILED;
 
 {Check name}
 if name = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls sem_open_ext (name=' + StrPas(name) + ' oflag=' + IntToHex(oflag,8) + ' value=' + IntToStr(value) + ')');
 {$ENDIF}
 
 {Note: mode not used}
 
 {Open Handle}
 Current:=HandleOpen(name);
 if Current = INVALID_HANDLE_VALUE then
  begin
   {Check Flags}
   if (oflag and O_CREAT) = 0 then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=ENOENT;
     
     Exit;
    end;
    
   {Check value}
   if value > SEM_VALUE_MAX then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EINVAL;
     
     Exit;
    end;
  
   {Create Semaphore}
   Handle:=SemaphoreCreate(value);
   if Handle = INVALID_HANDLE_VALUE then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EINVAL;
     
     Exit;
    end;
    
   {Create Handle}
   Entry:=HandleCreateEx(name,HANDLE_FLAG_NAMED,Handle,HANDLE_TYPE_SEMAPHORE);
   if Entry = nil then 
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EINVAL;
     
     Exit;
    end;
   
   {Return Result}
   Result:=@Entry^.Handle;
  end
 else 
  begin
   {Check Type}
   Entry:=HandleGet(Current);
   if (Entry <> nil) and (Entry^.HandleType <> HANDLE_TYPE_SEMAPHORE) then
    begin
     {Close Handle}
     HandleClose(Current);
     
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EACCES;
     
     Exit;
    end;
   
   {Check Flags}
   if (oflag and (O_CREAT or O_EXCL)) = (O_CREAT or O_EXCL) then
    begin
     {Close Handle}
     HandleClose(Current);
     
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EEXIST;
     
     Exit;
    end;
   
   {Return Result}
   Result:=@Entry^.Handle;
  end;
end;

{==============================================================================}

function sem_post(sem: Psem_t): int; cdecl;
{Unlock (Signal) a semaphore}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Entry:PHandleEntry;
begin
 {}
 Result:=-1;
 
 {Check sem}
 if sem = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls sem_post (sem=' + IntToHex(sem^,8) + ')');
 {$ENDIF}
 
 {Get Handle}
 Entry:=HandleGet(sem^);
 if Entry = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
   
   Exit;
  end;
 
 {Post Semaphore}
 if SemaphoreSignal(Entry^.Data) <> ERROR_SUCCESS then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
   
   Exit;
  end;
  
 Result:=0; 
end;

{==============================================================================}

function sem_timedwait(sem: Psem_t; abs_timeout: Ptimespec): int; cdecl;
{Lock (Wait for) a semaphore with a timeout}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Entry:PHandleEntry;
 Timeout:LongWord;
 Current:Ttimespec;
 Relative:Ttimespec;
 ResultCode:LongWord;
begin
 {}
 Result:=-1;
 
 {Check sem}
 if sem = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls sem_timedwait (sem=' + IntToHex(sem^,8) + ')');
 {$ENDIF}
 
 {Check abs timeout}
 if abs_timeout = nil then Exit;
 
 {Get Timeout}
 Timeout:=INFINITE;
 if clock_gettime(CLOCK_REALTIME,@Current) = 0 then
  begin
   Relative.tv_nsec:=abs_timeout^.tv_nsec - Current.tv_nsec;
   Relative.tv_sec:=abs_timeout^.tv_sec - Current.tv_sec;
   if Relative.tv_nsec < 0 then
    begin
     Relative.tv_nsec:=Relative.tv_nsec + 1000000000;
     Relative.tv_sec:=Relative.tv_sec - 1;
    end;
    
   if Relative.tv_sec < 0 then Exit;
   
   Timeout:=(Relative.tv_sec * 1000) + (Relative.tv_nsec div 1000000);
  end;
 
 {Get Handle}
 Entry:=HandleGet(sem^);
 if Entry = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
   
   Exit;
  end;
 
 {Wait Semaphore}
 ResultCode:=SemaphoreWaitEx(Entry^.Data,Timeout);
 if ResultCode = ERROR_SUCCESS then
  begin
   Result:=0;
  end
 else if ResultCode = ERROR_WAIT_TIMEOUT then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=ETIMEDOUT;
  end
 else
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
  end;
end;

{==============================================================================}

function sem_trywait(sem: Psem_t): int; cdecl;
{Try to lock (Wait for) a semaphore}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Entry:PHandleEntry;
 ResultCode:LongWord;
begin
 {}
 Result:=-1;
 
 {Check sem}
 if sem = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls sem_trywait (sem=' + IntToHex(sem^,8) + ')');
 {$ENDIF}
 
 {Get Handle}
 Entry:=HandleGet(sem^);
 if Entry = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
   
   Exit;
  end;
 
 {Wait Semaphore}
 ResultCode:=SemaphoreWaitEx(Entry^.Data,0);
 if ResultCode = ERROR_SUCCESS then
  begin
   Result:=0;
  end
 else if ResultCode = ERROR_WAIT_TIMEOUT then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EAGAIN;
  end
 else
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
  end;
end;

{==============================================================================}

function sem_unlink(name: PChar): int; cdecl;
{Remove a named semaphore}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Entry:PHandleEntry;
 Handle:TSemaphoreHandle;
 ResultCode:LongWord;
begin
 {}
 Result:=-1;
 
 {Check name}
 if name = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls sem_unlink (name=' + StrPas(name) + ')');
 {$ENDIF}
 
 {Find Handle}
 Entry:=HandleFind(name);
 if Entry = nil then 
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=ENOENT;
   
   Exit;
  end;
  
 {Get Semaphore}
 Handle:=Entry^.Data;
 
 {Destroy Handle}
 ResultCode:=HandleDestroy(Entry^.Handle);
 if ResultCode = ERROR_SUCCESS then
  begin
   {Destroy Semaphore}
   SemaphoreDestroy(Handle);
   
   {Return Result}
   Result:=0;
  end
 else if ResultCode = ERROR_IN_USE then
  begin
   {Return Result}
   Result:=0;
  end
 else
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
  end;
end;

{==============================================================================}

function sem_wait(sem: Psem_t): int; cdecl;
{Lock (Wait for) a semaphore}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Entry:PHandleEntry;
begin
 {}
 Result:=-1;
 
 {Check sem}
 if sem = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls sem_wait (sem=' + IntToHex(sem^,8) + ')');
 {$ENDIF}
 
 {Get Handle}
 Entry:=HandleGet(sem^);
 if Entry = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
   
   Exit;
  end;
 
 {Wait Semaphore}
 if SemaphoreWait(Entry^.Data) <> ERROR_SUCCESS then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
   
   Exit;
  end;
 
 Result:=0;
end;

{==============================================================================}
{==============================================================================}
{Syscalls Functions (Sockets)}
{$IFDEF SYSCALLS_EXPORT_SOCKETS}
function socket_get_error(error: int): int;
{Map a Socket error to a POSIX error}

{Note: Internal function, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;
 
 case error of
  {Windows Sockets definitions of regular Microsoft C error constants}
  WSAEINTR..WSAEMFILE:Result:=error - WSABASEERR;
  
  {Windows Sockets definitions of regular Berkeley error constants}
  WSAEWOULDBLOCK:Result:=EWOULDBLOCK;
  WSAEINPROGRESS:Result:=EINPROGRESS;
  WSAEALREADY:Result:=EALREADY;
  WSAENOTSOCK:Result:=ENOTSOCK;
  WSAEDESTADDRREQ:Result:=EDESTADDRREQ;
  WSAEMSGSIZE:Result:=EMSGSIZE;
  WSAEPROTOTYPE:Result:=EPROTOTYPE;
  WSAENOPROTOOPT:Result:=ENOPROTOOPT;
  WSAEPROTONOSUPPORT:Result:=EPROTONOSUPPORT;
  WSAESOCKTNOSUPPORT:Result:=ESOCKTNOSUPPORT;
  WSAEOPNOTSUPP:Result:=EOPNOTSUPP;
  WSAEPFNOSUPPORT:Result:=EPFNOSUPPORT;
  WSAEAFNOSUPPORT:Result:=EAFNOSUPPORT;
  WSAEADDRINUSE:Result:=EADDRINUSE;
  WSAEADDRNOTAVAIL:Result:=EADDRNOTAVAIL;
  WSAENETDOWN:Result:=ENETDOWN;
  WSAENETUNREACH:Result:=ENETUNREACH;
  WSAENETRESET:Result:=ENETRESET;
  WSAECONNABORTED:Result:=ECONNABORTED;
  WSAECONNRESET:Result:=ECONNRESET;
  WSAENOBUFS:Result:=ENOBUFS;
  WSAEISCONN:Result:=EISCONN;
  WSAENOTCONN:Result:=ENOTCONN;
  WSAESHUTDOWN:Result:=ESHUTDOWN;
  WSAETOOMANYREFS:Result:=ETOOMANYREFS;
  WSAETIMEDOUT:Result:=ETIMEDOUT;
  WSAECONNREFUSED:Result:=ECONNREFUSED;
  WSAELOOP:Result:=ELOOP;
  WSAENAMETOOLONG:Result:=ENAMETOOLONG;
  WSAEHOSTDOWN:Result:=EHOSTDOWN;
  WSAEHOSTUNREACH:Result:=EHOSTUNREACH;
  WSAENOTEMPTY:Result:=ENOTEMPTY;
  WSAEPROCLIM:Result:=EPROCLIM;
  WSAEUSERS:Result:=EUSERS;
  WSAEDQUOT:Result:=EDQUOT;
  WSAESTALE:Result:=ESTALE;
  WSAEREMOTE:Result:=EREMOTE;
  WSAEDISCON:Result:=ENOTCONN;
  
  {Extended Windows Sockets error constant definitions}
  WSASYSNOTREADY:Result:=EIO;
  WSAVERNOTSUPPORTED:Result:=ENOTSUP;
  WSANOTINITIALISED:Result:=EIO;
  
  WSAENOMORE:Result:=ENOMEM;
  WSAECANCELLED:Result:=ECANCELED;
  WSAEINVALIDPROCTABLE:Result:=EINVAL;
  WSAEINVALIDPROVIDER:Result:=EINVAL;
  WSAEPROVIDERFAILEDINIT:Result:=EFAULT;
  WSASYSCALLFAILURE:Result:=EFAULT;
  WSASERVICE_NOT_FOUND:Result:=ESRCH;
  WSATYPE_NOT_FOUND:Result:=ESRCH;
  WSA_E_NO_MORE:Result:=ENOMEM;
  WSA_E_CANCELLED:Result:=ECANCELED;
  WSAEREFUSED:Result:=ECONNREFUSED;
 end;
end;

{==============================================================================}

function socket_accept(socket: int; address: psockaddr; address_len: Psocklen_t): int; cdecl;
{Accept a new connection on a socket}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls accept (socket=' + IntToHex(socket,8) + ' address=' + PtrToHex(address) + ' address_len=' + PtrToHex(address_len) + ')');
 {$ENDIF}
 
 Result:=fpaccept(socket,address,psocklen(address_len));
 if Result = SOCKET_ERROR then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=socket_get_error(SocketError());
  end;
end;

{==============================================================================}

function socket_bind(socket: int; address: psockaddr; address_len: socklen_t): int; cdecl;
{Bind a name to a socket}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls bind (socket=' + IntToHex(socket,8) + ' address=' + PtrToHex(address) + ' address_len=' + IntToStr(address_len) + ')');
 {$ENDIF}
 
 Result:=fpbind(socket,address,address_len);
 if Result = SOCKET_ERROR then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=socket_get_error(SocketError());
  end;
end;

{==============================================================================}

function socket_connect(socket: int; address: psockaddr; address_len: socklen_t): int; cdecl;
{Connect a socket}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls connect (socket=' + IntToHex(socket,8) + ' address=' + PtrToHex(address) + ' address_len=' + IntToStr(address_len) + ')');
 {$ENDIF}
 
 Result:=fpconnect(socket,address,address_len);
 if Result = SOCKET_ERROR then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=socket_get_error(SocketError());
  end;
end;

{==============================================================================}

function socket_getpeername(socket: int; address: psockaddr; address_len: Psocklen_t): int; cdecl;
{Get the name of the peer socket}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls getpeername (socket=' + IntToHex(socket,8) + ' address=' + PtrToHex(address) + ' address_len=' + PtrToHex(address_len) + ')');
 {$ENDIF}
 
 Result:=fpgetpeername(socket,address,psocklen(address_len));
 if Result = SOCKET_ERROR then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=socket_get_error(SocketError());
  end;
end;

{==============================================================================}

function socket_getsockname(socket: int; address: psockaddr; address_len: Psocklen_t): int; cdecl;
{Get the socket name}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls getsockname (socket=' + IntToHex(socket,8) + ' address=' + PtrToHex(address) + ' address_len=' + PtrToHex(address_len) + ')');
 {$ENDIF}
 
 Result:=fpgetsockname(socket,address,psocklen(address_len));
 if Result = SOCKET_ERROR then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=socket_get_error(SocketError());
  end;
end;

{==============================================================================}

function socket_getsockopt(socket: int; level, option_name: int; option_value: Pointer; option_len: Psocklen_t): int; cdecl;
{Get the socket options}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls getsockopt (socket=' + IntToHex(socket,8) + ' level=' + IntToStr(level) + ' option_name=' + IntToStr(option_name) + ' option_value=' + PtrToHex(option_value) + ' option_len=' + PtrToHex(option_len) + ')');
 {$ENDIF}
 
 Result:=fpgetsockopt(socket,level,option_name,option_value,psocklen(option_len));
 if Result = SOCKET_ERROR then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=socket_get_error(SocketError());
  end;
end;

{==============================================================================}

function socket_listen(socket: int; backlog: int): int; cdecl;
{Listen for socket connections and limit the queue of incoming connections}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls listen (socket=' + IntToHex(socket,8) + ' backlog=' + IntToStr(backlog) + ')');
 {$ENDIF}
 
 Result:=fplisten(socket,backlog);
 if Result = SOCKET_ERROR then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=socket_get_error(SocketError());
  end;
end;

{==============================================================================}

function socket_recv(socket: int; buffer: Pointer; len: size_t; flags: int): ssize_t; cdecl;
{Receive a message from a connected socket}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls recv (socket=' + IntToHex(socket,8) + ' buffer=' + PtrToHex(buffer) + ' len=' + IntToStr(len) + ' flags=' + IntToHex(flags,8) + ')');
 {$ENDIF}
 
 Result:=fprecv(socket,buffer,len,flags);
 if Result = SOCKET_ERROR then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=socket_get_error(SocketError());
  end;
end;

{==============================================================================}

function socket_recvfrom(socket: int; buffer: Pointer; len: size_t; flags: int; address: psockaddr; address_len: Psocklen_t): ssize_t; cdecl;
{Receive a message from a socket}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls recv (socket=' + IntToHex(socket,8) + ' buffer=' + PtrToHex(buffer) + ' len=' + IntToStr(len) + ' flags=' + IntToHex(flags,8) + ' address=' + PtrToHex(address) + ' address_len=' + PtrToHex(address_len) + ')');
 {$ENDIF}
 
 Result:=fprecvfrom(socket,buffer,len,flags,address,psocklen(address_len));
 if Result = SOCKET_ERROR then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=socket_get_error(SocketError());
  end;
end;

{==============================================================================}

function socket_send(socket: int; buffer: Pointer; len: size_t; flags: int): ssize_t; cdecl;
{Send a message on a socket}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls send (socket=' + IntToHex(socket,8) + ' buffer=' + PtrToHex(buffer) + ' len=' + IntToStr(len) + ' flags=' + IntToHex(flags,8) + ')');
 {$ENDIF}
 
 Result:=fpsend(socket,buffer,len,flags);
 if Result = SOCKET_ERROR then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=socket_get_error(SocketError());
  end;
end;

{==============================================================================}

function socket_sendto(socket: int; buffer: Pointer; len: size_t; flags: int; dest_addr: psockaddr; dest_len: socklen_t): ssize_t; cdecl;
{Send a message on a socket}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls sendto (socket=' + IntToHex(socket,8) + ' buffer=' + PtrToHex(buffer) + ' len=' + IntToStr(len) + ' flags=' + IntToHex(flags,8) + ' dest_addr=' + PtrToHex(dest_addr) + ' dest_len=' + IntToStr(dest_len) + ')');
 {$ENDIF}
 
 Result:=fpsendto(socket,buffer,len,flags,dest_addr,dest_len);
 if Result = SOCKET_ERROR then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=socket_get_error(SocketError());
  end;
end;

{==============================================================================}

function socket_setsockopt(socket: int; level, option_name: int; option_value: Pointer; option_len: socklen_t): int; cdecl;
{Set the socket options}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls setsockopt (socket=' + IntToHex(socket,8) + ' level=' + IntToStr(level) + ' option_name=' + IntToStr(option_name) + ' option_value=' + PtrToHex(option_value) + ' option_len=' + IntToStr(option_len) + ')');
 {$ENDIF}
 
 Result:=fpsetsockopt(socket,level,option_name,option_value,option_len);
 if Result = SOCKET_ERROR then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=socket_get_error(SocketError());
  end;
end;

{==============================================================================}

function socket_shutdown(socket: int; how: int): int; cdecl;
{Shut down socket send and receive operations}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls shutdown (socket=' + IntToHex(socket,8) + ' how=' + IntToStr(how) + ')');
 {$ENDIF}
 
 Result:=fpshutdown(socket,how);
 if Result = SOCKET_ERROR then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=socket_get_error(SocketError());
  end;
end;

{==============================================================================}

function socket_socket(domain, sockettype, protocol: int): int; cdecl;
{Create an endpoint for communication}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls socket (domain=' + IntToStr(domain) + ' type=' + IntToStr(sockettype) + ' protocol=' + IntToStr(protocol) + ')');
 {$ENDIF}
 
 Result:=fpsocket(domain,sockettype,protocol);
 if Result = Integer(INVALID_SOCKET) then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=socket_get_error(SocketError());
  end;
end;

{==============================================================================}

function socket_socketpair(domain, sockettype, protocol: int; socket_vector: Pint): int; cdecl;
{Create a pair of connected sockets}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls socketpair (domain=' + IntToStr(domain) + ' type=' + IntToStr(sockettype) + ' protocol=' + IntToStr(protocol) + ' socket_vector=' + PtrToHex(socket_vector) + ')');
 {$ENDIF}
 
 Result:=fpsocketpair(domain,sockettype,protocol,socket_vector);
 if Result = SOCKET_ERROR then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=socket_get_error(SocketError());
  end;
end;

{==============================================================================}

function socket_select(nfds: int; readfds, writefds, exceptfds: Pfd_set; timeout: Ptimeval): int; cdecl;
{Perform synchronous I/O multiplexing on one or more sockets}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls socket (nfds=' + IntToStr(nfds) + ')');
 {$ENDIF}
 
 Result:=fpselect(nfds,readfds,writefds,exceptfds,timeout);
 if Result = SOCKET_ERROR then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=socket_get_error(SocketError());
  end;
end;

{==============================================================================}

function socket_htonl(hostlong: uint32_t): uint32_t; cdecl;
{Convert values between host and network byte order}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=htonl(hostlong);
end;

{==============================================================================}

function socket_htons(hostshort: uint16_t): uint16_t; cdecl;
{Convert values between host and network byte order}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=htons(hostshort);
end;

{==============================================================================}

function socket_ntohl(netlong: uint32_t): uint32_t; cdecl;
{Convert values between host and network byte order}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=ntohl(netlong);
end;

{==============================================================================}

function socket_ntohs(netshort: uint16_t): uint16_t; cdecl;
{Convert values between host and network byte order}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=ntohs(netshort);
end;

{==============================================================================}

function socket_inet_addr(cp: PChar): in_addr_t; cdecl;
{IPv4 address manipulation}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=Inet_Addr(cp);
end;
{==============================================================================}

function socket_inet_ntoa(inaddr: TInAddr): PChar; cdecl;
{IPv4 address manipulation}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=Inet_Ntoa(inaddr);
end;

{==============================================================================}

function socket_inet_aton(cp: PChar; inaddr: PInAddr): int; cdecl;
{IPv4 address manipulation}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=Inet_Aton(cp,inaddr);
end;

{==============================================================================}

function socket_inet_pton(af: int; src: PChar; dst: Pointer): int; cdecl;
{Convert IPv4 and IPv6 addresses from text to binary form}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=Inet_Pton(af,src,dst);
end;

{==============================================================================}

function socket_inet_ntop(af: int; src: Pointer; dst: PChar; size: socklen_t): PChar; cdecl;
{Convert IPv4 and IPv6 addresses from binary to text form}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=Inet_Ntop(af,src,dst,size);
end;

{==============================================================================}

function socket_gethostbyaddr(addr: Pointer; len: socklen_t; family: int): PHostEnt; cdecl;
{Network host database functions}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 //To Do //Resolve the discrepency in field sizes between PHostEnt from Winsock and hostent from POSIX (short versus int)
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls getservbyport (addr=' + PtrToHex(addr) + ' len=' + IntToStr(len) + ' family=' + IntToStr(family) + ')');
 {$ENDIF}
 
 Result:=GetHostByAddr(addr,len,family);
end;

{==============================================================================}

function socket_gethostbyname(name: PChar): PHostEnt; cdecl;
{Network host database functions}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 //To Do //Resolve the discrepency in field sizes between PHostEnt from Winsock and hostent from POSIX (short versus int)
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls gethostbyname (name=' + StrPas(name) + ')');
 {$ENDIF}
 
 Result:=GetHostByName(name);
end;

{==============================================================================}

function socket_getnetbyaddr(net: uint32_t; family: int): PNetEnt; cdecl;
{Network database functions}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Addr:TInAddr;
begin
 {}
 //To Do //Resolve the discrepency in field sizes between PNetEnt from Winsock and netent from POSIX (short versus int)
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls getservbyport (net=' + IntToHex(net,8) + ' family=' + IntToStr(family) + ')');
 {$ENDIF}
 
 Addr.S_addr:=htonl(net);
 
 Result:=GetNetByAddr(@Addr,SizeOf(TInAddr),family);
end;

{==============================================================================}

function socket_getnetbyname(name: PChar): PNetEnt; cdecl;
{Network database functions}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 //To Do //Resolve the discrepency in field sizes between PNetEnt from Winsock and netent from POSIX (short versus int)
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls getnetbyname (name=' + StrPas(name) + ')');
 {$ENDIF}
 
 Result:=GetNetByName(name);
end;

{==============================================================================}

function socket_getservbyport(port: int; proto: PChar): PServEnt; cdecl;
{Network services database functions}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 //To Do //Resolve the discrepency in field sizes between PServEnt from Winsock and servent from POSIX (short versus int)
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls getservbyport (port=' + IntToStr(port) + ' proto=' + StrPas(proto) + ')');
 {$ENDIF}
 
 Result:=GetServByPort(port,proto);
end;

{==============================================================================}

function socket_getservbyname(name, proto: PChar): PServEnt; cdecl;
{Network services database functions}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 //To Do //Resolve the discrepency in field sizes between PServEnt from Winsock and servent from POSIX (short versus int)
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls getservbyname (name=' + StrPas(name) + ' proto=' + StrPas(proto) + ')');
 {$ENDIF}
 
 Result:=GetServByName(name,proto);
end;

{==============================================================================}

function socket_getprotobynumber(proto: int): PProtoEnt; cdecl;
{Network protocol database functions}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 //To Do //Resolve the discrepency in field sizes between PProtoEnt from Winsock and protoent from POSIX (short versus int)
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls getprotobynumber (proto=' + IntToStr(proto) + ')');
 {$ENDIF}
 
 Result:=GetProtoByNumber(proto);
end;

{==============================================================================}

function socket_getprotobyname(name: PChar): PProtoEnt; cdecl;
{Network protocol database functions}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 //To Do //Resolve the discrepency in field sizes between PProtoEnt from Winsock and protoent from POSIX (short versus int)
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls getprotobyname (name=' + StrPas(name) + ')');
 {$ENDIF}
 
 Result:=GetProtoByName(name);
end;

{==============================================================================}

function socket_getaddrinfo(node: PChar; service: PChar; hints: PAddrInfo; var res: PAddrInfo): int; cdecl;
{Network address and service translation}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls getaddrinfo (node=' + StrPas(node) + ' service=' + StrPas(service) + ')');
 {$ENDIF}
 
 Result:=GetAddrInfo(node,service,hints,res);
end;

{==============================================================================}

function socket_getnameinfo(addr: PSockAddr; addrlen: socklen_t; host: PChar; hostlen: socklen_t; serv: PChar; servlen: socklen_t; flags: int): int; cdecl;
{Address-to-name  translation  in protocol-independent manner}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls getnameinfo');
 {$ENDIF}
 
 Result:=GetNameInfo(addr,addrlen,host,hostlen,serv,servlen,flags);
end;

{==============================================================================}

procedure socket_freeaddrinfo(res: PAddrInfo); cdecl;
{Network address and service translation}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls freeaddrinfo');
 {$ENDIF}
 
 FreeAddrInfo(res);
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{Syscalls Functions (Setjmp)}
function _setjmp(var env: jmp_buf): int; cdecl;
{Save information about the calling environment for later use by _longjmp}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _setjmp');
 {$ENDIF}
 
 Result:=setjmp(env);
end;

{==============================================================================}

procedure _longjmp(var env: jmp_buf; val: int); cdecl;
{Uses the information saved in env to transfer control back to the point where _setjmp was called}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _longjmp');
 {$ENDIF}
 
 longjmp(env,val);
end;
       
{==============================================================================}
{==============================================================================}
{Syscalls Functions (Non Standard)}
procedure msleep(msecs: uint); cdecl;
{Sleep for a specified number of milliseconds}

{Note: Does not support interruption by signal}
{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls msleep (msecs=' + IntToStr(msecs) + ')');
 {$ENDIF}
 
 ThreadSleep(msecs);
end;

{==============================================================================}
{==============================================================================}
{Syscalls Helper Functions}
procedure __malloc_lock(ptr: P_reent); cdecl;
{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 {Check reent}
 if ptr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls __malloc_lock (ptr=' + PtrToHex(ptr) + ')');
 {$ENDIF}
 
 {Lock Mutex}
 MutexLock(SyscallsMallocLock);
end;

{==============================================================================}

procedure __malloc_unlock(ptr: P_reent); cdecl;
{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 {Check reent}
 if ptr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls __malloc_unlock (ptr=' + PtrToHex(ptr) + ')');
 {$ENDIF}

 {Unlock Mutex}
 MutexUnlock(SyscallsMallocLock);
end;

{==============================================================================}

procedure __env_lock(ptr: P_reent); cdecl;
{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 {Check reent}
 if ptr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls __env_lock (ptr=' + PtrToHex(ptr) + ')');
 {$ENDIF}

 {Lock Mutex}
 MutexLock(SyscallsEnvLock);
end;

{==============================================================================}

procedure __env_unlock(ptr: P_reent); cdecl;
{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 {Check reent}
 if ptr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls __env_unlock (ptr=' + PtrToHex(ptr) + ')');
 {$ENDIF}

 {Unlock Mutex}
 MutexUnlock(SyscallsEnvLock);
end;

{==============================================================================}
{==============================================================================}
{Syscalls Macro Functions (Ioctl)}
function _IOC(dir,_type,nr,size: LongWord): LongWord;
begin
 {}
 Result:=(dir shl _IOC_DIRSHIFT) or (_type shl _IOC_TYPESHIFT) or (nr shl _IOC_NRSHIFT) or (size shl _IOC_SIZESHIFT);
end;

{==============================================================================}

function _IO(_type,nr: LongWord): LongWord;
begin
 {}
 Result:=_IOC(_IOC_NONE,_type,nr,0);
end;

{==============================================================================}

function _IOR(_type,nr,size: LongWord): LongWord;
begin
 {}
 Result:=_IOC(_IOC_READ,_type,nr,size);
end;

{==============================================================================}

function _IOW(_type,nr,size: LongWord): LongWord;
begin
 {}
 Result:=_IOC(_IOC_WRITE,_type,nr,size);
end;

{==============================================================================}

function _IOWR(_type,nr,size: LongWord): LongWord;
begin
 {}
 Result:=_IOC(_IOC_READ or _IOC_WRITE,_type,nr,size);
end;

{==============================================================================}

function _IOC_DIR(nr: LongWord): LongWord;
begin
 {}
 Result:=(nr shr _IOC_DIRSHIFT) and _IOC_DIRMASK;
end; 

{==============================================================================}

function _IOC_TYPE(nr: LongWord): LongWord;
begin
 {}
 Result:=(nr shr _IOC_TYPESHIFT) and _IOC_TYPEMASK;
end; 

{==============================================================================}

function _IOC_NR(nr: LongWord): LongWord;
begin
 {}
 Result:=(nr shr _IOC_NRSHIFT) and _IOC_NRMASK;
end; 

{==============================================================================}

function _IOC_SIZE(nr: LongWord): LongWord;
begin
 {}
 Result:=(nr shr _IOC_SIZESHIFT) and _IOC_SIZEMASK;
end; 

{==============================================================================}
{==============================================================================}
{Syscalls Internal Functions}
function SyscallsGetStat(Handle:THandle;stat:Pstat):Boolean; 
var
 Attributes:Integer;
 CreateTime:SysUtils.FILETIME;
 AccessTime:SysUtils.FILETIME;
 WriteTime:SysUtils.FILETIME;
begin
 {}
 Result:=False;
 
 {Check Handle}
 if Handle = INVALID_HANDLE_VALUE then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Get Stat (Handle=' + HandleToHex(Handle) + ')');
 {$ENDIF}
 
 {Check stat}
 if stat = nil then Exit;

 {Get stat}
 FillChar(stat^,SizeOf(Tstat),0);
 stat^.st_mode:=_S_IFREG;
 Attributes:=FSFileGetAttrEx(Handle);
 if (Attributes <> -1) and ((Attributes and faDirectory) <> 0) then
  begin
   stat^.st_mode:=_S_IFDIR;
  end;
 stat^.st_mode:=stat^.st_mode or _S_IREAD or _S_IWRITE or S_IEXEC;
 stat^.st_size:=FSFileSize(Handle);
 if FSGetFileTime(Handle,@CreateTime,@AccessTime,@WriteTime) then
  begin
   stat^.st_ctime:=(Int64(CreateTime) - TIME_TICKS_TO_1970) div TIME_TICKS_PER_SECOND;
   stat^.st_atime:=(Int64(AccessTime) - TIME_TICKS_TO_1970) div TIME_TICKS_PER_SECOND;
   stat^.st_mtime:=(Int64(WriteTime) - TIME_TICKS_TO_1970) div TIME_TICKS_PER_SECOND;
  end;
 
 {Return Result}
 Result:=True; 
end;

{==============================================================================}

function SyscallsGetStat64(Handle:THandle;stat64:Pstat64):Boolean; 
var
 Attributes:Integer;
 CreateTime:SysUtils.FILETIME;
 AccessTime:SysUtils.FILETIME;
 WriteTime:SysUtils.FILETIME;
begin
 {}
 Result:=False;
 
 {Check Handle}
 if Handle = INVALID_HANDLE_VALUE then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Get Stat64 (Handle=' + HandleToHex(Handle) + ')');
 {$ENDIF}
 
 {Check stat64}
 if stat64 = nil then Exit;
 
 {Get stat64}
 FillChar(stat64^,SizeOf(Tstat64),0);
 stat64^.st_mode:=_S_IFREG;
 Attributes:=FSFileGetAttrEx(Handle);
 if (Attributes <> -1) and ((Attributes and faDirectory) <> 0) then
  begin
   stat64^.st_mode:=_S_IFDIR;
  end;
 stat64^.st_mode:=stat64^.st_mode or _S_IREAD or _S_IWRITE or S_IEXEC;
 stat64^.st_size:=FSFileSize(Handle);
 if FSGetFileTime(Handle,@CreateTime,@AccessTime,@WriteTime) then
  begin
   stat64^.st_ctime:=(Int64(CreateTime) - TIME_TICKS_TO_1970) div TIME_TICKS_PER_SECOND;
   stat64^.st_atime:=(Int64(AccessTime) - TIME_TICKS_TO_1970) div TIME_TICKS_PER_SECOND;
   stat64^.st_mtime:=(Int64(WriteTime) - TIME_TICKS_TO_1970) div TIME_TICKS_PER_SECOND;
  end;
 
 {Return Result}
 Result:=True; 
end;

{==============================================================================}

function SyscallsGetEntry(Number:LongWord):PSyscallsEntry; 
var
 First:PSyscallsEntry;
 Next:PSyscallsEntry;
begin
 {}
 Result:=nil;
 
 {Check Number}
 if Number > SYSCALLS_TABLE_MAX then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Get Entry (Number=' + IntToStr(Number) + ')');
 {$ENDIF}
 
 {Lock Table}
 if MutexLock(SyscallsTableLock) <> ERROR_SUCCESS then Exit;
 
 {Get First}
 First:=SyscallsTable.Entries[Number and SYSCALLS_TABLE_MASK];
 if First <> nil then
  begin
   Next:=First;
   while Next <> nil do
    begin
     {Check Number}
     if Next^.Number = Number then
      begin
       Result:=Next;
       Break;
      end; 
     
     Next:=Next^.Next; 
    end; 
  end;  
 
 {Unlock Table}
 MutexUnlock(SyscallsTableLock);
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Get Entry (Result=' + PtrToHex(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function SyscallsAddEntry(Handle:THandle):PSyscallsEntry; 

 procedure SyscallsIncrementNext;
 begin
  {Update Next}
  Inc(SyscallsTable.Next);
  
  {Check Next}
  if SyscallsTable.Next > SYSCALLS_TABLE_MAX then
   begin
    SyscallsTable.Next:=SYSCALLS_TABLE_MIN;
   end;
  
  {Check Next}
  if SyscallsTable.Next < SYSCALLS_TABLE_MIN then
   begin
    SyscallsTable.Next:=SYSCALLS_TABLE_MIN;
   end;
 end;
 
var
 Start:LongWord;
 First:PSyscallsEntry;
 Next:PSyscallsEntry;
begin
 {}
 Result:=nil;
 
 {Check Handle}
 if Handle = INVALID_HANDLE_VALUE then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Add Entry (Handle=' + HandleToHex(Handle) + ')');
 {$ENDIF}
 
 {Lock Table}
 if MutexLock(SyscallsTableLock) <> ERROR_SUCCESS then Exit;

 {Get Start}
 Start:=SyscallsTable.Next;
 
 {Find Next}
 Next:=SyscallsGetEntry(SyscallsTable.Next);
 while Next <> nil do
  begin
   {Increment Next}
   SyscallsIncrementNext;
   
   {Check Next}
   if SyscallsTable.Next = Start then Break;
   
   {Find Next}
   Next:=SyscallsGetEntry(SyscallsTable.Next);
  end;
  
 {Check Next}
 if Next = nil then
  begin
   {Create Entry}
   Next:=AllocMem(SizeOf(TSyscallsEntry));
   if Next <> nil then 
    begin
     {Update Entry}
     Next^.Number:=SyscallsTable.Next;
     Next^.Handle:=Handle;
     Next^.Prev:=nil;
     
     {Get First}
     First:=SyscallsTable.Entries[Next^.Number and SYSCALLS_TABLE_MASK];
     
     {Link Entry}
     Next^.Next:=First;
     if First <> nil then First^.Prev:=Next;
     SyscallsTable.Entries[Next^.Number and SYSCALLS_TABLE_MASK]:=Next;
     
     {Increment Count}
     Inc(SyscallsTable.Count);
     
     {Increment Next}
     SyscallsIncrementNext;
     
     {$IFDEF SYSCALLS_DEBUG}
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Add Entry Number=' + IntToStr(Next^.Number));
     {$ENDIF}
     
     {Return Result}
     Result:=Next;
    end; 
  end;  
 
 {Unlock Table}
 MutexUnlock(SyscallsTableLock);
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Add Entry (Result=' + PtrToHex(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function SyscallsRemoveEntry(Entry:PSyscallsEntry):Boolean;
var
 Prev:PSyscallsEntry;
 Next:PSyscallsEntry;
begin
 {}
 Result:=False;
 
 {Check Entry}
 if Entry = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Remove Entry (Entry=' + PtrToHex(Entry) + ')');
 {$ENDIF}
 
 {Lock Table}
 if MutexLock(SyscallsTableLock) <> ERROR_SUCCESS then Exit;
 
 {Get Prev/Next}
 Prev:=Entry^.Prev;
 Next:=Entry^.Next;
 
 {Unlink Entry}
 if Prev = nil then
  begin
   SyscallsTable.Entries[Entry^.Number and SYSCALLS_TABLE_MASK]:=Next;
   if Next <> nil then
    begin
     Next^.Prev:=nil;
    end;       
  end
 else
  begin
   Prev^.Next:=Next;
   if Next <> nil then
    begin
     Next^.Prev:=Prev;
    end;       
  end;     

 {Decrement Count}
 Dec(SyscallsTable.Count);
 
 {Destroy Entry}
 FreeMem(Entry);
 
 {Return Result}
 Result:=True;
 
 {Unlock Table}
 MutexUnlock(SyscallsTableLock);
end;

{==============================================================================}

function SyscallsInitializeHeap:Boolean; 
var
 PageTableEntry:TPageTableEntry;
begin
 {}
 Result:=False;
 
 {Check Page Size}
 if MEMORY_PAGE_SIZE = 0 then Exit;
 
 {Check Block Size (Must be a power of 2)}
 if (SYSCALLS_HEAP_BLOCKSIZE = 0) or ((SYSCALLS_HEAP_BLOCKSIZE and (SYSCALLS_HEAP_BLOCKSIZE - 1)) <> 0) then
  begin
   {Default to 1MB}
   SYSCALLS_HEAP_BLOCKSIZE:=SIZE_1M;
  end;
  
 {Check Block Size (Must be at least page size)} 
 if SYSCALLS_HEAP_BLOCKSIZE < MEMORY_PAGE_SIZE then
  begin
   {Default to Page Size}
   SYSCALLS_HEAP_BLOCKSIZE:=MEMORY_PAGE_SIZE;
  end;
 
 {Check Block Base (Must be a multiple of page size)}
 if (SYSCALLS_HEAP_BLOCKSIZE mod MEMORY_PAGE_SIZE) <> 0 then
  begin
   SYSCALLS_HEAP_BLOCKSIZE:=SYSCALLS_HEAP_BLOCKSIZE - (SYSCALLS_HEAP_BLOCKSIZE mod MEMORY_PAGE_SIZE);
   if SYSCALLS_HEAP_BLOCKSIZE = 0 then SYSCALLS_HEAP_BLOCKSIZE:=MEMORY_PAGE_SIZE;
  end;
  
 {Check Heap Min (Must be a multiple of block size)}
 if (SYSCALLS_HEAP_MIN mod SYSCALLS_HEAP_BLOCKSIZE) <> 0 then
  begin
   SYSCALLS_HEAP_MIN:=SYSCALLS_HEAP_MIN - (SYSCALLS_HEAP_MIN mod SYSCALLS_HEAP_BLOCKSIZE);
   if SYSCALLS_HEAP_MIN = 0 then SYSCALLS_HEAP_MIN:=SYSCALLS_HEAP_BLOCKSIZE;
  end;
  
 {Check Heap Max (Must be a multiple of block size)}
 if (SYSCALLS_HEAP_MAX mod SYSCALLS_HEAP_BLOCKSIZE) <> 0 then
  begin
   SYSCALLS_HEAP_MAX:=SYSCALLS_HEAP_MAX - (SYSCALLS_HEAP_MAX mod SYSCALLS_HEAP_BLOCKSIZE);
   if SYSCALLS_HEAP_MAX = 0 then SYSCALLS_HEAP_MAX:=SYSCALLS_HEAP_BLOCKSIZE;
  end;
 
 {Check Heap Base (Must be a multiple of page size)}
 if (SYSCALLS_HEAP_BASE mod MEMORY_PAGE_SIZE) <> 0 then
  begin
   SYSCALLS_HEAP_BASE:=SYSCALLS_HEAP_BASE - (SYSCALLS_HEAP_BASE mod MEMORY_PAGE_SIZE);
  end;
 
 {Create First Block}
 SyscallsHeapFirst:=AllocMem(SizeOf(TSyscallsHeapBlock));
 if SyscallsHeapFirst = nil then
  begin
   if PLATFORM_LOG_ENABLED then PlatformLogError('Failed to create Syscalls Heap block');
   Exit;
  end;

 {Allocate First Block}
 SyscallsHeapFirst^.PhysicalAddress:=PtrUInt(GetAlignedMem(SYSCALLS_HEAP_MIN,MEMORY_PAGE_SIZE));
 if SyscallsHeapFirst^.PhysicalAddress = 0 then
  begin
   if PLATFORM_LOG_ENABLED then PlatformLogError('Failed to allocate Syscalls Heap block');
   Exit;
  end;
  
 {Check Heap Base}
 if SYSCALLS_HEAP_BASE = 0 then
  begin
   {Static Heap}
   {Update Block}
   SyscallsHeapFirst^.VirtualAddress:=SyscallsHeapFirst^.PhysicalAddress;
   SyscallsHeapFirst^.Size:=SYSCALLS_HEAP_MIN;
   SyscallsHeapFirst^.Used:=0;
   SyscallsHeapFirst^.Prev:=nil;
   SyscallsHeapFirst^.Next:=nil;
  end
 else
  begin
   {Dynamic Heap}
   {Check Block}
   PageTableGetEntry(SyscallsHeapFirst^.PhysicalAddress,PageTableEntry);
   if PageTableEntry.Size <> MEMORY_PAGE_SIZE then
    begin
     {Map Block}
     PageTableEntry.Size:=MEMORY_PAGE_SIZE;
     while PageTableEntry.PhysicalAddress < (SyscallsHeapFirst^.PhysicalAddress + SYSCALLS_HEAP_MIN) do
      begin
       PageTableSetEntry(PageTableEntry);
       
       Inc(PageTableEntry.VirtualAddress,MEMORY_PAGE_SIZE);
       Inc(PageTableEntry.PhysicalAddress,MEMORY_PAGE_SIZE);
      end;
    end;
   
   {Remap Block}
   PageTableGetEntry(SyscallsHeapFirst^.PhysicalAddress,PageTableEntry);
   PageTableEntry.VirtualAddress:=SYSCALLS_HEAP_BASE;
   PageTableEntry.Size:=MEMORY_PAGE_SIZE;
   while PageTableEntry.VirtualAddress < (SYSCALLS_HEAP_BASE + SYSCALLS_HEAP_MIN) do
    begin
     PageTableSetEntry(PageTableEntry);
     
     Inc(PageTableEntry.VirtualAddress,MEMORY_PAGE_SIZE);
     Inc(PageTableEntry.PhysicalAddress,MEMORY_PAGE_SIZE);
    end; 
   
   {Clean Cache}
   CleanDataCacheRange(SyscallsHeapFirst^.PhysicalAddress,SYSCALLS_HEAP_MIN);
   
   {Invalidate Cache}
   InvalidateDataCacheRange(SyscallsHeapFirst^.VirtualAddress,SYSCALLS_HEAP_MIN);
   
   {Update Block}
   SyscallsHeapFirst^.VirtualAddress:=SYSCALLS_HEAP_BASE;
   SyscallsHeapFirst^.Size:=SYSCALLS_HEAP_MIN;
   SyscallsHeapFirst^.Used:=0;
   SyscallsHeapFirst^.Prev:=nil;
   SyscallsHeapFirst^.Next:=nil;
  end;

 {Get Last Block}
 SyscallsHeapLast:=SyscallsHeapFirst;

 {Get Size and End}
 SyscallsHeapEnd:=Pointer(SyscallsHeapFirst^.VirtualAddress);
 SyscallsHeapSize:=SyscallsHeapFirst^.Size;
 
 {Initialize Lock}
 SyscallsHeapLock:=MutexCreateEx(False,MUTEX_DEFAULT_SPINCOUNT,MUTEX_FLAG_RECURSIVE);
 if SyscallsHeapLock = INVALID_HANDLE_VALUE then
  begin
   if PLATFORM_LOG_ENABLED then PlatformLogError('Failed to create Syscalls Heap lock');
   Exit;
  end;
 
 Result:=True;
end;

{==============================================================================}

function SyscallsIncreaseHeap(Size:LongWord):Pointer;
var
 Remain:LongWord;
 Address:Pointer;
 Prev:PSyscallsHeapBlock;
 Block:PSyscallsHeapBlock;
 PageTableEntry:TPageTableEntry;
begin
 {}
 Result:=nil;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Increase Heap (Size=' + IntToStr(Size) + ')');
 {$ENDIF}
 
 {Lock Heap}
 if MutexLock(SyscallsHeapLock) <> ERROR_SUCCESS then Exit;
 
 {Check Base}
 if SYSCALLS_HEAP_BASE = 0 then
  begin
   {Static Heap}
   {Get Last Block}
   Block:=SyscallsHeapLast;
   if Block <> nil then
    begin
     {$IFDEF SYSCALLS_DEBUG}
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  Block.PhysicalAddress=' + AddrToHex(Block^.PhysicalAddress));
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  Block.Size=' + IntToStr(Block^.Size));
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  Block.Used=' + IntToStr(Block^.Used));
     {$ENDIF}

     {Check Block Used}
     if (Block^.Used + Size) <= Block^.Size then
      begin
       {Return End}
       Result:=SyscallsHeapEnd;
       
       {Update Used}
       Inc(Block^.Used,Size);
       
       {Update End}
       Inc(SyscallsHeapEnd,Size);
      end; 
      
     {$IFDEF SYSCALLS_DEBUG}
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  HeapEnd=' + PtrToHex(SyscallsHeapEnd));
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  HeapSize=' + IntToStr(SyscallsHeapSize));
     {$ENDIF}
    end;  
  end
 else
  begin
   {Dynamic Heap}
   Address:=nil;
   
   {Get Last Block}
   Block:=SyscallsHeapLast;
   while Block <> nil do
    begin
     {$IFDEF SYSCALLS_DEBUG}
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  Block.PhysicalAddress=' + AddrToHex(Block^.PhysicalAddress));
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  Block.VirtualAddress=' + AddrToHex(Block^.VirtualAddress));
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  Block.Size=' + IntToStr(Block^.Size));
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  Block.Used=' + IntToStr(Block^.Used));
     {$ENDIF}
    
     {Get Remain}
     Remain:=Size;
     
     {Check Block Used}
     if (Block^.Used + Remain) > Block^.Size then
      begin
       {Update Remain}
       Remain:=Block^.Size - Block^.Used;
      end;
     
     {Check Remain}     
     if Remain > 0 then
      begin
       {Get End}
       if Address = nil then Address:=SyscallsHeapEnd;
       
       {Update Used}
       Inc(Block^.Used,Remain);
       
       {Update End}
       Inc(SyscallsHeapEnd,Remain);
       
       {$IFDEF SYSCALLS_DEBUG}
       if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  HeapEnd=' + PtrToHex(SyscallsHeapEnd));
       if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  HeapSize=' + IntToStr(SyscallsHeapSize));
       {$ENDIF}
       
       {Update Size}
       Dec(Size,Remain);
       
       {Check Complete}
       if Size = 0 then Break;
      end
     else
      begin
       {Add New Block}
       {$IFDEF SYSCALLS_DEBUG}
       if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls New Heap Block');
       {$ENDIF}
       
       {Check Max}
       if SyscallsHeapSize >= SYSCALLS_HEAP_MAX then
        begin
         {Failure}
         Address:=nil;
         Break;
        end; 
       
       {Get Prev}
       Prev:=Block;
       
       {Create Block}
       Block:=AllocMem(SizeOf(TSyscallsHeapBlock));
       if Block = nil then
        begin
         {Failure}
         Address:=nil;
         Break;
        end; 

       {Allocate Block}
       Block^.PhysicalAddress:=PtrUInt(GetAlignedMem(SYSCALLS_HEAP_BLOCKSIZE,MEMORY_PAGE_SIZE));
       if Block^.PhysicalAddress = 0 then
        begin
         {Failure}
         Address:=nil;
         Break;
        end; 
       
       {Check Block}
       PageTableGetEntry(Block^.PhysicalAddress,PageTableEntry);
       if PageTableEntry.Size <> MEMORY_PAGE_SIZE then
        begin
         {Map Block}
         PageTableEntry.Size:=MEMORY_PAGE_SIZE;
         while PageTableEntry.PhysicalAddress < (Block^.PhysicalAddress + SYSCALLS_HEAP_BLOCKSIZE) do
          begin
           PageTableSetEntry(PageTableEntry);
           
           Inc(PageTableEntry.VirtualAddress,MEMORY_PAGE_SIZE);
           Inc(PageTableEntry.PhysicalAddress,MEMORY_PAGE_SIZE);
          end;
        end;
       
       {Remap Block}
       PageTableGetEntry(Block^.PhysicalAddress,PageTableEntry);
       PageTableEntry.VirtualAddress:=PtrUInt(SyscallsHeapEnd);
       PageTableEntry.Size:=MEMORY_PAGE_SIZE;
       while PageTableEntry.VirtualAddress < (PtrUInt(SyscallsHeapEnd) + SYSCALLS_HEAP_BLOCKSIZE) do
        begin
         PageTableSetEntry(PageTableEntry);
         
         Inc(PageTableEntry.VirtualAddress,MEMORY_PAGE_SIZE);
         Inc(PageTableEntry.PhysicalAddress,MEMORY_PAGE_SIZE);
        end; 
       
       {Clean Cache}
       CleanDataCacheRange(Block^.PhysicalAddress,SYSCALLS_HEAP_BLOCKSIZE);
       
       {Invalidate Cache}
       InvalidateDataCacheRange(Block^.VirtualAddress,SYSCALLS_HEAP_BLOCKSIZE);
       
       {Update Block}
       Block^.VirtualAddress:=PtrUInt(SyscallsHeapEnd);
       Block^.Size:=SYSCALLS_HEAP_BLOCKSIZE;
       Block^.Used:=0;
       Block^.Prev:=Prev;
       Block^.Next:=nil;
       
       {Link Block}
       Prev^.Next:=Block;
       SyscallsHeapLast:=Block;
       
       {Update Size}
       Inc(SyscallsHeapSize,SYSCALLS_HEAP_BLOCKSIZE);
       
       {$IFDEF SYSCALLS_DEBUG}
       if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  HeapEnd=' + PtrToHex(SyscallsHeapEnd));
       if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  HeapSize=' + IntToStr(SyscallsHeapSize));
       {$ENDIF}
      end;
    end; 
    
   {Return End} 
   Result:=Address;
  end;
 
 {Unlock Heap}
 MutexUnlock(SyscallsHeapLock);
end;

{==============================================================================}

function SyscallsDecreaseHeap(Size:LongWord):Pointer; 
var
 Block:PSyscallsHeapBlock;
begin
 {}
 Result:=nil;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Decrease Heap (Size=' + IntToStr(Size) + ')');
 {$ENDIF}
 
 {Lock Heap}
 if MutexLock(SyscallsHeapLock) <> ERROR_SUCCESS then Exit;
 
 {Check Base}
 if SYSCALLS_HEAP_BASE = 0 then
  begin
   {Static Heap}
   {Get Last Block}
   Block:=SyscallsHeapLast;
   if Block <> nil then
    begin
     {Check Block Used}
     if Block^.Used >= Size then
      begin
       {Return End}
       Result:=SyscallsHeapEnd;
       
       {Update Used}
       Dec(Block^.Used,Size);
       
       {Update End}
       Dec(SyscallsHeapEnd,Size);
      end; 
      
     {$IFDEF SYSCALLS_DEBUG}
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  HeapEnd=' + PtrToHex(SyscallsHeapEnd));
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  HeapSize=' + IntToStr(SyscallsHeapSize));
     {$ENDIF}
    end;  
  end
 else
  begin
   {Dynamic Heap}
   {Get Last Block}
   Block:=SyscallsHeapLast;
   if Block <> nil then
    begin
     {Check Block Used}
     if Block^.Used >= Size then
      begin
       {Return End}
       Result:=SyscallsHeapEnd;
       
       {Update Used}
       Dec(Block^.Used,Size);
       
       {Update End}
       Dec(SyscallsHeapEnd,Size);
      end; 
     {Do not allow decrease beyond the last block} 
     
     {$IFDEF SYSCALLS_DEBUG}
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  HeapEnd=' + PtrToHex(SyscallsHeapEnd));
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  HeapSize=' + IntToStr(SyscallsHeapSize));
     {$ENDIF}
    end;  
  end;
 
 {Unlock Heap}
 MutexUnlock(SyscallsHeapLock);
end;

{==============================================================================}

function SyscallsGetPthread:PSyscallsPthread; 
var
 Pthread:PSyscallsPthread;
begin
 {}
 Result:=nil;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Get Pthread (Thread=' + HandleToHex(ThreadGetCurrent) + ')');
 {$ENDIF}
 
 {Get TLS Value}
 Pthread:=ThreadGetTlsValue(SyscallsPThreadIndex);
 if Pthread = nil then
  begin
   {Allocate TLS Value}
   Pthread:=AllocMem(SyscallsPthreadSize);
   if Pthread = nil then Exit;
   
   {$IFDEF SYSCALLS_DEBUG}
   if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Get Pthread (Allocated Pthread=' + PtrToHex(Pthread) + ')');
   {$ENDIF}
   
   {Set TLS Value}
   if ThreadSetTlsValue(SyscallsPThreadIndex,Pthread) <> ERROR_SUCCESS then Exit;

   {Initialize Pthread structure} 
   Pthread^.Cleanup:=nil;
  end; 
 
 {Return Result}
 Result:=Pthread;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Get Pthread (Result=' + PtrToHex(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function SyscallsPthreadStart(Data:PSyscallsPthreadData):PtrInt;
var
 Routine:Tpthread_start_routine;
 Arg:Pointer;
 Value:Pointer;
begin
 {}
 Result:=0;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Pthread Start (Thread=' + HandleToHex(ThreadGetCurrent) + ' Data=' + PtrToHex(Data) + ')');
 {$ENDIF}
 
 {Save the Parameters}
 Routine:=Data^.Routine;
 Arg:=Data^.Arg;
 
 {Free the Data}
 FreeMem(Data);
 
 if Assigned(Routine) then
  begin
   {Call Start Function}
   Value:=Routine(Arg);
   
   {Call Thread End}
   SyscallsPthreadEnd(Value);
  end; 
end;

{==============================================================================}

procedure SyscallsPthreadEnd(Value:Pointer);
var
 Count:LongWord;
 Data:Pointer;
 Pthread:PSyscallsPthread;
 Cleanup:PSyscallsPthreadCleanup;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Pthread End (Thread=' + HandleToHex(ThreadGetCurrent) + ' Value=' + PtrToHex(Value) + ')');
 {$ENDIF}

 {Call Key Destructors}
 for Count:=0 to THREAD_TLS_MAXIMUM - 1 do
  begin
   {Check Key Destructor}
   if Assigned(SyscallsKeyDestructor[Count]) then
    begin
     {Get TLS Value}
     Data:=ThreadGetTlsValue(Count);
     if Data <> nil then
      begin
       {Clear TLS Value}
       ThreadSetTlsValue(Count,nil);
      
       {$IFDEF SYSCALLS_DEBUG}
       if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Pthread End (Key=' + IntToHex(Count,8) + ' Destructor=' + PtrToHex(SyscallsKeyDestructor[Count]) + ' Data=' + PtrToHex(Data) + ')');
       {$ENDIF}
      
       {Call Key Destructor}
       SyscallsKeyDestructor[Count](Data);
      end;
    end;
  end;
 
 {Get Pthread}
 Pthread:=SyscallsGetPthread;
 if Pthread <> nil then
  begin
   {Call Cleanup Handlers}
   Cleanup:=Pthread^.Cleanup;
   while Cleanup <> nil do
    begin
     {$IFDEF SYSCALLS_DEBUG}
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Pthread End (Cleanup=' + PtrToHex(Cleanup) + ' Routine=' + PtrToHex(Cleanup^.Routine) + ' Arg=' + PtrToHex(Cleanup^.Arg) + ')');
     {$ENDIF}

     {Check Routine}
     if Assigned(Cleanup^.Routine) then
      begin
       {Call Routine}
       Cleanup^.Routine(Cleanup^.Arg);
      end;
      
     {Remove Cleanup}
     Pthread^.Cleanup:=Cleanup^.Next;
   
     {Free Cleanup} 
     FreeMem(Cleanup);
     
     {Get Next}
     Cleanup:=Pthread^.Cleanup;
    end;
   
   {Clear TLS Value}
   ThreadSetTlsValue(SyscallsPThreadIndex,nil);
   
   {Free TLS Value}
   FreeMem(Pthread);
  end;  
 
 {Call End Thread}
 EndThread(PtrUInt(Value));
end;

{==============================================================================}
{==============================================================================}

initialization
 SyscallsInit;

{==============================================================================}
 
finalization
 SyscallsQuit;

{==============================================================================}
{==============================================================================}

end.
 