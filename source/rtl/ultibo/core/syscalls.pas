{
Ultibo Newlib C Library Syscalls interface unit.

Copyright (C) 2016 - Paul Jervois.
Copyright (C) 2016 - SoftOz Pty Ltd.

Arch
====

 <All>

Boards
======

 <All>

Licence
=======

 LGPLv2.1 with static linking exception (See COPYING.modifiedLGPL.txt)
 
Credits
=======

 Information for this unit was obtained from:
 
References
==========

  Newlib - http://www.sourceware.org/newlib/

  Libc - https://www.sourceware.org/newlib/libc.html
  
  Libm - https://www.sourceware.org/newlib/libm.html
  
Syscalls
========

 This unit provides the system calls (syscalls) interface for the Newlib C library implementation
 to allow code compiled with GCC to be linked with Ultibo applications.
 
 The Newlib C library is a portable C library designed to be used in embedded environments as well
 as many other situations. It is made available by RedHat from the sourceware.org website, new
 releases are made at least yearly and this unit has been developed using 2.4.0 but should 
 work mostly unchanged with future releases.
 
 The build process below creates the libc.a, libm.a and libg.a static libraries, in addition
 to those GCC also requires the libgcc.a support library which is built at the same time as
 the compiler and provided in the distribution. 
 
 The build process is documented for Debian but should be translatable to other platforms. As
 documented this will produce a version of Newlib that has support for recursive library calls,
 has dynamic support for multiple threads and is compiled for the specific architectures that
 are supported by Ultibo.
 
 Note that Newlib supports code compiled with other C compilers so it should be completely 
 possible to link code generated by other C compilers with Ultibo applications. At this
 stage it has only been tested with GCC.
  
 Building Newlib:
 
  Flags: REENTRANT_SYSCALLS_PROVIDED
         __DYNAMIC_REENT__
         __LARGE64_FILES (Note: Not currently supported by Newlib, need to modify \newlib\configure.host to enable stdio64 support for arm-none-eabi or aarch64-none-elf)
      
  Options: 
  
   Raspberry Pi
   
    -mabi=aapcs
    -marm
    -march=armv6
    -mcpu=arm1176jzf-s
    -mfpu=vfp
    -mfloat-abi=hard
   
   Raspberry Pi2/3 and QEMU VersatilePB (32-bit)

    -mabi=aapcs
    -marm
    -march=armv7-a
    -mfpu=vfpv3-d16
    -mfloat-abi=hard
   
   Raspberry Pi3 and QEMU VersatilePB (64-bit)
   
    -mabi=lp64 (Note: Supported only by later versions of GCC)
    -march=armv8-a
    
  Build:
  
   Download Newlib (currently 2.4.0) from ftp://sourceware.org/pub/newlib/index.html
   
   Unpack to folder $HOME/newlib-2.4.0
  
  Build ARMv6: 
   
   cd
   
   mkdir build-newlib-armv6
   
   cd build-newlib-armv6
   
   export PATH=$HOME/gcc-arm-none-eabi-5_4-2016q2/bin:$PATH
   
   ../newlib-2.4.0/configure --disable-multilib --target=arm-none-eabi CFLAGS_FOR_TARGET="-O2 -mabi=aapcs -marm -march=armv6 -mfpu=vfp -mfloat-abi=hard -DREENTRANT_SYSCALLS_PROVIDED -D__DYNAMIC_REENT__"
   
   make all
   
   Dump:
    
    cd arm-none-eabi/newlib
    arm-none-eabi-objdump -d libc.a > libc.list
    arm-none-eabi-objdump -d libg.a > libg.list
    arm-none-eabi-objdump -d libm.a > libm.list
    
  Build ARMv7: 
   
   cd
 
   mkdir build-newlib-armv7
 
   cd build-newlib-armv7
 
   export PATH=$HOME/gcc-arm-none-eabi-5_4-2016q2/bin:$PATH
 
   ../newlib-2.4.0/configure --disable-multilib --target=arm-none-eabi CFLAGS_FOR_TARGET="-O2 -mabi=aapcs -marm -march=armv7-a -mfpu=vfpv3-d16 -mfloat-abi=hard -DREENTRANT_SYSCALLS_PROVIDED -D__DYNAMIC_REENT__"
   
   make all
   
   Dump:
   
    cd arm-none-eabi/newlib
    arm-none-eabi-objdump -d libc.a > libc.list
    arm-none-eabi-objdump -d libg.a > libg.list
    arm-none-eabi-objdump -d libm.a > libm.list
   
  Build ARMv8: 
       
   cd
 
   mkdir build-newlib-armv8
 
   cd build-newlib-armv8
  
   export PATH=$HOME/gcc-linaro-aarch64-none-elf-4.8-2014.04_linux/bin:$PATH
  
   ../newlib-2.4.0/configure --disable-multilib --target=aarch64-none-elf CFLAGS_FOR_TARGET="-O2 -march=armv8-a -DREENTRANT_SYSCALLS_PROVIDED -D__DYNAMIC_REENT__"
  
   make all
  
   Dump:
   
    cd aarch64-none-elf/newlib
    aarch64-none-elf-objdump -d libc.a > libc.list
    aarch64-none-elf-objdump -d libg.a > libg.list
    aarch64-none-elf-objdump -d libm.a > libm.list
  
 Notes:
 
  File handles (fd) passed to and returned from this unit are int values which are 32-bit
  however internally Newlib stores these into the _file member of a _FILE structure (see
  below) and this is defined as short which is only 16-bit. Because of this we have to map
  each Ultibo handle to a TSyscallsEntry and use the functions SyscallsAddEntry, 
  SyscallsRemoveEntry and SyscallsGetEntry which start at zero and increment to 65535.
  
  The global errno variable (not used for reentrant version ) is defined in 
  \newlib\libc\reent\reent.c 
   
   int errno;
   
  The global environ variable is defined in  
  \newlib\libc\stdlib\environ.c 
  
   char **environ = &initial_env[0];
   
  The TZ environment variable is used by a number of functions in Newlib including tzset and
  strftime. This variable can be set on the command line or using the SetEnvironmentVariable()
  function in the Ultibo unit. See the GNU C library reference for details of the format and
  value of the TZ environment variable:
  
   https://www.gnu.org/software/libc/manual/html_node/TZ-Variable.html
  
}

{--$mode delphi} {Default to Delphi compatible syntax} {Not compatible with external definitions below}
{$mode objfpc} 
{$H+}          {Default to AnsiString}
{$inline on}   {Allow use of Inline procedures}

unit Syscalls;

interface

uses GlobalConfig,GlobalConst,GlobalTypes,Platform,Threads,HeapManager,Devices,FileSystem,Sockets,SysUtils;

//To Do //Sockets support
        //Pthreads support
        //Libstdc++ support
        
{==============================================================================}
{Global definitions}
{$INCLUDE GlobalDefines.inc}

{$packrecords C} 

{==============================================================================}
const
 {Syscalls specific constants}
 
 {Basic constants}
 {From limits.h}
 INT_MAX  = 2147483647;
 INT_MIN  = -INT_MAX - 1;
 UINT_MAX = (INT_MAX * 2) + 1;
 
 LONG_MAX  = {$ifdef CPU64}9223372036854775807{$else CPU64}2147483647{$endif CPU64};
 LONG_MIN  = -LONG_MAX - 1;
 ULONG_MAX = (LONG_MAX * 2) + 1; 
 
const 
 {Newlib constants from sys/errno.h}
 EPERM             = 1;       // Not owner
 ENOENT            = 2;       // No such file or directory
 ESRCH             = 3;       // No such process
 EINTR             = 4;       // Interrupted system call
 EIO               = 5;       // I/O error
 ENXIO             = 6;       // No such device or address
 E2BIG             = 7;       // Arg list too long
 ENOEXEC           = 8;       // Exec format error
 EBADF             = 9;       // Bad file number
 ECHILD            = 10;      // No children
 EAGAIN            = 11;      // No more processes
 ENOMEM            = 12;      // Not enough space
 EACCES            = 13;      // Permission denied
 EFAULT            = 14;      // Bad address
 ENOTBLK           = 15;      // Block device required
 EBUSY             = 16;      // Device or resource busy
 EEXIST            = 17;      // File exists
 EXDEV             = 18;      // Cross-device link
 ENODEV            = 19;      // No such device
 ENOTDIR           = 20;      // Not a directory
 EISDIR            = 21;      // Is a directory
 EINVAL            = 22;      // Invalid argument
 ENFILE            = 23;      // Too many open files in system
 EMFILE            = 24;      // File descriptor value too large
 ENOTTY            = 25;      // Not a character device
 ETXTBSY           = 26;      // Text file busy
 EFBIG             = 27;      // File too large
 ENOSPC            = 28;      // No space left on device
 ESPIPE            = 29;      // Illegal seek
 EROFS             = 30;      // Read-only file system
 EMLINK            = 31;      // Too many links
 EPIPE             = 32;      // Broken pipe
 EDOM              = 33;      // Mathematics argument out of domain of function
 ERANGE            = 34;      // Result too large
 ENOMSG            = 35;      // No message of desired type
 EIDRM             = 36;      // Identifier removed
 ECHRNG            = 37;      // Channel number out of range
 EL2NSYNC          = 38;      // Level 2 not synchronized
 EL3HLT            = 39;      // Level 3 halted
 EL3RST            = 40;      // Level 3 reset
 ELNRNG            = 41;      // Link number out of range
 EUNATCH           = 42;      // Protocol driver not attached
 ENOCSI            = 43;      // No CSI structure available
 EL2HLT            = 44;      // Level 2 halted
 EDEADLK           = 45;      // Deadlock
 ENOLCK            = 46;      // No lock
 EBADE             = 50;      // Invalid exchange
 EBADR             = 51;      // Invalid request descriptor
 EXFULL            = 52;      // Exchange full
 ENOANO            = 53;      // No anode
 EBADRQC           = 54;      // Invalid request code
 EBADSLT           = 55;      // Invalid slot
 EDEADLOCK         = 56;      // File locking deadlock error
 EBFONT            = 57;      // Bad font file fmt
 ENOSTR            = 60;      // Not a stream
 ENODATA           = 61;      // No data (for no delay io)
 ETIME             = 62;      // Stream ioctl timeout
 ENOSR             = 63;      // No stream resources
 ENONET            = 64;      // Machine is not on the network
 ENOPKG            = 65;      // Package not installed
 EREMOTE           = 66;      // The object is remote
 ENOLINK           = 67;      // Virtual circuit is gone
 EADV              = 68;      // Advertise error
 ESRMNT            = 69;      // Srmount error
 ECOMM             = 70;      // Communication error on send
 EPROTO            = 71;      // Protocol error
 EMULTIHOP         = 74;      // Multihop attempted
 ELBIN             = 75;      // Inode is remote (not really error)
 EDOTDOT           = 76;      // Cross mount point (not really error)
 EBADMSG           = 77;      // Bad message
 EFTYPE            = 79;      // Inappropriate file type or format
 ENOTUNIQ          = 80;      // Given log. name not unique
 EBADFD            = 81;      // f.d. invalid for this operation
 EREMCHG           = 82;      // Remote address changed
 ELIBACC           = 83;      // Can't access a needed shared lib
 ELIBBAD           = 84;      // Accessing a corrupted shared lib
 ELIBSCN           = 85;      // .lib section in a.out corrupted
 ELIBMAX           = 86;      // Attempting to link in too many libs
 ELIBEXEC          = 87;      // Attempting to exec a shared library
 ENOSYS            = 88;      // Function not implemented
 ENMFILE           = 89;      // No more files
 ENOTEMPTY         = 90;      // Directory not empty
 ENAMETOOLONG      = 91;      // File or path name too long
 ELOOP             = 92;      // Too many symbolic links
 EOPNOTSUPP        = 95;      // Operation not supported on socket
 EPFNOSUPPORT      = 96;      // Protocol family not supported
 ECONNRESET        = 104;     // Connection reset by peer
 ENOBUFS           = 105;     // No buffer space available
 EAFNOSUPPORT      = 106;     // Address family not supported by protocol family
 EPROTOTYPE        = 107;     // Protocol wrong type for socket
 ENOTSOCK          = 108;     // Socket operation on non-socket
 ENOPROTOOPT       = 109;     // Protocol not available
 ESHUTDOWN         = 110;     // Can't send after socket shutdown
 ECONNREFUSED      = 111;     // Connection refused
 EADDRINUSE        = 112;     // Address already in use
 ECONNABORTED      = 113;     // Software caused connection abort
 ENETUNREACH       = 114;     // Network is unreachable
 ENETDOWN          = 115;     // Network interface is not configured
 ETIMEDOUT         = 116;     // Connection timed out
 EHOSTDOWN         = 117;     // Host is down
 EHOSTUNREACH      = 118;     // Host is unreachable
 EINPROGRESS       = 119;     // Connection already in progress
 EALREADY          = 120;     // Socket already connected
 EDESTADDRREQ      = 121;     // Destination address required
 EMSGSIZE          = 122;     // Message too long
 EPROTONOSUPPORT   = 123;     // Unknown protocol
 ESOCKTNOSUPPORT   = 124;     // Socket type not supported
 EADDRNOTAVAIL     = 125;     // Address not available
 ENETRESET         = 126;     // Connection aborted by network
 EISCONN           = 127;     // Socket is already connected
 ENOTCONN          = 128;     // Socket is not connected
 ETOOMANYREFS      = 129;
 EPROCLIM          = 130;
 EUSERS            = 131;
 EDQUOT            = 132;
 ESTALE            = 133;
 ENOTSUP           = 134;     // Not supported
 ENOMEDIUM         = 135;     // No medium (in tape drive)
 ENOSHARE          = 136;     // No such host or network path
 ECASECLASH        = 137;     // Filename exists with different case
 EILSEQ            = 138;     // Illegal byte sequence
 EOVERFLOW         = 139;     // Value too large for defined data type
 ECANCELED         = 140;     // Operation canceled
 ENOTRECOVERABLE   = 141;     // State not recoverable
 EOWNERDEAD        = 142;     // Previous owner died
 ESTRPIPE          = 143;     // Streams pipe error
 EWOULDBLOCK       = EAGAIN;  // Operation would block

 __ELASTERROR      = 2000;    // Users can add values starting here
 
const 
 {Newlib constants from sys/stat.h}
 _IFMT             = $0170000; // type of file
 _IFDIR            = $0040000; // directory
 _IFCHR            = $0020000; // character special
 _IFBLK            = $0060000; // block special
 _IFREG            = $0100000; // regular
 _IFLNK            = $0120000; // symbolic link
 _IFSOCK           = $0140000; // socket
 _IFIFO            = $0010000; // fifo

 S_BLKSIZE         = 1024;     // size of a block

 S_ISUID           = $0004000; // set user id on execution
 S_ISGID           = $0002000; // set group id on execution
 S_ISVTX           = $0001000; // save swapped text even after use

 S_IREAD           = $0000400; // read permission, owner
 S_IWRITE          = $0000200; // write permission, owner
 S_IEXEC           = $0000100; // execute/search permission, owner
 S_ENFMT           = $0002000; // enforcement-mode locking

 S_IFMT            = _IFMT;
 S_IFDIR           = _IFDIR;
 S_IFCHR           = _IFCHR;
 S_IFBLK           = _IFBLK;
 S_IFREG           = _IFREG;
 S_IFLNK           = _IFLNK;
 S_IFSOCK          = _IFSOCK;
 S_IFIFO           = _IFIFO;

 _S_IFMT           = _IFMT;
 _S_IFDIR          = _IFDIR;
 _S_IFCHR          = _IFCHR;
 _S_IFIFO          = _IFIFO;
 _S_IFREG          = _IFREG;
 _S_IREAD          = $0000400;
 _S_IWRITE         = $0000200;
 {Open modes}
 S_IRUSR           = $0000400; // read permission, owner
 S_IWUSR           = $0000200; // write permission, owner
 S_IXUSR           = $0000100; // execute / search permission, owner
 S_IRWXU           = S_IRUSR or S_IWUSR or S_IXUSR;
 S_IRGRP           = $0000040; // read permission, group
 S_IWGRP           = $0000020; // write permission, grougroup
 S_IXGRP           = $0000010; // execute / search permission, group
 S_IRWXG           = S_IRGRP or S_IWGRP or S_IXGRP;
 S_IROTH           = $0000004; // read permission, other
 S_IWOTH           = $0000002; // write permission, other
 S_IXOTH           = $0000001; // execute / search permission, other
 S_IRWXO           = S_IROTH or S_IWOTH or S_IXOTH;
 
const 
 {File constants from default_fcntl.h}
 {Open flags}
 O_RDONLY          = 0;
 O_WRONLY          = 1;
 O_RDWR            = 2;
 O_APPEND          = $0008;    {append (writes guaranteed at the end)}
 O_CREAT           = $0200;    {If set, the file will be created if it doesn’t already exist}
 O_EXCL            = $0800;    {If both O_CREAT and O_EXCL are set, then open fails if the specified file already exists. This is guaranteed to never clobber an existing file}
 O_NONBLOCK        = $4000;    {This prevents open from blocking for a “long time” to open the file. This is only meaningful for some kinds of files, usually devices such as serial ports; when it is not meaningful, it is harmless and ignored. Often opening a port to a modem blocks until the modem reports carrier detection; if O_NONBLOCK is specified, open will return immediately without a carrier}
                               {Note that the O_NONBLOCK flag is overloaded as both an I/O operating mode and a file name translation flag. This means that specifying O_NONBLOCK in open also sets nonblocking I/O mode; see Operating Modes. To open the file without blocking but do normal I/O that blocks, you must call open with O_NONBLOCK set and then call fcntl to turn the bit off}
 O_NOCTTY          = $8000;    {If the named file is a terminal device, don’t make it the controlling terminal for the process. See Job Control, for information about what it means to be the controlling terminal}
                               {On GNU/Hurd systems and 4.4 BSD, opening a file never makes it the controlling terminal and O_NOCTTY is zero. However, GNU/Linux systems and some other systems use a nonzero value for O_NOCTTY and set the controlling terminal when you open a file that is a terminal device; so to be portable, use O_NOCTTY when it is important to avoid this}

 {The open-time action flags tell open to do additional operations which are not really related to opening the file. The reason to do them as part of open instead of in separate calls is that open can do them atomically}
 O_TRUNC          = $0400;     {Truncate the file to zero length. This option is only useful for regular files, not special files such as directories or FIFOs. POSIX.1 requires that you open the file for writing to use O_TRUNC. In BSD and GNU you must have permission to write the file to truncate it, but you need not open for write access}
                               {This is the only open-time action flag specified by POSIX.1. There is no good reason for truncation to be done by open, instead of by calling ftruncate afterwards. The O_TRUNC flag existed in Unix before ftruncate was invented, and is retained for backward compatibility}

 {The remaining operating modes are BSD extensions. They exist only on some systems. On other systems, these macros are not defined}
 O_SHLOCK         = $0080;     {Acquire a shared lock on the file, as with flock. See File Locks}
                               {If O_CREAT is specified, the locking is done atomically when creating the file. You are guaranteed that no other process will get the lock on the new file first}
 O_EXLOCK         = $0100;     {Acquire an exclusive lock on the file, as with flock. See File Locks. This is atomic like O_SHLOCK}

 O_BINARY         = $0001000;
 O_TEXT           = $0002000;
 
const 
 {Handle constants from sys/unistd.h}
 STDIN_FILENO  = 0;       {standard input file descriptor}
 STDOUT_FILENO = 1;       {standard output file descriptor}
 STDERR_FILENO = 2;       {standard error file descriptor}
 
const 
 {Sysconf values per IEEE Std 1003.1, 2008 Edition}
 _SC_ARG_MAX                       = 0;
 _SC_CHILD_MAX                     = 1;
 _SC_CLK_TCK                       = 2;
 _SC_NGROUPS_MAX                   = 3;
 _SC_OPEN_MAX                      = 4;
 _SC_JOB_CONTROL                   = 5;
 _SC_SAVED_IDS                     = 6;
 _SC_VERSION                       = 7;
 _SC_PAGESIZE                      = 8;
 _SC_PAGE_SIZE                     = _SC_PAGESIZE;

 _SC_NPROCESSORS_CONF              = 9;
 _SC_NPROCESSORS_ONLN              = 10;
 _SC_PHYS_PAGES                    = 11;
 _SC_AVPHYS_PAGES                  = 12;
 // End of non-POSIX values.
 _SC_MQ_OPEN_MAX                   = 13;
 _SC_MQ_PRIO_MAX                   = 14;
 _SC_RTSIG_MAX                     = 15;
 _SC_SEM_NSEMS_MAX                 = 16;
 _SC_SEM_VALUE_MAX                 = 17;
 _SC_SIGQUEUE_MAX                  = 18;
 _SC_TIMER_MAX                     = 19;
 _SC_TZNAME_MAX                    = 20;
 _SC_ASYNCHRONOUS_IO               = 21;
 _SC_FSYNC                         = 22;
 _SC_MAPPED_FILES                  = 23;
 _SC_MEMLOCK                       = 24;
 _SC_MEMLOCK_RANGE                 = 25;
 _SC_MEMORY_PROTECTION             = 26;
 _SC_MESSAGE_PASSING               = 27;
 _SC_PRIORITIZED_IO                = 28;
 _SC_REALTIME_SIGNALS              = 29;
 _SC_SEMAPHORES                    = 30;
 _SC_SHARED_MEMORY_OBJECTS         = 31;
 _SC_SYNCHRONIZED_IO               = 32;
 _SC_TIMERS                        = 33;
 _SC_AIO_LISTIO_MAX                = 34;
 _SC_AIO_MAX                       = 35;
 _SC_AIO_PRIO_DELTA_MAX            = 36;
 _SC_DELAYTIMER_MAX                = 37;
 _SC_THREAD_KEYS_MAX               = 38;
 _SC_THREAD_STACK_MIN              = 39;
 _SC_THREAD_THREADS_MAX            = 40;
 _SC_TTY_NAME_MAX                  = 41;
 _SC_THREADS                       = 42;
 _SC_THREAD_ATTR_STACKADDR         = 43;
 _SC_THREAD_ATTR_STACKSIZE         = 44;
 _SC_THREAD_PRIORITY_SCHEDULING    = 45;
 _SC_THREAD_PRIO_INHERIT           = 46;
 // _SC_THREAD_PRIO_PROTECT was _SC_THREAD_PRIO_CEILING in early drafts
 _SC_THREAD_PRIO_PROTECT           = 47;
 _SC_THREAD_PRIO_CEILING           = _SC_THREAD_PRIO_PROTECT;
 _SC_THREAD_PROCESS_SHARED         = 48;
 _SC_THREAD_SAFE_FUNCTIONS         = 49;
 _SC_GETGR_R_SIZE_MAX              = 50;
 _SC_GETPW_R_SIZE_MAX              = 51;
 _SC_LOGIN_NAME_MAX                = 52;
 _SC_THREAD_DESTRUCTOR_ITERATIONS  = 53;
 _SC_ADVISORY_INFO                 = 54;
 _SC_ATEXIT_MAX                    = 55;
 _SC_BARRIERS                      = 56;
 _SC_BC_BASE_MAX                   = 57;
 _SC_BC_DIM_MAX                    = 58;
 _SC_BC_SCALE_MAX                  = 59;
 _SC_BC_STRING_MAX                 = 60;
 _SC_CLOCK_SELECTION               = 61;
 _SC_COLL_WEIGHTS_MAX              = 62;
 _SC_CPUTIME                       = 63;
 _SC_EXPR_NEST_MAX                 = 64;
 _SC_HOST_NAME_MAX                 = 65;
 _SC_IOV_MAX                       = 66;
 _SC_IPV6                          = 67;
 _SC_LINE_MAX                      = 68;
 _SC_MONOTONIC_CLOCK               = 69;
 _SC_RAW_SOCKETS                   = 70;
 _SC_READER_WRITER_LOCKS           = 71;
 _SC_REGEXP                        = 72;
 _SC_RE_DUP_MAX                    = 73;
 _SC_SHELL                         = 74;
 _SC_SPAWN                         = 75;
 _SC_SPIN_LOCKS                    = 76;
 _SC_SPORADIC_SERVER               = 77;
 _SC_SS_REPL_MAX                   = 78;
 _SC_SYMLOOP_MAX                   = 79;
 _SC_THREAD_CPUTIME                = 80;
 _SC_THREAD_SPORADIC_SERVER        = 81;
 _SC_TIMEOUTS                      = 82;
 _SC_TRACE                         = 83;
 _SC_TRACE_EVENT_FILTER            = 84;
 _SC_TRACE_EVENT_NAME_MAX          = 85;
 _SC_TRACE_INHERIT                 = 86;
 _SC_TRACE_LOG                     = 87;
 _SC_TRACE_NAME_MAX                = 88;
 _SC_TRACE_SYS_MAX                 = 89;
 _SC_TRACE_USER_EVENT_MAX          = 90;
 _SC_TYPED_MEMORY_OBJECTS          = 91;
 _SC_V7_ILP32_OFF32                = 92;
 _SC_V6_ILP32_OFF32                = _SC_V7_ILP32_OFF32;
 _SC_XBS5_ILP32_OFF32              = _SC_V7_ILP32_OFF32;
 _SC_V7_ILP32_OFFBIG               = 93;
 _SC_V6_ILP32_OFFBIG               = _SC_V7_ILP32_OFFBIG;
 _SC_XBS5_ILP32_OFFBIG             = _SC_V7_ILP32_OFFBIG;
 _SC_V7_LP64_OFF64                 = 94;
 _SC_V6_LP64_OFF64                 = _SC_V7_LP64_OFF64;
 _SC_XBS5_LP64_OFF64               = _SC_V7_LP64_OFF64;
 _SC_V7_LPBIG_OFFBIG               = 95;
 _SC_V6_LPBIG_OFFBIG               = _SC_V7_LPBIG_OFFBIG;
 _SC_XBS5_LPBIG_OFFBIG             = _SC_V7_LPBIG_OFFBIG;
 _SC_XOPEN_CRYPT                   = 96;
 _SC_XOPEN_ENH_I18N                = 97;
 _SC_XOPEN_LEGACY                  = 98;
 _SC_XOPEN_REALTIME                = 99;
 _SC_STREAM_MAX                    = 100;
 _SC_PRIORITY_SCHEDULING           = 101;
 _SC_XOPEN_REALTIME_THREADS        = 102;
 _SC_XOPEN_SHM                     = 103;
 _SC_XOPEN_STREAMS                 = 104;
 _SC_XOPEN_UNIX                    = 105;
 _SC_XOPEN_VERSION                 = 106;
 _SC_2_CHAR_TERM                   = 107;
 _SC_2_C_BIND                      = 108;
 _SC_2_C_DEV                       = 109;
 _SC_2_FORT_DEV                    = 110;
 _SC_2_FORT_RUN                    = 111;
 _SC_2_LOCALEDEF                   = 112;
 _SC_2_PBS                         = 113;
 _SC_2_PBS_ACCOUNTING              = 114;
 _SC_2_PBS_CHECKPOINT              = 115;
 _SC_2_PBS_LOCATE                  = 116;
 _SC_2_PBS_MESSAGE                 = 117;
 _SC_2_PBS_TRACK                   = 118;
 _SC_2_SW_DEV                      = 119;
 _SC_2_UPE                         = 120;
 _SC_2_VERSION                     = 121;
 _SC_THREAD_ROBUST_PRIO_INHERIT    = 122;
 _SC_THREAD_ROBUST_PRIO_PROTECT    = 123;
 _SC_XOPEN_UUCP                    = 124;
 
const
 {Reentrant constants from /sys/reent.h}
 {rand48 family support}
 _RAND48_SEED_0 = $330e;
 _RAND48_SEED_1 = $abcd;
 _RAND48_SEED_2 = $1234;
 _RAND48_MULT_0 = $e66d;
 _RAND48_MULT_1 = $deec;
 _RAND48_MULT_2 = $0005;
 _RAND48_ADD    = $000b;
 
 {How big the some arrays are}
 _REENT_EMERGENCY_SIZE = 25;
 _REENT_ASCTIME_SIZE = 26;
 _REENT_SIGNAL_SIZE = 24;

 _N_LISTS = 30;
 
 _ATEXIT_SIZE = 32;  {Must be at least 32 to guarantee ANSI conformance}
 
{==============================================================================}
type
 {Syscalls specific types}
 
 {Basic Types}
 int = Integer; {INT_MAX}
 Pint = ^int;
 long = PtrInt; {LONG_MAX}
 short = Smallint;
 
type
 {From stddef.h}
 ptrdiff_t = PtrInt; {LONG_MAX}
 size_t = PtrUInt;
 ssize_t = PtrInt;
 wint_t = Cardinal; {unsigned int}          
 
type
 {From sys/types.h}
 dev_t = Smallint;  {short}              
 mode_t = Cardinal; {unsigned int}          
 ino_t = Word;      {unsigned short}           
 nlink_t = Word;    {unsigned short}           
 gid_t = Word;      {unsigned short}             
 uid_t = Word;      {unsigned short}
 time_t = PtrInt;   {long}       
 off_t = PtrInt;    {long}
 off64_t = Int64;   {long long} 
 clock_t = PtrUInt; {_CLOCK_T_ in machine/types.h}{unsigned long}
 
type 
 {From sys/_types.h}
 _ssize_t = PtrInt; {int or long}
 _fpos_t = PtrInt;  {long}
 _off_t  = PtrInt;  {long}
 _flock_t = int;    {_LOCK_RECURSIVE_T in lock.h}
 _fpos64_t = Int64;  {long long}
 _off64_t = Int64;  {long long}
 
 {Conversion state information}
 P_mbstate_value = ^T_mbstate_value;
 T_mbstate_value = record
  case Integer of
   0:(__wch:wint_t;
     );
   1:(__wchb:array[0..3] of Char;
     ); 
  end;
  
 P_mbstate_t = ^T_mbstate_t;
 T_mbstate_t = record
  __count:int;
  __value:T_mbstate_value; {Value so far}
 end;
 
type
 {From _ansi.h} 
 _PTR = Pointer;
 
type
 {From sys/config.h}
 _READ_WRITE_RETURN_TYPE = int; {See note in \newlib\libc\include\sys\config.h may be ssize_t in some implementations}
 _READ_WRITE_BUFSIZE_TYPE = int; {See note in \newlib\libc\include\sys\config.h may be ssize_t in some implementations}
 
type
 {From sys/reent.h} {Types required for T_reent below}
 P_reent = ^T_reent;
 
 __ULong = long;
 
 P_Bigint = ^T_Bigint;
 T_Bigint = record
  _next:P_Bigint;
  _k:int;
  _maxwds:int;
  _sign:int;
  _wds:int;
  _x:array[0..0] of __ULong;
 end;
 PP_Bigint = ^P_Bigint;
 
 P__tm = ^T__tm;
 T__tm = record
  __tm_sec:int;
  __tm_min:int;
  __tm_hour:int;
  __tm_mday:int;
  __tm_mon:int;
  __tm_year:int;
  __tm_wday:int;
  __tm_yday:int;
  __tm_isdst:int;
 end; 
 
 {Stdio buffers}
 P__sbuf = ^T__sbuf; 
 T__sbuf = record
  _base:PChar;
  _size:int;
 end;
 
 P__sFILE = ^T__sFILE;
 T__sFILE = record
  _p:PChar;        {current position in (some) buffer}
  _r:int;          {read space left for getc()}
  _w:int;          {write space left for putc()}
  _flags:short;    {flags, below; this FILE is free if 0}
  _file:short;     {fileno, if Unix descriptor, else -1}
  _bf:T__sbuf;     {the buffer (at least 1 byte, if !NULL)}
  _lbfsize:int;    {0 or -_bf._size, for inline putc}
  
  {operations}
  _cookie:_PTR;    {cookie passed to io functions}
  _read:function(ptr: P_reent; cookie: _PTR; buf: PChar; size: _READ_WRITE_BUFSIZE_TYPE):_READ_WRITE_RETURN_TYPE; cdecl;
  _write:function(ptr: P_reent; cookie: _PTR; buf: PChar; size: _READ_WRITE_BUFSIZE_TYPE):_READ_WRITE_RETURN_TYPE; cdecl;
  _seek:function(ptr: P_reent; cookie: _PTR; pos: _fpos_t; dir: int):_fpos_t; cdecl; 
  _close:function(ptr: P_reent; cookie: _PTR):int; cdecl; 
  
  {separate buffer for long sequences of ungetc()}
  _ub:T__sbuf; {ungetc buffer}
  _up:PChar;   {saved _p when _p is doing ungetc data}
  _ur:int;     {saved _r when _r is counting ungetc data}
  
  {tricks to meet minimum requirements even when malloc() fails}
  _ubuf:array[0..2] of Char; {guarantee an ungetc() buffer}
  _nbuf:array[0..0] of Char; {guarantee a getc() buffer}
  
  {separate buffer for fgetline() when line crosses buffer boundary}
  _lb:T__sbuf; {buffer for fgetline()}
  
  {Unix stdio files get aligned to block boundaries on fseek()}
  _blksize:int;     {stat.st_blksize (may be != _bf._size)}
  _offset:_off_t;   {current lseek offset}
  
  _data:P_reent;    {Here for binary compatibility? Remove?}
  
  _lock:_flock_t;   {for thread-safety locking}
  
  _mbstate:T_mbstate_t; {for wide char stdio functions}
  _flags2:int;          {for future use}
 end;
 
 {$IFDEF SYSCALLS_LARGE64_FILES}
 P__sFILE64 = ^T__sFILE64;
 T__sFILE64 = record
  _p:PChar;        {current position in (some) buffer}
  _r:int;          {read space left for getc()}
  _w:int;          {write space left for putc()}
  _flags:short;    {flags, below; this FILE is free if 0}
  _file:short;     {fileno, if Unix descriptor, else -1}
  _bf:T__sbuf;     {the buffer (at least 1 byte, if !NULL)}
  _lbfsize:int;    {0 or -_bf._size, for inline putc}

  _data:P_reent;   
  
  {operations}
  _cookie:_PTR;    {cookie passed to io functions}
  _read:function(ptr: P_reent; cookie: _PTR; buf: PChar; size: _READ_WRITE_BUFSIZE_TYPE):_READ_WRITE_RETURN_TYPE; cdecl;
  _write:function(ptr: P_reent; cookie: _PTR; buf: PChar; size: _READ_WRITE_BUFSIZE_TYPE):_READ_WRITE_RETURN_TYPE; cdecl;
  _seek:function(ptr: P_reent; cookie: _PTR; pos: _fpos_t; dir: int):_fpos_t; cdecl; 
  _close:function(ptr: P_reent; cookie: _PTR):int; cdecl; 

  {separate buffer for long sequences of ungetc()}
  _ub:T__sbuf; {ungetc buffer}
  _up:PChar;   {saved _p when _p is doing ungetc data}
  _ur:int;     {saved _r when _r is counting ungetc data}
  
  {tricks to meet minimum requirements even when malloc() fails}
  _ubuf:array[0..2] of Char; {guarantee an ungetc() buffer}
  _nbuf:array[0..0] of Char; {guarantee a getc() buffer}

  {separate buffer for fgetline() when line crosses buffer boundary}
  _lb:T__sbuf; {buffer for fgetline()}

  {Unix stdio files get aligned to block boundaries on fseek()}
  _blksize:int;     {stat.st_blksize (may be != _bf._size)}
  _flags2:int;          {for future use}

  _offset:_off64_t;   {current lseek offset}
  _seek64:function(ptr: P_reent; cookie: _PTR; pos: _fpos64_t; dir: int):_fpos64_t; cdecl; 

  _lock:_flock_t;   {for thread-safety locking}
  _mbstate:T_mbstate_t; {for wide char stdio functions}
 end;
 {$ENDIF}
 
 {$IFDEF SYSCALLS_LARGE64_FILES}
 T__FILE = T__sFILE64;
 P__FILE = P__sFILE64;
 {$ELSE}
 T__FILE = T__sFILE;
 P__FILE = P__sFILE;
 {$ENDIF}
 
 P_glue = ^T_glue;
 T_glue = record
  _next:P_glue;
  _niobs:int;
  _iobs:P__FILE;
 end;
 
 P_rand48 = ^T_rand48;
 T_rand48 = record
  _seed:array[0..2] of Word; {unsigned short}
  _mult:array[0..2]of Word;  {unsigned short}
  _add:Word;                 {unsigned short}
 end;
 
 P_on_exit_args = ^T_on_exit_args;
 T_on_exit_args = record
  _fnargs:array[0.._ATEXIT_SIZE - 1] of Pointer;         {user fn args}
  _dso_handle:array[0.._ATEXIT_SIZE - 1] of Pointer;
  {Bitmask is set if user function takes arguments}
  _fntypes:__ULong;   {type of exit routine - Must have at least _ATEXIT_SIZE bits}
  {Bitmask is set if function was registered via __cxa_atexit.}
  _is_cxa:__ULong;
 end;
 
 P_atexit = ^T_atexit;
 T_atexit = record
  _next:P_atexit;   {next in list}
  _ind:int;         {next index in this table}
  {Some entries may already have been called, and will be NULL.}
  _fns:array[0.._ATEXIT_SIZE - 1] of procedure; {the table itself}
  _on_exit_args:T_on_exit_args;
 end;
 
 {From sys/reent.h} {Note that reent.h uses an alternate version of this if _REENT_SMALL if defined however that version is not supported}
 T_reent_new = record
  case Integer of
   0:(_unused_rand:Cardinal; {unsigned int}
      _strtok_last:PChar;
      _asctime_buf:array[0.._REENT_ASCTIME_SIZE - 1] of Char;
      _localtime_buf:T__tm;
      _gamma_signgam:int;
      _rand_next:Int64; {unsigned long long}
      _r48:T_rand48;
      _mblen_state:T_mbstate_t;
      _mbtowc_state:T_mbstate_t;
      _wctomb_state:T_mbstate_t;
      _l64a_buf:array[0..7] of Char;
      _signal_buf:array[0.._REENT_SIGNAL_SIZE - 1] of Char;
      _getdate_err:int;
      _mbrlen_state:T_mbstate_t;
      _mbrtowc_state:T_mbstate_t;
      _mbsrtowcs_state:T_mbstate_t;
      _wcrtomb_state:T_mbstate_t;
      _wcsrtombs_state:T_mbstate_t;
   _h_errno:int;
     ); {_reent}
   {Two next two fields were once used by malloc.  They are no longer used. They are used to preserve the space used before so as to allow addition of new reent fields and keep binary compatibility}
   1:(_nextf:array[0.._N_LISTS - 1] of PChar;
      _nmalloc:array[0.._N_LISTS - 1] of Cardinal; {unsigned int}
     ); {_unused}
 end;

 T_reent = record
  _errno:int;                    {local copy of errno}
  _stdin:P__FILE;                {FILE is a big struct and may change over time.  To try to achieve binary}
  _stdout:P__FILE;               {compatibility with future versions, put stdin,stdout,stderr here.}
  _stderr:P__FILE;               {These are pointers into member __sf defined below.}
  _inc:int;                      {used by tmpnam}
  _emergency:array[0.._REENT_EMERGENCY_SIZE - 1] of Char;
  _current_category:int;         {used by setlocale}
  _current_locale:PChar;
  __sdidinit:int;                {1 means stdio has been init'd}
  __cleanup:procedure(ptr: P_reent); cdecl;

  {used by mprec routines}
  _result:P_Bigint;
  _result_k:int;
  _p5s:P_Bigint;
  _freelist:PP_Bigint;

  {used by some fp conversion routines}
  _cvtlen:int;   {should be size_t}
  _cvtbuf:PChar;

  _new:T_reent_new;
  
  {atexit stuff}
  _atexit:P_atexit;  {points to head of LIFO stack}
  _atexit0:T_atexit; {one guaranteed table, required by ANSI}
  
  {signal info}
  _sig_func:function(param: int): PPointer; cdecl;
  
  {These are here last so that __FILE can grow without changing the offsets  of the above members (on the off chance that future binary compatibility  would be broken otherwise)}
  __sglue:T_glue;             {root of glue chain}
  __sf:array[0..2] of T__FILE;   {first three file descriptors}
 end;

type 
 {From sys/stat.h}
 Pstat = ^Tstat;
 Tstat = record
  st_dev:dev_t;            // ID of device containing file
  st_ino:ino_t;            // inode number
  st_mode:mode_t;          // protection
  st_nlink:nlink_t;        // number of hard links
  st_uid:uid_t;            // user ID of owner
  st_gid:gid_t;            // group ID of owner
  st_rdev:dev_t;           // device ID (if special file)
  st_size:off_t;           // total size, in bytes
  st_atime:time_t;         // time of last access
  st_spare1:long;          // spare - access nsecs
  st_mtime:time_t;         // time of last modification
  st_spare2:long;          // spare - mod nsecs
  st_ctime:time_t;         // time of last status change
  st_spare3:long;          // spare - change nsecs
  st_blksize:long;         // blocksize for file system I/O
  st_blocks:long;          // number of 512B blocks allocated
  st_spare4:array [0..1] of long;
 end;

 Pstat64 = ^Tstat64;
 Tstat64 = Tstat;
 
type 
 {From sys/times.h}
 Ptms = ^Ttms;
 Ttms = record
  tms_utime: clock_t;  {user time}
  tms_stime: clock_t;  {system time}
  tms_cutime: clock_t; {user time, children}
  tms_cstime: clock_t; {system time, children}
 end;
 
type
 {From machine/types.h}
 __suseconds_t = long;
 
type
 {From sys/_timeval.h}
 suseconds_t = __suseconds_t;
 
 Ptimeval = ^Ttimeval;
 Ttimeval = record
  tv_sec:time_t;       {seconds}
  tv_usec:suseconds_t; {and microseconds}
 end;
 
{==============================================================================}
var
 {Syscalls specific variables}
 environ:PPChar; external;  {Pointer to the global environment block in the C library}
 
{==============================================================================}
{Initialization Functions}
procedure SyscallsInit;
procedure SyscallsQuit;

{==============================================================================}
{Syscalls Functions (Standard)}
procedure _exit; cdecl; public name '_exit';

{==============================================================================}
{Syscalls Functions (Recursive)}
function _close_r(ptr: P_reent; fd: int): int; cdecl; public name '_close_r';

function _execve_r(ptr: P_reent; name: PChar; argv: PPChar; env: PPChar): int; cdecl; public name '_execve_r';
function _fork_r(ptr: P_reent): int; cdecl; public name '_fork_r';
function _wait_r(ptr: P_reent; status: Pint): int; cdecl; public name '_wait_r';

function _fcntl_r(ptr: P_reent; fd: int; cmd:int; arg:int): int; cdecl; public name '_fcntl_r';

{$IFDEF SYSCALLS_LARGE64_FILES}
function _fstat64_r(ptr: P_reent; fd: int; stat: Pstat64): int; cdecl; public name '_fstat64_r';
{$ENDIF}

function _fstat_r(ptr: P_reent; fd: int; stat: Pstat): int; cdecl; public name '_fstat_r';

function __getreent: P_reent; cdecl; public name '__getreent';

function _gettimeofday_r(ptr: P_reent; timeval: Ptimeval; timezone: Pointer): int; cdecl; public name '_gettimeofday_r';

function _isatty_r(ptr: P_reent; fd: int): int; cdecl; public name '_isatty_r';

function _link_r(ptr: P_reent; old: PChar; new: PChar): int; cdecl; public name '_link_r';

{$IFDEF SYSCALLS_LARGE64_FILES}
function _lseek64_r(ptr: P_reent;  fd: int; pos: off64_t; whence: int): off64_t; cdecl; public name '_lseek64_r';
{$ENDIF}

function _lseek_r(ptr: P_reent; fd: int; pos: off_t; whence: int): off_t; cdecl; public name '_lseek_r';

function _mkdir_r(ptr: P_reent; path: PChar; mode: int): int; cdecl; public name '_mkdir_r';
  
{$IFDEF SYSCALLS_LARGE64_FILES}  
function _open64_r(ptr: P_reent; name: PChar; flags: int; mode: int): int; cdecl; public name '_open64_r';
{$ENDIF}

function _open_r(ptr: P_reent; name: PChar; flags: int; mode: int): int; cdecl; public name '_open_r';

function _read_r(ptr: P_reent; fd: int; buf: Pointer; cnt: size_t): _ssize_t; cdecl; public name '_read_r';

function _rename_r(ptr: P_reent; old: PChar; new: PChar): int; cdecl; public name '_rename_r';

function _sbrk_r(ptr: P_reent; incr: ptrdiff_t): Pointer; cdecl; public name '_sbrk_r';

function _kill_r(ptr: P_reent; pid: int; sig: int): int; cdecl; public name '_kill_r';
function _getpid_r(ptr: P_reent): int; cdecl; public name '_getpid_r';

{$IFDEF SYSCALLS_LARGE64_FILES}  
function _stat64_r(ptr: P_reent; name: PChar; stat: Pstat64): int; cdecl; public name '_stat64_r';
{$ENDIF}

function _stat_r(ptr: P_reent; name: PChar; stat: Pstat): int; cdecl; public name '_stat_r';

function _times_r(ptr: P_reent; tms: Ptms): clock_t; cdecl; public name '_times_r';

function _unlink_r(ptr: P_reent; name: PChar): int; cdecl; public name '_unlink_r';

function _write_r(ptr: P_reent; fd: int; buf: Pointer; cnt: size_t): _ssize_t; cdecl; public name '_write_r';
       
{==============================================================================}
{Syscalls Functions (Extra)}
function mkdir(path: PChar; mode: int): int; cdecl; public name 'mkdir';
function sysconf(name: int):int; cdecl; public name 'sysconf';
       
{==============================================================================}
{Syscalls Functions (Pthread)}
//TestingPThreads
     
{==============================================================================}
{Syscalls Helper Functions}
procedure __malloc_lock(ptr: P_reent); cdecl; public name '__malloc_lock';
procedure __malloc_unlock(ptr: P_reent); cdecl; public name '__malloc_unlock';

procedure __env_lock(ptr: P_reent); cdecl; public name '__env_lock';
procedure __env_unlock(ptr: P_reent); cdecl; public name '__env_unlock';
 
{==============================================================================}
{==============================================================================}
{Syscalls Libraries}
{$linklib c}
{$linklib gcc}

{==============================================================================}
{==============================================================================}

implementation

{==============================================================================}
{==============================================================================}
const
 {Syscalls specific constants}
 SYSCALLS_TABLE_MIN = 3;     {Skip Stdin, Stdout, Stderr}
 SYSCALLS_TABLE_MAX = 65535; {Only support 16-bit handles}
 SYSCALLS_TABLE_MASK = $F;   {16 buckets for handle lookups}
 
{==============================================================================}
{==============================================================================}
type
 {Syscalls specific types}
 PSyscallsEntry = ^TSyscallsEntry;
 
 PSyscallsTable = ^TSyscallsTable;
 TSyscallsTable = record
  Next:LongWord;
  Count:LongWord;
  Entries:array of PSyscallsEntry;
 end;
 
 TSyscallsEntry = record
  Number:LongWord;
  Handle:THandle;
  Prev:PSyscallsEntry;
  Next:PSyscallsEntry;
 end;
 
 PSyscallsHeapBlock = ^TSyscallsHeapBlock;
 TSyscallsHeapBlock = record
  VirtualAddress:PtrUInt;
  PhysicalAddress:PtrUInt;
  Size:LongWord;
  Used:LongWord;
  Prev:PSyscallsHeapBlock;
  Next:PSyscallsHeapBlock;
 end;
 
{==============================================================================}
{==============================================================================}
var
 {Syscalls specific variables}
 SyscallsInitialized:Boolean;

 SyscallsTlsSize:LongWord;
 SyscallsTlsIndex:LongWord;
 
 SyscallsMallocLock:TMutexHandle = INVALID_HANDLE_VALUE;
 SyscallsEnvLock:TMutexHandle = INVALID_HANDLE_VALUE;

 SyscallsTable:TSyscallsTable;
 SyscallsTableLock:TMutexHandle = INVALID_HANDLE_VALUE;
 
 SyscallsHeapFirst:PSyscallsHeapBlock;
 SyscallsHeapLast:PSyscallsHeapBlock;
 SyscallsHeapEnd:Pointer;
 SyscallsHeapSize:LongWord;
 SyscallsHeapLock:TMutexHandle = INVALID_HANDLE_VALUE;
 
 //__exidx_end //__exidx_start //TestingLIBSTDC++ //Possibly not required, used internally by Libgcc etc?
 
 //__preinit_array_start //__preinit_array_end //TestingLIBSTDC++
 
 //__init_array_start //__init_array_end //TestingLIBSTDC++
 
 //__fini_array_start //__fini_array_end //TestingLIBSTDC++
 
{==============================================================================}
{==============================================================================}
{Forward Declarations}
function SyscallsGetStat(Handle:THandle;stat:Pstat):Boolean; forward;
function SyscallsGetStat64(Handle:THandle;stat64:Pstat64):Boolean; forward;

function SyscallsGetEntry(Number:LongWord):PSyscallsEntry; forward;
function SyscallsAddEntry(Handle:THandle):PSyscallsEntry; forward;
function SyscallsRemoveEntry(Entry:PSyscallsEntry):Boolean; forward;

function SyscallsInitializeHeap:Boolean; forward;
function SyscallsIncreaseHeap(Size:LongWord):Pointer; forward;
function SyscallsDecreaseHeap(Size:LongWord):Pointer; forward;
 
{==============================================================================}
{==============================================================================}
{Initialization Functions}
procedure SyscallsInit;
var
 Count:LongWord;
begin
 {}
 {Check Initialized}
 if SyscallsInitialized then Exit;

 {Set TLS Size}
 SyscallsTlsSize:=SizeOf(T_reent);
 
 {Allocate TLS Index}
 SyscallsTlsIndex:=ThreadAllocTlsIndexEx(THREAD_TLS_FLAG_FREE);
 if SyscallsTlsIndex = TLS_OUT_OF_INDEXES then
  begin
   if PLATFORM_LOG_ENABLED then PlatformLogError('Failed to allocate Syscalls TLS index');
  end;
 
 {Initialize Malloc Lock}
 SyscallsMallocLock:=MutexCreateEx(False,MUTEX_DEFAULT_SPINCOUNT,MUTEX_FLAG_RECURSIVE);
 if SyscallsMallocLock = INVALID_HANDLE_VALUE then
  begin
   if PLATFORM_LOG_ENABLED then PlatformLogError('Failed to create Syscalls Malloc lock');
  end;
 
 {Initialize Env Lock}
 SyscallsEnvLock:=MutexCreateEx(False,MUTEX_DEFAULT_SPINCOUNT,MUTEX_FLAG_RECURSIVE);
 if SyscallsEnvLock = INVALID_HANDLE_VALUE then
  begin
   if PLATFORM_LOG_ENABLED then PlatformLogError('Failed to create Syscalls Env lock');
  end;
  
 {Initialize Handles}
 SyscallsTable.Next:=SYSCALLS_TABLE_MIN;
 SyscallsTable.Count:=0;
 SetLength(SyscallsTable.Entries,SYSCALLS_TABLE_MASK + 1);
 for Count:=0 to SYSCALLS_TABLE_MASK do
  begin
   SyscallsTable.Entries[Count]:=nil;
  end;
 SyscallsTableLock:=MutexCreateEx(False,MUTEX_DEFAULT_SPINCOUNT,MUTEX_FLAG_RECURSIVE);
 if SyscallsTableLock = INVALID_HANDLE_VALUE then
  begin
   if PLATFORM_LOG_ENABLED then PlatformLogError('Failed to create Syscalls Table lock');
  end;
 
 {Allocate Heap}
 if not SyscallsInitializeHeap then
  begin
   if PLATFORM_LOG_ENABLED then PlatformLogError('Failed to initialize Syscalls heap');
  end;

 {Allocate Environment}
 environ:=AllocMem(SizeOf(PChar) * (ENVIRONMENT_STRING_COUNT + 1)); {Add one for terminating null}
 if environ = nil then
  begin
   if PLATFORM_LOG_ENABLED then PlatformLogError('Failed to allocate Syscalls environment');
  end;
  
 {Copy Environment}
 for Count:=0 to (ENVIRONMENT_STRING_COUNT + 1) - 1 do
  begin
   environ[Count]:=StrNew(envp[Count]);
  end;

 {Constructors of Static Objects (cin / cout / cerr / clog etc)}
 //TestingLIBSTDC++
 
 SyscallsInitialized:=True;
end; 
 
{==============================================================================}

procedure SyscallsQuit;
begin
 {}
 {Check Initialized}
 if not SyscallsInitialized then Exit;
 
 {Destructors of Static Objects (cin / cout / cerr / clog etc)}
 //TestingLIBSTDC++
 
 SyscallsInitialized:=False;
end;

{==============================================================================}
{==============================================================================}
{Syscalls Functions (Standard)}
procedure _exit; cdecl;
{Exit the program without cleaning up files}
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _exit');
 {$ENDIF}

 {Halt the thread} 
 HaltThread (0);
end;
 
{==============================================================================}
{==============================================================================}
{Syscalls Functions (Recursive)}
function _close_r(ptr: P_reent; fd: int): int; cdecl;
{Close a file}
{See: \newlib\libc\reent\closer.c}
var
 Entry:PSyscallsEntry;
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _close_r (ptr=' + IntToHex(PtrUInt(ptr),8) + ' fd=' + IntToStr(fd) + ')');
 {$ENDIF}
 
 {Check descriptor}
 if (fd = STDIN_FILENO) or (fd = STDOUT_FILENO) or (fd = STDERR_FILENO) then
  begin
   {Stdin, Stdout, Stderr}
   Result:=0;
  end
 else
  begin
   {Normal file}
   Entry:=SyscallsGetEntry(fd);
   if Entry <> nil then
    begin
     {Close file}
     FSFileClose(Entry^.Handle);
     
     {Remove Entry}
     SyscallsRemoveEntry(Entry); 
     
     {Return Result}
     Result:=0;
    end; 
  end;
  
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _close_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _execve_r(ptr: P_reent; name: PChar; argv: PPChar; env: PPChar): int; cdecl;
{Transfer control to a new process}
{See: \newlib\libc\reent\execr.c}
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _execve_r (ptr=' + IntToHex(PtrUInt(ptr),8) + ')');
 {$ENDIF}
 
 {Return Error}
 ptr^._errno:=ENOMEM;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _execve_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _fork_r(ptr: P_reent): int; cdecl;
{Create a new process}
{See: \newlib\libc\reent\execr.c}
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _fork_r (ptr=' + IntToHex(PtrUInt(ptr),8) + ')');
 {$ENDIF}
 
 {Return Error}
 ptr^._errno:=EAGAIN;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _fork_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _wait_r(ptr: P_reent; status: Pint): int; cdecl;
{Wait for a child process}
{See: \newlib\libc\reent\execr.c}
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _wait_r (ptr=' + IntToHex(PtrUInt(ptr),8) + ')');
 {$ENDIF}
 
 {Return Error}
 ptr^._errno:=ECHILD;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _wait_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _fcntl_r(ptr: P_reent; fd: int; cmd:int; arg:int): int; cdecl;
{Control an open file}
{See: \newlib\libc\reent\fcntlr.c}
var
 Entry:PSyscallsEntry;
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _fcntl_r (ptr=' + IntToHex(PtrUInt(ptr),8) + ' cmd=' + IntToStr(cmd) + ' arg=' + IntToStr(arg) + ')');
 {$ENDIF}
 
 {Get Entry}
 Entry:=SyscallsGetEntry(fd);
 if Entry <> nil then
  begin
   //To Do //Implement any that are required
  end
 else 
  begin
   {Return Error}
   ptr^._errno:=EINVAL;
  end;  
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _fcntl_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}
{$IFDEF SYSCALLS_LARGE64_FILES}
function _fstat64_r(ptr: P_reent; fd: int; stat: Pstat64): int; cdecl;
{Status of an open file}
{See: \newlib\libc\reent\fstat64r.c}
var
 Entry:PSyscallsEntry;
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _fstat64_r (ptr=' + IntToHex(PtrUInt(ptr),8) + ' fd=' + IntToStr(fd) + ')');
 {$ENDIF}
 
 {Check stat}
 if stat = nil then Exit;
 
 {Check descriptor}
 if (fd = STDIN_FILENO) or (fd = STDOUT_FILENO) or (fd = STDERR_FILENO) then
  begin
   {Stdin, Stdout, Stderr}
   FillChar(stat^,SizeOf(Tstat64),0);
   stat^.st_mode:=_S_IFCHR;
   Result:=0;
  end
 else
  begin
   {Normal file}
   Entry:=SyscallsGetEntry(fd);
   if Entry <> nil then
    begin
     {Get Stat}
     if not SyscallsGetStat64(Entry^.Handle,stat) then Exit;
     
     {Return Result}
     Result:=0;
    end
   else
    begin
     {Return Error}
     ptr^._errno:=EINVAL;
    end;    
  end;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _fstat64_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;
{$ENDIF}
{==============================================================================}

function _fstat_r(ptr: P_reent; fd: int; stat: Pstat): int; cdecl;
{Status of an open file}
{See: \newlib\libc\reent\fstatr.c}
var
 Entry:PSyscallsEntry;
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _fstat_r (ptr=' + IntToHex(PtrUInt(ptr),8) + ' fd=' + IntToStr(fd) + ')');
 {$ENDIF}
 
 {Check stat}
 if stat = nil then Exit;
 
 {Check descriptor}
 if (fd = STDIN_FILENO) or (fd = STDOUT_FILENO) or (fd = STDERR_FILENO) then
  begin
   {Stdin, Stdout, Stderr}
   FillChar(stat^,SizeOf(Tstat),0);
   stat^.st_mode:=_S_IFCHR;
   Result:=0;
  end
 else
  begin
   {Normal file}
   Entry:=SyscallsGetEntry(fd);
   if Entry <> nil then
    begin
     {Get Stat}
     if not SyscallsGetStat(Entry^.Handle,stat) then Exit;
     
     {Return Result}
     Result:=0;
    end
   else
    begin
     {Return Error}
     ptr^._errno:=EINVAL;
    end;    
  end;
  
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _fstat_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function __getreent: P_reent; cdecl;
{Return the _reent structure for the calling thread or allocate a new one if not found}
{See: \newlib\libc\reent\getreent.c}
var
 reent:P_reent;
begin
 {}
 Result:=nil;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls __getreent');
 {$ENDIF}
 
 {Get TLS Value}
 reent:=ThreadGetTlsValue(SyscallsTlsIndex);
 if reent = nil then
  begin
   {Allocate TLS Value}
   reent:=AllocMem(SyscallsTlsSize);
   if reent = nil then Exit;
   
   {Set TLS Value}
   if ThreadSetTlsValue(SyscallsTlsIndex,reent) <> ERROR_SUCCESS then Exit;
  end;

 {Initialize reent structure} 
 {See: _REENT_INIT_PTR_ZEROED in \newlib\libc\include\sys\reent.h}
 reent^._stdin:=@reent^.__sf[0];
 reent^._stdout:=@reent^.__sf[1];
 reent^._stderr:=@reent^.__sf[2];
 reent^._current_locale:='C';
 reent^._new._rand_next:=1;
 reent^._new._r48._seed[0]:=_RAND48_SEED_0;
 reent^._new._r48._seed[1]:=_RAND48_SEED_1; 
 reent^._new._r48._seed[2]:=_RAND48_SEED_2; 
 reent^._new._r48._mult[0]:=_RAND48_MULT_0; 
 reent^._new._r48._mult[1]:=_RAND48_MULT_1; 
 reent^._new._r48._mult[2]:=_RAND48_MULT_2; 
 reent^._new._r48._add:=_RAND48_ADD; 
 
 {Return Result}
 Result:=reent;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls __getreent (Result=' + IntToHex(PtrUInt(Result),8) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _gettimeofday_r(ptr: P_reent; timeval: Ptimeval; timezone: Pointer): int; cdecl;
{Get the date and time}
{See: \newlib\libc\reent\gettimeofdayr.c}
var
 ClockTime:Int64;
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _gettimeofday_r (ptr=' + IntToHex(PtrUInt(ptr),8) + ' timeval=' + IntToHex(PtrUInt(timeval),8) + ')');
 {$ENDIF}
 
 {Check timeval}
 if timeval = nil then Exit;
  
 {Get Time}
 ClockTime:=ClockGetTime;
 
 {Convert to timeval}
 if Int64(ClockTime) < TIME_TICKS_TO_1970 then Exit;
 timeval^.tv_sec:=(Int64(ClockTime) - TIME_TICKS_TO_1970) div TIME_TICKS_PER_SECOND;
 timeval^.tv_usec:=((Int64(ClockTime) - TIME_TICKS_TO_1970) mod TIME_TICKS_PER_SECOND) div TIME_TICKS_PER_MICROSECOND;
 
 {Return Result}
 Result:=0;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _gettimeofday_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _isatty_r(ptr: P_reent; fd: int): int; cdecl;
{Query whether output stream is a terminal}
{See: \newlib\libc\reent\isattyr.c}
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _isatty_r (ptr=' + IntToHex(PtrUInt(ptr),8) + ' fd=' + IntToStr(fd) + ')');
 {$ENDIF}
 
 {Check descriptor}
 if (fd = STDOUT_FILENO) or (fd = STDERR_FILENO) then
  begin
   {Stdout, Stderr}
   Result:=1;
  end;
  
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _isatty_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _link_r(ptr: P_reent; old: PChar; new: PChar): int; cdecl;
{Establish a new name for an existing file}
{See: \newlib\libc\reent\linkr.c}
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _link_r (ptr=' + IntToHex(PtrUInt(ptr),8) + ' old=' + StrPas(old) + ' new=' + StrPas(new) + ')');
 {$ENDIF}
 
 if FSCreateSymbolicLink(new,old,FSDirectoryExists(old)) then
  begin
   {Return Result}
   Result:=0;
  end
 else
  begin
   {Return Error}
   ptr^._errno:=EINVAL;
  end;  
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _link_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}
{$IFDEF SYSCALLS_LARGE64_FILES}
function _lseek64_r(ptr: P_reent;  fd: int; pos: off64_t; whence: int): off64_t; cdecl;
{Set position in a file}
{See: \newlib\libc\reent\lseek64r.c}
var
 Entry:PSyscallsEntry;
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _lseek64_r (ptr=' + IntToHex(PtrUInt(ptr),8) + ' fd=' + IntToStr(fd) + ' pos=' + IntToStr(pos) + ' whence=' + IntToStr(whence) + ')');
 {$ENDIF}
 
 {Get Entry}
 Entry:=SyscallsGetEntry(fd);
 if Entry <> nil then
  begin
   {Seek file}
   Result:=FSFileSeekEx(Entry^.Handle,pos,whence);
  end
 else
  begin
   {Return Error}
   ptr^._errno:=EINVAL;
  end;    
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _lseek64_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;
{$ENDIF}
{==============================================================================}

function _lseek_r(ptr: P_reent; fd: int; pos: off_t; whence: int): off_t; cdecl;
{Set position in a file}
{See: \newlib\libc\reent\lseekr.c}
var
 Entry:PSyscallsEntry;
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _lseek_r (ptr=' + IntToHex(PtrUInt(ptr),8) + ' fd=' + IntToStr(fd) + ' pos=' + IntToStr(pos) + ' whence=' + IntToStr(whence) + ')');
 {$ENDIF}
 
 {Get Entry}
 Entry:=SyscallsGetEntry(fd);
 if Entry <> nil then
  begin
   {Seek file}
   Result:=FSFileSeek(Entry^.Handle,pos,whence);
  end
 else
  begin
   {Return Error}
   ptr^._errno:=EINVAL;
  end;    
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _lseek_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _mkdir_r(ptr: P_reent; path: PChar; mode: int): int; cdecl;
{Make a directory}
{See: \newlib\libc\reent\mkdirr.c}
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _mkdir_r (ptr=' + IntToHex(PtrUInt(ptr),8) + ' path=' + StrPas(path) + ' mode=' + IntToStr(mode) + ')');
 {$ENDIF}
 
 {Create Directory}
 if CreateDir(path) then
  begin
   {Return Result}
   Result:=0;
  end
 else
  begin
   {Return Error}
   ptr^._errno:=EEXIST;
  end;  
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _mkdir_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}
{$IFDEF SYSCALLS_LARGE64_FILES}
function _open64_r(ptr: P_reent; name: PChar; flags: int; mode: int): int; cdecl;
{Open a file}
{See: \newlib\libc\reent\open64r.c}
var
 Handle:THandle;
 Entry:PSyscallsEntry;
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _open64_r (ptr=' + IntToHex(PtrUInt(ptr),8) + ' name=' + StrPas(name) + ' flags=' + IntToStr(flags) + ' mode=' + IntToStr(mode) + ')');
 {$ENDIF}
 
 {Call Open}
 Result:=_open_r(ptr,name,flags,mode);
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _open64_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;
{$ENDIF}
{==============================================================================}

function _open_r(ptr: P_reent; name: PChar; flags: int; mode: int): int; cdecl;
{Open a file}
{See: \newlib\libc\reent\openr.c}
var
 Handle:THandle;
 AccessMode:LongWord;
 ShareMode:LongWord;
 CreateFlags:LongWord;
 Entry:PSyscallsEntry;
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _open_r (ptr=' + IntToHex(PtrUInt(ptr),8) + ' name=' + StrPas(name) + ' flags=' + IntToStr(flags) + ' mode=' + IntToStr(mode) + ')');
 {$ENDIF}

 {Get Access Mode} 
 if (flags and (O_RDONLY or O_WRONLY or O_RDWR)) = O_RDONLY then
  begin
   AccessMode:=GENERIC_READ;
  end
 else if (flags and (O_RDONLY or O_WRONLY or O_RDWR)) = O_WRONLY then  
  begin
   AccessMode:=GENERIC_WRITE;
  end
 else if (flags and (O_RDONLY or O_WRONLY or O_RDWR)) = O_RDWR then   
  begin
   AccessMode:=GENERIC_READ or GENERIC_WRITE;
  end
 else
  begin
   {Return Error}
   ptr^._errno:=EINVAL;
   Exit;
  end;
  
 {Get Share Mode}
 ShareMode:=0;
 
 {Get Create Flags} 
 CreateFlags:=OPEN_EXISTING;
 if (flags and (O_CREAT or O_EXCL)) = (O_CREAT or O_EXCL) then
  begin
   CreateFlags:=CREATE_NEW;
  end
 else if (flags and O_CREAT) = O_CREAT then  
  begin
   CreateFlags:=OPEN_ALWAYS;
  end;
 
 {Create File}
 Handle:=FSCreateFile(name,AccessMode,ShareMode,CreateFlags,FILE_ATTRIBUTE_NORMAL);
 if Handle = INVALID_HANDLE_VALUE then
  begin
   {Return Error}
   ptr^._errno:=EINVAL;
   Exit;
  end;

 {Add Entry}  
 Entry:=SyscallsAddEntry(Handle);
 if Entry = nil then
  begin
   {Return Error}
   ptr^._errno:=ENOMEM;
   Exit;
  end;
  
 {Check Append}
 if (flags and O_APPEND) = O_APPEND then    
  begin
   FSFileSeekEx(Handle,0,FILE_END);
  end; 
 
 {Check Truncate}
 if (flags and O_TRUNC) = O_TRUNC then   
  begin
   FSFileSeekEx(Handle,0,FILE_BEGIN);
   FSFileTruncate(Handle);
  end;
 
 {Return Result}
 Result:=Entry^.Number;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _open_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _read_r(ptr: P_reent; fd: int; buf: Pointer; cnt: size_t): _ssize_t; cdecl;
{Read from a file}
{See: \newlib\libc\reent\readr.c}
var
 Ch:Char;
 Next:PChar;
 Count:LongInt;
 EndChar:Boolean;
 Entry:PSyscallsEntry;
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _read_r (ptr=' + IntToHex(PtrUInt(ptr),8) + ' fd=' + IntToStr(fd) + ' buf=' + IntToHex(PtrUInt(buf),8) + ' cnt=' + IntToStr(cnt) + ')');
 {$ENDIF}
 
 {Check descriptor}
 if fd = STDIN_FILENO then
  begin
   {Stdin}
   Count:=0;
   EndChar:=False;
   Next:=PChar(buf);
   while (Count < cnt) and not(EndChar) do
    begin
     if ConsoleReadChar(Ch,nil) then
      begin
       if Ch = #13 then EndChar:=True;
       
       Next^:=Ch;
       
       Inc(Next);
       Inc(Count);
       
       if EndChar and (Count < cnt) then
        begin
         Next^:=#10;
         
         Inc(Next);
         Inc(Count);
        end;
      end;
    end;
   
   Result:=Count;   
  end
 else
  begin
   {Normal file}
   Entry:=SyscallsGetEntry(fd);
   if Entry <> nil then
    begin
     {Read file}
     Result:=FSFileRead(Entry^.Handle,buf^,cnt);
    end
   else
    begin
     {Return Error}
     ptr^._errno:=EINVAL;
    end;    
  end;
  
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _read_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _rename_r(ptr: P_reent; old: PChar; new: PChar): int; cdecl;
{Rename a file}
{See: \newlib\libc\reent\renamer.c}
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _rename_r (ptr=' + IntToHex(PtrUInt(ptr),8) + ' old=' + StrPas(old) + ' new=' + StrPas(new) + ')');
 {$ENDIF}
 
 {Rename File}
 if FSRenameFile(old,new) then
  begin
   {Return Result}
   Result:=0;
  end
 else
  begin
   {Return Error}
   ptr^._errno:=EINVAL;
  end;  
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _rename_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _sbrk_r(ptr: P_reent; incr: ptrdiff_t): Pointer; cdecl;
{Increase program data space}
{See: \newlib\libc\reent\sbrkr.c}
var
 Value:Pointer;
begin
 {}
 Result:=Pointer(-1);
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _sbrk_r (ptr=' + IntToHex(PtrUInt(ptr),8) + ' incr=' + IntToStr(incr) + ')');
 {$ENDIF}
 
 {Check incr}
 if incr > 0 then
  begin
   {Increase Heap}
   Value:=SyscallsIncreaseHeap(incr);
  end
 else
  begin
   {Note: incr 0 can be used to determine the current heap end}
   Value:=SyscallsDecreaseHeap(-incr);
  end; 
  
 if Value <> nil then
  begin
   {Return Result}
   Result:=Value;
  end
 else
  begin
   {Return Error}
   ptr^._errno:=ENOMEM;
   Result:=Pointer(-1);
  end;  
  
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _sbrk_r (Result=' + IntToHex(PtrUInt(Result),8) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _kill_r(ptr: P_reent; pid: int; sig: int): int; cdecl;
{Send a signal}
{See: \newlib\libc\reent\signalr.c}
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _kill_r (ptr=' + IntToHex(PtrUInt(ptr),8) + ' pid=' + IntToStr(pid) + ' sig=' + IntToStr(sig) + ')');
 {$ENDIF}
 
 {Return Error}
 ptr^._errno:=EINVAL;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _kill_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _getpid_r(ptr: P_reent): int; cdecl;
{Process-ID; this is sometimes used to generate strings unlikely to conflict with other processes}
{See: \newlib\libc\reent\signalr.c}
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _getpid_r (ptr=' + IntToHex(PtrUInt(ptr),8) + ')');
 {$ENDIF}
 
 {Get Current Thread}
 Result:=ThreadGetCurrent;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _getpid_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}
{$IFDEF SYSCALLS_LARGE64_FILES}
function _stat64_r(ptr: P_reent; name: PChar; stat: Pstat64): int; cdecl;
{Status of a file (by name)}
{See: \newlib\libc\reent\stat64r.c}
var
 Handle:THandle;
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _stat64_r (ptr=' + IntToHex(PtrUInt(ptr),8) + ' name=' + StrPas(name) + ')');
 {$ENDIF}
 
 {Check stat}
 if stat = nil then Exit;
 
 {Open file}
 Handle:=FSCreateFile(name,GENERIC_READ,0,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL);
 if Handle = INVALID_HANDLE_VALUE then
  begin
   {Return Error}
   ptr^._errno:=ENOENT;
   Exit;
  end;
  
 {Get Stat}
 if SyscallsGetStat64(Handle,stat) then
  begin
   {Return Result}
   Result:=0;
  end
 else
  begin
   {Return Error}
   ptr^._errno:=EINVAL;
  end;  
 
 {Close File}
 FSFileClose(Handle);
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _stat64_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;
{$ENDIF}
{==============================================================================}

function _stat_r(ptr: P_reent; name: PChar; stat: Pstat): int; cdecl;
{Status of a file (by name)}
{See: \newlib\libc\reent\statr.c}
var
 Handle:THandle;
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _stat_r (ptr=' + IntToHex(PtrUInt(ptr),8) + ' name=' + StrPas(name) + ')');
 {$ENDIF}
 
 {Check stat}
 if stat = nil then Exit;
 
 {Open file}
 Handle:=FSCreateFile(name,GENERIC_READ,0,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL);
 if Handle = INVALID_HANDLE_VALUE then
  begin
   {Return Error}
   ptr^._errno:=ENOENT;
   Exit;
  end;
  
 {Get Stat}
 if SyscallsGetStat(Handle,stat) then
  begin
   {Return Result}
   Result:=0;
  end
 else
  begin
   {Return Error}
   ptr^._errno:=EINVAL;
  end;  
 
 {Close File}
 FSFileClose(Handle);
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _stat_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _times_r(ptr: P_reent; tms: Ptms): clock_t; cdecl;
{Timing information for current process}
{See: \newlib\libc\reent\timesr.c}
var
 SysTime:Int64;
 CreateTime:Int64;
 ExitTime:Int64;
 KernelTime:Int64;
begin
 {}
 Result:=clock_t(-1);
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _times_r (ptr=' + IntToHex(PtrUInt(ptr),8) + ')');
 {$ENDIF}
 
 {Check tms}
 if tms = nil then Exit;
 
 {Get Thread Times}
 if ThreadGetTimes(ThreadGetCurrent,CreateTime,ExitTime,KernelTime) = ERROR_SUCCESS then
  begin
   {$IFDEF SYSCALLS_DEBUG}
   if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  CreateTime=' + IntToHex(CreateTime,16));
   if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  ExitTime=' + IntToHex(ExitTime,16));
   if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  KernelTime=' + IntToHex(KernelTime,16));
   {$ENDIF}
  
   {Return tms}
   tms^.tms_utime:=0;
   if TIME_TICKS_PER_SCHEDULER_INTERRUPT > 0 then
    SysTime:=(KernelTime - TIME_TICKS_TO_1899) div TIME_TICKS_PER_SCHEDULER_INTERRUPT {Avoid 32-bit overflow}
   else
    SysTime:=0;
   tms^.tms_stime:=SysTime;
   tms^.tms_cutime:=0;
   tms^.tms_cstime:=0;
   
   {$IFDEF SYSCALLS_DEBUG}
   if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  SysTime=' + IntToHex(SysTime,16));
   if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  tms_stime=' + IntToStr(tms^.tms_stime));
   {$ENDIF}
   
   {Return Result}
   Result:=GetTickCount64;
  end
 else
  begin
   {Return Error}
   ptr^._errno:=EINVAL;
  end;  
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _times_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _unlink_r(ptr: P_reent; name: PChar): int; cdecl;
{Remove a file’s directory entry}
{See: \newlib\libc\reent\unlinkr.c}
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _unlink_r (ptr=' + IntToHex(PtrUInt(ptr),8) + ' name=' + StrPas(name) + ')');
 {$ENDIF}
 
 {Delete File}
 if FSDeleteFile(name) then
  begin
   {Return Result}
   Result:=0;
  end
 else
  begin
   {Return Error}
   ptr^._errno:=EINVAL;
  end;  
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _unlink_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _write_r(ptr: P_reent; fd: int; buf: Pointer; cnt: size_t): _ssize_t; cdecl;
{Write to a file}
{See: \newlib\libc\reent\writer.c}
var
 Next:PChar;
 Count:LongInt;
 Entry:PSyscallsEntry;
begin
 {}
 Result:=-1;
 
 {Check reent}
 if ptr = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _write_r (ptr=' + IntToHex(PtrUInt(ptr),8) + ' fd=' + IntToStr(fd) + ' buf=' + IntToHex(PtrUInt(buf),8) + ' cnt=' + IntToStr(cnt) + ')');
 {$ENDIF}
 
 {Check descriptor}
 if fd = STDOUT_FILENO then
  begin
   {Stdout}
   Count:=0;
   Next:=PChar(buf);
   while Count < cnt do
    begin
     if not ConsoleWriteChar(Next^,nil) then Exit;
   
     Inc(Next);
     Inc(Count);
    end;
   
   Result:=cnt;
  end
 else if fd = STDERR_FILENO then
  begin
   {Stderr}
   Count:=0;
   Next:=PChar(buf);
   while Count < cnt do
    begin
     if not ConsoleWriteChar(Next^,nil) then Exit;
   
     Inc(Next);
     Inc(Count);
    end;
   
   Result:=cnt;
  end
 else
  begin
   {Normal file}
   Entry:=SyscallsGetEntry(fd);
   if Entry <> nil then
    begin
     {Write file}
     Result:=FSFileWrite(Entry^.Handle,buf^,cnt);
    end
   else
    begin
     {Return Error}
     ptr^._errno:=EINVAL;
    end;    
  end;  
  
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _write_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}
{==============================================================================}
{Syscalls Functions (Extra)}
function mkdir(path: PChar; mode: int): int; cdecl;
{Create a directory}
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls mkdir (path=' + StrPas(path) + ' mode=' + IntToStr(mode) + ')');
 {$ENDIF}

 Result:=_mkdir_r(__getreent,path,mode);
end;

{==============================================================================}

function sysconf(name: int):int; cdecl;
{Get configurable system variables}
var
 ptr:P_reent;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls sysconf (name=' + IntToStr(name) + ')');
 {$ENDIF}
 
 {Check name}
 case name of
  _SC_CLK_TCK:begin
    {Clock ticks per second (Scheduler ticks)}
    Result:=SCHEDULER_INTERRUPTS_PER_SECOND;
   end;
  _SC_PAGESIZE:begin
    {Size of a page in bytes}
    Result:=MEMORY_PAGE_SIZE;
   end;
  //To Do //Implement any others that are required
 else
  begin
   {Return Error}
   Result:=-1;
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
  end; 
 end; 
end;

{==============================================================================}
{==============================================================================}
{Syscalls Functions (Pthread)}
//TestingPThreads

{==============================================================================}
{==============================================================================}
{Syscalls Helper Functions}
procedure __malloc_lock(ptr: P_reent); cdecl;
begin
 {}
 {Check reent}
 if ptr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls __malloc_lock (ptr=' + IntToHex(PtrUInt(ptr),8) + ')');
 {$ENDIF}
 
 {Lock Mutex}
 MutexLock(SyscallsMallocLock);
end;

{==============================================================================}

procedure __malloc_unlock(ptr: P_reent); cdecl;
begin
 {}
 {Check reent}
 if ptr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls __malloc_unlock (ptr=' + IntToHex(PtrUInt(ptr),8) + ')');
 {$ENDIF}

 {Unlock Mutex}
 MutexUnlock(SyscallsMallocLock);
end;

{==============================================================================}

procedure __env_lock(ptr: P_reent); cdecl;
begin
 {}
 {Check reent}
 if ptr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls __env_lock (ptr=' + IntToHex(PtrUInt(ptr),8) + ')');
 {$ENDIF}

 {Lock Mutex}
 MutexLock(SyscallsEnvLock);
end;

{==============================================================================}

procedure __env_unlock(ptr: P_reent); cdecl;
begin
 {}
 {Check reent}
 if ptr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls __env_unlock (ptr=' + IntToHex(PtrUInt(ptr),8) + ')');
 {$ENDIF}

 {Unlock Mutex}
 MutexUnlock(SyscallsEnvLock);
end;

{==============================================================================}
{==============================================================================}
{Syscalls Internal Functions}
function SyscallsGetStat(Handle:THandle;stat:Pstat):Boolean; 
var
 Attributes:Integer;
 CreateTime:SysUtils.FILETIME;
 AccessTime:SysUtils.FILETIME;
 WriteTime:SysUtils.FILETIME;
begin
 {}
 Result:=False;
 
 {Check Handle}
 if Handle = INVALID_HANDLE_VALUE then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Get Stat (Handle=' + IntToHex(Handle,8) + ')');
 {$ENDIF}
 
 {Check stat}
 if stat = nil then Exit;

 {Get stat}
 FillChar(stat^,SizeOf(Tstat),0);
 stat^.st_mode:=_S_IFREG;
 Attributes:=FSFileGetAttrEx(Handle);
 if (Attributes <> -1) and ((Attributes and faDirectory) <> 0) then
  begin
   stat^.st_mode:=_S_IFDIR;
  end;
 stat^.st_mode:=stat^.st_mode or _S_IREAD or _S_IWRITE or S_IEXEC;
 stat^.st_size:=FSFileSize(Handle);
 if FSGetFileTime(Handle,@CreateTime,@AccessTime,@WriteTime) then
  begin
   stat^.st_ctime:=(Int64(CreateTime) - TIME_TICKS_TO_1970) div TIME_TICKS_PER_SECOND;
   stat^.st_atime:=(Int64(AccessTime) - TIME_TICKS_TO_1970) div TIME_TICKS_PER_SECOND;
   stat^.st_mtime:=(Int64(WriteTime) - TIME_TICKS_TO_1970) div TIME_TICKS_PER_SECOND;
  end;
 
 {Return Result}
 Result:=True; 
end;

{==============================================================================}

function SyscallsGetStat64(Handle:THandle;stat64:Pstat64):Boolean; 
var
 Attributes:Integer;
 CreateTime:SysUtils.FILETIME;
 AccessTime:SysUtils.FILETIME;
 WriteTime:SysUtils.FILETIME;
begin
 {}
 Result:=False;
 
 {Check Handle}
 if Handle = INVALID_HANDLE_VALUE then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Get Stat64 (Handle=' + IntToHex(Handle,8) + ')');
 {$ENDIF}
 
 {Check stat64}
 if stat64 = nil then Exit;
 
 {Get stat64}
 FillChar(stat64^,SizeOf(Tstat64),0);
 stat64^.st_mode:=_S_IFREG;
 Attributes:=FSFileGetAttrEx(Handle);
 if (Attributes <> -1) and ((Attributes and faDirectory) <> 0) then
  begin
   stat64^.st_mode:=_S_IFDIR;
  end;
 stat64^.st_mode:=stat64^.st_mode or _S_IREAD or _S_IWRITE or S_IEXEC;
 stat64^.st_size:=FSFileSize(Handle);
 if FSGetFileTime(Handle,@CreateTime,@AccessTime,@WriteTime) then
  begin
   stat64^.st_ctime:=(Int64(CreateTime) - TIME_TICKS_TO_1970) div TIME_TICKS_PER_SECOND;
   stat64^.st_atime:=(Int64(AccessTime) - TIME_TICKS_TO_1970) div TIME_TICKS_PER_SECOND;
   stat64^.st_mtime:=(Int64(WriteTime) - TIME_TICKS_TO_1970) div TIME_TICKS_PER_SECOND;
  end;
 
 {Return Result}
 Result:=True; 
end;

{==============================================================================}

function SyscallsGetEntry(Number:LongWord):PSyscallsEntry; 
var
 First:PSyscallsEntry;
 Next:PSyscallsEntry;
begin
 {}
 Result:=nil;
 
 {Check Number}
 if Number > SYSCALLS_TABLE_MAX then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Get Entry (Number=' + IntToStr(Number) + ')');
 {$ENDIF}
 
 {Lock Table}
 if MutexLock(SyscallsTableLock) <> ERROR_SUCCESS then Exit;
 
 {Get First}
 First:=SyscallsTable.Entries[Number and SYSCALLS_TABLE_MASK];
 if First <> nil then
  begin
   Next:=First;
   while Next <> nil do
    begin
     {Check Number}
     if Next^.Number = Number then
      begin
       Result:=Next;
       Break;
      end; 
     
     Next:=Next^.Next; 
    end; 
  end;  
 
 {Unlock Table}
 MutexUnlock(SyscallsTableLock);
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Get Entry (Result=' + IntToHex(PtrUInt(Result),8) + ')');
 {$ENDIF}
end;

{==============================================================================}

function SyscallsAddEntry(Handle:THandle):PSyscallsEntry; 
var
 Start:LongWord;
 First:PSyscallsEntry;
 Next:PSyscallsEntry;
begin
 {}
 Result:=nil;
 
 {Check Handle}
 if Handle = INVALID_HANDLE_VALUE then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Add Entry (Handle=' + IntToHex(Handle,8) + ')');
 {$ENDIF}
 
 {Lock Table}
 if MutexLock(SyscallsTableLock) <> ERROR_SUCCESS then Exit;

 {Get Start}
 Start:=SyscallsTable.Next;
 
 {Find Next}
 Next:=SyscallsGetEntry(SyscallsTable.Next);
 while Next <> nil do
  begin
   {Update Next}
   Inc(SyscallsTable.Next);
   
   {Check Next}
   if SyscallsTable.Next > SYSCALLS_TABLE_MAX then
    begin
     SyscallsTable.Next:=SYSCALLS_TABLE_MIN;
    end;
   
   {Check Next}
   if SyscallsTable.Next < SYSCALLS_TABLE_MIN then
    begin
     SyscallsTable.Next:=SYSCALLS_TABLE_MIN;
    end;
   
   {Check Next}
   if SyscallsTable.Next = Start then Break;
   
   {Find Next}
   Next:=SyscallsGetEntry(SyscallsTable.Next);
  end;
  
 {Check Next}
 if Next = nil then
  begin
   {Create Entry}
   Next:=AllocMem(SizeOf(TSyscallsEntry));
   if Next <> nil then 
    begin
     {Update Entry}
     Next^.Number:=SyscallsTable.Next;
     Next^.Handle:=Handle;
     Next^.Prev:=nil;
     
     {Get First}
     First:=SyscallsTable.Entries[Next^.Number and SYSCALLS_TABLE_MASK];
     
     {Link Entry}
     Next^.Next:=First;
     if First <> nil then First^.Prev:=Next;
     SyscallsTable.Entries[Next^.Number and SYSCALLS_TABLE_MASK]:=Next;
     
     {Increment Count}
     Inc(SyscallsTable.Count);
     
     {$IFDEF SYSCALLS_DEBUG}
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Add Entry Number=' + IntToStr(Next^.Number));
     {$ENDIF}
     
     {Return Result}
     Result:=Next;
    end; 
  end;  
 
 {Unlock Table}
 MutexUnlock(SyscallsTableLock);
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Add Entry (Result=' + IntToHex(PtrUInt(Result),8) + ')');
 {$ENDIF}
end;

{==============================================================================}

function SyscallsRemoveEntry(Entry:PSyscallsEntry):Boolean;
var
 Prev:PSyscallsEntry;
 Next:PSyscallsEntry;
begin
 {}
 Result:=False;
 
 {Check Entry}
 if Entry = nil then Exit;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Remove Entry (Entry=' + IntToHex(PtrUInt(Entry),8) + ')');
 {$ENDIF}
 
 {Lock Table}
 if MutexLock(SyscallsTableLock) <> ERROR_SUCCESS then Exit;
 
 {Get Prev/Next}
 Prev:=Entry^.Prev;
 Next:=Entry^.Next;
 
 {Unlink Entry}
 if Prev = nil then
  begin
   SyscallsTable.Entries[Entry^.Number and SYSCALLS_TABLE_MASK]:=Next;
   if Next <> nil then
    begin
     Next^.Prev:=nil;
    end;       
  end
 else
  begin
   Prev^.Next:=Next;
   if Next <> nil then
    begin
     Next^.Prev:=Prev;
    end;       
  end;     

 {Decrement Count}
 Dec(SyscallsTable.Count);
 
 {Destroy Entry}
 FreeMem(Entry);
 
 {Return Result}
 Result:=True;
 
 {Unlock Table}
 MutexUnlock(SyscallsTableLock);
end;

{==============================================================================}

function SyscallsInitializeHeap:Boolean; 
var
 PageTableEntry:TPageTableEntry;
begin
 {}
 Result:=False;
 
 {Check Page Size}
 if MEMORY_PAGE_SIZE = 0 then Exit;
 
 {Check Block Size (Must be a power of 2)}
 if (SYSCALLS_HEAP_BLOCKSIZE = 0) or ((SYSCALLS_HEAP_BLOCKSIZE and (SYSCALLS_HEAP_BLOCKSIZE - 1)) <> 0) then
  begin
   {Default to 1MB}
   SYSCALLS_HEAP_BLOCKSIZE:=SIZE_1M;
  end;
  
 {Check Block Size (Must be at least page size)} 
 if SYSCALLS_HEAP_BLOCKSIZE < MEMORY_PAGE_SIZE then
  begin
   {Default to Page Size}
   SYSCALLS_HEAP_BLOCKSIZE:=MEMORY_PAGE_SIZE;
  end;
 
 {Check Block Base (Must be a multiple of page size)}
 if (SYSCALLS_HEAP_BLOCKSIZE mod MEMORY_PAGE_SIZE) <> 0 then
  begin
   SYSCALLS_HEAP_BLOCKSIZE:=SYSCALLS_HEAP_BLOCKSIZE - (SYSCALLS_HEAP_BLOCKSIZE mod MEMORY_PAGE_SIZE);
   if SYSCALLS_HEAP_BLOCKSIZE = 0 then SYSCALLS_HEAP_BLOCKSIZE:=MEMORY_PAGE_SIZE;
  end;
  
 {Check Heap Min (Must be a multiple of block size)}
 if (SYSCALLS_HEAP_MIN mod SYSCALLS_HEAP_BLOCKSIZE) <> 0 then
  begin
   SYSCALLS_HEAP_MIN:=SYSCALLS_HEAP_MIN - (SYSCALLS_HEAP_MIN mod SYSCALLS_HEAP_BLOCKSIZE);
   if SYSCALLS_HEAP_MIN = 0 then SYSCALLS_HEAP_MIN:=SYSCALLS_HEAP_BLOCKSIZE;
  end;
  
 {Check Heap Max (Must be a multiple of block size)}
 if (SYSCALLS_HEAP_MAX mod SYSCALLS_HEAP_BLOCKSIZE) <> 0 then
  begin
   SYSCALLS_HEAP_MAX:=SYSCALLS_HEAP_MAX - (SYSCALLS_HEAP_MAX mod SYSCALLS_HEAP_BLOCKSIZE);
   if SYSCALLS_HEAP_MAX = 0 then SYSCALLS_HEAP_MAX:=SYSCALLS_HEAP_BLOCKSIZE;
  end;
 
 {Check Heap Base (Must be a multiple of page size)}
 if (SYSCALLS_HEAP_BASE mod MEMORY_PAGE_SIZE) <> 0 then
  begin
   SYSCALLS_HEAP_BASE:=SYSCALLS_HEAP_BASE - (SYSCALLS_HEAP_BASE mod MEMORY_PAGE_SIZE);
  end;
 
 {Create First Block}
 SyscallsHeapFirst:=AllocMem(SizeOf(TSyscallsHeapBlock));
 if SyscallsHeapFirst = nil then
  begin
   if PLATFORM_LOG_ENABLED then PlatformLogError('Failed to create Syscalls Heap block');
   Exit;
  end;

 {Allocate First Block}
 SyscallsHeapFirst^.PhysicalAddress:=PtrUInt(GetAlignedMem(SYSCALLS_HEAP_MIN,MEMORY_PAGE_SIZE));
 if SyscallsHeapFirst^.PhysicalAddress = 0 then
  begin
   if PLATFORM_LOG_ENABLED then PlatformLogError('Failed to allocate Syscalls Heap block');
   Exit;
  end;
  
 {Check Heap Base}
 if SYSCALLS_HEAP_BASE = 0 then
  begin
   {Static Heap}
   {Update Block}
   SyscallsHeapFirst^.VirtualAddress:=SyscallsHeapFirst^.PhysicalAddress;
   SyscallsHeapFirst^.Size:=SYSCALLS_HEAP_MIN;
   SyscallsHeapFirst^.Used:=0;
   SyscallsHeapFirst^.Prev:=nil;
   SyscallsHeapFirst^.Next:=nil;
  end
 else
  begin
   {Dynamic Heap}
   {Check Block}
   PageTableEntry:=PageTableGetEntry(SyscallsHeapFirst^.PhysicalAddress);
   if PageTableEntry.Size <> MEMORY_PAGE_SIZE then
    begin
     {Map Block}
     PageTableEntry.Size:=MEMORY_PAGE_SIZE;
     while PageTableEntry.PhysicalAddress < (SyscallsHeapFirst^.PhysicalAddress + SYSCALLS_HEAP_MIN) do
      begin
       PageTableSetEntry(PageTableEntry);
       
       Inc(PageTableEntry.VirtualAddress,MEMORY_PAGE_SIZE);
       Inc(PageTableEntry.PhysicalAddress,MEMORY_PAGE_SIZE);
      end;
    end;
   
   {Remap Block}
   PageTableEntry:=PageTableGetEntry(SyscallsHeapFirst^.PhysicalAddress);
   PageTableEntry.VirtualAddress:=SYSCALLS_HEAP_BASE;
   PageTableEntry.Size:=MEMORY_PAGE_SIZE;
   while PageTableEntry.VirtualAddress < (SYSCALLS_HEAP_BASE + SYSCALLS_HEAP_MIN) do
    begin
     PageTableSetEntry(PageTableEntry);
     
     Inc(PageTableEntry.VirtualAddress,MEMORY_PAGE_SIZE);
     Inc(PageTableEntry.PhysicalAddress,MEMORY_PAGE_SIZE);
    end; 
   
   {Clean Cache}
   CleanDataCacheRange(SyscallsHeapFirst^.PhysicalAddress,SYSCALLS_HEAP_MIN);
   
   {Invalidate Cache}
   InvalidateDataCacheRange(SyscallsHeapFirst^.VirtualAddress,SYSCALLS_HEAP_MIN);
   
   {Update Block}
   SyscallsHeapFirst^.VirtualAddress:=SYSCALLS_HEAP_BASE;
   SyscallsHeapFirst^.Size:=SYSCALLS_HEAP_MIN;
   SyscallsHeapFirst^.Used:=0;
   SyscallsHeapFirst^.Prev:=nil;
   SyscallsHeapFirst^.Next:=nil;
  end;

 {Get Last Block}
 SyscallsHeapLast:=SyscallsHeapFirst;

 {Get Size and End}
 SyscallsHeapEnd:=Pointer(SyscallsHeapFirst^.VirtualAddress);
 SyscallsHeapSize:=SyscallsHeapFirst^.Size;
 
 {Initialize Lock}
 SyscallsHeapLock:=MutexCreateEx(False,MUTEX_DEFAULT_SPINCOUNT,MUTEX_FLAG_RECURSIVE);
 if SyscallsHeapLock = INVALID_HANDLE_VALUE then
  begin
   if PLATFORM_LOG_ENABLED then PlatformLogError('Failed to create Syscalls Heap lock');
   Exit;
  end;
 
 Result:=True;
end;

{==============================================================================}

function SyscallsIncreaseHeap(Size:LongWord):Pointer;
var
 Remain:LongWord;
 Address:Pointer;
 Prev:PSyscallsHeapBlock;
 Block:PSyscallsHeapBlock;
 PageTableEntry:TPageTableEntry;
begin
 {}
 Result:=nil;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Increase Heap (Size=' + IntToStr(Size) + ')');
 {$ENDIF}
 
 {Lock Heap}
 if MutexLock(SyscallsHeapLock) <> ERROR_SUCCESS then Exit;
 
 {Check Base}
 if SYSCALLS_HEAP_BASE = 0 then
  begin
   {Static Heap}
   {Get Last Block}
   Block:=SyscallsHeapLast;
   if Block <> nil then
    begin
     {$IFDEF SYSCALLS_DEBUG}
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  Block.PhysicalAddress=' + IntToHex(Block^.PhysicalAddress,8));
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  Block.Size=' + IntToStr(Block^.Size));
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  Block.Used=' + IntToStr(Block^.Used));
     {$ENDIF}

     {Check Block Used}
     if (Block^.Used + Size) <= Block^.Size then
      begin
       {Return End}
       Result:=SyscallsHeapEnd;
       
       {Update Used}
       Inc(Block^.Used,Size);
       
       {Update End}
       Inc(SyscallsHeapEnd,Size);
      end; 
      
     {$IFDEF SYSCALLS_DEBUG}
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  HeapEnd=' + IntToHex(PtrUInt(SyscallsHeapEnd),8));
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  HeapSize=' + IntToStr(SyscallsHeapSize));
     {$ENDIF}
    end;  
  end
 else
  begin
   {Dynamic Heap}
   Address:=nil;
   
   {Get Last Block}
   Block:=SyscallsHeapLast;
   while Block <> nil do
    begin
     {$IFDEF SYSCALLS_DEBUG}
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  Block.PhysicalAddress=' + IntToHex(Block^.PhysicalAddress,8));
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  Block.VirtualAddress=' + IntToHex(Block^.VirtualAddress,8));
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  Block.Size=' + IntToStr(Block^.Size));
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  Block.Used=' + IntToStr(Block^.Used));
     {$ENDIF}
    
     {Get Remain}
     Remain:=Size;
     
     {Check Block Used}
     if (Block^.Used + Remain) > Block^.Size then
      begin
       {Update Remain}
       Remain:=Block^.Size - Block^.Used;
      end;
     
     {Check Remain}     
     if Remain > 0 then
      begin
       {Get End}
       if Address = nil then Address:=SyscallsHeapEnd;
       
       {Update Used}
       Inc(Block^.Used,Remain);
       
       {Update End}
       Inc(SyscallsHeapEnd,Remain);
       
       {$IFDEF SYSCALLS_DEBUG}
       if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  HeapEnd=' + IntToHex(PtrUInt(SyscallsHeapEnd),8));
       if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  HeapSize=' + IntToStr(SyscallsHeapSize));
       {$ENDIF}
       
       {Update Size}
       Dec(Size,Remain);
       
       {Check Complete}
       if Size = 0 then Break;
      end
     else
      begin
       {Add New Block}
       {$IFDEF SYSCALLS_DEBUG}
       if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls New Heap Block');
       {$ENDIF}
       
       {Check Max}
       if SyscallsHeapSize >= SYSCALLS_HEAP_MAX then
        begin
         {Failure}
         Address:=nil;
         Break;
        end; 
       
       {Get Prev}
       Prev:=Block;
       
       {Create Block}
       Block:=AllocMem(SizeOf(TSyscallsHeapBlock));
       if Block = nil then
        begin
         {Failure}
         Address:=nil;
         Break;
        end; 

       {Allocate Block}
       Block^.PhysicalAddress:=PtrUInt(GetAlignedMem(SYSCALLS_HEAP_BLOCKSIZE,MEMORY_PAGE_SIZE));
       if Block^.PhysicalAddress = 0 then
        begin
         {Failure}
         Address:=nil;
         Break;
        end; 
       
       {Check Block}
       PageTableEntry:=PageTableGetEntry(Block^.PhysicalAddress);
       if PageTableEntry.Size <> MEMORY_PAGE_SIZE then
        begin
         {Map Block}
         PageTableEntry.Size:=MEMORY_PAGE_SIZE;
         while PageTableEntry.PhysicalAddress < (Block^.PhysicalAddress + SYSCALLS_HEAP_BLOCKSIZE) do
          begin
           PageTableSetEntry(PageTableEntry);
           
           Inc(PageTableEntry.VirtualAddress,MEMORY_PAGE_SIZE);
           Inc(PageTableEntry.PhysicalAddress,MEMORY_PAGE_SIZE);
          end;
        end;
       
       {Remap Block}
       PageTableEntry:=PageTableGetEntry(Block^.PhysicalAddress);
       PageTableEntry.VirtualAddress:=PtrUInt(SyscallsHeapEnd);
       PageTableEntry.Size:=MEMORY_PAGE_SIZE;
       while PageTableEntry.VirtualAddress < (PtrUInt(SyscallsHeapEnd) + SYSCALLS_HEAP_BLOCKSIZE) do
        begin
         PageTableSetEntry(PageTableEntry);
         
         Inc(PageTableEntry.VirtualAddress,MEMORY_PAGE_SIZE);
         Inc(PageTableEntry.PhysicalAddress,MEMORY_PAGE_SIZE);
        end; 
       
       {Clean Cache}
       CleanDataCacheRange(Block^.PhysicalAddress,SYSCALLS_HEAP_BLOCKSIZE);
       
       {Invalidate Cache}
       InvalidateDataCacheRange(Block^.VirtualAddress,SYSCALLS_HEAP_BLOCKSIZE);
       
       {Update Block}
       Block^.VirtualAddress:=PtrUInt(SyscallsHeapEnd);
       Block^.Size:=SYSCALLS_HEAP_BLOCKSIZE;
       Block^.Used:=0;
       Block^.Prev:=Prev;
       Block^.Next:=nil;
       
       {Link Block}
       Prev^.Next:=Block;
       SyscallsHeapLast:=Block;
       
       {Update Size}
       Inc(SyscallsHeapSize,SYSCALLS_HEAP_BLOCKSIZE);
       
       {$IFDEF SYSCALLS_DEBUG}
       if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  HeapEnd=' + IntToHex(PtrUInt(SyscallsHeapEnd),8));
       if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  HeapSize=' + IntToStr(SyscallsHeapSize));
       {$ENDIF}
      end;
    end; 
    
   {Return End} 
   Result:=Address;
  end;
 
 {Unlock Heap}
 MutexUnlock(SyscallsHeapLock);
end;

{==============================================================================}

function SyscallsDecreaseHeap(Size:LongWord):Pointer; 
var
 Block:PSyscallsHeapBlock;
begin
 {}
 Result:=nil;
 
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Decrease Heap (Size=' + IntToStr(Size) + ')');
 {$ENDIF}
 
 {Lock Heap}
 if MutexLock(SyscallsHeapLock) <> ERROR_SUCCESS then Exit;
 
 {Check Base}
 if SYSCALLS_HEAP_BASE = 0 then
  begin
   {Static Heap}
   {Get Last Block}
   Block:=SyscallsHeapLast;
   if Block <> nil then
    begin
     {Check Block Used}
     if Block^.Used >= Size then
      begin
       {Return End}
       Result:=SyscallsHeapEnd;
       
       {Update Used}
       Dec(Block^.Used,Size);
       
       {Update End}
       Dec(SyscallsHeapEnd,Size);
      end; 
      
     {$IFDEF SYSCALLS_DEBUG}
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  HeapEnd=' + IntToHex(PtrUInt(SyscallsHeapEnd),8));
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  HeapSize=' + IntToStr(SyscallsHeapSize));
     {$ENDIF}
    end;  
  end
 else
  begin
   {Dynamic Heap}
   {Get Last Block}
   Block:=SyscallsHeapLast;
   if Block <> nil then
    begin
     {Check Block Used}
     if Block^.Used >= Size then
      begin
       {Return End}
       Result:=SyscallsHeapEnd;
       
       {Update Used}
       Dec(Block^.Used,Size);
       
       {Update End}
       Dec(SyscallsHeapEnd,Size);
      end; 
     {Do not allow decrease beyond the last block} 
     
     {$IFDEF SYSCALLS_DEBUG}
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  HeapEnd=' + IntToHex(PtrUInt(SyscallsHeapEnd),8));
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  HeapSize=' + IntToStr(SyscallsHeapSize));
     {$ENDIF}
    end;  
  end;
 
 {Unlock Heap}
 MutexUnlock(SyscallsHeapLock);
end;

{==============================================================================}
{==============================================================================}

initialization
 SyscallsInit;

{==============================================================================}
 
finalization
 SyscallsQuit;

{==============================================================================}
{==============================================================================}

end.
 