{
Ultibo Newlib C Library Syscalls interface unit.

Copyright (C) 2016 - Paul Jervois.
Copyright (C) 2025 - SoftOz Pty Ltd.

Arch
====

 <All>

Boards
======

 <All>

Licence
=======

 LGPLv2.1 with static linking exception (See COPYING.modifiedLGPL.txt)

Credits
=======

 Information for this unit was obtained from:

References
==========

  Newlib - http://www.sourceware.org/newlib/

  Libc - https://www.sourceware.org/newlib/libc.html

  Libm - https://www.sourceware.org/newlib/libm.html

  POSIX Threads (pthreads) - http://pubs.opengroup.org/onlinepubs/7908799/xsh/pthread.h.html
                             http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html

  POSIX Sockets - http://pubs.opengroup.org/onlinepubs/009695399/basedefs/sys/socket.h.html

Syscalls
========

 This unit provides the system calls (syscalls) interface for the Newlib C library implementation
 to allow code compiled with GCC to be linked with Ultibo applications.

 The Newlib C library is a portable C library designed to be used in embedded environments as well
 as many other situations. It is made available by RedHat from the sourceware.org website, new
 releases are made at least yearly and this unit has been developed using 4.4.0 but should
 work mostly unchanged with future releases.

 The build process below creates the libc.a, libm.a and libg.a static libraries, in addition
 to those GCC also requires the libgcc.a support library which is built at the same time as
 the compiler and provided in the distribution.

 The build process is documented for Debian but should be translatable to other platforms. As
 documented this will produce a version of Newlib that has support for recursive library calls,
 has dynamic support for multiple threads and is compiled for the specific architectures that
 are supported by Ultibo.

 Note that Newlib supports code compiled with other C compilers so it should be completely
 possible to link code generated by other C compilers with Ultibo applications. At this
 stage it has only been tested with GCC.

 Building Newlib:

  Flags: REENTRANT_SYSCALLS_PROVIDED
         __DYNAMIC_REENT__
         __LARGE64_FILES
         _REENT_BACKWARD_BINARY_COMPAT
         _POSIX_THREADS

  Options:

   Raspberry Pi

    -mabi=aapcs
    -marm
    -march=armv6
    -mcpu=arm1176jzf-s
    -mfpu=vfp
    -mfloat-abi=hard

   Raspberry Pi2/3/4 and QEMU VersatilePB (32-bit)

    -mabi=aapcs
    -marm
    -march=armv7-a
    -mfpu=vfpv3-d16
    -mfloat-abi=hard

   Raspberry Pi3/4 and QEMU VersatilePB (64-bit)

    -mabi=lp64 (Note: Supported only by later versions of GCC)
    -march=armv8-a

  Build:

   Download Newlib (currently 4.4.0.20231231) from https://www.sourceware.org/ftp/newlib/index.html

   Unpack to folder $HOME/newlib-4.4.0.20231231


   Build with GCC arm-none-eabi 13.3.rel1

   Extracted to folder $HOME/arm-gnu-toolchain-13.3.rel1-x86_64-arm-none-eabi


   Build with GCC aarch64-none-elf 13.3.rel1

   Extracted to folder $HOME/arm-gnu-toolchain-13.3.rel1-x86_64-aarch64-none-elf


   Edit $HOME/libraries/newlib-4.4.0.20231231/configure.host

   Change stdio64_dir= to stdio64_dir=stdio64


   Install Ultibo API to $HOME/ultibo/api

  Build ARMv6:

   cd

   mkdir build-newlib-armv6

   cd build-newlib-armv6

   export PATH=$HOME/arm-gnu-toolchain-13.3.rel1-x86_64-arm-none-eabi/bin:$PATH

   ../newlib-4.4.0.20231231/configure --disable-multilib --target=arm-none-eabi CFLAGS_FOR_TARGET="-O2 -mabi=aapcs -marm -march=armv6 -mfpu=vfp -mfloat-abi=hard -I$HOME/ultibo/api/include -DREENTRANT_SYSCALLS_PROVIDED -D__DYNAMIC_REENT__ -D__LARGE64_FILES -D_REENT_BACKWARD_BINARY_COMPAT -D_POSIX_THREADS"

   make all

   Dump:

    cd arm-none-eabi/newlib
    arm-none-eabi-objdump -d libc.a > libc.list
    arm-none-eabi-objdump -d libg.a > libg.list
    arm-none-eabi-objdump -d libm.a > libm.list

  Build ARMv7:

   cd

   mkdir build-newlib-armv7

   cd build-newlib-armv7

   export PATH=$HOME/arm-gnu-toolchain-13.3.rel1-x86_64-arm-none-eabi/bin:$PATH

   ../newlib-4.4.0.20231231/configure --disable-multilib --target=arm-none-eabi CFLAGS_FOR_TARGET="-O2 -mabi=aapcs -marm -march=armv7-a -mfpu=vfpv3-d16 -mfloat-abi=hard -I$HOME/ultibo/api/include -DREENTRANT_SYSCALLS_PROVIDED -D__DYNAMIC_REENT__ -D__LARGE64_FILES -D_REENT_BACKWARD_BINARY_COMPAT -D_POSIX_THREADS"

   make all

   Dump:

    cd arm-none-eabi/newlib
    arm-none-eabi-objdump -d libc.a > libc.list
    arm-none-eabi-objdump -d libg.a > libg.list
    arm-none-eabi-objdump -d libm.a > libm.list

  Build ARMv8:

   cd

   mkdir build-newlib-armv8

   cd build-newlib-armv8

   export PATH=$HOME/arm-gnu-toolchain-13.3.rel1-x86_64-aarch64-none-elf/bin:$PATH

   ../newlib-4.4.0.20231231/configure --disable-multilib --target=aarch64-none-elf CFLAGS_FOR_TARGET="-O2 -march=armv8-a -I$HOME/ultibo/api/include -DREENTRANT_SYSCALLS_PROVIDED -D__DYNAMIC_REENT__ -D__LARGE64_FILES -D_REENT_BACKWARD_BINARY_COMPAT -D_POSIX_THREADS"

   make all

   Dump:

    cd aarch64-none-elf/newlib
    aarch64-none-elf-objdump -d libc.a > libc.list
    aarch64-none-elf-objdump -d libg.a > libg.list
    aarch64-none-elf-objdump -d libm.a > libm.list

 Notes:

  File handles (fd) passed to and returned from this unit are int values which are 32-bit
  however internally Newlib stores these into the _file member of a _FILE structure (see
  below) and this is defined as short which is only 16-bit. Because of this we have to map
  each Ultibo handle to a TSyscallsEntry and use the functions SyscallsAddEntry,
  SyscallsRemoveEntry and SyscallsGetEntry which start at zero and increment to 1023 (was 65535).

  The global errno variable (not used for reentrant version) is defined in
  \newlib\libc\reent\reent.c

   int errno;

  The global environ variable is defined in
  \newlib\libc\stdlib\environ.c

   char **environ = &initial_env[0];

  The environ variable is allocated by this unit during initialization and the existing
  system environment is copied to it. The environ variable must not be modified directly
  by applications, the only access to it should be using getenv(), setenv() and unsetenv().

  The TZ environment variable is used by a number of functions in Newlib including tzset and
  strftime. This variable can be set on the command line or using the SetEnvironmentVariable()
  function in the Ultibo unit. See the GNU C library reference for details of the format and
  value of the TZ environment variable:

   https://www.gnu.org/software/libc/manual/html_node/TZ-Variable.html

  Memory management for the C library and code compiled to use it is handled by Newlib itself
  which provides a complete implementation of malloc(), free(), calloc(), realloc() and others.

  This implementation relies on the underlying platform to implement sbrk() (_sbrk_r for the
  reentrant build of the library) and this unit provides all of the necessary details of this
  to allow full functionality of the memory management within the C library.

  Because sbrk() expects a contiguous heap space that grows upward in response to each request
  the Ultibo implementation uses the virtual memory functionality of the processor to map
  blocks of (possibly not contiguous) memory allocated from the Ultibo heap manager into
  an address space dedicated to supporting the C library.

  There are a number of parameters in the GlobalConfig unit which can be used to adjust the
  default behaviour of this as follows:

   SYSCALLS_HEAP_BASE - The starting point (bottom) of the virtual heap provided by sbrk() (Default: $C0000000)
   SYSCALLS_HEAP_MIN - The minimum (initial) allocation made to the virtual heap during startup (Default: 2MB)
   SYSCALLS_HEAP_MAX - The maximum size the virtual heap will be allowed to grow to (Default: 1GB)
   SYSCALLS_HEAP_BLOCKSIZE - The size of each block added to the virtual heap (Default: 1MB)

  Under normal usage these parameters should not need to be changed but they are available for
  advanced use cases which may require them.

}

{--$mode delphi} {Default to Delphi compatible syntax} {Not compatible with external definitions below}
{$mode objfpc}
{$H+}          {Default to AnsiString}
{$inline on}   {Allow use of Inline procedures}

unit Syscalls;

interface

uses
  GlobalConfig,
  GlobalConst,
  GlobalTypes,
  GlobalSock,
  Platform,
  Threads,
  HeapManager,
  Devices,
  FileSystem,
  Sockets,
  Crypto,
  Ultibo,
  SysUtils;

//To Do //Which Pthreads functions are cancellation points? (Find a list)
        //See: http://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_09_05

//To Do //Dummy / wrapper for pthread_kill()
        //See: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/pthread.h.html
        //And: pthread.h
        // pthread_atfork
        // pthread_barrier_init / pthread_barrier_destroy / pthread_barrier_wait
        // pthread_cond_clockwait
        // pthread_rwlock_clockrdlock / pthread_rwlock_clockwrlock
        // pthread_sigmask ?

{==============================================================================}
{Global definitions}
{$INCLUDE GlobalDefines.inc}

{$packrecords C}

{==============================================================================}
{Local definitions}
{$DEFINE SYSCALLS_USE_INITFINI_ARRAY}       {Use the init_atray and fini_array sections for global constructors and initialization instead of ctors and dtors (Default: On)}
{--$DEFINE SYSCALLS_USE_LIBC_INITFINI}      {Use the functions built into Libc to process the init_array and fini_array sections instead of processing them locally (Default: Off)}

{$DEFINE SYSCALLS_WARN_UNINITIALIZED}       {Log use of uninitialized mutex, condition and rwlock variables as a warning (Default: On)}
{$DEFINE SYSCALLS_CREATE_UNINITIALIZED}     {Allow uninitialized mutex, condition and rwlock variables to be created on first use (Default: On)}

{--$DEFINE _POSIX_THREAD_GUARDSIZE}         {Enable Pthread Guard Size attribute (Default: Off) (Not used by Ultibo}
{--$DEFINE _POSIX_THREAD_CPUTIME}           {Enable Pthread CPU Time Clock Allowed attribute (Default: Off) (Not used by Ultibo}

{--$DEFINE _POSIX_THREAD_SPORADIC_SERVER}   {Enable Pthread Scheduling for Sporadic server (Default: Off) (Not used by Ultibo}

{--$DEFINE _POSIX_THREAD_PROCESS_SHARED}    {Enable Pthread Mutex Process Shared attribute (Default: Off) (Not used by Ultibo}
{--$DEFINE _POSIX_THREAD_PRIO_PROTECT}      {Enable Pthread Mutex Priority Ceiling Shared attribute (Default: Off) (Not used by Ultibo}
{$DEFINE _UNIX98_THREAD_MUTEX_ATTRIBUTES}   {Enable Pthread Mutex Type attribute (Default: On)}

{$DEFINE SYSCALLS_REENT_BACKWARD_BINARY_COMPAT} {Maintain backward compatibility (by adding reserved fields) for _reent structure (Default: On)}

{==============================================================================}
const
 {Syscalls specific constants}

 {Basic constants}
 {From limits.h}
 INT_MAX  = 2147483647;
 INT_MIN  = -INT_MAX - 1;
 UINT_MAX = (INT_MAX * 2) + 1;

 LONG_MAX  = {$ifdef CPU64}9223372036854775807{$else CPU64}2147483647{$endif CPU64};
 LONG_MIN  = -LONG_MAX - 1;
 ULONG_MAX = (LONG_MAX * 2) + 1;

 ARG_MAX = 4096;
 PATH_MAX = 4096;

const
 {From sys/syslimits.h}
 {ARG_MAX = 65536;} {max bytes for an exec function}
 NAME_MAX = 255; {max bytes in a file name}
 {PATH_MAX = 1024;} {max bytes in pathname}
 IOV_MAX = 1024; {max elements in i/o vector}

const
 {Newlib constants from sys/errno.h}
 EPERM             = 1;       // Not owner
 ENOENT            = 2;       // No such file or directory
 ESRCH             = 3;       // No such process
 EINTR             = 4;       // Interrupted system call
 EIO               = 5;       // I/O error
 ENXIO             = 6;       // No such device or address
 E2BIG             = 7;       // Arg list too long
 ENOEXEC           = 8;       // Exec format error
 EBADF             = 9;       // Bad file number
 ECHILD            = 10;      // No children
 EAGAIN            = 11;      // No more processes
 ENOMEM            = 12;      // Not enough space
 EACCES            = 13;      // Permission denied
 EFAULT            = 14;      // Bad address
 ENOTBLK           = 15;      // Block device required
 EBUSY             = 16;      // Device or resource busy
 EEXIST            = 17;      // File exists
 EXDEV             = 18;      // Cross-device link
 ENODEV            = 19;      // No such device
 ENOTDIR           = 20;      // Not a directory
 EISDIR            = 21;      // Is a directory
 EINVAL            = 22;      // Invalid argument
 ENFILE            = 23;      // Too many open files in system
 EMFILE            = 24;      // File descriptor value too large
 ENOTTY            = 25;      // Not a character device
 ETXTBSY           = 26;      // Text file busy
 EFBIG             = 27;      // File too large
 ENOSPC            = 28;      // No space left on device
 ESPIPE            = 29;      // Illegal seek
 EROFS             = 30;      // Read-only file system
 EMLINK            = 31;      // Too many links
 EPIPE             = 32;      // Broken pipe
 EDOM              = 33;      // Mathematics argument out of domain of function
 ERANGE            = 34;      // Result too large
 ENOMSG            = 35;      // No message of desired type
 EIDRM             = 36;      // Identifier removed
 ECHRNG            = 37;      // Channel number out of range
 EL2NSYNC          = 38;      // Level 2 not synchronized
 EL3HLT            = 39;      // Level 3 halted
 EL3RST            = 40;      // Level 3 reset
 ELNRNG            = 41;      // Link number out of range
 EUNATCH           = 42;      // Protocol driver not attached
 ENOCSI            = 43;      // No CSI structure available
 EL2HLT            = 44;      // Level 2 halted
 EDEADLK           = 45;      // Deadlock
 ENOLCK            = 46;      // No lock
 EBADE             = 50;      // Invalid exchange
 EBADR             = 51;      // Invalid request descriptor
 EXFULL            = 52;      // Exchange full
 ENOANO            = 53;      // No anode
 EBADRQC           = 54;      // Invalid request code
 EBADSLT           = 55;      // Invalid slot
 EDEADLOCK         = 56;      // File locking deadlock error
 EBFONT            = 57;      // Bad font file fmt
 ENOSTR            = 60;      // Not a stream
 ENODATA           = 61;      // No data (for no delay io)
 ETIME             = 62;      // Stream ioctl timeout
 ENOSR             = 63;      // No stream resources
 ENONET            = 64;      // Machine is not on the network
 ENOPKG            = 65;      // Package not installed
 EREMOTE           = 66;      // The object is remote
 ENOLINK           = 67;      // Virtual circuit is gone
 EADV              = 68;      // Advertise error
 ESRMNT            = 69;      // Srmount error
 ECOMM             = 70;      // Communication error on send
 EPROTO            = 71;      // Protocol error
 EMULTIHOP         = 74;      // Multihop attempted
 ELBIN             = 75;      // Inode is remote (not really error)
 EDOTDOT           = 76;      // Cross mount point (not really error)
 EBADMSG           = 77;      // Bad message
 EFTYPE            = 79;      // Inappropriate file type or format
 ENOTUNIQ          = 80;      // Given log. name not unique
 EBADFD            = 81;      // f.d. invalid for this operation
 EREMCHG           = 82;      // Remote address changed
 ELIBACC           = 83;      // Can't access a needed shared lib
 ELIBBAD           = 84;      // Accessing a corrupted shared lib
 ELIBSCN           = 85;      // .lib section in a.out corrupted
 ELIBMAX           = 86;      // Attempting to link in too many libs
 ELIBEXEC          = 87;      // Attempting to exec a shared library
 ENOSYS            = 88;      // Function not implemented
 ENMFILE           = 89;      // No more files
 ENOTEMPTY         = 90;      // Directory not empty
 ENAMETOOLONG      = 91;      // File or path name too long
 ELOOP             = 92;      // Too many symbolic links
 EOPNOTSUPP        = 95;      // Operation not supported on socket
 EPFNOSUPPORT      = 96;      // Protocol family not supported
 ECONNRESET        = 104;     // Connection reset by peer
 ENOBUFS           = 105;     // No buffer space available
 EAFNOSUPPORT      = 106;     // Address family not supported by protocol family
 EPROTOTYPE        = 107;     // Protocol wrong type for socket
 ENOTSOCK          = 108;     // Socket operation on non-socket
 ENOPROTOOPT       = 109;     // Protocol not available
 ESHUTDOWN         = 110;     // Can't send after socket shutdown
 ECONNREFUSED      = 111;     // Connection refused
 EADDRINUSE        = 112;     // Address already in use
 ECONNABORTED      = 113;     // Software caused connection abort
 ENETUNREACH       = 114;     // Network is unreachable
 ENETDOWN          = 115;     // Network interface is not configured
 ETIMEDOUT         = 116;     // Connection timed out
 EHOSTDOWN         = 117;     // Host is down
 EHOSTUNREACH      = 118;     // Host is unreachable
 EINPROGRESS       = 119;     // Connection already in progress
 EALREADY          = 120;     // Socket already connected
 EDESTADDRREQ      = 121;     // Destination address required
 EMSGSIZE          = 122;     // Message too long
 EPROTONOSUPPORT   = 123;     // Unknown protocol
 ESOCKTNOSUPPORT   = 124;     // Socket type not supported
 EADDRNOTAVAIL     = 125;     // Address not available
 ENETRESET         = 126;     // Connection aborted by network
 EISCONN           = 127;     // Socket is already connected
 ENOTCONN          = 128;     // Socket is not connected
 ETOOMANYREFS      = 129;
 EPROCLIM          = 130;
 EUSERS            = 131;
 EDQUOT            = 132;
 ESTALE            = 133;
 ENOTSUP           = 134;     // Not supported
 ENOMEDIUM         = 135;     // No medium (in tape drive)
 ENOSHARE          = 136;     // No such host or network path
 ECASECLASH        = 137;     // Filename exists with different case
 EILSEQ            = 138;     // Illegal byte sequence
 EOVERFLOW         = 139;     // Value too large for defined data type
 ECANCELED         = 140;     // Operation canceled
 ENOTRECOVERABLE   = 141;     // State not recoverable
 EOWNERDEAD        = 142;     // Previous owner died
 ESTRPIPE          = 143;     // Streams pipe error
 EWOULDBLOCK       = EAGAIN;  // Operation would block

 __ELASTERROR      = 2000;    // Users can add values starting here

const
 {Newlib constants from sys/stat.h}
 {Note these values are Octal not Hexadecimal}
 _IFMT             = &0170000; // type of file
 _IFDIR            = &0040000; // directory
 _IFCHR            = &0020000; // character special
 _IFBLK            = &0060000; // block special
 _IFREG            = &0100000; // regular
 _IFLNK            = &0120000; // symbolic link
 _IFSOCK           = &0140000; // socket
 _IFIFO            = &0010000; // fifo

 S_BLKSIZE         = 1024;     // size of a block

 S_ISUID           = &0004000; // set user id on execution
 S_ISGID           = &0002000; // set group id on execution
 S_ISVTX           = &0001000; // save swapped text even after use

 S_IREAD           = &0000400; // read permission, owner
 S_IWRITE          = &0000200; // write permission, owner
 S_IEXEC           = &0000100; // execute/search permission, owner
 S_ENFMT           = &0002000; // enforcement-mode locking

 S_IFMT            = _IFMT;
 S_IFDIR           = _IFDIR;
 S_IFCHR           = _IFCHR;
 S_IFBLK           = _IFBLK;
 S_IFREG           = _IFREG;
 S_IFLNK           = _IFLNK;
 S_IFSOCK          = _IFSOCK;
 S_IFIFO           = _IFIFO;

 _S_IFMT           = _IFMT;
 _S_IFDIR          = _IFDIR;
 _S_IFCHR          = _IFCHR;
 _S_IFIFO          = _IFIFO;
 _S_IFREG          = _IFREG;
 _S_IREAD          = &0000400;
 _S_IWRITE         = &0000200;
 {Open modes}
 S_IRUSR           = &0000400; // read permission, owner
 S_IWUSR           = &0000200; // write permission, owner
 S_IXUSR           = &0000100; // execute / search permission, owner
 S_IRWXU           = S_IRUSR or S_IWUSR or S_IXUSR;
 S_IRGRP           = &0000040; // read permission, group
 S_IWGRP           = &0000020; // write permission, grougroup
 S_IXGRP           = &0000010; // execute / search permission, group
 S_IRWXG           = S_IRGRP or S_IWGRP or S_IXGRP;
 S_IROTH           = &0000004; // read permission, other
 S_IWOTH           = &0000002; // write permission, other
 S_IXOTH           = &0000001; // execute / search permission, other
 S_IRWXO           = S_IROTH or S_IWOTH or S_IXOTH;

const
 {File constants from default_fcntl.h}
 {Open flags}
 O_RDONLY          = 0;
 O_WRONLY          = 1;
 O_RDWR            = 2;
 O_APPEND          = $0008;    {append (writes guaranteed at the end)}
 O_ASYNC           = $0040;    {signal pgrp when data ready (Note: Not defined in default_fcntl.h, use "#define O_ASYNC _FASYNC" locally)}
 O_CREAT           = $0200;    {If set, the file will be created if it doesn’t already exist}
 O_EXCL            = $0800;    {If both O_CREAT and O_EXCL are set, then open fails if the specified file already exists. This is guaranteed to never clobber an existing file}

 O_SYNC            = $2000;
 O_NONBLOCK        = $4000;    {This prevents open from blocking for a “long time” to open the file. This is only meaningful for some kinds of files, usually devices such as serial ports; when it is not meaningful, it is harmless and ignored. Often opening a port to a modem blocks until the modem reports carrier detection; if O_NONBLOCK is specified, open will return immediately without a carrier}
 O_NOCTTY          = $8000;    {If the named file is a terminal device, don’t make it the controlling terminal for the process. See Job Control, for information about what it means to be the controlling terminal}
                               {On GNU/Hurd systems and 4.4 BSD, opening a file never makes it the controlling terminal and O_NOCTTY is zero. However, GNU/Linux systems and some other systems use a nonzero value for O_NOCTTY and set the controlling terminal when you open a file that is a terminal device; so to be portable, use O_NOCTTY when it is important to avoid this}

 {The open-time action flags tell open to do additional operations which are not really related to opening the file. The reason to do them as part of open instead of in separate calls is that open can do them atomically}
 O_TRUNC           = $0400;    {Truncate the file to zero length. This option is only useful for regular files, not special files such as directories or FIFOs. POSIX.1 requires that you open the file for writing to use O_TRUNC. In BSD and GNU you must have permission to write the file to truncate it, but you need not open for write access}
                               {This is the only open-time action flag specified by POSIX.1. There is no good reason for truncation to be done by open, instead of by calling ftruncate afterwards. The O_TRUNC flag existed in Unix before ftruncate was invented, and is retained for backward compatibility}

 {The remaining operating modes are BSD extensions. They exist only on some systems. On other systems, these macros are not defined}
 O_SHLOCK          = $0080;    {Acquire a shared lock on the file, as with flock. See File Locks}
                               {If O_CREAT is specified, the locking is done atomically when creating the file. You are guaranteed that no other process will get the lock on the new file first}
 O_EXLOCK          = $0100;    {Acquire an exclusive lock on the file, as with flock. See File Locks. This is atomic like O_SHLOCK}

 O_BINARY          = $0001000;
 O_TEXT            = $0002000;
 O_CLOEXEC         = $0040000;
 O_DIRECT          = $0080000;
 O_NOFOLLOW        = $0100000;
 O_DSYNC           = $0002000;
 O_RSYNC           = $0002000;
 O_DIRECTORY       = $0200000;
 O_EXEC            = $0400000;
 O_SEARCH          = $0400000;

 O_ACCMODE         = (O_RDONLY or O_WRONLY or O_RDWR);

 {Close on exec request}
 FD_CLOEXEC      = 1;  {Posix}

 {Fcntl requests}
 F_DUPFD         = 0;  {Duplicate fildes}
 F_GETFD         = 1;  {Get fildes flags (close on exec)}
 F_SETFD         = 2;  {Set fildes flags (close on exec)}
 F_GETFL         = 3;  {Get file flags}
 F_SETFL         = 4;  {Set file flags}
 F_GETOWN        = 5;  {Get owner - for ASYNC}
 F_SETOWN        = 6;  {Set owner - for ASYNC}
 F_GETLK         = 7;  {Get record-locking information}
 F_SETLK         = 8;  {Set or Clear a record-lock (Non-Blocking)}
 F_SETLKW        = 9;  {Set or Clear a record-lock (Blocking)}
 F_RGETLK        = 10; {Test a remote lock to see if it is blocked}
 F_RSETLK        = 11; {Set or unlock a remote lock}
 F_CNVT          = 12; {Convert a fhandle to an open fd}
 F_RSETLKW       = 13; {Set or Clear remote record-lock(Blocking)}
 F_DUPFD_CLOEXEC = 14; {As F_DUPFD, but set close-on-exec flag}

const
 {Handle constants from sys/unistd.h}
 STDIN_FILENO  = 0;       {standard input file descriptor}
 STDOUT_FILENO = 1;       {standard output file descriptor}
 STDERR_FILENO = 2;       {standard error file descriptor}

const
 {Sysconf values per IEEE Std 1003.1, 2008 Edition}
 _SC_ARG_MAX                       = 0;
 _SC_CHILD_MAX                     = 1;
 _SC_CLK_TCK                       = 2;
 _SC_NGROUPS_MAX                   = 3;
 _SC_OPEN_MAX                      = 4;
 _SC_JOB_CONTROL                   = 5;
 _SC_SAVED_IDS                     = 6;
 _SC_VERSION                       = 7;
 _SC_PAGESIZE                      = 8;
 _SC_PAGE_SIZE                     = _SC_PAGESIZE;

 _SC_NPROCESSORS_CONF              = 9;
 _SC_NPROCESSORS_ONLN              = 10;
 _SC_PHYS_PAGES                    = 11;
 _SC_AVPHYS_PAGES                  = 12;
 {End of non-POSIX values}
 _SC_MQ_OPEN_MAX                   = 13;
 _SC_MQ_PRIO_MAX                   = 14;
 _SC_RTSIG_MAX                     = 15;
 _SC_SEM_NSEMS_MAX                 = 16;
 _SC_SEM_VALUE_MAX                 = 17;
 _SC_SIGQUEUE_MAX                  = 18;
 _SC_TIMER_MAX                     = 19;
 _SC_TZNAME_MAX                    = 20;
 _SC_ASYNCHRONOUS_IO               = 21;
 _SC_FSYNC                         = 22;
 _SC_MAPPED_FILES                  = 23;
 _SC_MEMLOCK                       = 24;
 _SC_MEMLOCK_RANGE                 = 25;
 _SC_MEMORY_PROTECTION             = 26;
 _SC_MESSAGE_PASSING               = 27;
 _SC_PRIORITIZED_IO                = 28;
 _SC_REALTIME_SIGNALS              = 29;
 _SC_SEMAPHORES                    = 30;
 _SC_SHARED_MEMORY_OBJECTS         = 31;
 _SC_SYNCHRONIZED_IO               = 32;
 _SC_TIMERS                        = 33;
 _SC_AIO_LISTIO_MAX                = 34;
 _SC_AIO_MAX                       = 35;
 _SC_AIO_PRIO_DELTA_MAX            = 36;
 _SC_DELAYTIMER_MAX                = 37;
 _SC_THREAD_KEYS_MAX               = 38;
 _SC_THREAD_STACK_MIN              = 39;
 _SC_THREAD_THREADS_MAX            = 40;
 _SC_TTY_NAME_MAX                  = 41;
 _SC_THREADS                       = 42;
 _SC_THREAD_ATTR_STACKADDR         = 43;
 _SC_THREAD_ATTR_STACKSIZE         = 44;
 _SC_THREAD_PRIORITY_SCHEDULING    = 45;
 _SC_THREAD_PRIO_INHERIT           = 46;
 {_SC_THREAD_PRIO_PROTECT was _SC_THREAD_PRIO_CEILING in early drafts}
 _SC_THREAD_PRIO_PROTECT           = 47;
 _SC_THREAD_PRIO_CEILING           = _SC_THREAD_PRIO_PROTECT;
 _SC_THREAD_PROCESS_SHARED         = 48;
 _SC_THREAD_SAFE_FUNCTIONS         = 49;
 _SC_GETGR_R_SIZE_MAX              = 50;
 _SC_GETPW_R_SIZE_MAX              = 51;
 _SC_LOGIN_NAME_MAX                = 52;
 _SC_THREAD_DESTRUCTOR_ITERATIONS  = 53;
 _SC_ADVISORY_INFO                 = 54;
 _SC_ATEXIT_MAX                    = 55;
 _SC_BARRIERS                      = 56;
 _SC_BC_BASE_MAX                   = 57;
 _SC_BC_DIM_MAX                    = 58;
 _SC_BC_SCALE_MAX                  = 59;
 _SC_BC_STRING_MAX                 = 60;
 _SC_CLOCK_SELECTION               = 61;
 _SC_COLL_WEIGHTS_MAX              = 62;
 _SC_CPUTIME                       = 63;
 _SC_EXPR_NEST_MAX                 = 64;
 _SC_HOST_NAME_MAX                 = 65;
 _SC_IOV_MAX                       = 66;
 _SC_IPV6                          = 67;
 _SC_LINE_MAX                      = 68;
 _SC_MONOTONIC_CLOCK               = 69;
 _SC_RAW_SOCKETS                   = 70;
 _SC_READER_WRITER_LOCKS           = 71;
 _SC_REGEXP                        = 72;
 _SC_RE_DUP_MAX                    = 73;
 _SC_SHELL                         = 74;
 _SC_SPAWN                         = 75;
 _SC_SPIN_LOCKS                    = 76;
 _SC_SPORADIC_SERVER               = 77;
 _SC_SS_REPL_MAX                   = 78;
 _SC_SYMLOOP_MAX                   = 79;
 _SC_THREAD_CPUTIME                = 80;
 _SC_THREAD_SPORADIC_SERVER        = 81;
 _SC_TIMEOUTS                      = 82;
 _SC_TRACE                         = 83;
 _SC_TRACE_EVENT_FILTER            = 84;
 _SC_TRACE_EVENT_NAME_MAX          = 85;
 _SC_TRACE_INHERIT                 = 86;
 _SC_TRACE_LOG                     = 87;
 _SC_TRACE_NAME_MAX                = 88;
 _SC_TRACE_SYS_MAX                 = 89;
 _SC_TRACE_USER_EVENT_MAX          = 90;
 _SC_TYPED_MEMORY_OBJECTS          = 91;
 _SC_V7_ILP32_OFF32                = 92;
 _SC_V6_ILP32_OFF32                = _SC_V7_ILP32_OFF32;
 _SC_XBS5_ILP32_OFF32              = _SC_V7_ILP32_OFF32;
 _SC_V7_ILP32_OFFBIG               = 93;
 _SC_V6_ILP32_OFFBIG               = _SC_V7_ILP32_OFFBIG;
 _SC_XBS5_ILP32_OFFBIG             = _SC_V7_ILP32_OFFBIG;
 _SC_V7_LP64_OFF64                 = 94;
 _SC_V6_LP64_OFF64                 = _SC_V7_LP64_OFF64;
 _SC_XBS5_LP64_OFF64               = _SC_V7_LP64_OFF64;
 _SC_V7_LPBIG_OFFBIG               = 95;
 _SC_V6_LPBIG_OFFBIG               = _SC_V7_LPBIG_OFFBIG;
 _SC_XBS5_LPBIG_OFFBIG             = _SC_V7_LPBIG_OFFBIG;
 _SC_XOPEN_CRYPT                   = 96;
 _SC_XOPEN_ENH_I18N                = 97;
 _SC_XOPEN_LEGACY                  = 98;
 _SC_XOPEN_REALTIME                = 99;
 _SC_STREAM_MAX                    = 100;
 _SC_PRIORITY_SCHEDULING           = 101;
 _SC_XOPEN_REALTIME_THREADS        = 102;
 _SC_XOPEN_SHM                     = 103;
 _SC_XOPEN_STREAMS                 = 104;
 _SC_XOPEN_UNIX                    = 105;
 _SC_XOPEN_VERSION                 = 106;
 _SC_2_CHAR_TERM                   = 107;
 _SC_2_C_BIND                      = 108;
 _SC_2_C_DEV                       = 109;
 _SC_2_FORT_DEV                    = 110;
 _SC_2_FORT_RUN                    = 111;
 _SC_2_LOCALEDEF                   = 112;
 _SC_2_PBS                         = 113;
 _SC_2_PBS_ACCOUNTING              = 114;
 _SC_2_PBS_CHECKPOINT              = 115;
 _SC_2_PBS_LOCATE                  = 116;
 _SC_2_PBS_MESSAGE                 = 117;
 _SC_2_PBS_TRACK                   = 118;
 _SC_2_SW_DEV                      = 119;
 _SC_2_UPE                         = 120;
 _SC_2_VERSION                     = 121;
 _SC_THREAD_ROBUST_PRIO_INHERIT    = 122;
 _SC_THREAD_ROBUST_PRIO_PROTECT    = 123;
 _SC_XOPEN_UUCP                    = 124;

const
 {Reentrant constants from sys/reent.h}
 {rand48 family support}
 _RAND48_SEED_0 = $330e;
 _RAND48_SEED_1 = $abcd;
 _RAND48_SEED_2 = $1234;
 _RAND48_MULT_0 = $e66d;
 _RAND48_MULT_1 = $deec;
 _RAND48_MULT_2 = $0005;
 _RAND48_ADD    = $000b;

 {How big the some arrays are}
 _REENT_EMERGENCY_SIZE = 25;
 _REENT_ASCTIME_SIZE = 26;
 _REENT_SIGNAL_SIZE = 24;

 _ATEXIT_SIZE = 32;  {Must be at least 32 to guarantee ANSI conformance}

{$IFDEF SYSCALLS_EXPORT_SOCKETS}
const
 {Error constants from netdb.h}
 HOST_NOT_FOUND = 1; {Authoritative Answer Host not found}
 TRY_AGAIN      = 2; {Non-Authoritative Host not found, or SERVERFAIL}
 NO_RECOVERY    = 3; {Non recoverable errors, FORMERR, REFUSED, NOTIMP}
 NO_DATA        = 4; {Valid name, no data record of requested type}

 {Error constants from netdb.h}
 EAI_ADDRFAMILY = 1;  {address family for hostname not supported (Obsolete)}
 EAI_AGAIN      = 2;  {name could not be resolved at this time}
 EAI_BADFLAGS   = 3;  {flags parameter had an invalid value}
 EAI_FAIL       = 4;  {non-recoverable failure in name resolution}
 EAI_FAMILY     = 5;  {address family not recognized}
 EAI_MEMORY     = 6;  {memory allocation failure}
 EAI_NODATA     = 7;  {no address associated with hostname (Obsolete)}
 EAI_NONAME     = 8;  {name does not resolve}
 EAI_SERVICE    = 9;  {service not recognized for socket type}
 EAI_SOCKTYPE   = 10; {intended socket type was not recognized}
 EAI_SYSTEM     = 11; {system error returned in errno}
 EAI_BADHINTS   = 12; {invalid value for hints}
 EAI_PROTOCOL   = 13; {resolved protocol is unknown}
 EAI_OVERFLOW   = 14; {argument buffer overflow}
 EAI_MAX        = 15;

 EAI_STRERROR:array[0..EAI_MAX] of String = (
  'No error',
  'Address family for hostname not supported',  {EAI_ADDRFAMILY}
  'Temporary failure in name resolution',       {EAI_AGAIN}
  'Bad value for ai_flags',                     {EAI_BADFLAGS}
  'Non-recoverable failure in name resolution', {EAI_FAIL}
  'ai_family not supported',                    {EAI_FAMILY}
  'Memory allocation failure',                  {EAI_MEMORY}
  'No address associated with hostname',        {EAI_NODATA}
  'Name or service not known',                  {EAI_NONAME}
  'Servname not supported for ai_socktype',     {EAI_SERVICE}
  'ai_socktype not supported',                  {EAI_SOCKTYPE}
  'System error',                               {EAI_SYSTEM}
  'Invalid value for hints',                    {EAI_BADHINTS}
  'Resolved protocol is unknown',               {EAI_PROTOCOL}
  'Argument buffer too small',                  {EAI_OVERFLOW}
  'Unknown error');                             {EAI_MAX}
{$ENDIF}

const
 {Filesystem constants from sys/statfs.h}
 {Filesystem types}
 EXT_SUPER_MAGIC   = $137D;
 EXT2_SUPER_MAGIC  = $EF53;
 EXT3_SUPER_MAGIC  = $EF53;
 EXT4_SUPER_MAGIC  = $EF53;
 MSDOS_SUPER_MAGIC = $4d44;
 NTFS_SB_MAGIC     = $5346544e;
 SMB_SUPER_MAGIC   = $517b;

const
 {Filesystem constants from sys/statvfs.h}
 {Filesystem flags}
 ST_RDONLY = 1;
 ST_NOSUID = 2;

const
 {Scheduler constants from sched.h}
 {Scheduling Policies}
 SCHED_OTHER    = 0;
 SCHED_FIFO     = 1;
 SCHED_RR       = 2;
 {$IFDEF _POSIX_THREAD_SPORADIC_SERVER}
 SCHED_SPORADIC = 4;
 {$ENDIF}

const
 {CPU set constants from cpuset.h}
 CPU_SETSIZE = 32;
 _NCPUBITS = SizeOf(LongWord) * 8; {uint32_t}
 _NCPUWORDS = (CPU_SETSIZE + _NCPUBITS - 1) div _NCPUBITS;

const
 {Directory constants from dirent.h}
 DT_UNKNOWN     = 0;  {The file type could not be determined}
 DT_FIFO        = 1;  {A named pipe (FIFO)}
 DT_CHR         = 2;  {A character device}
 DT_DIR         = 4;  {A directory}
 DT_BLK         = 6;  {A block device}
 DT_REG         = 8;  {A regular file}
 DT_LNK         = 10; {A symbolic link}
 DT_SOCK        = 12; {A UNIX domain socket}

const
 {Pthread constants from sys/types.h}
 {Values for contention scope}
 PTHREAD_SCOPE_PROCESS = 0;
 PTHREAD_SCOPE_SYSTEM  = 1;

 {Values for inherit schedule}
 PTHREAD_INHERIT_SCHED  = 1; {Scheduling policy and associated attributes are inherited from the calling thread}
 PTHREAD_EXPLICIT_SCHED = 2; {Set from provided attribute object}

 {Values for detach state}
 PTHREAD_CREATE_DETACHED = 0;
 PTHREAD_CREATE_JOINABLE = 1; {Default}

 {Values for process shared}
 PTHREAD_PROCESS_PRIVATE = 0; {Visible within only the creating process}
 PTHREAD_PROCESS_SHARED  = 1; {Visible too all processes with access to the memory where the resource is located}

 {Values for blocking protocol}
 PTHREAD_PRIO_NONE    = 0;
 PTHREAD_PRIO_INHERIT = 1;
 PTHREAD_PRIO_PROTECT = 2;

 {Values for mutex type}
 PTHREAD_MUTEX_NORMAL     = 0; {This type of mutex does not detect deadlock. A thread attempting to relock this mutex without first unlocking it shall deadlock}
 PTHREAD_MUTEX_RECURSIVE  = 1; {A thread attempting to relock this mutex without first unlocking it shall succeed in locking the mutex}
 PTHREAD_MUTEX_ERRORCHECK = 2; {This type of mutex provides error checking. A thread attempting to relock this mutex without first unlocking it shall return with an error}
 PTHREAD_MUTEX_DEFAULT    = 3; {Attempting to recursively lock a mutex of this type results in undefined behavior}

 {Pthread constants from pthread.h}
 PTHREAD_CANCEL_ENABLE  = 0; {Default}
 PTHREAD_CANCEL_DISABLE = 1;

 PTHREAD_CANCEL_DEFERRED = 0; {Default}
 PTHREAD_CANCEL_ASYNCHRONOUS = 1;

 PTHREAD_CANCELED = Pointer(-1);

const
 {Clock constants from time.h}
 CLOCK_REALTIME           = 1;
 CLOCK_PROCESS_CPUTIME_ID = 2; {The CPU_time clock associated with the PROCESS making the function call}
 CLOCK_THREAD_CPUTIME_ID  = 3; {The CPU_time clock associated with the THREAD making the function call}
 CLOCK_MONOTONIC          = 4; {A clock whose value cannot be set via clock_settime() and which cannot have backward clock jumps}

const
 {Semaphore constants from semahore.h}
 SEM_FAILED = nil; {Value returned if `sem_open' failed.}
 SEM_VALUE_MAX = $7FFFFFFF; {Maximum value the semaphore can have}

const
 {Ioctl constants from sys/ioctl.h}
 _IOC_NRBITS = 8;
 _IOC_TYPEBITS = 8;

 _IOC_SIZEBITS = 14;
 _IOC_DIRBITS = 2;

 _IOC_NRMASK = ((1 shl _IOC_NRBITS) - 1);
 _IOC_TYPEMASK = ((1 shl _IOC_TYPEBITS) - 1);
 _IOC_SIZEMASK = ((1 shl _IOC_SIZEBITS) - 1);
 _IOC_DIRMASK = ((1 shl _IOC_DIRBITS) - 1);

 _IOC_NRSHIFT = 0;
 _IOC_TYPESHIFT = (_IOC_NRSHIFT + _IOC_NRBITS);
 _IOC_SIZESHIFT = (_IOC_TYPESHIFT + _IOC_TYPEBITS);
 _IOC_DIRSHIFT = (_IOC_SIZESHIFT + _IOC_SIZEBITS);

 {Direction bits}
 _IOC_NONE = 0;
 _IOC_WRITE = 1;
 _IOC_READ = 2;

{$IFDEF SYSCALLS_EXPORT_SOCKETS}
const
 {FD set constants from sys/select.h}
 FD_SETSIZE = 1024;
 NFDBITS = 8 * SizeOf(PtrUInt); {fd_mask}
{$ENDIF}

const
 {Library names}
 libc = 'c';

{==============================================================================}
type
 {Syscalls specific types}

 {Basic Types} {Note: These should match (Except for case) with those from GlobalTypes unit}
 int = Integer; {INT_MAX}
 Pint = ^int;
 long = PtrInt; {LONG_MAX}
 Plong = ^long;
 short = Smallint;
 Pshort = ^short;
 uint = Cardinal; {unsigned int}
 Puint = ^uint;

type
 {From stddef.h}
 ptrdiff_t = PtrInt; {LONG_MAX}
 size_t = PtrUInt;
 Psize_t = ^size_t;
 ssize_t = PtrInt;
 wint_t = Cardinal; {unsigned int}

type
 {From sys/types.h}
 dev_t = Smallint;  {short}
 mode_t = Cardinal; {unsigned int}
 ino_t = Word;      {unsigned short}
 ino64_t = Qword;   {unsigned long long}
 nlink_t = Word;    {unsigned short}
 gid_t = Word;      {unsigned short}
 uid_t = Word;      {unsigned short}
 {$IFDEF SYSCALLS_USE_LONG_TIME_T}
 {time_t = PtrInt;} {long} {time_t is now defined in GlobalTypes}
 {$ELSE}
 {time_t = Int64;}  {int64_t} {time_t is now defined in GlobalTypes}
 {$ENDIF}
 pid_t = int;
 off_t = PtrInt;    {long}
 off64_t = Int64;   {long long}
 clock_t = PtrUInt; {_CLOCK_T_ in machine/types.h}{unsigned long}
 clockid_t = PtrUInt; {_CLOCK_T_ in machine/types.h}{unsigned long}
 useconds_t = PtrUInt; {unsigned long}

 blkcnt_t = PtrInt;    {long}
 blksize_t = PtrInt;    {long}

 fsblkcnt_t = uint64_t;
 fsfilcnt_t = uint32_t;

 fsblkcnt64_t = uint64_t;
 fsfilcnt64_t = uint64_t;

type
 {From sys/lock.h}
 _LOCK_T = int;
 _LOCK_RECURSIVE_T = int;

type
 {From sys/_types.h}
 _ssize_t = PtrInt; {int or long}
 _fpos_t = PtrInt;  {long}
 _off_t  = PtrInt;  {long}
 _flock_t = int;    {_LOCK_RECURSIVE_T in lock.h}
 _fpos64_t = Int64; {long long}
 _off64_t = Int64;  {long long}
 _pid_t = int;

 {Conversion state information}
 P_mbstate_value = ^T_mbstate_value;
 T_mbstate_value = record
  case Integer of
   0:(__wch:wint_t;
     );
   1:(__wchb:array[0..3] of Char;
     );
  end;

 P_mbstate_t = ^T_mbstate_t;
 T_mbstate_t = record
  __count:int;
  __value:T_mbstate_value; {Value so far}
 end;

type
 {From _ansi.h}
 _PTR = Pointer;

type
 {From sys/config.h}
 _READ_WRITE_RETURN_TYPE = int; {See note in \newlib\libc\include\sys\config.h may be ssize_t in some implementations}
 _READ_WRITE_BUFSIZE_TYPE = int; {See note in \newlib\libc\include\sys\config.h may be ssize_t in some implementations}

type
 {From sys/reent.h} {Types required for T_reent below}
 P_reent = ^T_reent;

 __ULong = long;

 P__locale_t = ^T__locale_t;
 T__locale_t = record
  {To be defined for future use, currently treated as opaque}
 end;

 P_Bigint = ^T_Bigint;
 T_Bigint = record
  _next:P_Bigint;
  _k:int;
  _maxwds:int;
  _sign:int;
  _wds:int;
  _x:array[0..0] of __ULong;
 end;
 PP_Bigint = ^P_Bigint;

 P__tm = ^T__tm;
 T__tm = record
  __tm_sec:int;
  __tm_min:int;
  __tm_hour:int;
  __tm_mday:int;
  __tm_mon:int;
  __tm_year:int;
  __tm_wday:int;
  __tm_yday:int;
  __tm_isdst:int;
 end;

 {Stdio buffers}
 P__sbuf = ^T__sbuf;
 T__sbuf = record
  _base:PChar;
  _size:int;
 end;

 P__sFILE = ^T__sFILE;
 T__sFILE = record
  _p:PChar;        {current position in (some) buffer}
  _r:int;          {read space left for getc()}
  _w:int;          {write space left for putc()}
  _flags:short;    {flags, below; this FILE is free if 0}
  _file:short;     {fileno, if Unix descriptor, else -1}
  _bf:T__sbuf;     {the buffer (at least 1 byte, if !NULL)}
  _lbfsize:int;    {0 or -_bf._size, for inline putc}

  {operations}
  _cookie:_PTR;    {cookie passed to io functions}
  _read:function(ptr: P_reent; cookie: _PTR; buf: PChar; size: _READ_WRITE_BUFSIZE_TYPE):_READ_WRITE_RETURN_TYPE; cdecl;
  _write:function(ptr: P_reent; cookie: _PTR; buf: PChar; size: _READ_WRITE_BUFSIZE_TYPE):_READ_WRITE_RETURN_TYPE; cdecl;
  _seek:function(ptr: P_reent; cookie: _PTR; pos: _fpos_t; dir: int):_fpos_t; cdecl;
  _close:function(ptr: P_reent; cookie: _PTR):int; cdecl;

  {separate buffer for long sequences of ungetc()}
  _ub:T__sbuf; {ungetc buffer}
  _up:PChar;   {saved _p when _p is doing ungetc data}
  _ur:int;     {saved _r when _r is counting ungetc data}

  {tricks to meet minimum requirements even when malloc() fails}
  _ubuf:array[0..2] of Char; {guarantee an ungetc() buffer}
  _nbuf:array[0..0] of Char; {guarantee a getc() buffer}

  {separate buffer for fgetline() when line crosses buffer boundary}
  _lb:T__sbuf; {buffer for fgetline()}

  {Unix stdio files get aligned to block boundaries on fseek()}
  _blksize:int;     {stat.st_blksize (may be != _bf._size)}
  _offset:_off_t;   {current lseek offset}

  _data:P_reent;    {Here for binary compatibility? Remove?}

  _lock:_flock_t;   {for thread-safety locking}

  _mbstate:T_mbstate_t; {for wide char stdio functions}
  _flags2:int;          {for future use}
 end;

 {$IFDEF SYSCALLS_LARGE64_FILES}
 P__sFILE64 = ^T__sFILE64;
 T__sFILE64 = record
  _p:PChar;        {current position in (some) buffer}
  _r:int;          {read space left for getc()}
  _w:int;          {write space left for putc()}
  _flags:short;    {flags, below; this FILE is free if 0}
  _file:short;     {fileno, if Unix descriptor, else -1}
  _bf:T__sbuf;     {the buffer (at least 1 byte, if !NULL)}
  _lbfsize:int;    {0 or -_bf._size, for inline putc}

  _data:P_reent;

  {operations}
  _cookie:_PTR;    {cookie passed to io functions}
  _read:function(ptr: P_reent; cookie: _PTR; buf: PChar; size: _READ_WRITE_BUFSIZE_TYPE):_READ_WRITE_RETURN_TYPE; cdecl;
  _write:function(ptr: P_reent; cookie: _PTR; buf: PChar; size: _READ_WRITE_BUFSIZE_TYPE):_READ_WRITE_RETURN_TYPE; cdecl;
  _seek:function(ptr: P_reent; cookie: _PTR; pos: _fpos_t; dir: int):_fpos_t; cdecl;
  _close:function(ptr: P_reent; cookie: _PTR):int; cdecl;

  {separate buffer for long sequences of ungetc()}
  _ub:T__sbuf; {ungetc buffer}
  _up:PChar;   {saved _p when _p is doing ungetc data}
  _ur:int;     {saved _r when _r is counting ungetc data}

  {tricks to meet minimum requirements even when malloc() fails}
  _ubuf:array[0..2] of Char; {guarantee an ungetc() buffer}
  _nbuf:array[0..0] of Char; {guarantee a getc() buffer}

  {separate buffer for fgetline() when line crosses buffer boundary}
  _lb:T__sbuf; {buffer for fgetline()}

  {Unix stdio files get aligned to block boundaries on fseek()}
  _blksize:int;     {stat.st_blksize (may be != _bf._size)}
  _flags2:int;          {for future use}

  _offset:_off64_t;   {current lseek offset}
  _seek64:function(ptr: P_reent; cookie: _PTR; pos: _fpos64_t; dir: int):_fpos64_t; cdecl;

  _lock:_flock_t;   {for thread-safety locking}
  _mbstate:T_mbstate_t; {for wide char stdio functions}
 end;
 {$ENDIF}

 {$IFDEF SYSCALLS_LARGE64_FILES}
 T__FILE = T__sFILE64;
 P__FILE = P__sFILE64;
 {$ELSE}
 T__FILE = T__sFILE;
 P__FILE = P__sFILE;
 {$ENDIF}

 P_glue = ^T_glue;
 T_glue = record
  _next:P_glue;
  _niobs:int;
  _iobs:P__FILE;
 end;

 P_rand48 = ^T_rand48;
 T_rand48 = record
  _seed:array[0..2] of Word; {unsigned short}
  _mult:array[0..2]of Word;  {unsigned short}
  _add:Word;                 {unsigned short}
 end;

 P_on_exit_args = ^T_on_exit_args;
 T_on_exit_args = record
  _fnargs:array[0.._ATEXIT_SIZE - 1] of Pointer;         {user fn args}
  _dso_handle:array[0.._ATEXIT_SIZE - 1] of Pointer;
  {Bitmask is set if user function takes arguments}
  _fntypes:__ULong;   {type of exit routine - Must have at least _ATEXIT_SIZE bits}
  {Bitmask is set if function was registered via __cxa_atexit.}
  _is_cxa:__ULong;
 end;

 P_atexit = ^T_atexit;
 T_atexit = record
  _next:P_atexit;   {next in list}
  _ind:int;         {next index in this table}
  {Some entries may already have been called, and will be NULL.}
  _fns:array[0.._ATEXIT_SIZE - 1] of procedure; {the table itself}
  _on_exit_args:T_on_exit_args;
 end;

 {From sys/reent.h} {Note that reent.h uses an alternate version of this if _REENT_SMALL if defined however that version is not supported}
 T_reent_new = record
  case Integer of
   0:(
      {$IFDEF SYSCALLS_REENT_BACKWARD_BINARY_COMPAT}
      _reserved_2:uint; {unsigned int}
      {$ENDIF}
      _strtok_last:PChar;
      _asctime_buf:array[0.._REENT_ASCTIME_SIZE - 1] of Char;
      _localtime_buf:T__tm;
      _gamma_signgam:int;
      _rand_next:Int64; {unsigned long long}
      _r48:T_rand48;
      _mblen_state:T_mbstate_t;
      _mbtowc_state:T_mbstate_t;
      _wctomb_state:T_mbstate_t;
      _l64a_buf:array[0..7] of Char;
      _signal_buf:array[0.._REENT_SIGNAL_SIZE - 1] of Char;
      _getdate_err:int;
      _mbrlen_state:T_mbstate_t;
      _mbrtowc_state:T_mbstate_t;
      _mbsrtowcs_state:T_mbstate_t;
      _wcrtomb_state:T_mbstate_t;
      _wcsrtombs_state:T_mbstate_t;
   _h_errno:int;
     ); {_reent}
   {$IFDEF SYSCALLS_REENT_BACKWARD_BINARY_COMPAT}
   1:(_reserved_3:array[0..30 - 1] of PChar;
      _reserved_4:array[0..30 - 1] of uint; {unsigned int}
     ); {_reserved_5}
   {$ENDIF}
 end;

 T_reent = record
  _errno:int;                    {local copy of errno}

  _stdin:P__FILE;                {FILE is a big struct and may change over time.  To try to achieve binary}
  _stdout:P__FILE;               {compatibility with future versions, put stdin,stdout,stderr here.}
  _stderr:P__FILE;               {These are pointers into member __sf defined below.}

  _inc:int;                      {used by tmpnam}
  _emergency:array[0.._REENT_EMERGENCY_SIZE - 1] of Char;

  {$IFDEF SYSCALLS_REENT_BACKWARD_BINARY_COMPAT}
  _reserved_1:int;
  {$ENDIF}

  _locale:P__locale_t;           {per-thread locale}

  {$IFDEF SYSCALLS_REENT_BACKWARD_BINARY_COMPAT}
  _reserved_0:int;
  {$ENDIF}

  __cleanup:procedure(ptr: P_reent); cdecl;

  {used by mprec routines}
  _result:P_Bigint;
  _result_k:int;
  _p5s:P_Bigint;
  _freelist:PP_Bigint;

  {used by some fp conversion routines}
  _cvtlen:int;   {should be size_t}
  _cvtbuf:PChar;

  _new:T_reent_new;

  {$IFDEF SYSCALLS_REENT_BACKWARD_BINARY_COMPAT}
  _reserved_6:P_atexit;
  _reserved_7:T_atexit;
  {$ENDIF}

  {signal info}
  _sig_func:function(param: int): PPointer; cdecl;

  {$IFDEF SYSCALLS_REENT_BACKWARD_BINARY_COMPAT}
  _reserved_8:T_glue;
  _reserved_9:array[0..2] of T__FILE;
  {$ENDIF}
 end;

type
 {From sys/_timespec.h}
 Ptimespec = ^Ttimespec;
 Ttimespec = record
  tv_sec: time_t; {seconds}
  tv_nsec: long;  {and nanoseconds}
 end;

type
 {From sys/stat.h}
 Pstat = ^Tstat;
 Tstat = record
  st_dev:dev_t;            // ID of device containing file
  st_ino:ino_t;            // inode number
  st_mode:mode_t;          // protection
  st_nlink:nlink_t;        // number of hard links
  st_uid:uid_t;            // user ID of owner
  st_gid:gid_t;            // group ID of owner
  st_rdev:dev_t;           // device ID (if special file)
  st_size:off_t;           // total size, in bytes
  st_atime:Ttimespec;      // time of last access
  st_mtime:Ttimespec;      // time of last modification
  st_ctime:Ttimespec;      // time of last status change
  st_blksize:blksize_t;    // blocksize for file system I/O
  st_blocks:blkcnt_t;      // number of 512B blocks allocated
  st_spare4:array [0..1] of long;
 end;

 Pstat64 = ^Tstat64;
 Tstat64 = Tstat;

type
 {From sys/times.h}
 Ptms = ^Ttms;
 Ttms = record
  tms_utime: clock_t;  {user time}
  tms_stime: clock_t;  {system time}
  tms_cutime: clock_t; {user time, children}
  tms_cstime: clock_t; {system time, children}
 end;

type
 {From machine/types.h}
 __suseconds_t = long;

type
 {From sys/_timeval.h}
 suseconds_t = __suseconds_t;

 Ptimeval = ^Ttimeval;
 Ttimeval = record
  tv_sec: time_t;       {seconds}
  tv_usec: suseconds_t; {and microseconds}
 end;

type
 {From sys/_iovec.h}
 Piovec = ^Tiovec;
 Tiovec = record
  iov_base: Pointer;  {Base address}
  iov_len: size_t;    {Length}
 end;

{$IFDEF SYSCALLS_EXPORT_SOCKETS}
type
 {From netdb.h}
 {Structures returned by network data base library}
 P_hostent = ^T_hostent;
 T_hostent = record
  h_name: PChar;             {official name of host}
  h_aliases: ^PChar;         {alias list}
  h_addrtype: int;           {host address type}
  h_length: int;             {length of address}
  case Byte of
   0: (h_addr_list: ^PChar); {list of addresses from name server (Network order)}
   1: (h_addr: ^PChar);      {address, for backward compatibility (Network order)}
 end;

 P_netent = ^T_netent;
 T_netent = record
  n_name: PChar;     {official name of net}
  n_aliases: ^PChar; {alias list}
  n_addrtype: int;   {net address type}
  n_net: uint32_t;   {network # (Host order)}
 end;

 P_servent = ^T_servent;
 T_servent = record
  s_name: PChar;     {official service name}
  s_aliases: ^PChar; {alias list}
  s_port: int;       {port # (Network order)}
  s_proto: PChar;    {protocol to use}
 end;

 P_protoent = ^T_protoent;
 T_protoent = record
  p_name: PChar;     {official protocol name}
  p_aliases: ^PChar; {alias list}
  p_proto: int;      {protocol #}
 end;

type
 {From sys/select.h}
 fd_mask = PtrUInt; {unsigned long}

 Pfd_set = ^Tfd_set;
 Tfd_set = record
  fds_bits: array[0..(FD_SETSIZE div NFDBITS) - 1] of fd_mask
 end;

type
 {From arpa/inet.h}
 {Socket types}
 Psocklen_t = ^socklen_t;
 socklen_t = uint32_t;
 in_addr_t = uint32_t;
 in_port_t = uint16_t;

 P_in_addr = ^T_in_addr;
 T_in_addr = record
  s_addr: in_addr_t;
 end;

type
 {From sys/socket.h}
 {Socket types}
 sa_family_t = uint8_t;

 {Structure used by kernel to store most addresses}
 P_sockaddr = ^T_sockaddr;
 T_sockaddr = record
  sa_len: uint8_t;               {total length}
  sa_family: sa_family_t;        {address family}
  sa_data: array[0..13] of Char; {actually longer; address value}
 end;

 {Message header for recvmsg and sendmsg calls}
 {Used value-result for recvmsg, value only for sendmsg}
 Pmsghdr = ^Tmsghdr;
 Tmsghdr = record
  msg_name: Pointer;         {optional address}
  msg_namelen: socklen_t;    {size of address}
  msg_iov: Piovec;           {scatter/gather array}
  msg_iovlen: int;           {elements in msg_iov}
  msg_control: Pointer;      {ancillary data, see below}
  msg_controllen: socklen_t; {ancillary data buffer len}
  msg_flags: int;            {flags on received message}
 end;

 {Header for ancillary data objects in msg_control buffer}
 {Used for additional information with/about a datagram}
 {not expressible by flags.  The format is a sequence}
 {of message elements headed by Tcmsghdr structures}
 Pcmsghdr = ^Tcmsghdr;
 Tcmsghdr = record
  cmsg_len: socklen_t; {data byte count, including hdr}
  cmsg_level: int;     {originating protocol}
  cmsg_type: int;      {protocol-specific type}
 end;

type
 {From netinet/in.h}
 {Socket address, internet style}
 P_sockaddr_in = ^T_sockaddr_in;
 T_sockaddr_in = record
  sin_len: uint8_t;
  sin_family: sa_family_t;
  sin_port: in_port_t;
  sin_addr: T_in_addr;
  sin_zero: array[0..7] of Char;
 end;

type
 {From netinet6/in6.h}
 {IPv6 address}
 P_in6_addr = ^T_in6_addr;
 T_in6_addr = record
  case byte of
   0: (u6_addr8  : array[0..15] of uint8_t);
   1: (u6_addr16 : array[0..7] of uint16_t);
   2: (u6_addr32 : array[0..3] of uint32_t);
   3: (u6_addr : array[0..3] of uint32_t);
 end;

 {Socket address for IPv6}
 P_sockaddr_in6 = ^T_sockaddr_in6;
 T_sockaddr_in6 = record
  sin6_len: uint8_t;         {length of this struct}
  sin6_family: sa_family_t;  {AF_INET6}
  sin6_port: in_port_t;      {Transport layer port #}
  sin6_flowinfo: uint32_t;   {IP6 flow information}
  sin6_addr: T_in6_addr;     {IP6 address}
  sin6_scope_id: uint32_t;   {scope zone index}
 end;

type
 {From netdb.h}
 {Structure returned by getaddrinfo()}
 P_addrinfo = ^T_addrinfo;
 T_addrinfo = record
  ai_flags: int;         {AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST}
  ai_family: int;        {AF_xxx}
  ai_socktype: int;      {SOCK_xxx}
  ai_protocol: int;      {0 or IPPROTO_xxx for IPv4 and IPv6}
  ai_addrlen: socklen_t; {length of ai_addr}
  ai_canonname: PChar;   {canonical name for hostname}
  ai_addr: P_sockaddr;   {binary address}
  ai_next: P_addrinfo;   {next structure in linked list}
 end;
 PP_addrinfo = ^P_addrinfo;
{$ENDIF}

type
 {From sys/statfs.h}
 fsid_t = record
  val: array[0..1] of int;
 end;

 Pstatfs = ^Tstatfs;
 Tstatfs = record
  f_type: uint32_t;    {Type of filesystem (see above)}
  f_bsize: uint32_t;   {Optimal transfer block size}
  {$IFNDEF SYSCALLS_FILE_OFFSET64}
  f_blocks: uint32_t;  {Total data blocks in filesystem}
  f_bfree: uint32_t;   {Free blocks in filesystem}
  f_bavail: uint32_t;  {Free blocks available to unprivileged user}
  f_files: uint32_t;   {Total inodes in filesystem}
  f_ffree: uint32_t;   {Free inodes in filesystem}
  {$ELSE}
  f_blocks: uint64_t;  {Total data blocks in filesystem}
  f_bfree: uint64_t;   {Free blocks in filesystem}
  f_bavail: uint64_t;  {Free blocks available to unprivileged user}
  f_files: uint64_t;   {Total inodes in filesystem}
  f_ffree: uint64_t;   {Free inodes in filesystem}
  {$ENDIF}
  f_fsid: fsid_t;      {Filesystem ID}
  f_namelen: uint32_t; {Maximum length of filenames}
  f_frsize: uint32_t;  {Fragment size (since Linux 2.6)}
  f_flags: uint32_t;   {Mount flags of filesystem (since Linux 2.6.36)}
  f_spare: array[0..3] of uint32_t; {Padding bytes reserved for future use}
 end;

 {$IFDEF SYSCALLS_LARGE64_FILES}
 Pstatfs64 = ^Tstatfs64;
 Tstatfs64 = record
  f_type: uint32_t;    {Type of filesystem (see above)}
  f_bsize: uint32_t;   {Optimal transfer block size}
  f_blocks: uint64_t;  {Total data blocks in filesystem}
  f_bfree: uint64_t;   {Free blocks in filesystem}
  f_bavail: uint64_t;  {Free blocks available to unprivileged user}
  f_files: uint64_t;   {Total inodes in filesystem}
  f_ffree: uint64_t;   {Free inodes in filesystem}
  f_fsid: fsid_t;      {Filesystem ID}
  f_namelen: uint32_t; {Maximum length of filenames}
  f_frsize: uint32_t;  {Fragment size (since Linux 2.6)}
  f_flags: uint32_t;   {Mount flags of filesystem (since Linux 2.6.36)}
  f_spare: array[0..3] of uint32_t; {Padding bytes reserved for future use}
 end;
 {$ENDIF}

type
 {From sys/statvfs.h}
 Pstatvfs = ^Tstatvfs;
 Tstatvfs = record
  f_bsize: PtrUInt;       {File system block size} {unsigned long}
  f_frsize: PtrUInt;      {Fundamental file system block size} {unsigned long}
  {$IFNDEF SYSCALLS_FILE_OFFSET64}
  f_blocks: fsblkcnt_t;   {Total number of blocks on file system in units of f_frsize}
  f_bfree: fsblkcnt_t;    {Total number of free blocks}
  f_bavail: fsblkcnt_t;   {Number of free blocks available to non-privileged process}
  f_files: fsfilcnt_t;    {Total number of file serial numbers}
  f_ffree: fsfilcnt_t;    {Total number of free file serial numbers}
  f_favail: fsfilcnt_t;   {Number of file serial numbers available to non-privileged process.}
  {$ELSE}
  f_blocks: fsblkcnt64_t; {Total number of blocks on file system in units of f_frsize}
  f_bfree: fsblkcnt64_t;  {Total number of free blocks}
  f_bavail: fsblkcnt64_t; {Number of free blocks available to non-privileged process}
  f_files: fsfilcnt64_t;  {Total number of file serial numbers}
  f_ffree: fsfilcnt64_t;  {Total number of free file serial numbers}
  f_favail: fsfilcnt64_t; {Number of file serial numbers available to non-privileged process.}
  {$ENDIF}
  f_fsid: fsid_t;         {File system ID}
  f_flag: PtrUInt;        {Bit mask of f_flag values} {unsigned long}
  f_namemax: PtrUInt;     { Maximum filename length} {unsigned long}
  __f_spare: array[0..5] of uint; {Padding bytes reserved for future use} {unsigned int}
 end;

 {$IFDEF SYSCALLS_LARGE64_FILES}
 Pstatvfs64 = ^Tstatvfs64;
 Tstatvfs64 = record
  f_bsize: PtrUInt;       {File system block size} {unsigned long}
  f_frsize: PtrUInt;      {Fundamental file system block size} {unsigned long}
  f_blocks: fsblkcnt64_t; {Total number of blocks on file system in units of f_frsize}
  f_bfree: fsblkcnt64_t;  {Total number of free blocks}
  f_bavail: fsblkcnt64_t; {Number of free blocks available to non-privileged process}
  f_files: fsfilcnt64_t;  {Total number of file serial numbers}
  f_ffree: fsfilcnt64_t;  {Total number of free file serial numbers}
  f_favail: fsfilcnt64_t; {Number of file serial numbers available to non-privileged process.}
  f_fsid: fsid_t;         {File system ID}
  f_flag: PtrUInt;        {Bit mask of f_flag values} {unsigned long}
  f_namemax: PtrUInt;     { Maximum filename length} {unsigned long}
  __f_spare: array[0..5] of uint; {Padding bytes reserved for future use} {unsigned int}
 end;
 {$ENDIF}

type
 {From pwd.h}
 Ppasswd = ^Tpasswd;
 Tpasswd = record
  pw_name: PChar;     {user name}
  pw_passwd: PChar;   {encrypted password}
  pw_uid: uid_t;      {user uid}
  pw_gid: gid_t;      {user gid}
  pw_comment: PChar;  {comment}
  pw_gecos: PChar;    {Honeywell login info}
  pw_dir: PChar;      {home directory}
  pw_shell: PChar;    {default shell}
 end;

type
 {From grp.h}
 Pgroup = ^Tgroup;
 Tgroup = record
  gr_name: PChar;     {group name}
  gr_passwd: PChar;   {group password}
  gr_gid: gid_t;      {group id}
  gr_mem: PPChar;     {group members}
 end;

type
 {From sched.h}
 Psched_param = ^Tsched_param;
 Tsched_param = record
  sched_priority: int;             {Process execution scheduling priority}
  {$IFDEF _POSIX_THREAD_SPORADIC_SERVER}
  sched_ss_low_priority: int;      {Low scheduling priority for sporadic server}
  sched_ss_repl_period: Ttimespec; {Replenishment period for sporadic server}
  sched_ss_init_budget: Ttimespec; {Initial budget for sporadic server}
  sched_ss_max_repl: int;          {Maximum pending replenishments for sporadic server}
  {$ENDIF}
 end;

type
 {From cpuset.h}
 cpu_set_word_t = uint32_t;
 cpu_set_t = record
  __bits: array[0.._NCPUWORDS - 1] of cpu_set_word_t;
 end;
 Pcpu_set_t = ^cpu_set_t;

type
 {From dirent.h}
 PPdirent = ^Pdirent;
 Pdirent = ^Tdirent;
 Tdirent = record
  {$IFNDEF SYSCALLS_FILE_OFFSET64}
  d_ino: ino_t;
  d_off: off_t;
  {$ELSE}
  d_ino: ino64_t;
  d_off: off64_t;
  {$ENDIF}
  d_reclen: Word;
  d_type: Byte;
  d_name:array[0..255] of Char;
 end;

 {$IFDEF SYSCALLS_LARGE64_FILES}
 PPdirent64 = ^Pdirent64;
 Pdirent64 = ^Tdirent64;
 Tdirent64 = record
  d_ino: ino64_t;
  d_off: off64_t;
  d_reclen: Word;
  d_type: Byte;
  d_name:array[0..255] of Char;
 end;
 {$ENDIF}

 PDIR = ^DIR;
 DIR = record
  dd_fd: int;    {directory file}
  dd_loc: int;   {position in buffer}
  dd_seek: int;
  dd_buf: PByte; {buffer}
  dd_len: int;   {buffer length}
  dd_size: int;  {amount of data in buffer}
  dd_lock: _LOCK_RECURSIVE_T;
 end;

type
 {From sys/types.h}
 {Pthread types}
 pthread_t = PtrUInt; {unsigned long}
 Ppthread_t = ^pthread_t;

 Ppthread_attr_t = ^Tpthread_attr_t;
 Tpthread_attr_t = record
  is_initialized: int;
  stackaddr: Pointer;
  stacksize: int;
  contentionscope: int;
  inheritsched: int;
  schedpolicy: int;
  schedparam: Tsched_param;
  {$IFDEF _POSIX_THREAD_GUARDSIZE}
  guardsize: size_t; {Note: This is defined in the Linux version of pthread_attr_t but not for other platforms. Ultibo uses THREAD_STACK_GUARD_ENABLED from GlobalConfig}
  {$ENDIF}
  {$IFDEF _POSIX_THREAD_CPUTIME}
  cputime_clock_allowed: int;  {See time.h}
  {$ENDIF}
  detachstate: int;
 end;

 {Pthread Mutex types}
 pthread_mutex_t = PtrUInt; {unsigned long}
 Ppthread_mutex_t = ^pthread_mutex_t;

 Ppthread_mutexattr_t = ^Tpthread_mutexattr_t;
 Tpthread_mutexattr_t = record
  is_initialized: int;
  {$IFDEF _POSIX_THREAD_PROCESS_SHARED}
  process_shared: int;  {Allow mutex to be shared amongst processes (Not applicable to Ultibo)}
  {$ENDIF}
  {$IFDEF _POSIX_THREAD_PRIO_PROTECT}
  prio_ceiling: int;
  protocol: int;
  {$ENDIF}
  {$IFDEF _UNIX98_THREAD_MUTEX_ATTRIBUTES}
  _type: int;
  {$ENDIF}
  recursive: int;
 end;

 {Pthread Condition Variable types}
 pthread_cond_t = PtrUInt; {unsigned long}
 Ppthread_cond_t = ^pthread_cond_t;

 Ppthread_condattr_t = ^Tpthread_condattr_t;
 Tpthread_condattr_t = record
  is_initialized: int;
  clock: clock_t;       {Specifiy clock for timeouts}
  {$IFDEF _POSIX_THREAD_PROCESS_SHARED}
  process_shared: int;  {Allow this to be shared amongst processes (Not applicable to Ultibo)}
  {$ENDIF}
 end;

 {Pthread Key types}
 pthread_key_t = PtrUInt; {unsigned long}
 Ppthread_key_t = ^pthread_key_t;

 Ppthread_once_t = ^Tpthread_once_t;
 Tpthread_once_t = record
  is_initialized: int;  {Is this structure initialized}
  init_executed: int;   {Has the initialization routine been run}
 end;

 {Pthread Barrier types}
 pthread_barrier_t = PtrUInt; {unsigned long}
 Ppthread_barrier_t = ^pthread_barrier_t;

 Ppthread_barrierattr_t = ^Tpthread_barrierattr_t;
 Tpthread_barrierattr_t = record
  is_initialized: int;  {Is this structure initialized}
  {$IFDEF _POSIX_THREAD_PROCESS_SHARED}
  process_shared: int;  {Allow this to be shared amongst processes (Not applicable to Ultibo)}
  {$ENDIF}
 end;

 {Pthread Spin Lock types}
 pthread_spinlock_t = PtrUInt; {unsigned long}
 Ppthread_spinlock_t = ^pthread_spinlock_t;

 {Pthread Reader/Writer Lock types}
 pthread_rwlock_t = PtrUInt; {unsigned long}
 Ppthread_rwlock_t = ^pthread_rwlock_t;

 Ppthread_rwlockattr_t = ^Tpthread_rwlockattr_t;
 Tpthread_rwlockattr_t = record
  is_initialized: int;  {Is this structure initialized}
  {$IFDEF _POSIX_THREAD_PROCESS_SHARED}
  process_shared: int;  {Allow this to be shared amongst processes (Not applicable to Ultibo)}
  {$ENDIF}
 end;

 {Pthread Function types}
 Tpthread_cleanup_routine = procedure(arg: Pointer); cdecl;
 Tpthread_destructor_routine = procedure(value: Pointer); cdecl;
 Tpthread_start_routine = function(arg: Pointer): Pointer; cdecl;
 Tpthread_init_routine = procedure; cdecl;

type
 {From semahore.h}
 sem_t = Cardinal; {uint32_t} {sem_t should be opaque to the user}
 Psem_t = ^sem_t;

{==============================================================================}
var
 {Syscalls specific variables}
 environ:PPAnsiChar; external;           {Pointer to the global environment block in the C library (\newlib\libc\stdlib\environ.c)}
 __sf:array[0..2] of T__FILE; external;  {First three file descriptors in the C library (\newlib\libc\stdio\findfp.c)}
 __sglue:T_glue; external;               {Root of glue chain in the C library (\newlib\libc\stdio\findfp.c)}

 {__dso_handle:Pointer; cvar;}           {Dynamic shared object handle for C++ library support} {Provided by crtbegin.o}

var
 {Static initialization variables}
 PTHREAD_MUTEX_INITIALIZER:pthread_mutex_t = $FFFFFFFF; {This is used to statically initialize a pthread_mutex_t}
 PTHREAD_COND_INITIALIZER:pthread_cond_t = $FFFFFFFF; {This is used to statically initialize a pthread_cond_t}
 PTHREAD_RWLOCK_INITIALIZER:pthread_rwlock_t = $FFFFFFFF; {This is used to statically initialize a pthread_rwlock_t}

 PTHREAD_ONCE_INIT:Tpthread_once_t = (  {This is used to statically initialize a Tpthread_once_t (Is initialized and not run)}
  is_initialized:1;
  init_executed:0);

{==============================================================================}
{Initialization Functions}
procedure SyscallsInit;
procedure SyscallsQuit;

{==============================================================================}
{Syscalls Functions (Standard)}
procedure _exit; cdecl; public name '_exit';
procedure __sync_synchronize; cdecl; public name '__sync_synchronize';

{==============================================================================}
{Syscalls Functions (Recursive)}
function _close_r(ptr: P_reent; fd: int): int; cdecl; public name '_close_r';

function _execve_r(ptr: P_reent; name: PChar; argv: PPChar; env: PPChar): int; cdecl; public name '_execve_r';
function _fork_r(ptr: P_reent): int; cdecl; public name '_fork_r';
function _wait_r(ptr: P_reent; status: Pint): int; cdecl; public name '_wait_r';

function _fcntl_r(ptr: P_reent; fd: int; cmd:int; arg:int): int; cdecl; public name '_fcntl_r';

{$IFDEF SYSCALLS_LARGE64_FILES}
function _fstat64_r(ptr: P_reent; fd: int; stat: Pstat64): int; cdecl; public name '_fstat64_r';
{$ENDIF}

function _fstat_r(ptr: P_reent; fd: int; stat: Pstat): int; cdecl; public name '_fstat_r';

function __getreent: P_reent; cdecl; public name '__getreent';

function _gettimeofday_r(ptr: P_reent; timeval: Ptimeval; timezone: Pointer): int; cdecl; public name '_gettimeofday_r';

function _isatty_r(ptr: P_reent; fd: int): int; cdecl; public name '_isatty_r';

function _link_r(ptr: P_reent; old: PChar; new: PChar): int; cdecl; public name '_link_r';

{$IFDEF SYSCALLS_LARGE64_FILES}
function _lseek64_r(ptr: P_reent;  fd: int; pos: off64_t; whence: int): off64_t; cdecl; public name '_lseek64_r';
{$ENDIF}

function _lseek_r(ptr: P_reent; fd: int; pos: off_t; whence: int): off_t; cdecl; public name '_lseek_r';

function _mkdir_r(ptr: P_reent; path: PChar; mode: int): int; cdecl; public name '_mkdir_r';

{$IFDEF SYSCALLS_LARGE64_FILES}
function _open64_r(ptr: P_reent; name: PChar; flags: int; mode: int): int; cdecl; public name '_open64_r';
{$ENDIF}

function _open_r(ptr: P_reent; name: PChar; flags: int; mode: int): int; cdecl; public name '_open_r';

function _read_r(ptr: P_reent; fd: int; buf: Pointer; cnt: size_t): _ssize_t; cdecl; public name '_read_r';

function _rename_r(ptr: P_reent; old: PChar; new: PChar): int; cdecl; public name '_rename_r';

function _sbrk_r(ptr: P_reent; incr: ptrdiff_t): Pointer; cdecl; public name '_sbrk_r';

function _kill_r(ptr: P_reent; pid: int; sig: int): int; cdecl; public name '_kill_r';
function _getpid_r(ptr: P_reent): int; cdecl; public name '_getpid_r';

{$IFDEF SYSCALLS_LARGE64_FILES}
function _stat64_r(ptr: P_reent; name: PChar; stat: Pstat64): int; cdecl; public name '_stat64_r';
{$ENDIF}

function _stat_r(ptr: P_reent; name: PChar; stat: Pstat): int; cdecl; public name '_stat_r';

function _times_r(ptr: P_reent; tms: Ptms): clock_t; cdecl; public name '_times_r';

function _unlink_r(ptr: P_reent; name: PChar): int; cdecl; public name '_unlink_r';

function _write_r(ptr: P_reent; fd: int; buf: Pointer; cnt: size_t): _ssize_t; cdecl; public name '_write_r';

function _getentropy_r(ptr: P_reent; buffer: Pointer; length: size_t): int; cdecl; public name '_getentropy_r';

{==============================================================================}
{Syscalls Functions (Stat)}
function mkdir(path: PChar; mode: mode_t): int; cdecl; public name 'mkdir';
function chmod(path: PChar; mode: mode_t): int; cdecl; public name 'chmod';

function lstat(path: PChar; stat: Pstat): int; cdecl; public name 'lstat';

function umask(mask: mode_t): mode_t; cdecl; public name 'umask';

{==============================================================================}
{Syscalls Functions (Stdio)}
procedure __sinit(ptr: P_reent); cdecl; external libc name '__sinit';

{==============================================================================}
{Syscalls Functions (Misc)}
{$IFDEF SYSCALLS_USE_LIBC_INITFINI}
procedure __libc_init_array; cdecl; external libc name '__libc_init_array';
procedure __libc_fini_array; cdecl; external libc name '__libc_fini_array';

procedure _init; cdecl; public name '_init';
procedure _fini; cdecl; public name '_fini';
{$ENDIF}
{==============================================================================}
{Syscalls Functions (Stdlib)}
function malloc(size: size_t): Pointer; cdecl; external libc name 'malloc';
function memalign(alignment, size: size_t): Pointer; cdecl; external libc name 'memalign';

function posix_memalign(memptr: PPointer; alignment, size: size_t): int; cdecl; public name 'posix_memalign';

function realpath(path, resolved_path: PChar): PChar; cdecl; public name 'realpath';

function setenv(name, value: PChar; overwrite: int): int; cdecl; public name 'setenv';
function unsetenv(name: PChar): int; cdecl; public name 'unsetenv';

{==============================================================================}
{Syscalls Functions (Unistd)}
function chdir(path: PChar): int; cdecl; public name 'chdir';

function dup(oldfd: int): int; cdecl; public name 'dup';
function dup2(oldfd, newfd: int): int; cdecl; public name 'dup2';
function dup3(oldfd, newfd, flags: int): int; cdecl; public name 'dup3';

function getentropy(buffer: Pointer; length: size_t): int; cdecl; public name 'getentropy';

function link(path1, path2: PChar): int; cdecl; public name 'link';

function rmdir(path: PChar): int; cdecl; public name 'rmdir';

function sysconf(name: int): int; cdecl; public name 'sysconf';

function getpagesize: int; cdecl; public name 'getpagesize';

function ssleep(seconds: uint): uint; cdecl; public name 'sleep';
function usleep(useconds: useconds_t): int; cdecl; public name 'usleep';

function symlink(path1, path2: PChar): int; cdecl; public name 'symlink';

function unlink(path: PChar): int; cdecl; public name 'unlink';

function ftruncate(fd: int; length: off_t): int; cdecl; public name 'ftruncate';
function truncate(path: PChar; length: off_t): int; cdecl; public name 'truncate';

function fsync(fd: int): int; cdecl; public name 'fsync';
function fdatasync(fd: int): int; cdecl; public name 'fdatasync';

function sethostname(name: PChar; size: size_t): int; cdecl; public name 'sethostname';
{$IF not(DEFINED(API_EXPORT_WINSOCK)) and not(DEFINED(API_EXPORT_WINSOCK2))}
function gethostname(name: PChar; size: size_t): int; cdecl; public name 'gethostname';
{$ENDIF}
{==============================================================================}
{Syscalls Functions (Mman)}
function mmap(addr: Pointer; length: size_t; prot, flags, fd: int; offset: off_t): Pointer; cdecl; public name 'mmap';
function munmap(addr: Pointer; length: size_t): int; cdecl; public name 'munmap';

{==============================================================================}
{Syscalls Functions (Time)}
function settimeofday(tv: Ptimeval; tz: Pointer): int; cdecl; public name 'settimeofday';

function clock_getres(clk_id: clockid_t; res: Ptimespec): int; cdecl; public name 'clock_getres';
function clock_gettime(clk_id: clockid_t; tp: Ptimespec): int; cdecl; public name 'clock_gettime';
function clock_settime(clk_id: clockid_t; tp: Ptimespec): int; cdecl; public name 'clock_settime';

function nanosleep(req, rem: Ptimespec): int; cdecl; public name 'nanosleep';

{==============================================================================}
{Syscalls Functions (Statfs)}
function statfs(path: PChar; buf: Pstatfs): int; cdecl; public name 'statfs';
function fstatfs(fd: int; buf: Pstatfs): int; cdecl; public name 'fstatfs';

{$IFDEF SYSCALLS_LARGE64_FILES}
function statfs64(path: PChar; buf: Pstatfs64): int; cdecl; public name 'statfs64';
function fstatfs64(fd: int; buf: Pstatfs64): int; cdecl; public name 'fstatfs64';
{$ENDIF}
{==============================================================================}
{Syscalls Functions (Statvfs)}
function statvfs(path: PChar; buf: Pstatvfs): int; cdecl; public name 'statvfs';
function fstatvfs(fd: int; buf: Pstatvfs): int; cdecl; public name 'fstatvfs';

{$IFDEF SYSCALLS_LARGE64_FILES}
function statvfs64(path: PChar; buf: Pstatvfs64): int; cdecl; public name 'statvfs64';
function fstatvfs64(fd: int; buf: Pstatvfs64): int; cdecl; public name 'fstatvfs64';
{$ENDIF}
{==============================================================================}
{Syscalls Functions (Uio)}
function readv(fd: int; iov: Piovec; iovcnt: int): ssize_t; cdecl; public name 'readv';
function writev(fd: int; iov: Piovec; iovcnt: int): ssize_t; cdecl; public name 'writev';

{==============================================================================}
{Syscalls Functions (Pwd)}
function getpwuid(uid: uid_t): Ppasswd; cdecl; public name 'getpwuid';

{==============================================================================}
{Syscalls Functions (Grp)}
function getgrgid(gid: gid_t): Pgroup; cdecl; public name 'getgrgid';

{==============================================================================}
{Syscalls Functions (Sched)}
function sched_yield: int; cdecl; public name 'sched_yield';

function sched_getcpu: int; cdecl; public name 'sched_getcpu';

function sched_getaffinity(pid: pid_t; cpusetsize: size_t; mask: Pcpu_set_t): int; cdecl; public name 'sched_getaffinity';
function sched_setaffinity(pid: pid_t; cpusetsize: size_t; mask: Pcpu_set_t): int; cdecl; public name 'sched_setaffinity';

function sched_get_priority_max(policy: int): int; cdecl; public name 'sched_get_priority_max';
function sched_get_priority_min(policy: int): int; cdecl; public name 'sched_get_priority_min';

{==============================================================================}
{Syscalls Functions (Dirent)}
function opendir(name: PChar): PDIR; cdecl; public name 'opendir';
function readdir(dirp: PDIR): Pdirent; cdecl; public name 'readdir';
function readdir_r(dirp: PDIR; entry: Pdirent; _result: PPdirent): int; cdecl; public name 'readdir_r';
function closedir(dirp: PDIR): int; cdecl; public name 'closedir';

{$IFDEF SYSCALLS_LARGE64_FILES}
function readdir64(dirp: PDIR): Pdirent64; cdecl; public name 'readdir64';
function readdir64_r(dirp: PDIR; entry: Pdirent64; _result: PPdirent64): int; cdecl; public name 'readdir64_r';
{$ENDIF}

procedure seekdir(dirp: PDIR; loc: long); cdecl; public name 'seekdir';
procedure rewinddir(dirp: PDIR); cdecl; public name 'rewinddir';
function telldir(dirp: PDIR): long; cdecl; public name 'telldir';

{==============================================================================}
{Syscalls Functions (Pthread) (http://pubs.opengroup.org/onlinepubs/7908799/xsh/pthread.h.html)}
function pthread_attr_init(attr: Ppthread_attr_t): int; cdecl; public name 'pthread_attr_init';
function pthread_attr_destroy(attr: Ppthread_attr_t): int; cdecl; public name 'pthread_attr_destroy';
function pthread_attr_getdetachstate(attr: Ppthread_attr_t; detachstate: Pint): int; cdecl; public name 'pthread_attr_getdetachstate';
function pthread_attr_setdetachstate(attr: Ppthread_attr_t; detachstate: int): int; cdecl; public name 'pthread_attr_setdetachstate';
function pthread_attr_getguardsize(attr: Ppthread_attr_t; guardsize: Psize_t): int; cdecl; public name 'pthread_attr_getguardsize';
function pthread_attr_setguardsize(attr: Ppthread_attr_t; guardsize: size_t): int; cdecl; public name 'pthread_attr_setguardsize';
function pthread_attr_getinheritsched(attr: Ppthread_attr_t; inheritsched: Pint): int; cdecl; public name 'pthread_attr_getinheritsched';
function pthread_attr_setinheritsched(attr: Ppthread_attr_t; inheritsched: int): int; cdecl; public name 'pthread_attr_setinheritsched';
function pthread_attr_getschedparam(attr: Ppthread_attr_t; param: Psched_param): int; cdecl; public name 'pthread_attr_getschedparam';
function pthread_attr_setschedparam(attr: Ppthread_attr_t; param: Psched_param): int; cdecl; public name 'pthread_attr_setschedparam';
function pthread_attr_getschedpolicy(attr: Ppthread_attr_t; policy: Pint): int; cdecl; public name 'pthread_attr_getschedpolicy';
function pthread_attr_setschedpolicy(attr: Ppthread_attr_t; policy: int): int; cdecl; public name 'pthread_attr_setschedpolicy';
function pthread_attr_getscope(attr: Ppthread_attr_t; contentionscope: Pint): int; cdecl; public name 'pthread_attr_getscope';
function pthread_attr_setscope(attr: Ppthread_attr_t; contentionscope: int): int; cdecl; public name 'pthread_attr_setscope';
function pthread_attr_getstackaddr(attr: Ppthread_attr_t; stackaddr: PPointer): int; cdecl; public name 'pthread_attr_getstackaddr';
function pthread_attr_setstackaddr(attr: Ppthread_attr_t; stackaddr: Pointer): int; cdecl; public name 'pthread_attr_setstackaddr';
function pthread_attr_getstacksize(attr: Ppthread_attr_t; stacksize: Psize_t): int; cdecl; public name 'pthread_attr_getstacksize';
function pthread_attr_setstacksize(attr: Ppthread_attr_t; stacksize: size_t): int; cdecl; public name 'pthread_attr_setstacksize';

procedure pthread_cleanup_push(routine: Tpthread_cleanup_routine; arg: Pointer); cdecl; public name 'pthread_cleanup_push';
procedure pthread_cleanup_pop(execute: int); cdecl; public name 'pthread_cleanup_pop';

function pthread_cond_init(cond: Ppthread_cond_t; attr: Ppthread_condattr_t): int; cdecl; public name 'pthread_cond_init';
function pthread_cond_destroy(cond: Ppthread_cond_t): int; cdecl; public name 'pthread_cond_destroy';
function pthread_cond_broadcast(cond: Ppthread_cond_t): int; cdecl; public name 'pthread_cond_broadcast';
function pthread_cond_signal(cond: Ppthread_cond_t): int; cdecl; public name 'pthread_cond_signal';
function pthread_cond_wait(cond: Ppthread_cond_t; mutex: Ppthread_mutex_t): int; cdecl; public name 'pthread_cond_wait';
function pthread_cond_timedwait(cond: Ppthread_cond_t; mutex: Ppthread_mutex_t; abstime: Ptimespec): int; cdecl; public name 'pthread_cond_timedwait';

function pthread_condattr_init(attr: Ppthread_condattr_t): int; cdecl; public name 'pthread_condattr_init';
function pthread_condattr_destroy(attr: Ppthread_condattr_t): int; cdecl; public name 'pthread_condattr_destroy';
function pthread_condattr_getpshared(attr: Ppthread_condattr_t; pshared: Pint): int; cdecl; public name 'pthread_condattr_getpshared';
function pthread_condattr_setpshared(attr: Ppthread_condattr_t; pshared: int): int; cdecl; public name 'pthread_condattr_setpshared';

function pthread_create(thread: Ppthread_t; attr: Ppthread_attr_t; start_routine: Tpthread_start_routine; arg: Pointer): int; cdecl; public name 'pthread_create';
function pthread_cancel(thread: pthread_t): int; cdecl; public name 'pthread_cancel';
function pthread_detach(thread: pthread_t): int; cdecl; public name 'pthread_detach';
procedure pthread_exit(value_ptr: Pointer); cdecl; public name 'pthread_exit';
function pthread_equal(t1: pthread_t; t2: pthread_t): int; cdecl; public name 'pthread_equal';
function pthread_join(thread: pthread_t; value_ptr: PPointer): int; cdecl; public name 'pthread_join';
function pthread_self: pthread_t; cdecl; public name 'pthread_self';
procedure pthread_yield; cdecl; public name 'pthread_yield';
function pthread_getconcurrency: int; cdecl; public name 'pthread_getconcurrency';
function pthread_setconcurrency(new_level: int): int; cdecl; public name 'pthread_setconcurrency';
function pthread_getschedparam(thread: pthread_t; policy: Pint; param: Psched_param): int; cdecl; public name 'pthread_getschedparam';
function pthread_setschedparam(thread: pthread_t; policy: int; param: Psched_param): int; cdecl; public name 'pthread_setschedparam';
function pthread_setschedprio(thread: pthread_t; prio: int): int; cdecl; public name 'pthread_setschedprio';
function pthread_getcpuclockid(thread: pthread_t; var clock_id: clockid_t): int; cdecl; public name 'pthread_getcpuclockid';

function pthread_key_create(key: Ppthread_key_t; destructor_routine: Tpthread_destructor_routine): int; cdecl; public name 'pthread_key_create';
function pthread_key_delete(key: pthread_key_t): int; cdecl; public name 'pthread_key_delete';
function pthread_getspecific(key: pthread_key_t): Pointer; cdecl; public name 'pthread_getspecific';
function pthread_setspecific(key: pthread_key_t; value: Pointer): int; cdecl; public name 'pthread_setspecific';

function pthread_mutex_init(mutex: Ppthread_mutex_t; attr: Ppthread_mutexattr_t): int; cdecl; public name 'pthread_mutex_init';
function pthread_mutex_destroy(mutex: Ppthread_mutex_t): int; cdecl; public name 'pthread_mutex_destroy';
function pthread_mutex_lock(mutex: Ppthread_mutex_t): int; cdecl; public name 'pthread_mutex_lock';
function pthread_mutex_trylock(mutex: Ppthread_mutex_t): int; cdecl; public name 'pthread_mutex_trylock';
function pthread_mutex_unlock(mutex: Ppthread_mutex_t): int; cdecl; public name 'pthread_mutex_unlock';
function pthread_mutex_getprioceiling(mutex: Ppthread_mutex_t; prioceiling: Pint): int; cdecl; public name 'pthread_mutex_getprioceiling';
function pthread_mutex_setprioceiling(mutex: Ppthread_mutex_t; prioceiling: int; old_ceiling: Pint): int; cdecl; public name 'pthread_mutex_setprioceiling';

function pthread_mutexattr_init(attr: Ppthread_mutexattr_t): int; cdecl; public name 'pthread_mutexattr_init';
function pthread_mutexattr_destroy(attr: Ppthread_mutexattr_t): int; cdecl; public name 'pthread_mutexattr_destroy';
function pthread_mutexattr_getprioceiling(attr: Ppthread_mutexattr_t; prioceiling: Pint): int; cdecl; public name 'pthread_mutexattr_getprioceiling';
function pthread_mutexattr_setprioceiling(attr: Ppthread_mutexattr_t; prioceiling: int): int; cdecl; public name 'pthread_mutexattr_setprioceiling';
function pthread_mutexattr_getprotocol(attr: Ppthread_mutexattr_t; protocol: Pint): int; cdecl; public name 'pthread_mutexattr_getprotocol';
function pthread_mutexattr_setprotocol(attr: Ppthread_mutexattr_t; protocol: int): int; cdecl; public name 'pthread_mutexattr_setprotocol';
function pthread_mutexattr_getpshared(attr: Ppthread_mutexattr_t; pshared: Pint): int; cdecl; public name 'pthread_mutexattr_getpshared';
function pthread_mutexattr_setpshared(attr: Ppthread_mutexattr_t; pshared: int): int; cdecl; public name 'pthread_mutexattr_setpshared';
function pthread_mutexattr_gettype(attr: Ppthread_mutexattr_t; _type: Pint): int; cdecl; public name 'pthread_mutexattr_gettype';
function pthread_mutexattr_settype(attr: Ppthread_mutexattr_t; _type: int): int; cdecl; public name 'pthread_mutexattr_settype';

function pthread_once(once_control: Ppthread_once_t; init_routine: Tpthread_init_routine): int; cdecl; public name 'pthread_once';

function pthread_spin_init(spinlock: Ppthread_spinlock_t; pshared: Pint): int; cdecl; public name 'pthread_spin_init';
function pthread_spin_destroy(spinlock: Ppthread_spinlock_t): int; cdecl; public name 'pthread_spin_destroy';
function pthread_spin_lock(_spinlock: Ppthread_spinlock_t): int; cdecl; public name 'pthread_spin_lock';
function pthread_spin_trylock(_spinlock: Ppthread_spinlock_t): int; cdecl; public name 'pthread_spin_trylock';
function pthread_spin_unlock(spinlock: Ppthread_spinlock_t): int; cdecl; public name 'pthread_spin_unlock';

function pthread_rwlock_init(rwlock: Ppthread_rwlock_t ; attr: Ppthread_rwlockattr_t): int; cdecl; public name 'pthread_rwlock_init';
function pthread_rwlock_destroy(rwlock: Ppthread_rwlock_t): int; cdecl; public name 'pthread_rwlock_destroy';
function pthread_rwlock_rdlock(rwlock: Ppthread_rwlock_t): int; cdecl; public name 'pthread_rwlock_rdlock';
function pthread_rwlock_wrlock(rwlock: Ppthread_rwlock_t): int; cdecl; public name 'pthread_rwlock_wrlock';
function pthread_rwlock_tryrdlock(rwlock: Ppthread_rwlock_t): int; cdecl; public name 'pthread_rwlock_tryrdlock';
function pthread_rwlock_trywrlock(rwlock: Ppthread_rwlock_t): int; cdecl; public name 'pthread_rwlock_trywrlock';
function pthread_rwlock_unlock(rwlock: Ppthread_rwlock_t): int; cdecl; public name 'pthread_rwlock_unlock';

function pthread_rwlockattr_init(attr: Ppthread_rwlockattr_t): int; cdecl; public name 'pthread_rwlockattr_init';
function pthread_rwlockattr_destroy(attr: Ppthread_rwlockattr_t): int; cdecl; public name 'pthread_rwlockattr_destroy';
function pthread_rwlockattr_getpshared(attr: Ppthread_rwlockattr_t; pshared: Pint): int; cdecl; public name 'pthread_rwlockattr_getpshared';
function pthread_rwlockattr_setpshared(attr: Ppthread_rwlockattr_t; pshared: int): int; cdecl; public name 'pthread_rwlockattr_setpshared';

function pthread_setcancelstate(state: int; oldstate: Pint): int; cdecl; public name 'pthread_setcancelstate';
function pthread_setcanceltype(_type: int; oldtype: Pint): int; cdecl; public name 'pthread_setcanceltype';
procedure pthread_testcancel; cdecl; public name 'pthread_testcancel';

{==============================================================================}
{Syscalls Functions (Semaphore)}
function sem_close(sem: Psem_t): int; cdecl; public name 'sem_close';
function sem_destroy(sem: Psem_t): int; cdecl; public name 'sem_destroy';

function sem_getvalue(sem: Psem_t; sval: Pint): int; cdecl; public name 'sem_getvalue';
function sem_init(sem: Psem_t; pshared: int; value: uint): int; cdecl; public name 'sem_init';

function sem_open(name: PChar; oflag: int): Psem_t; cdecl; public name 'sem_open';
function sem_open_ext(name: PChar; oflag: int; mode: mode_t; value: uint): Psem_t; cdecl; public name 'sem_open_ext';

function sem_post(sem: Psem_t): int; cdecl; public name 'sem_post';
function sem_timedwait(sem: Psem_t; abs_timeout: Ptimespec): int; cdecl; public name 'sem_timedwait';
function sem_trywait(sem: Psem_t): int; cdecl; public name 'sem_trywait';
function sem_unlink(name: PChar): int; cdecl; public name 'sem_unlink';
function sem_wait(sem: Psem_t): int; cdecl; public name 'sem_wait';

{==============================================================================}
{Syscalls Functions (Sockets)}
{$IFDEF SYSCALLS_EXPORT_SOCKETS}
{From sys/socket.h}
function socket_accept(socket: int; address: P_sockaddr; address_len: Psocklen_t): int; cdecl; public name 'accept';
function socket_bind(socket: int; const address: P_sockaddr; address_len: socklen_t): int; cdecl; public name 'bind';
function socket_connect(socket: int; const address: P_sockaddr; address_len: socklen_t): int; cdecl; public name 'connect';
function socket_getpeername(socket: int; address: P_sockaddr; address_len: Psocklen_t): int; cdecl; public name 'getpeername';
function socket_getsockname(socket: int; address: P_sockaddr; address_len: Psocklen_t): int; cdecl; public name 'getsockname';
function socket_getsockopt(socket: int; level, option_name: int; option_value: Pointer; option_len: Psocklen_t): int; cdecl; public name 'getsockopt';
function socket_listen(socket: int; backlog: int): int; cdecl; public name 'listen';
function socket_recv(socket: int; buffer: Pointer; len: size_t; flags: int): ssize_t; cdecl; public name 'recv';
function socket_recvfrom(socket: int; buffer: Pointer; len: size_t; flags: int; address: P_sockaddr; address_len: Psocklen_t): ssize_t; cdecl; public name 'recvfrom';
function socket_recvmsg(socket: int; msg: Pmsghdr; flags: int): ssize_t; cdecl; public name 'recvmsg';
function socket_send(socket: int; const buffer: Pointer; len: size_t; flags: int): ssize_t; cdecl; public name 'send';
function socket_sendto(socket: int; const buffer: Pointer; len: size_t; flags: int; dest_addr: P_sockaddr; dest_len: socklen_t): ssize_t; cdecl; public name 'sendto';
function socket_sendmsg(socket: int; const msg: Pmsghdr; flags: int): ssize_t; cdecl; public name 'sendmsg';
function socket_setsockopt(socket: int; level, option_name: int; const option_value: Pointer; option_len: socklen_t): int; cdecl; public name 'setsockopt';
function socket_shutdown(socket: int; how: int): int; cdecl; public name 'shutdown';
function socket_socket(domain, sockettype, protocol: int): int; cdecl; public name 'socket';
function socket_socketpair(domain, sockettype, protocol: int; socket_vector: Pint): int; cdecl; public name 'socketpair';

{From sys/select.h}
function socket_select(nfds: int; readfds, writefds, exceptfds: Pfd_set; timeout: Ptimeval): int; cdecl; public name 'select';

{From arpa/inet.h}
function socket_htonl(hostlong: uint32_t): uint32_t; cdecl; public name 'htonl';
function socket_htons(hostshort: uint16_t): uint16_t; cdecl; public name 'htons';
function socket_ntohl(netlong: uint32_t): uint32_t; cdecl; public name 'ntohl';
function socket_ntohs(netshort: uint16_t): uint16_t; cdecl; public name 'ntohs';

function socket_inet_addr(cp: PChar): in_addr_t; cdecl; public name 'inet_addr';
function socket_inet_ntoa(inaddr: T_in_addr): PChar; cdecl; public name 'inet_ntoa';
function socket_inet_aton(cp: PChar; inaddr: P_in_addr): int; cdecl; public name 'inet_aton';

function socket_inet_pton(af: int; src: PChar; dst: Pointer): int; cdecl; public name 'inet_pton';
function socket_inet_ntop(af: int; src: Pointer; dst: PChar; size: socklen_t): PChar; cdecl; public name 'inet_ntop';

{From netdb.h}
function socket_gethostbyaddr(addr: Pointer; len: socklen_t; family: int): P_hostent; cdecl; public name 'gethostbyaddr';
function socket_gethostbyname(name: PChar): P_hostent; cdecl; public name 'gethostbyname';

function socket_getnetbyaddr(net: uint32_t; family: int): P_netent; cdecl; public name 'getnetbyaddr';
function socket_getnetbyname(name: PChar): P_netent; cdecl; public name 'getnetbyname';

function socket_getservbyport(port: int; proto: PChar): P_servent; cdecl; public name 'getservbyport';
function socket_getservbyname(name, proto: PChar): P_servent; cdecl; public name 'getservbyname';

function socket_getprotobynumber(proto: int): P_protoent; cdecl; public name 'getprotobynumber';
function socket_getprotobyname(name: PChar): P_protoent; cdecl; public name 'getprotobyname';

function socket_getaddrinfo(node: PChar; service: PChar; hints: P_addrinfo; res: PP_addrinfo): int; cdecl; public name 'getaddrinfo';
function socket_getnameinfo(addr: P_sockaddr; addrlen: socklen_t; host: PChar; hostlen: socklen_t; serv: PChar; servlen: socklen_t; flags: int): int; cdecl; public name 'getnameinfo';
procedure socket_freeaddrinfo(res: P_addrinfo); cdecl; public name 'freeaddrinfo';

function socket_gai_strerror(ecode: int): PChar; cdecl; public name 'gai_strerror';
{$ENDIF}
{==============================================================================}
{Syscalls Functions (Setjmp)}
function _setjmp(var env: jmp_buf): int; cdecl; public name '_setjmp';
procedure _longjmp(var env: jmp_buf; val: int); cdecl; public name '_longjmp';

{==============================================================================}
{Syscalls Functions (Non Standard)}
procedure msleep(msecs: uint); cdecl; public name 'msleep';
function gettid: pid_t; cdecl; public name 'gettid';

{==============================================================================}
{Syscalls Helper Functions}
procedure __malloc_lock(ptr: P_reent); cdecl; public name '__malloc_lock';
procedure __malloc_unlock(ptr: P_reent); cdecl; public name '__malloc_unlock';

procedure __env_lock(ptr: P_reent); cdecl; public name '__env_lock';
procedure __env_unlock(ptr: P_reent); cdecl; public name '__env_unlock';

{==============================================================================}
{Syscalls Macro Functions (Ioctl)}
{Creating Ioctl numbers}
function _IO(_type,nr: LongWord): LongWord;
function _IOR(_type,nr,size: LongWord): LongWord;
function _IOW(_type,nr,size: LongWord): LongWord;
function _IOWR(_type,nr,size: LongWord): LongWord;

{Decoding Ioctl numbers}
function _IOC_DIR(nr: LongWord): LongWord;
function _IOC_TYPE(nr: LongWord): LongWord;
function _IOC_NR(nr: LongWord): LongWord;
function _IOC_SIZE(nr: LongWord): LongWord;
{$IFDEF SYSCALLS_EXPORT_SOCKETS}
{Syscalls Macro Functions (FD sets)}
function FD_CLR(fdno: int; var nset: Tfd_set): int;
function FD_ISSET(fdno: int; const nset: Tfd_set): int;
function FD_SET(fdno: int; var nset: Tfd_set): int;
function FD_ZERO(out nset: Tfd_set): int;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{Syscalls Libraries}
{$linklib c}
{$linklib gcc}

{==============================================================================}
{==============================================================================}

implementation

{==============================================================================}
{==============================================================================}
const
 {Syscalls specific constants}
 SYSCALLS_THREAD_NAME = 'POSIX Thread'; {Name of a Posix Thread}

 SYSCALLS_TABLE_MIN  = 3;    {Skip Stdin, Stdout, Stderr}
 SYSCALLS_TABLE_MAX  = 1023; {Only support 16-bit handles} {Reduced from 65535}
 SYSCALLS_TABLE_MASK = $1F;  {32 buckets for handle lookups}

 SYSCALLS_ENTRY_NONE   = 0;
 SYSCALLS_ENTRY_FILE   = 1;
 SYSCALLS_ENTRY_SOCKET = 2;

 SYSCALLS_INVALID_FILENO = LongWord(-1);

{$IFDEF SYSCALLS_EXPORT_SOCKETS}
 {Syscalls FD set constants}
 {$IFDEF CPU32}
 FDSET_SHIFT = 5; {32bit : ln(32)/ln(2)=5}
 {$ENDIF CPU32}
 {$IFDEF CPU64}
 FDSET_SHIFT = 6; {64bit : ln(64)/ln(2)=6}
 {$ENDIF CPU64}
 FDSET_MASK = (1 shl FDSET_SHIFT) - 1;
{$ENDIF}
{==============================================================================}
{==============================================================================}
type
 {Syscalls specific types}
 PSyscallsEntry = ^TSyscallsEntry;

 PSyscallsTable = ^TSyscallsTable;
 TSyscallsTable = record
  Next:LongWord;
  Count:LongWord;
  Entries:array of PSyscallsEntry;
 end;

 TSyscallsEntry = record
  Number:LongWord;
  Handle:THandle;
  Source:LongWord;
  StatusFlags:LongWord;
  DescriptorFlags:LongWord;
  Prev:PSyscallsEntry;
  Next:PSyscallsEntry;
 end;

{$IFDEF SYSCALLS_EXPORT_SOCKETS}
 PSyscallsNetdb = ^TSyscallsNetdb;
 TSyscallsNetdb = record
  HostEnt:T_hostent;
  NetEnt:T_netent;
  ServEnt:T_servent;
  ProtoEnt:T_protoent;
 end;
{$ENDIF}

 PSyscallsHeapBlock = ^TSyscallsHeapBlock;
 TSyscallsHeapBlock = record
  VirtualAddress:PtrUInt;
  PhysicalAddress:PtrUInt;
  Size:LongWord;
  Used:LongWord;
  Prev:PSyscallsHeapBlock;
  Next:PSyscallsHeapBlock;
 end;

 PSyscallsPthreadCleanup = ^TSyscallsPthreadCleanup;

 PSyscallsPthread = ^TSyscallsPthread;
 TSyscallsPthread = record
  {Cleanup Handlers}
  Cleanup:PSyscallsPthreadCleanup;
 end;

 TSyscallsPthreadCleanup = record
  Routine:Tpthread_cleanup_routine;
  Arg:Pointer;
  Next:PSyscallsPthreadCleanup;
 end;

 PSyscallsPthreadData = ^TSyscallsPthreadData;
 TSyscallsPthreadData = record
  Routine:Tpthread_start_routine;
  Arg:Pointer;
 end;

 TSyscallsPreinit = procedure; cdecl;
 TSyscallsInit = procedure; cdecl;
 TSyscallsFini = procedure; cdecl;
 TSyscallsCtor = procedure; cdecl;
 TSyscallsDtor = procedure; cdecl;

 PFileSearchRec = ^TFileSearchRec;

 Piovecs = ^Tiovecs;
 Tiovecs = array[0..0] of Tiovec;

{==============================================================================}
{==============================================================================}
var
 {Syscalls specific variables}
 SyscallsInitialized:Boolean;

 SyscallsReentSize:LongWord;
 SyscallsReentIndex:LongWord;     {Newlib reent structure TLS index}

{$IFDEF SYSCALLS_EXPORT_SOCKETS}
 SyscallsNetdbSize:LongWord;
 SyscallsNetdbIndex:LongWord;     {Sockets netdb structure TLS index}
{$ENDIF}

 SyscallsMallocLock:TMutexHandle = INVALID_HANDLE_VALUE;
 SyscallsEnvLock:TMutexHandle = INVALID_HANDLE_VALUE;

 SyscallsTable:TSyscallsTable;
 SyscallsTableLock:TMutexHandle = INVALID_HANDLE_VALUE;

 SyscallsHeapFirst:PSyscallsHeapBlock;
 SyscallsHeapLast:PSyscallsHeapBlock;
 SyscallsHeapEnd:Pointer;
 SyscallsHeapSize:UInt64;
 SyscallsHeapLock:TMutexHandle = INVALID_HANDLE_VALUE;

 SyscallsPthreadSize:LongWord;
 SyscallsPthreadIndex:LongWord;                           {Pthread TLS index (For Cleanup handlers)}
 SyscallsPthreadLock:TMutexHandle = INVALID_HANDLE_VALUE;
 SyscallsPthreadConcurrency:Integer;                      {Pthread concurrency level (Not used by Ultibo)}

 SyscallsKeyDestructor:array[0..THREAD_TLS_MAXIMUM - 1] of Tpthread_destructor_routine;

 SyscallsEnvSetHandler:TEnvironmentSet;  {System EnvironmentSet handler (Replaced to allow updating C environment)}

{==============================================================================}
{==============================================================================}
{Forward Declarations}
{$IFDEF SYSCALLS_EXPORT_SOCKETS}
function socket_get_error(error: int): int; forward;
function socket_get_db_error(error: int): int; forward;
function socket_get_eai_error(error: int): int; forward;
{$ENDIF}
function SyscallsGetStat(Handle:THandle;stat:Pstat):Boolean; forward;
function SyscallsGetStat64(Handle:THandle;stat64:Pstat64):Boolean; forward;

function SyscallsGetStatfs(const Path:String;statfs:Pstatfs):Boolean; forward;
{$IFDEF SYSCALLS_LARGE64_FILES}
function SyscallsGetStatfs64(const Path:String;statfs64:Pstatfs64):Boolean; forward;
{$ENDIF}
function SyscallsGetStatvfs(const Path:String;statvfs:Pstatvfs):Boolean; forward;
{$IFDEF SYSCALLS_LARGE64_FILES}
function SyscallsGetStatvfs64(const Path:String;statvfs64:Pstatvfs64):Boolean; forward;
{$ENDIF}
function SyscallsGetEntry(Number:LongWord):PSyscallsEntry; forward;
function SyscallsFindEntry(Handle:THandle):PSyscallsEntry; forward;
function SyscallsAddEntry(Handle:THandle;Source,Origin,Number:LongWord):PSyscallsEntry; forward;
function SyscallsRemoveEntry(Entry:PSyscallsEntry):Boolean; forward;

function SyscallsInitializeHeap:Boolean; forward;
function SyscallsIncreaseHeap(Size:LongWord):Pointer; forward;
function SyscallsDecreaseHeap(Size:LongWord):Pointer; forward;

function SyscallsGetPthread:PSyscallsPthread; forward;

function SyscallsPthreadStart(Data:PSyscallsPthreadData):PtrInt; forward;
procedure SyscallsPthreadEnd(Value:Pointer); forward;

function SyscallsEnvironmentSet(const Name,Value:String):LongWord; forward;
{$IFDEF SYSCALLS_EXPORT_SOCKETS}
function SyscallsSockAddrToWinsock(Source:P_sockaddr;SourceLen:Psocklen_t;Dest:PSockAddr;DestLen:PLongint):Boolean; forward;
function SyscallsWinsockToSockAddr(Source:PSockAddr;SourceLen:PLongint;Dest:P_sockaddr;DestLen:Psocklen_t):Boolean; forward;
function SyscallsAllocateWinsock(Source:P_sockaddr;SourceLen:Psocklen_t;DestBuf:PLongInt;var Dest:PSockAddr;var DestLen:PLongint):Boolean; forward;
function SyscallsAllocateSockAddr(Source:PSockAddr;SourceLen:PLongint;DestBuf:Psocklen_t;var Dest:P_sockaddr;var DestLen:Psocklen_t):Boolean; forward;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{Initialization Functions}
procedure SyscallsInit;
{Initialize the Syscalls unit and Syscalls handle table}

{Note: Called only during system startup}
var
 Count:LongWord;
 TableStart:PPointer;
 TableEnd:PPointer;
 TableProc:procedure; cdecl;
begin
 {}
 {Check Initialized}
 if SyscallsInitialized then Exit;

 {Set Reent TLS Size}
 SyscallsReentSize:=SizeOf(T_reent);

 {Allocate Reent TLS Index}
 SyscallsReentIndex:=ThreadAllocTlsIndexEx(THREAD_TLS_FLAG_FREE);
 if SyscallsReentIndex = TLS_OUT_OF_INDEXES then
  begin
   if PLATFORM_LOG_ENABLED then PlatformLogError('Failed to allocate Syscalls Reent TLS index');
  end;

{$IFDEF SYSCALLS_EXPORT_SOCKETS}
 {Set Netdb TLS Size}
 SyscallsNetdbSize:=SizeOf(TSyscallsNetdb);

 {Allocate Netdb TLS Index}
 SyscallsNetdbIndex:=ThreadAllocTlsIndexEx(THREAD_TLS_FLAG_FREE);
 if SyscallsNetdbIndex = TLS_OUT_OF_INDEXES then
  begin
   if PLATFORM_LOG_ENABLED then PlatformLogError('Failed to allocate Syscalls Netdb TLS index');
  end;
{$ENDIF}

 {Set Pthread TLS Size}
 SyscallsPthreadSize:=SizeOf(TSyscallsPthread);

 {Allocate Pthread TLS Index}
 SyscallsPthreadIndex:=ThreadAllocTlsIndexEx(THREAD_TLS_FLAG_NONE);
 if SyscallsPthreadIndex = TLS_OUT_OF_INDEXES then
  begin
   if PLATFORM_LOG_ENABLED then PlatformLogError('Failed to allocate Syscalls Pthread TLS index');
  end;

 {Initialize Malloc Lock}
 SyscallsMallocLock:=MutexCreateEx(False,MUTEX_DEFAULT_SPINCOUNT,MUTEX_FLAG_RECURSIVE);
 if SyscallsMallocLock = INVALID_HANDLE_VALUE then
  begin
   if PLATFORM_LOG_ENABLED then PlatformLogError('Failed to create Syscalls Malloc lock');
  end;

 {Initialize Env Lock}
 SyscallsEnvLock:=MutexCreateEx(False,MUTEX_DEFAULT_SPINCOUNT,MUTEX_FLAG_RECURSIVE);
 if SyscallsEnvLock = INVALID_HANDLE_VALUE then
  begin
   if PLATFORM_LOG_ENABLED then PlatformLogError('Failed to create Syscalls Env lock');
  end;

 {Initialize Pthread Lock}
 SyscallsPthreadLock:=MutexCreateEx(False,MUTEX_DEFAULT_SPINCOUNT,MUTEX_FLAG_RECURSIVE);
 if SyscallsPthreadLock = INVALID_HANDLE_VALUE then
  begin
   if PLATFORM_LOG_ENABLED then PlatformLogError('Failed to create Syscalls Pthread lock');
  end;

 {Initialize Handles}
 SyscallsTable.Next:=SYSCALLS_TABLE_MIN;
 SyscallsTable.Count:=0;
 SetLength(SyscallsTable.Entries,SYSCALLS_TABLE_MASK + 1);
 for Count:=0 to SYSCALLS_TABLE_MASK do
  begin
   SyscallsTable.Entries[Count]:=nil;
  end;
 SyscallsTableLock:=MutexCreateEx(False,MUTEX_DEFAULT_SPINCOUNT,MUTEX_FLAG_RECURSIVE);
 if SyscallsTableLock = INVALID_HANDLE_VALUE then
  begin
   if PLATFORM_LOG_ENABLED then PlatformLogError('Failed to create Syscalls Table lock');
  end;

 {Allocate Heap}
 if not SyscallsInitializeHeap then
  begin
   if PLATFORM_LOG_ENABLED then PlatformLogError('Failed to initialize Syscalls heap');
  end;

 {Lock Mutex}
 MutexLock(SyscallsEnvLock);

 {Allocate Environment}
 environ:=AllocMem(SizeOf(PAnsiChar) * (ENVIRONMENT_STRING_COUNT + 1)); {Add one for terminating null}
 if environ = nil then
  begin
   if PLATFORM_LOG_ENABLED then PlatformLogError('Failed to allocate Syscalls environment');
  end;

 {Copy Environment}
 for Count:=0 to (ENVIRONMENT_STRING_COUNT + 1) - 1 do
  begin
   environ[Count]:=StrNew(envp[Count]);
  end;

 {Setup Environment Handler}
 SyscallsEnvSetHandler:=EnvironmentSetHandler;
 EnvironmentSetHandler:=@SyscallsEnvironmentSet;

 {Unlock Mutex}
 MutexUnlock(SyscallsEnvLock);

{$IFDEF SYSCALLS_USE_INITFINI_ARRAY}
{$IFDEF SYSCALLS_USE_LIBC_INITFINI}
 {Call __libc_init_array}
 __libc_init_array();
{$ELSE}
 {Execute Preinit functions}
 TableStart:=@__preinit_array_start;
 TableEnd:=@__preinit_array_end;
 while TableStart < TableEnd do
  begin
   {Call Preinit}
   TableProc:=TSyscallsPreinit(TableStart^);
   TableProc();

   {Update Start}
   Inc(TableStart); {Increment PPointer increments by SizeOf(Pointer)}
  end;

 {Execute Init functions}
 TableStart:=@__init_array_start;
 TableEnd:=@__init_array_end;
 while TableStart < TableEnd do
  begin
   {Call Init}
   TableProc:=TSyscallsInit(TableStart^);
   TableProc();

   {Update Start}
   Inc(TableStart); {Increment PPointer increments by SizeOf(Pointer)}
  end;
{$ENDIF}
{$ELSE}
 {Execute Constructor (ctor) functions}
 TableStart:=@__ctors_start;
 TableEnd:=@__ctors_end;
 while TableStart < TableEnd do
  begin
   {Call Constructor}
   TableProc:=TSyscallsCtor(TableStart^);
   TableProc();

   {Update Start}
   Inc(TableStart); {Increment PPointer increments by SizeOf(Pointer)}
  end;
{$ENDIF}

 //To Do //Register SyscallsQuit as a Shutdown handler

 SyscallsInitialized:=True;
end;

{==============================================================================}

procedure SyscallsQuit;
{Terminate the Syscalls unit and Syscalls handle table}

{Note: Called only during system shutdown}
var
 TableStart:PPointer;
 TableEnd:PPointer;
 TableProc:procedure; cdecl;
begin
 {}
 {Check Initialized}
 if not SyscallsInitialized then Exit;

{$IFDEF SYSCALLS_USE_INITFINI_ARRAY}
{$IFDEF SYSCALLS_USE_LIBC_INITFINI}
 {Call __libc_fini_array}
 __libc_fini_array();
{$ELSE}
 {Execute Fini functions}
 TableStart:=@__fini_array_start;
 TableEnd:=@__fini_array_end;
 while TableStart < TableEnd do
  begin
   {Call Fini}
   TableProc:=TSyscallsFini(TableStart^);
   TableProc();

   {Update Start}
   Inc(TableStart); {Increment PPointer increments by SizeOf(Pointer)}
  end;
{$ENDIF}
{$ELSE}
 {Execute Destructor (dtor) functions}
 TableStart:=@__dtors_start;
 TableEnd:=@__dtors_end;
 while TableStart < TableEnd do
  begin
   {Call Destructor}
   TableProc:=TSyscallsDtor(TableStart^);
   TableProc();

   {Update Start}
   Inc(TableStart); {Increment PPointer increments by SizeOf(Pointer)}
  end;
{$ENDIF}

 SyscallsInitialized:=False;
end;

{==============================================================================}
{==============================================================================}
{Syscalls Functions (Standard)}
procedure _exit; cdecl;
{Exit the program without cleaning up files}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _exit');
 {$ENDIF}

 {Halt the thread}
 HaltThread(0);
end;

{==============================================================================}

procedure __sync_synchronize; cdecl;
{Perform a full memory barrier}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls __sync_synchronize');
 {$ENDIF}

 {Data Synchronization Barrier}
 DataSynchronizationBarrier;
end;

{==============================================================================}
{==============================================================================}
{Syscalls Functions (Recursive)}
function _close_r(ptr: P_reent; fd: int): int; cdecl;
{Close a file}
{See: \newlib\libc\reent\closer.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Entry:PSyscallsEntry;
begin
 {}
 Result:=-1;

 {Check reent}
 if ptr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _close_r (ptr=' + PtrToHex(ptr) + ' fd=' + IntToStr(fd) + ')');
 {$ENDIF}

 {Check descriptor}
 Entry:=SyscallsGetEntry(fd);
 if Entry <> nil then
  begin
   {Normal descriptor}
   if Entry^.Source = SYSCALLS_ENTRY_FILE then
    begin
     {Close file}
     FSFileClose(Entry^.Handle);

     {Return Result}
     Result:=0;
    end
   {$IFDEF SYSCALLS_EXPORT_SOCKETS}
   else if Entry^.Source = SYSCALLS_ENTRY_SOCKET then
    begin
     {Close socket}
     Result:=Sockets.CloseSocket(Entry^.Handle);

     {Check Error}
     if Result = SOCKET_ERROR then ptr^._errno:=socket_get_error(Sockets.SocketError());
    end
   {$ENDIF}
   else
    begin
     {Return Error}
     ptr^._errno:=EINVAL;
    end;

   {Remove Entry}
   SyscallsRemoveEntry(Entry);
  end
 else
  begin
   if (fd = STDIN_FILENO) or (fd = STDOUT_FILENO) or (fd = STDERR_FILENO) then
    begin
     {Stdin, Stdout, Stderr}
     Result:=0;
    end
   else
    begin
     {Return Error}
     ptr^._errno:=EBADF;
    end;
  end;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _close_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _execve_r(ptr: P_reent; name: PChar; argv: PPChar; env: PPChar): int; cdecl;
{Transfer control to a new process}
{See: \newlib\libc\reent\execr.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=-1;

 {Check reent}
 if ptr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _execve_r (ptr=' + PtrToHex(ptr) + ')');
 {$ENDIF}

 {Return Error}
 ptr^._errno:=ENOMEM;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _execve_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _fork_r(ptr: P_reent): int; cdecl;
{Create a new process}
{See: \newlib\libc\reent\execr.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=-1;

 {Check reent}
 if ptr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _fork_r (ptr=' + PtrToHex(ptr) + ')');
 {$ENDIF}

 {Return Error}
 ptr^._errno:=EAGAIN;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _fork_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _wait_r(ptr: P_reent; status: Pint): int; cdecl;
{Wait for a child process}
{See: \newlib\libc\reent\execr.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=-1;

 {Check reent}
 if ptr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _wait_r (ptr=' + PtrToHex(ptr) + ')');
 {$ENDIF}

 {Return Error}
 ptr^._errno:=ECHILD;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _wait_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _fcntl_r(ptr: P_reent; fd: int; cmd:int; arg:int): int; cdecl;
{Control an open file}
{See: \newlib\libc\reent\fcntlr.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
const
 STATUS_FLAGS = O_APPEND or O_DIRECT or O_NONBLOCK or O_SYNC or O_DSYNC;
 DESCRIPTOR_FLAGS = FD_CLOEXEC;

var
 Handle:THandle;
 {$IFDEF SYSCALLS_EXPORT_SOCKETS}
 Argument:LongWord;
 {$ENDIF}
 Entry:PSyscallsEntry;
 Duplicate:PSyscallsEntry;
begin
 {}
 Result:=-1;

 {Check reent}
 if ptr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _fcntl_r (ptr=' + PtrToHex(ptr) + ' fd=' + IntToStr(fd) + ' cmd=' + IntToStr(cmd) + ' arg=' + IntToStr(arg) + ')');
 {$ENDIF}

 {Get Entry}
 Entry:=SyscallsGetEntry(fd);
 if Entry <> nil  then
  begin
   {Normal descriptor}
   if Entry^.Source = SYSCALLS_ENTRY_FILE then
    begin
     {File}
     case cmd of
      F_DUPFD,
      F_DUPFD_CLOEXEC:begin
        {Duplicate file descriptor}
        Handle:=FSDuplicateHandle(Entry^.Handle);
        if Handle = INVALID_HANDLE_VALUE then
         begin
          {Return Error}
          ptr^._errno:=EINVAL;
          Exit;
         end;

        {Add Duplicate Entry (Lowest file number greater than or equal to arg)}
        Duplicate:=SyscallsAddEntry(Handle,SYSCALLS_ENTRY_FILE,arg,SYSCALLS_INVALID_FILENO);
        if Duplicate = nil then
         begin
          {Return Error}
          ptr^._errno:=ENOMEM;
          Exit;
         end;

        {Return Result}
        Result:=Duplicate^.Number;
       end;
      F_GETFD:begin
        {Get Descriptor Flags}
        Result:=Entry^.DescriptorFlags;
       end;
      F_SETFD:begin
        {Set Descriptor Flags}
        arg:=arg and DESCRIPTOR_FLAGS;
        Entry^.DescriptorFlags:=(Entry^.DescriptorFlags and not DESCRIPTOR_FLAGS) or arg;

        {Return Result}
        Result:=0;
       end;
      F_GETFL:begin
        {Get Status Flags}
        Result:=Entry^.StatusFlags;
       end;
      F_SETFL:begin
        {Set Status Flags}
        arg:=arg and STATUS_FLAGS;
        Entry^.StatusFlags:=(Entry^.StatusFlags and not STATUS_FLAGS) or arg;

        {Return Result}
        Result:=0;
       end;
      else
       begin
        {Return Error}
        ptr^._errno:=EINVAL;
       end;
     end;
    end
   {$IFDEF SYSCALLS_EXPORT_SOCKETS}
   else if Entry^.Source = SYSCALLS_ENTRY_SOCKET then
    begin
     {Socket}
     case cmd of
      F_GETFD:begin
        {Get Descriptor Flags}
        Result:=Entry^.DescriptorFlags;
       end;
      F_SETFD:begin
        {Set Descriptor Flags}
        arg:=arg and DESCRIPTOR_FLAGS;
        Entry^.DescriptorFlags:=(Entry^.DescriptorFlags and not DESCRIPTOR_FLAGS) or arg;

        {Return Result}
        Result:=0;
       end;
      F_GETFL:begin
        {Get Status Flags}
        Result:=Entry^.StatusFlags;
       end;
      F_SETFL:begin
        {Set Status Flags}
        arg:=arg and STATUS_FLAGS;

        {Check Status Flags}
        if (arg and O_NONBLOCK) <> (Entry^.StatusFlags and O_NONBLOCK) then
         begin
          if (arg and O_NONBLOCK) <> 0 then
           begin
            {Enable Non Blocking}
            Argument:=1;
           end
          else
           begin
            {Disable Non Blocking}
            Argument:=0;
           end;

          {Ioctl Socket}
          if Sockets.IoCtlSocket(Entry^.Handle,FIONBIO,Argument) = SOCKET_ERROR then
           begin
            {Return Error}
            ptr^._errno:=socket_get_error(Sockets.SocketError());
            Exit;
           end;
         end;

        {Update Status Flags}
        Entry^.StatusFlags:=(Entry^.StatusFlags and not STATUS_FLAGS) or arg;

        {Return Result}
        Result:=0;
       end;
     end;
    end
   {$ENDIF}
   else
    begin
     {Return Error}
     ptr^._errno:=EINVAL;
    end;
  end
 else
  begin
   if (fd = STDIN_FILENO) or (fd = STDOUT_FILENO) or (fd = STDERR_FILENO) then
    begin
     {Stdin, Stdout, Stderr}
     Result:=0;
    end
   else
    begin
     {Return Error}
     ptr^._errno:=EBADF;
    end;
  end;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _fcntl_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}
{$IFDEF SYSCALLS_LARGE64_FILES}
function _fstat64_r(ptr: P_reent; fd: int; stat: Pstat64): int; cdecl;
{Status of an open file}
{See: \newlib\libc\reent\fstat64r.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Entry:PSyscallsEntry;
begin
 {}
 Result:=-1;

 {Check reent}
 if ptr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _fstat64_r (ptr=' + PtrToHex(ptr) + ' fd=' + IntToStr(fd) + ')');
 {$ENDIF}

 {Check stat}
 if stat = nil then Exit;

 {Check descriptor}
 Entry:=SyscallsGetEntry(fd);
 if (Entry <> nil) and (Entry^.Source = SYSCALLS_ENTRY_FILE) then
  begin
   {Normal descriptor}
   {Get Stat}
   if not SyscallsGetStat64(Entry^.Handle,stat) then Exit;

   {Return Result}
   Result:=0;
  end
 else
  begin
   if (Entry = nil) and ((fd = STDIN_FILENO) or (fd = STDOUT_FILENO) or (fd = STDERR_FILENO)) then
    begin
     {Stdin, Stdout, Stderr}
     FillChar(stat^,SizeOf(Tstat64),0);
     stat^.st_mode:=_S_IFCHR;
     Result:=0;
    end
   else
    begin
     {Return Error}
     ptr^._errno:=EBADF;
    end;
  end;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _fstat64_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;
{$ENDIF}
{==============================================================================}

function _fstat_r(ptr: P_reent; fd: int; stat: Pstat): int; cdecl;
{Status of an open file}
{See: \newlib\libc\reent\fstatr.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Entry:PSyscallsEntry;
begin
 {}
 Result:=-1;

 {Check reent}
 if ptr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _fstat_r (ptr=' + PtrToHex(ptr) + ' fd=' + IntToStr(fd) + ')');
 {$ENDIF}

 {Check stat}
 if stat = nil then Exit;

 {Check descriptor}
 Entry:=SyscallsGetEntry(fd);
 if (Entry <> nil) and (Entry^.Source = SYSCALLS_ENTRY_FILE) then
  begin
   {Normal descriptor}
   {Get Stat}
   if not SyscallsGetStat(Entry^.Handle,stat) then Exit;

   {Return Result}
   Result:=0;
  end
 else
  begin
   if (Entry = nil) and ((fd = STDIN_FILENO) or (fd = STDOUT_FILENO) or (fd = STDERR_FILENO)) then
    begin
     {Stdin, Stdout, Stderr}
     FillChar(stat^,SizeOf(Tstat),0);
     stat^.st_mode:=_S_IFCHR;
     Result:=0;
    end
   else
    begin
     {Return Error}
     ptr^._errno:=EBADF;
    end;
  end;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _fstat_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function __getreent: P_reent; cdecl;
{Return the _reent structure for the calling thread or allocate a new one if not found}
{See: \newlib\libc\reent\getreent.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 reent:P_reent;
begin
 {}
 Result:=nil;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls __getreent');
 {$ENDIF}

 {Get TLS Value}
 reent:=ThreadGetTlsValue(SyscallsReentIndex);
 if reent = nil then
  begin
   {Allocate TLS Value}
   reent:=AllocMem(SyscallsReentSize);
   if reent = nil then Exit;

   {$IFDEF SYSCALLS_DEBUG}
   if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls __getreent (Allocated reent=' + PtrToHex(reent) + ')');
   {$ENDIF}

   {Set TLS Value}
   if ThreadSetTlsValue(SyscallsReentIndex,reent) <> ERROR_SUCCESS then Exit;

   {Initialize reent structure}
   {See: _REENT_INIT_PTR_ZEROED in \newlib\libc\include\sys\reent.h}
   reent^._stdin:=@__sf[0];
   reent^._stdout:=@__sf[1];
   reent^._stderr:=@__sf[2];
   reent^._new._rand_next:=1;
   reent^._new._r48._seed[0]:=_RAND48_SEED_0;
   reent^._new._r48._seed[1]:=_RAND48_SEED_1;
   reent^._new._r48._seed[2]:=_RAND48_SEED_2;
   reent^._new._r48._mult[0]:=_RAND48_MULT_0;
   reent^._new._r48._mult[1]:=_RAND48_MULT_1;
   reent^._new._r48._mult[2]:=_RAND48_MULT_2;
   reent^._new._r48._add:=_RAND48_ADD;

   {Initialize stdio}
   __sinit(reent);
  end;

 {Return Result}
 Result:=reent;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls __getreent (Result=' + PtrToHex(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _gettimeofday_r(ptr: P_reent; timeval: Ptimeval; timezone: Pointer): int; cdecl;
{Get the date and time}
{See: \newlib\libc\reent\gettimeofdayr.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ClockTime:Int64;
begin
 {}
 Result:=-1;

 {Check reent}
 if ptr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _gettimeofday_r (ptr=' + PtrToHex(ptr) + ' timeval=' + PtrToHex(timeval) + ')');
 {$ENDIF}

 {Check timeval}
 if timeval = nil then
  begin
   {Return Error}
   ptr^._errno:=EFAULT;
  end
 else
  begin
   {Get Time}
   ClockTime:=ClockGetTime;

   {Convert to timeval}
   if Int64(ClockTime) < TIME_TICKS_TO_1970 then Exit;
   timeval^.tv_sec:=(Int64(ClockTime) - TIME_TICKS_TO_1970) div TIME_TICKS_PER_SECOND;
   timeval^.tv_usec:=((Int64(ClockTime) - TIME_TICKS_TO_1970) mod TIME_TICKS_PER_SECOND) div TIME_TICKS_PER_MICROSECOND;

   {Return Result}
   Result:=0;

   {$IFDEF SYSCALLS_DEBUG}
   if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _gettimeofday_r (Result=' + IntToStr(Result) + ')');
   {$ENDIF}
  end;
end;

{==============================================================================}

function _isatty_r(ptr: P_reent; fd: int): int; cdecl;
{Query whether output stream is a terminal}
{See: \newlib\libc\reent\isattyr.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Entry:PSyscallsEntry;
begin
 {}
 Result:=-1;

 {Check reent}
 if ptr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _isatty_r (ptr=' + PtrToHex(ptr) + ' fd=' + IntToStr(fd) + ')');
 {$ENDIF}

 {Check descriptor}
 Entry:=SyscallsGetEntry(fd);
 if (Entry = nil) and ((fd = STDOUT_FILENO) or (fd = STDERR_FILENO)) then
  begin
   {Stdout, Stderr}
   Result:=1;
  end;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _isatty_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _link_r(ptr: P_reent; old: PChar; new: PChar): int; cdecl;
{Establish a new name for an existing file}
{See: \newlib\libc\reent\linkr.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 OldName:String;
 NewName:String;
begin
 {}
 Result:=-1;

 {Check reent}
 if ptr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _link_r (ptr=' + PtrToHex(ptr) + ' old=' + StrPas(old) + ' new=' + StrPas(new) + ')');
 {$ENDIF}

 {Get Names}
 OldName:=StrPas(old);
 NewName:=StrPas(new);

 {Check Names}
 if (Length(OldName) = 0) or (Length(NewName) = 0) then
  begin
   {Return Error}
   ptr^._errno:=ENOENT;
   Exit;
  end;

 {Check Old}
 if not FSFileExists(OldName) and not FSDirectoryExists(OldName) then
  begin
   {Return Error}
   ptr^._errno:=ENOENT;
   Exit;
  end;

 {Check New}
 if FSFileExists(NewName) or FSDirectoryExists(NewName) then
  begin
   {Return Error}
   ptr^._errno:=EEXIST;
   Exit;
  end;

 {Create Hard Link}
 if FSCreateHardLink(NewName,OldName) then
  begin
   {Return Result}
   Result:=0;
  end
 else
  begin
   {Return Error}
   ptr^._errno:=EINVAL;
  end;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _link_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}
{$IFDEF SYSCALLS_LARGE64_FILES}
function _lseek64_r(ptr: P_reent;  fd: int; pos: off64_t; whence: int): off64_t; cdecl;
{Set position in a file}
{See: \newlib\libc\reent\lseek64r.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Entry:PSyscallsEntry;
begin
 {}
 Result:=-1;

 {Check reent}
 if ptr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _lseek64_r (ptr=' + PtrToHex(ptr) + ' fd=' + IntToStr(fd) + ' pos=' + IntToStr(pos) + ' whence=' + IntToStr(whence) + ')');
 {$ENDIF}

 {Get Entry}
 Entry:=SyscallsGetEntry(fd);
 if (Entry <> nil) and (Entry^.Source = SYSCALLS_ENTRY_FILE) then
  begin
   {Seek file}
   Result:=FSFileSeekEx(Entry^.Handle,pos,whence);
  end
 else
  begin
   {Return Error}
   ptr^._errno:=EBADF;
  end;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _lseek64_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;
{$ENDIF}
{==============================================================================}

function _lseek_r(ptr: P_reent; fd: int; pos: off_t; whence: int): off_t; cdecl;
{Set position in a file}
{See: \newlib\libc\reent\lseekr.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Entry:PSyscallsEntry;
begin
 {}
 Result:=-1;

 {Check reent}
 if ptr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _lseek_r (ptr=' + PtrToHex(ptr) + ' fd=' + IntToStr(fd) + ' pos=' + IntToStr(pos) + ' whence=' + IntToStr(whence) + ')');
 {$ENDIF}

 {Get Entry}
 Entry:=SyscallsGetEntry(fd);
 if (Entry <> nil) and (Entry^.Source = SYSCALLS_ENTRY_FILE) then
  begin
   {Seek file}
   Result:=FSFileSeek(Entry^.Handle,pos,whence);
  end
 else
  begin
   {Return Error}
   ptr^._errno:=EBADF;
  end;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _lseek_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _mkdir_r(ptr: P_reent; path: PChar; mode: int): int; cdecl;
{Make a directory}
{See: \newlib\libc\reent\mkdirr.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 PathName:String;
begin
 {}
 Result:=-1;

 {Check reent}
 if ptr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _mkdir_r (ptr=' + PtrToHex(ptr) + ' path=' + StrPas(path) + ' mode=' + IntToStr(mode) + ')');
 {$ENDIF}

 {Get Name}
 PathName:=StrPas(path);

 {Check Name}
 if Length(PathName) = 0 then
  begin
   {Return Error}
   ptr^._errno:=ENOENT;
   Exit;
  end;

 {Check Path}
 if FSFileExists(PathName) or FSDirectoryExists(PathName) then
  begin
   {Return Error}
   ptr^._errno:=EEXIST;
   Exit;
  end;

 {Create Directory}
 if FSCreateDir(PathName) then
  begin
   {Return Result}
   Result:=0;
  end
 else
  begin
   {Return Error}
   ptr^._errno:=EINVAL;
  end;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _mkdir_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}
{$IFDEF SYSCALLS_LARGE64_FILES}
function _open64_r(ptr: P_reent; name: PChar; flags: int; mode: int): int; cdecl;
{Open a file}
{See: \newlib\libc\reent\open64r.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Handle:THandle;
 Entry:PSyscallsEntry;
begin
 {}
 Result:=-1;

 {Check reent}
 if ptr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _open64_r (ptr=' + PtrToHex(ptr) + ' name=' + StrPas(name) + ' flags=' + IntToStr(flags) + ' mode=' + IntToStr(mode) + ')');
 {$ENDIF}

 {Call Open}
 Result:=_open_r(ptr,name,flags,mode);

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _open64_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;
{$ENDIF}
{==============================================================================}

function _open_r(ptr: P_reent; name: PChar; flags: int; mode: int): int; cdecl;
{Open a file}
{See: \newlib\libc\reent\openr.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Handle:THandle;
 FileName:String;
 AccessMode:LongWord;
 ShareMode:LongWord;
 CreateFlags:LongWord;
 Entry:PSyscallsEntry;
begin
 {}
 Result:=-1;

 {Check reent}
 if ptr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _open_r (ptr=' + PtrToHex(ptr) + ' name=' + StrPas(name) + ' flags=' + IntToStr(flags) + ' mode=' + IntToStr(mode) + ')');
 {$ENDIF}

 {Get Name}
 FileName:=StrPas(name);

 {Check Name}
 if Length(FileName) = 0 then
  begin
   {Return Error}
   ptr^._errno:=ENOENT;
   Exit;
  end;

 {Check Flags}
 if (flags and O_DIRECTORY) = O_DIRECTORY then
  begin
   {Return Error}
   ptr^._errno:=EINVAL;
   Exit;
  end;

 {Get Access Mode}
 if (flags and (O_RDONLY or O_WRONLY or O_RDWR)) = O_RDONLY then
  begin
   AccessMode:=GENERIC_READ;
  end
 else if (flags and (O_RDONLY or O_WRONLY or O_RDWR)) = O_WRONLY then
  begin
   AccessMode:=GENERIC_WRITE;
  end
 else if (flags and (O_RDONLY or O_WRONLY or O_RDWR)) = O_RDWR then
  begin
   AccessMode:=GENERIC_READ or GENERIC_WRITE;
  end
 else
  begin
   {Return Error}
   ptr^._errno:=EINVAL;
   Exit;
  end;

 {Get Share Mode}
 ShareMode:=FILE_SHARE_READ or FILE_SHARE_WRITE;

 {Get Create Flags}
 if (flags and (O_CREAT or O_EXCL)) = (O_CREAT or O_EXCL) then
  begin
   CreateFlags:=CREATE_NEW;

   {Check File}
   if FSFileExists(FileName) or FSDirectoryExists(FileName) then
    begin
     {Return Error}
     ptr^._errno:=EEXIST;
     Exit;
    end;
  end
 else if (flags and O_CREAT) = O_CREAT then
  begin
   CreateFlags:=OPEN_ALWAYS;
  end
 else
  begin
   CreateFlags:=OPEN_EXISTING;

   {Check File}
   if not FSFileExists(FileName) then
    begin
     {Return Error}
     ptr^._errno:=ENOENT;
     Exit;
    end;
  end;

 {Create File}
 Handle:=FSCreateFile(FileName,AccessMode,ShareMode,CreateFlags,FILE_ATTRIBUTE_NORMAL);
 if Handle = INVALID_HANDLE_VALUE then
  begin
   {Return Error}
   ptr^._errno:=EINVAL;
   Exit;
  end;

 {Add Entry}
 Entry:=SyscallsAddEntry(Handle,SYSCALLS_ENTRY_FILE,SYSCALLS_INVALID_FILENO,SYSCALLS_INVALID_FILENO);
 if Entry = nil then
  begin
   {Return Error}
   ptr^._errno:=ENOMEM;
   Exit;
  end;

 {Check Append} {Happens on each write}
 {if (flags and O_APPEND) = O_APPEND then
  begin
   FSFileSeekEx(Handle,0,FILE_END);
  end;}

 {Check Truncate}
 if (flags and O_TRUNC) = O_TRUNC then
  begin
   FSFileSeekEx(Handle,0,FILE_BEGIN);
   FSFileTruncate(Handle);
  end;

 {Save Status Flags}
 Entry^.StatusFlags:=flags;

 {Return Result}
 Result:=Entry^.Number;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _open_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _read_r(ptr: P_reent; fd: int; buf: Pointer; cnt: size_t): _ssize_t; cdecl;
{Read from a file}
{See: \newlib\libc\reent\readr.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Ch:Char;
 Next:PChar;
 Count:LongInt;
 EndChar:Boolean;
 Entry:PSyscallsEntry;
begin
 {}
 Result:=-1;

 {Check reent}
 if ptr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _read_r (ptr=' + PtrToHex(ptr) + ' fd=' + IntToStr(fd) + ' buf=' + PtrToHex(buf) + ' cnt=' + IntToStr(cnt) + ')');
 {$ENDIF}

 {Check buffer}
 if buf = nil then
  begin
   {Return Error}
   ptr^._errno:=EFAULT;
   Exit;
  end;

 {Check descriptor}
 Entry:=SyscallsGetEntry(fd);
 if Entry <> nil then
  begin
   {Normal descriptor}
   if Entry^.Source = SYSCALLS_ENTRY_FILE then
    begin
     {Read file}
     Result:=FSFileRead(Entry^.Handle,buf^,cnt);
    end
   {$IFDEF SYSCALLS_EXPORT_SOCKETS}
   else if Entry^.Source = SYSCALLS_ENTRY_SOCKET then
    begin
     {Read socket}
     Result:=Sockets.fprecv(Entry^.Handle,buf,cnt,0);

     {Check Error}
     if Result = SOCKET_ERROR then ptr^._errno:=socket_get_error(Sockets.SocketError());
    end
   {$ENDIF}
   else
    begin
     {Return Error}
     ptr^._errno:=EINVAL;
    end;
  end
 else
  begin
   if fd = STDIN_FILENO then
    begin
     {Stdin}
     Count:=0;
     EndChar:=False;
     Next:=PChar(buf);
     while (Count < cnt) and not(EndChar) do
      begin
       if TextIOReadChar(Ch,nil) then
        begin
         if Ch = #13 then EndChar:=True;

         Next^:=Ch;

         Inc(Next);
         Inc(Count);

         if EndChar and (Count < cnt) then
          begin
           Next^:=#10;

           Inc(Next);
           Inc(Count);
          end;
        end;
      end;

     Result:=Count;
    end
   else
    begin
     {Return Error}
     ptr^._errno:=EBADF;
    end;
  end;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _read_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _rename_r(ptr: P_reent; old: PChar; new: PChar): int; cdecl;
{Rename a file}
{See: \newlib\libc\reent\renamer.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
  OldName:String;
  NewName:String;
begin
 {}
 Result:=-1;

 {Check reent}
 if ptr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _rename_r (ptr=' + PtrToHex(ptr) + ' old=' + StrPas(old) + ' new=' + StrPas(new) + ')');
 {$ENDIF}

 {Get Names}
 OldName:=StrPas(old);
 NewName:=StrPas(new);

 {Check Names}
 if (Length(OldName) = 0) or (Length(NewName) = 0) then
  begin
   {Return Error}
   ptr^._errno:=ENOENT;
   Exit;
  end;

 {Check File}
 if not FSFileExists(OldName) then
  begin
   {Return Error}
   ptr^._errno:=ENOENT;
   Exit;
  end;

 {Check File}
 if FSFileExists(NewName) then
  begin
   {Return Error}
   ptr^._errno:=EEXIST;
   Exit;
  end;

 {Rename File}
 if FSRenameFile(OldName,NewName) then
  begin
   {Return Result}
   Result:=0;
  end
 else
  begin
   {Return Error}
   ptr^._errno:=EINVAL;
  end;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _rename_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _sbrk_r(ptr: P_reent; incr: ptrdiff_t): Pointer; cdecl;
{Increase program data space}
{See: \newlib\libc\reent\sbrkr.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Value:Pointer;
begin
 {}
 Result:=Pointer(-1);

 {Check reent}
 if ptr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _sbrk_r (ptr=' + PtrToHex(ptr) + ' incr=' + IntToStr(incr) + ')');
 {$ENDIF}

 {Check incr}
 if incr > 0 then
  begin
   {Increase Heap}
   Value:=SyscallsIncreaseHeap(incr);
  end
 else
  begin
   {Note: incr 0 can be used to determine the current heap end}
   Value:=SyscallsDecreaseHeap(-incr);
  end;

 if Value <> nil then
  begin
   {Return Result}
   Result:=Value;
  end
 else
  begin
   {Return Error}
   ptr^._errno:=ENOMEM;
   Result:=Pointer(-1);
  end;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _sbrk_r (Result=' + PtrToHex(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _kill_r(ptr: P_reent; pid: int; sig: int): int; cdecl;
{Send a signal}
{See: \newlib\libc\reent\signalr.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=-1;

 {Check reent}
 if ptr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _kill_r (ptr=' + PtrToHex(ptr) + ' pid=' + IntToStr(pid) + ' sig=' + IntToStr(sig) + ')');
 {$ENDIF}

 {Return Error}
 ptr^._errno:=EINVAL;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _kill_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _getpid_r(ptr: P_reent): int; cdecl;
{Process-ID; this is sometimes used to generate strings unlikely to conflict with other processes}
{See: \newlib\libc\reent\signalr.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=-1;

 {Check reent}
 if ptr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _getpid_r (ptr=' + PtrToHex(ptr) + ')');
 {$ENDIF}

 {Get Current Thread}
 Result:=ThreadGetCurrent;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _getpid_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}
{$IFDEF SYSCALLS_LARGE64_FILES}
function _stat64_r(ptr: P_reent; name: PChar; stat: Pstat64): int; cdecl;
{Status of a file (by name)}
{See: \newlib\libc\reent\stat64r.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Handle:THandle;
begin
 {}
 Result:=-1;

 {Check reent}
 if ptr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _stat64_r (ptr=' + PtrToHex(ptr) + ' name=' + StrPas(name) + ')');
 {$ENDIF}

 {Check stat}
 if stat = nil then Exit;

 {Open file}
 Handle:=FSCreateFile(name,GENERIC_READ,FILE_SHARE_READ or FILE_SHARE_WRITE,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL);
 if Handle = INVALID_HANDLE_VALUE then
  begin
   {Return Error}
   ptr^._errno:=ENOENT;
   Exit;
  end;

 {Get Stat}
 if SyscallsGetStat64(Handle,stat) then
  begin
   {Return Result}
   Result:=0;
  end
 else
  begin
   {Return Error}
   ptr^._errno:=EINVAL;
  end;

 {Close File}
 FSFileClose(Handle);

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _stat64_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;
{$ENDIF}
{==============================================================================}

function _stat_r(ptr: P_reent; name: PChar; stat: Pstat): int; cdecl;
{Status of a file (by name)}
{See: \newlib\libc\reent\statr.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Handle:THandle;
begin
 {}
 Result:=-1;

 {Check reent}
 if ptr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _stat_r (ptr=' + PtrToHex(ptr) + ' name=' + StrPas(name) + ')');
 {$ENDIF}

 {Check stat}
 if stat = nil then Exit;

 {Open file}
 Handle:=FSCreateFile(name,GENERIC_READ,FILE_SHARE_READ or FILE_SHARE_WRITE,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL);
 if Handle = INVALID_HANDLE_VALUE then
  begin
   {Return Error}
   ptr^._errno:=ENOENT;
   Exit;
  end;

 {Get Stat}
 if SyscallsGetStat(Handle,stat) then
  begin
   {Return Result}
   Result:=0;
  end
 else
  begin
   {Return Error}
   ptr^._errno:=EINVAL;
  end;

 {Close File}
 FSFileClose(Handle);

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _stat_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _times_r(ptr: P_reent; tms: Ptms): clock_t; cdecl;
{Timing information for current process}
{See: \newlib\libc\reent\timesr.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 SysTime:Int64;
 CreateTime:Int64;
 ExitTime:Int64;
 KernelTime:Int64;
begin
 {}
 Result:=clock_t(-1);

 {Check reent}
 if ptr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _times_r (ptr=' + PtrToHex(ptr) + ')');
 {$ENDIF}

 {Check tms}
 if tms = nil then Exit;

 {Get Thread Times}
 if ThreadGetTimes(ThreadGetCurrent,CreateTime,ExitTime,KernelTime) = ERROR_SUCCESS then
  begin
   {$IFDEF SYSCALLS_DEBUG}
   if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  CreateTime=' + IntToHex(CreateTime,16));
   if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  ExitTime=' + IntToHex(ExitTime,16));
   if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  KernelTime=' + IntToHex(KernelTime,16));
   {$ENDIF}

   {Return tms}
   tms^.tms_utime:=0;
   if TIME_TICKS_PER_SCHEDULER_INTERRUPT > 0 then
    SysTime:=(KernelTime - TIME_TICKS_TO_1899) div TIME_TICKS_PER_SCHEDULER_INTERRUPT {Avoid 32-bit overflow}
   else
    SysTime:=0;
   tms^.tms_stime:=SysTime;
   tms^.tms_cutime:=0;
   tms^.tms_cstime:=0;

   {$IFDEF SYSCALLS_DEBUG}
   if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  SysTime=' + IntToHex(SysTime,16));
   if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  tms_stime=' + IntToStr(tms^.tms_stime));
   {$ENDIF}

   {Return Result}
   Result:=(GetTickCount64 div MILLISECONDS_PER_SECOND) * SCHEDULER_INTERRUPTS_PER_SECOND;
  end
 else
  begin
   {Return Error}
   ptr^._errno:=EINVAL;
  end;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _times_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _unlink_r(ptr: P_reent; name: PChar): int; cdecl;
{Remove a file or directory entry}
{See: \newlib\libc\reent\unlinkr.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 FileName:String;
begin
 {}
 Result:=-1;

 {Check reent}
 if ptr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _unlink_r (ptr=' + PtrToHex(ptr) + ' name=' + StrPas(name) + ')');
 {$ENDIF}

 {Get Name}
 FileName:=StrPas(name);

 {Check Name}
 if Length(FileName) = 0 then
  begin
   {Return Error}
   ptr^._errno:=ENOENT;
   Exit;
  end;

 {Check File}
 if FSFileExists(FileName) then
  begin
   {Delete File}
   if FSDeleteFile(FileName) then
    begin
     {Return Result}
     Result:=0;
    end
   else
    begin
     {Return Error}
     ptr^._errno:=EINVAL;
    end;
  end
 {Check Directory}
 else if FSDirectoryExists(FileName) then
  begin
   {Remove Directory}
   if FSRemoveDir(FileName) then
    begin
     {Return Result}
     Result:=0;
    end
   else
    begin
     {Return Error}
     ptr^._errno:=EINVAL;
    end;
  end
 else
  begin
   {Return Error}
   ptr^._errno:=ENOENT;
   Exit;
  end;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _unlink_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _write_r(ptr: P_reent; fd: int; buf: Pointer; cnt: size_t): _ssize_t; cdecl;
{Write to a file}
{See: \newlib\libc\reent\writer.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Entry:PSyscallsEntry;
begin
 {}
 Result:=-1;

 {Check reent}
 if ptr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _write_r (ptr=' + PtrToHex(ptr) + ' fd=' + IntToStr(fd) + ' buf=' + PtrToHex(buf) + ' cnt=' + IntToStr(cnt) + ')');
 {$ENDIF}

 {Check buffer}
 if buf = nil then
  begin
   {Return Error}
   ptr^._errno:=EFAULT;
   Exit;
  end;

 {Check descriptor}
 Entry:=SyscallsGetEntry(fd);
 if Entry <> nil then
  begin
   {Normal descriptor}
   if Entry^.Source = SYSCALLS_ENTRY_FILE then
    begin
     {Check Append}
     if (Entry^.StatusFlags and O_APPEND) = O_APPEND then
      begin
       {Seek to End}
       FSFileSeekEx(Entry^.Handle,0,FILE_END);
      end;

     {Write file}
     Result:=FSFileWrite(Entry^.Handle,buf^,cnt);
    end
   {$IFDEF SYSCALLS_EXPORT_SOCKETS}
   else if Entry^.Source = SYSCALLS_ENTRY_SOCKET then
    begin
     {Write socket}
     Result:=Sockets.fpsend(Entry^.Handle,buf,cnt,0);

     {Check Error}
     if Result = SOCKET_ERROR then ptr^._errno:=socket_get_error(Sockets.SocketError());
    end
   {$ENDIF}
   else
    begin
     {Return Error}
     ptr^._errno:=EINVAL;
    end;
  end
 else
  begin
   if fd = STDOUT_FILENO then
    begin
     {Stdout}
     Result:=TextIOWriteBuffer(PChar(buf),cnt,nil);
    end
   else if fd = STDERR_FILENO then
    begin
     {Stderr}
     Result:=TextIOWriteBuffer(PChar(buf),cnt,nil);
    end
   else
    begin
     {Return Error}
     ptr^._errno:=EBADF;
    end;
  end;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _write_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function _getentropy_r(ptr: P_reent; buffer: Pointer; length: size_t): int; cdecl;
{Fill a buffer with random bytes}
{See: \newlib\libc\reent\getentropyr.c}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=-1;

 {Check reent}
 if ptr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _getentropy_r (ptr=' + PtrToHex(ptr) + ' buffer=' + PtrToHex(buf) + ' length=' + IntToStr(length) + ')');
 {$ENDIF}

 {Check buffer}
 if buffer = nil then
  begin
   {Return Error}
   ptr^._errno:=EFAULT;
   Exit;
  end;

 {Check length}
 if length > 256 then
  begin
   {Return Error}
   ptr^._errno:=EIO;
   Exit;
  end;

 {Get Random Bytes}
 if GetRandomBytes(buffer,length) then
  begin
   {Return Result}
   Result:=0;
  end
 else
  begin
   {Return Error}
   ptr^._errno:=EIO;
  end;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _getentropy_r (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}
{==============================================================================}
{Syscalls Functions (Stat)}
function mkdir(path: PChar; mode: mode_t): int; cdecl;
{Create a directory}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls mkdir (path=' + StrPas(path) + ' mode=' + IntToStr(mode) + ')');
 {$ENDIF}

 Result:=_mkdir_r(__getreent,path,mode);
end;

{==============================================================================}

function chmod(path: PChar; mode: mode_t): int; cdecl;
{Change mode of a file}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls chmod (path=' + StrPas(path) + ' mode=' + IntToStr(mode) + ')');
 {$ENDIF}

 Result:=0;
end;

{==============================================================================}

function lstat(path: PChar; stat: Pstat): int; cdecl; public name 'lstat';
{Get symbolic link status}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls lstat (path=' + StrPas(path) + ')');
 {$ENDIF}

 Result:=_stat_r(__getreent,path,stat);
end;

{==============================================================================}

function umask(mask: mode_t): mode_t; cdecl;
{Set file mode creation mask}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls umask (mask=' + IntToStr(mask) + ')');
 {$ENDIF}

 Result:=0;
end;

{==============================================================================}
{==============================================================================}
{Syscalls Functions (Misc)}
{$IFDEF SYSCALLS_USE_LIBC_INITFINI}
procedure _init; cdecl;
begin
 {Nothing, provides the _init function if _HAVE_INIT_FINI is defined in Libc}
end;

{==============================================================================}

procedure _fini; cdecl;
begin
 {Nothing, provides the _fini function if _HAVE_INIT_FINI is defined in Libc}
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{Syscalls Functions (Stdlib)}
function posix_memalign(memptr: PPointer; alignment, size: size_t): int; cdecl;
{Aligned memory allocation}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 mem:Pointer;
begin
 {}
 Result:=EINVAL;

 {Check memptr}
 if memptr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls posix_memalign (alignment=' + IntToStr(alignment) + ' size=' + IntToStr(size) + ')');
 {$ENDIF}

 {Test whether the ALIGNMENT argument is valid}
 if ((alignment mod SizeOf(Pointer)) <> 0) or (alignment and (alignment - 1) <> 0) then Exit;

 Result:=ENOMEM;

 mem:=memalign(alignment,size);
 if mem = nil then Exit;

 memptr^:=mem;

 Result:=0;
end;

{==============================================================================}

function realpath(path, resolved_path: PChar): PChar; cdecl;
{Return the canonicalized absolute pathname}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Buffer:PChar;
 Fullpath:String;
begin
 {}
 Result:=nil;

 {Check path}
 if path = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
   Exit;
  end;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls realpath (path=' + StrPas(path) + ' resolved_path=' + StrPas(resolved_path) + ')');
 {$ENDIF}

 {Get resolved path}
 Buffer:=resolved_path;
 if Buffer = nil then
  begin
   {Allocate buffer (Must use malloc)}
   Buffer:=malloc(PATH_MAX);
  end;

 {Check Buffer}
 if Buffer = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=ENOMEM;
   Exit;
  end;

 {Get Full Path}
 Fullpath:=FSGetLongName(path);

 {Copy Full Path}
 StrLCopy(Buffer,PChar(Fullpath),PATH_MAX);

 {Return Result}
 Result:=Buffer;
end;

{==============================================================================}

function setenv(name, value: PChar; overwrite: int): int; cdecl;
{Change or add an environment variable}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 ResultCode:LongWord;
begin
 {}
 Result:=-1;

 {Check Overwrite Existing}
 if (overwrite = 0) and (EnvironmentIndex(name) <> 0) then
  begin
    Result:=0;
    Exit;
  end;

 {Set Environment}
 ResultCode:=SyscallsEnvironmentSet(name,value);
 if ResultCode = ERROR_SUCCESS then
  begin
   Result:=0;
  end
 else if ResultCode = ERROR_INVALID_PARAMETER then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
  end
 else if ResultCode = ERROR_NOT_ENOUGH_MEMORY then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=ENOMEM;
  end
 else
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EFAULT;
  end;
end;

{==============================================================================}

function unsetenv(name: PChar): int; cdecl;
{Delete an environment variable}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 ResultCode:LongWord;
begin
 {}
 Result:=-1;

 {Set Environment}
 ResultCode:=SyscallsEnvironmentSet(name,'');
 if ResultCode = ERROR_SUCCESS then
  begin
   Result:=0;
  end
 else if ResultCode = ERROR_INVALID_PARAMETER then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
  end
 else if ResultCode = ERROR_NOT_ENOUGH_MEMORY then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=ENOMEM;
  end
 else
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EFAULT;
  end;
end;

{==============================================================================}
{==============================================================================}
{Syscalls Functions (Unistd)}
function chdir(path: PChar): int; cdecl;
{Change working directory}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 Result:=-1;

 {Check path}
 if path = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EFAULT;
   Exit;
  end;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls chdir (path=' + StrPas(path) + ')');
 {$ENDIF}

 {Set Current Directory}
 if FSSetCurrentDir(path) then
  begin
   Result:=0;
  end
 else
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EIO;
  end;
end;

{==============================================================================}

function dup(oldfd: int): int; cdecl;
{Duplicate a file descriptor}
{The new file descriptor number will be the lowest-numbered file descriptor that was unused}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Handle:THandle;
 Entry:PSyscallsEntry;
 Duplicate:PSyscallsEntry;
begin
 {}
 Result:=-1;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls dup (oldfd=' + IntToStr(oldfd) + ')');
 {$ENDIF}

 {Get Existing Entry}
 Entry:=SyscallsGetEntry(oldfd);
 if (Entry <> nil) and (Entry^.Source = SYSCALLS_ENTRY_FILE) then
  begin
   {Duplicate Handle}
   Handle:=FSDuplicateHandle(Entry^.Handle);
   if Handle = INVALID_HANDLE_VALUE then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EINVAL;
     Exit;
    end;

   {Add Duplicate Entry (Lowest file number)}
   Duplicate:=SyscallsAddEntry(Handle,SYSCALLS_ENTRY_FILE,SYSCALLS_TABLE_MIN,SYSCALLS_INVALID_FILENO);
   if Duplicate = nil then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=ENOMEM;
     Exit;
    end;

   {Return Result}
   Result:=Duplicate^.Number;
  end
 else
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EBADF;
  end;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls dup (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function dup2(oldfd, newfd: int): int; cdecl;
{Duplicate a file descriptor}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Handle:THandle;
 Entry:PSyscallsEntry;
 Duplicate:PSyscallsEntry;
begin
 {}
 Result:=-1;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls dup2 (oldfd=' + IntToStr(oldfd) + ' newfd=' + IntToStr(newfd) + ')');
 {$ENDIF}

 {Check newfd}
 if (newfd < 0) or (newfd > SYSCALLS_TABLE_MAX) then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EBADF;
   Exit;
  end;

 {Get Existing Entry}
 Entry:=SyscallsGetEntry(oldfd);
 if (Entry <> nil) and (Entry^.Source = SYSCALLS_ENTRY_FILE) then
  begin
   {Check fds}
   if oldfd = newfd then
    begin
     {Return Result}
     Result:=newfd;
     Exit;
    end;

   {Lock Table}
   if MutexLock(SyscallsTableLock) = ERROR_SUCCESS then
    begin
     try
       {Get Duplicate Entry}
       Duplicate:=SyscallsGetEntry(newfd);
       if Duplicate <> nil then
        begin
         if Duplicate^.Source = SYSCALLS_ENTRY_FILE then
          begin
           {Close file}
           FSFileClose(Duplicate^.Handle);
          end
         {$IFDEF SYSCALLS_EXPORT_SOCKETS}
         else if Duplicate^.Source = SYSCALLS_ENTRY_SOCKET then
          begin
           {Close socket}
           Sockets.CloseSocket(Duplicate^.Handle);
          end
         {$ENDIF}
         else
          begin
           {Return Error}
           ptr:=__getreent;
           if ptr <> nil then ptr^._errno:=EINVAL;
           Exit;
          end;
        end;

       {Duplicate Handle}
       Handle:=FSDuplicateHandle(Entry^.Handle);
       if Handle = INVALID_HANDLE_VALUE then
        begin
         {Return Error}
         ptr:=__getreent;
         if ptr <> nil then ptr^._errno:=EINVAL;
         Exit;
        end;

       {Add Duplicate Entry (Specified file number)}
       Duplicate:=SyscallsAddEntry(Handle,SYSCALLS_ENTRY_FILE,SYSCALLS_INVALID_FILENO,newfd);
       if Duplicate = nil then
        begin
         {Return Error}
         ptr:=__getreent;
         if ptr <> nil then ptr^._errno:=ENOMEM;
         Exit;
        end;

      {Return Result}
      Result:=Duplicate^.Number;
     finally
      {Unlock Table}
      MutexUnlock(SyscallsTableLock);
     end;
    end
   else
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EINVAL;
    end;
  end
 else
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EBADF;
  end;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls dup2 (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function dup3(oldfd, newfd, flags: int): int; cdecl;
{Duplicate a file descriptor}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 Result:=-1;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls dup3 (oldfd=' + IntToStr(oldfd) + ' newfd=' + IntToStr(newfd) + ' flags=' + IntToHex(flags,8) + ')');
 {$ENDIF}

 {Check fds}
 if oldfd = newfd then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
   Exit;
  end;

 {Duplicate file descriptor}
 Result:=dup2(oldfd,newfd);
end;

{==============================================================================}

function getentropy(buffer: Pointer; length: size_t): int; cdecl;
{Fill a buffer with random bytes}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls getentropy (buffer=' + PtrToHex(buffer) + ' length=' + IntToStr(length) + ')');
 {$ENDIF}

 Result:=_getentropy_r(__getreent,buffer,length);
end;

{==============================================================================}

function link(path1, path2: PChar): int; cdecl;
{Link to a file}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls link (path1=' + StrPas(path1) + ' path2=' + StrPas(path2) + ')');
 {$ENDIF}

 Result:=_link_r(__getreent,path1,path2);
end;

{==============================================================================}

function rmdir(path: PChar): int; cdecl;
{Delete a directory, which must be empty}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 Result:=-1;

 {Check path}
 if path = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EFAULT;
   Exit;
  end;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls rmdir (path=' + StrPas(path) + ')');
 {$ENDIF}

 {Check Directory}
 if not FSDirectoryExists(path) then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=ENOTDIR;
   Exit;
  end;

 {Remove Directory}
 if FSRemoveDir(path) then
  begin
   Result:=0;
  end
 else
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=ENOTEMPTY;
  end;
end;

{==============================================================================}

function sysconf(name: int):int; cdecl;
{Get configurable system variables}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 FPCStatus:TFPCHeapStatus;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls sysconf (name=' + IntToStr(name) + ')');
 {$ENDIF}

 {Check name}
 case name of
  _SC_CLK_TCK:begin
    {Clock ticks per second (Scheduler ticks)}
    Result:=SCHEDULER_INTERRUPTS_PER_SECOND;
   end;
  _SC_OPEN_MAX:begin
    {The maximum number of files that can be open at any time (Applies only to functions that utilize file descriptors)}
    Result:=SYSCALLS_TABLE_MAX + 1;
   end;
  _SC_PAGESIZE:begin
    {Size of a page in bytes}
    Result:=MEMORY_PAGE_SIZE;
   end;
  _SC_PHYS_PAGES:begin
    {The number of pages of physical memory}
    Result:=MEMORY_SIZE div MEMORY_PAGE_SIZE;
   end;
  _SC_AVPHYS_PAGES:begin
    {The number of available pages of physical memory}
    FPCStatus:=GetFPCHeapStatus;

    Result:=FPCStatus.CurrHeapFree div MEMORY_PAGE_SIZE;
   end;
  _SC_NPROCESSORS_CONF:begin
    {The number of processors configured}
    Result:=CPU_COUNT;
   end;
  _SC_NPROCESSORS_ONLN:begin
    {The number of processors currently online (available)}
    Result:=SCHEDULER_CPU_COUNT;
   end;
  _SC_TZNAME_MAX:begin
    {The maximum number of bytes in a timezone name}
    Result:=SIZE_64; {TIMEZONE_NAME_LENGTH}
   end;
  _SC_HOST_NAME_MAX:begin
    {Maximum length of a hostname}
    Result:=255;
   end;
 else
  begin
   {Return Error}
   Result:=-1;
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
  end;
 end;
end;

{==============================================================================}

function getpagesize: int; cdecl;
{Return the number of bytes in a memory page}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=sysconf(_SC_PAGESIZE);

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls getpagesize (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function ssleep(seconds: uint): uint; cdecl;
{Sleep for a specified number of seconds}

{Note: Does not support interruption by signal}
{Note: Declared as ssleep to avoid conflict with Pascal Sleep() function}
{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=0;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls sleep (seconds=' + IntToStr(seconds) + ')');
 {$ENDIF}

 ThreadSleep(seconds * 1000);
end;

{==============================================================================}

function usleep(useconds: useconds_t): int; cdecl;
{Suspend execution for microsecond intervals}

{Note: Does not support interruption by signal}
{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Remain: PtrUInt;
begin
 {}
 Result:=0;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls usleep (useconds=' + IntToStr(useconds) + ')');
 {$ENDIF}

 Remain:=useconds;

 if useconds > 1000 then
  begin
   ThreadSleep(useconds div 1000);
   Remain:=useconds mod 1000;
  end;

 if Remain > 0 then
  begin
   MicrosecondDelay(Remain);
  end;
end;

{==============================================================================}

function symlink(path1, path2: PChar): int; cdecl;
{Make a symbolic link to a file}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 LinkName:String;
 TargetName:String;
begin
 {}
 Result:=-1;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls symlink (path1=' + StrPas(path1) + ' path2=' + StrPas(path2) + ')');
 {$ENDIF}

 {Get Names}
 LinkName:=StrPas(path2);
 TargetName:=StrPas(path1);

 {Check Names}
 if (Length(TargetName) = 0) or (Length(LinkName) = 0) then
  begin
   {Return Error}
   ptr^._errno:=ENOENT;
   Exit;
  end;

 {Check Link}
 if FSFileExists(LinkName) or FSDirectoryExists(LinkName) then
  begin
   {Return Error}
   ptr^._errno:=EEXIST;
   Exit;
  end;

 {Check Target}
 if not FSFileExists(TargetName) and not FSDirectoryExists(TargetName) then
  begin
   {Return Error}
   ptr^._errno:=ENOENT;
   Exit;
  end;

 {Create Symbolic Link}
 if FSCreateSymbolicLink(LinkName,TargetName,FSDirectoryExists(TargetName)) then
  begin
   {Return Result}
   Result:=0;
  end
 else
  begin
   {Return Error}
   ptr^._errno:=EINVAL;
  end;
end;

{==============================================================================}

function unlink(path: PChar): int; cdecl;
{Delete a name and possibly the file it refers to}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls unlink (path=' + StrPas(path) + ')');
 {$ENDIF}

 Result:=_unlink_r(__getreent,path);
end;

{==============================================================================}

function ftruncate(fd: int; length: off_t): int; cdecl;
{Truncate a file to a specified length}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Entry:PSyscallsEntry;
begin
 {}
 Result:=-1;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls ftruncate (fd=' + IntToStr(fd) + ' length=' + IntToStr(length) + ')');
 {$ENDIF}

 {Check Length}
 if length < 0 then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
   Exit;
  end;

 {Check descriptor}
 Entry:=SyscallsGetEntry(fd);
 if (Entry <> nil) and (Entry^.Source = SYSCALLS_ENTRY_FILE) then
  begin
   {Normal descriptor}
   {Truncate}
   FSFileSeekEx(Entry^.Handle,length,FILE_BEGIN);
   if not FSFileTruncate(Entry^.Handle) then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EIO;
     Exit;
    end;

   {Return Result}
   Result:=0;
  end
 else
  begin
   if (Entry = nil) and ((fd = STDIN_FILENO) or (fd = STDOUT_FILENO) or (fd = STDERR_FILENO)) then
    begin
     {Stdin, Stdout, Stderr}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EBADF;
     Exit;
    end
   else
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EBADF;
    end;
  end;
end;

{==============================================================================}

function truncate(path: PChar; length: off_t): int; cdecl;
{Truncate a file to a specified length}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Handle:THandle;
begin
 {}
 Result:=-1;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls truncate (path=' + StrPas(path) + ' length=' + IntToStr(length) + ')');
 {$ENDIF}

 {Check Length}
 if length < 0 then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
   Exit;
  end;

 {Open file}
 Handle:=FSCreateFile(path,GENERIC_READ or GENERIC_WRITE,FILE_SHARE_READ or FILE_SHARE_WRITE,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL);
 if Handle = INVALID_HANDLE_VALUE then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=ENOENT;
   Exit;
  end;

 {Truncate}
 FSFileSeekEx(Handle,length,FILE_BEGIN);
 if FSFileTruncate(Handle) then
  begin
   {Return Result}
   Result:=0;
  end
 else
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EIO;
   Exit;
  end;

 {Close File}
 FSFileClose(Handle);
end;

{==============================================================================}

function fsync(fd: int): int; cdecl;
{Synchronize a file's state with storage}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Entry:PSyscallsEntry;
begin
 {}
 Result:=-1;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls fsync (fd=' + IntToStr(fd) + ')');
 {$ENDIF}

 {Check descriptor}
 Entry:=SyscallsGetEntry(fd);
 if (Entry <> nil) and (Entry^.Source = SYSCALLS_ENTRY_FILE) then
  begin
   {Normal descriptor}
   {Flush}
   if not FSFileFlush(Entry^.Handle) then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EIO;
     Exit;
    end;

   {Return Result}
   Result:=0;
  end
 else
  begin
   if (Entry = nil) and ((fd = STDIN_FILENO) or (fd = STDOUT_FILENO) or (fd = STDERR_FILENO)) then
    begin
     {Stdin, Stdout, Stderr}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EINVAL;
     Exit;
    end
   else
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EBADF;
    end;
  end;
end;

{==============================================================================}

function fdatasync(fd: int): int; cdecl;
{Synchronize a file's state with storage}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Entry:PSyscallsEntry;
begin
 {}
 Result:=-1;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls fdatasync (fd=' + IntToStr(fd) + ')');
 {$ENDIF}

 {Check descriptor}
 Entry:=SyscallsGetEntry(fd);
 if (Entry <> nil) and (Entry^.Source = SYSCALLS_ENTRY_FILE) then
  begin
   {Normal descriptor}
   {Flush}
   if not FSFileFlush(Entry^.Handle) then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EIO;
     Exit;
    end;

   {Return Result}
   Result:=0;
  end
 else
  begin
   if (Entry = nil) and ((fd = STDIN_FILENO) or (fd = STDOUT_FILENO) or (fd = STDERR_FILENO)) then
    begin
     {Stdin, Stdout, Stderr}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EINVAL;
     Exit;
    end
   else
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EBADF;
    end;
  end;
end;

{==============================================================================}

function sethostname(name: PChar; size: size_t): int; cdecl;
{Set the system host name}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 HostName:String;
begin
 {}
 Result:=-1;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls sethostname (name=' + StrPas(name) + ' size=' + IntToStr(size) + ')');
 {$ENDIF}

 {Check name}
 if name = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EFAULT;
   Exit;
  end;

 {Get Name}
 HostName:=StrPas(name);

 {Set Name}
 if not HostSetName(HostName) then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
   Exit;
  end;

 Result:=0;
end;

{==============================================================================}
{$IF not(DEFINED(API_EXPORT_WINSOCK)) and not(DEFINED(API_EXPORT_WINSOCK2))}
function gethostname(name: PChar; size: size_t): int; cdecl;
{Get the system host name}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 {$IFNDEF SYSCALLS_EXPORT_SOCKETS}
 HostName:String;
 {$ENDIF}
begin
 {}
 {$IFDEF SYSCALLS_EXPORT_SOCKETS}
 Result:=Sockets.GetHostName(name,size);
 if Result = SOCKET_ERROR then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=socket_get_error(Sockets.SocketError());
  end;
 {$ELSE}
 Result:=-1;

 {Check name}
 if name = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EFAULT;
   Exit;
  end;

 {Get Name}
 HostName:=HostGetName;

 {Check Name}
 if size < Length(HostName) then
  begin
   {Check Size}
   if size > 0 then size:=size - 1;
  end;

 {Copy Name}
 StrLCopy(name,PChar(HostName),size);

 {Return Result}
 Result:=0;
 {$ENDIF}
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{Syscalls Functions (Mman)}
function mmap(addr: Pointer; length: size_t; prot, flags, fd: int; offset: off_t): Pointer; cdecl;
{Map files or devices into memory}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls mmap (addr=' + PtrToHex(addr) + ' length=' + IntToStr(length) + ')');
 {$ENDIF}

 {Return Error}
 Result:=Pointer(-1); {MAP_FAILED}
 ptr:=__getreent;
 if ptr <> nil then ptr^._errno:=EINVAL;
end;

{==============================================================================}

function munmap(addr: Pointer; length: size_t): int; cdecl;
{Unmap files or devices into memory}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls munmap (addr=' + PtrToHex(addr) + ' length=' + IntToStr(length) + ')');
 {$ENDIF}

 {Return Error}
 Result:=-1;
 ptr:=__getreent;
 if ptr <> nil then ptr^._errno:=EINVAL;
end;

{==============================================================================}
{==============================================================================}
{Syscalls Functions (Time)}
function settimeofday(tv: Ptimeval; tz: Pointer): int; cdecl;
{Set the date and time}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 ClockTime:Int64;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls settimeofday (tv=' + PtrToHex(tv) + ' tz=' + PtrToHex(tz) + ')');
 {$ENDIF}

 {Check tv}
 if tv = nil then
  begin
   {Return Error}
   Result:=-1;
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EFAULT;
  end
 else
  begin
   {Convert timeval}
   ClockTime:=TIME_TICKS_TO_1970 + (tv^.tv_sec * TIME_TICKS_PER_SECOND) + (tv^.tv_usec * TIME_TICKS_PER_MICROSECOND);

   {Set time}
   ClockSetTime(ClockTime,True);

   {Return Result}
   Result:=0;
  end;
end;

{==============================================================================}

function clock_getres(clk_id: clockid_t; res: Ptimespec): int; cdecl;
{Return the resolution of the requested clock}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 {Check res}
 {if res = nil then Exit;} {May be nil}

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls clock_getres (clk_id=' + IntToStr(clk_id) + ')');
 {$ENDIF}

 {Check Clock}
 case clk_id of
  CLOCK_REALTIME,CLOCK_THREAD_CPUTIME_ID:begin
    if res <> nil then
     begin
      res^.tv_sec:=0;
      res^.tv_nsec:=100; {Ultibo time is in 100ns intervals}
     end;

    Result:=0;
   end;
  CLOCK_MONOTONIC:begin
    if res <> nil then
     begin
      res^.tv_sec:=0;
      if CLOCK_CYCLES_PER_NANOSECOND > 0 then
       begin
        res^.tv_nsec:=1;
       end
      else if CLOCK_CYCLES_PER_MICROSECOND > 0 then
       begin
        res^.tv_nsec:=1000;
       end
      else if CLOCK_CYCLES_PER_MILLISECOND > 0 then
       begin
        res^.tv_nsec:=1000000;
       end
      else
       begin
        res^.tv_sec:=1;
        res^.tv_nsec:=0;
       end;
     end;

    Result:=0;
   end;
  CLOCK_PROCESS_CPUTIME_ID:begin
    {Return Error}
    Result:=-1;
    ptr:=__getreent;
    if ptr <> nil then ptr^._errno:=EINVAL;
   end;
  else
   begin
    {Return Error}
    Result:=-1;
    ptr:=__getreent;
    if ptr <> nil then ptr^._errno:=EINVAL;
   end;
 end;
end;

{==============================================================================}

function clock_gettime(clk_id: clockid_t; tp: Ptimespec): int; cdecl;
{Get the time from the requested clock}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Value:Int64;
 CreateTime:Int64;
 ExitTime:Int64;
 KernelTime:Int64;
begin
 {}
 {Check tp}
 if tp = nil then
  begin
   {Return Error}
   Result:=-1;
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EFAULT;

   Exit;
  end;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls clock_gettime (clk_id=' + IntToStr(clk_id) + ')');
 {$ENDIF}

 {Check Clock}
 case clk_id of
  CLOCK_REALTIME:begin
    {Get Clock Time}
    Value:=ClockGetTime;
    if Value <  TIME_TICKS_TO_1970 then
     begin
      tp^.tv_sec:=0;
      tp^.tv_nsec:=0;
     end
    else
     begin
      {Convert to timespec}
      Value:=Value - TIME_TICKS_TO_1970;

      tp^.tv_sec:=Value div TIME_TICKS_PER_SECOND;
      tp^.tv_nsec:=(Value mod TIME_TICKS_PER_SECOND) * 100;
     end;

    {$IFDEF SYSCALLS_DEBUG}
    if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls clock_gettime (tv_sec=' + IntToStr(tp^.tv_sec) + ' tv_nsec=' + IntToStr(tp^.tv_nsec) + ')');
    {$ENDIF}

    Result:=0;
   end;
  CLOCK_MONOTONIC:begin
    if CLOCK_FREQUENCY = 0 then
     begin
      tp^.tv_sec:=0;
      tp^.tv_nsec:=0;
     end
    else
     begin
      {Get Clock Total}
      Value:=ClockGetTotal;

      tp^.tv_sec:=Value div CLOCK_FREQUENCY;
      if CLOCK_CYCLES_PER_NANOSECOND > 0 then
       begin
        tp^.tv_nsec:=(Value mod CLOCK_FREQUENCY) div CLOCK_CYCLES_PER_NANOSECOND;
       end
      else if CLOCK_CYCLES_PER_MICROSECOND > 0 then
       begin
        tp^.tv_nsec:=((Value mod CLOCK_FREQUENCY) div CLOCK_CYCLES_PER_MICROSECOND) * 1000;
       end
      else if CLOCK_CYCLES_PER_MILLISECOND > 0 then
       begin
        tp^.tv_nsec:=((Value mod CLOCK_FREQUENCY) div CLOCK_CYCLES_PER_MILLISECOND) * 1000000;
       end;
     end;

    {$IFDEF SYSCALLS_DEBUG}
    if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls clock_gettime (tv_sec=' + IntToStr(tp^.tv_sec) + ' tv_nsec=' + IntToStr(tp^.tv_nsec) + ')');
    {$ENDIF}

    Result:=0;
   end;
  CLOCK_THREAD_CPUTIME_ID:begin
    {Get Thread Times}
    if ThreadGetTimes(ThreadGetCurrent,CreateTime,ExitTime,KernelTime) <> ERROR_SUCCESS then
     begin
      tp^.tv_sec:=0;
      tp^.tv_nsec:=0;
     end
    else
     begin
      {Convert to timespec}
      Value:=KernelTime - TIME_TICKS_TO_1899;

      tp^.tv_sec:=Value div TIME_TICKS_PER_SECOND;
      tp^.tv_nsec:=(Value mod TIME_TICKS_PER_SECOND) * 100;
     end;

    {$IFDEF SYSCALLS_DEBUG}
    if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls clock_gettime (tv_sec=' + IntToStr(tp^.tv_sec) + ' tv_nsec=' + IntToStr(tp^.tv_nsec) + ')');
    {$ENDIF}

    Result:=0;
   end;
  CLOCK_PROCESS_CPUTIME_ID:begin
    {Return Error}
    Result:=-1;
    ptr:=__getreent;
    if ptr <> nil then ptr^._errno:=EINVAL;
   end;
  else
   begin
    {Return Error}
    Result:=-1;
    ptr:=__getreent;
    if ptr <> nil then ptr^._errno:=EINVAL;
   end;
 end;
end;

{==============================================================================}

function clock_settime(clk_id: clockid_t; tp: Ptimespec): int; cdecl;
{Set the time of the requested clock}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Value:Int64;
begin
 {}
 {Check tp}
 if tp = nil then
  begin
   {Return Error}
   Result:=-1;
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EFAULT;

   Exit;
  end;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls clock_settime (clk_id=' + IntToStr(clk_id) + ' tv_sec=' + IntToStr(tp^.tv_sec) + ' tv_nsec=' + IntToStr(tp^.tv_nsec) + ')');
 {$ENDIF}

 {Check Clock}
 case clk_id of
  CLOCK_REALTIME:begin
    {Convert timespec}
    Value:=TIME_TICKS_TO_1970 + (tp^.tv_sec * TIME_TICKS_PER_SECOND) + (tp^.tv_nsec div 100);

    {Set Time}
    ClockSetTime(Value,True);

    Result:=0;
   end;
  else
   begin
    {Return Error}
    Result:=-1;
    ptr:=__getreent;
    if ptr <> nil then ptr^._errno:=EINVAL;
   end;
 end;
end;

{==============================================================================}

function nanosleep(req, rem: Ptimespec): int; cdecl;
{High-resolution sleep}

{Note: Does not support interruption by signal}
{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=0;

 {Check req}
 if req = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls nanosleep (tv_sec=' + IntToStr(req^.tv_sec) + ' tv_nsec=' + IntToStr(req^.tv_nsec) + ')');
 {$ENDIF}

 ThreadSleep((req^.tv_sec * 1000) + (req^.tv_nsec div 1000000));

 {Check rem}
 if rem <> nil then
  begin
   rem^.tv_sec:=0;
   rem^.tv_nsec:=0;
  end;
end;

{==============================================================================}
{==============================================================================}
{Syscalls Functions (Statfs)}
function statfs(path: PChar; buf: Pstatfs): int; cdecl;
{Get filesystem statistics}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 Result:=-1;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls statfs (path=' + StrPas(path) + ' buf=' + PtrToHex(buf) + ')');
 {$ENDIF}

 {Check buf}
 if buf = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EFAULT;
   Exit;
  end;

 {Get Statfs}
 if not SyscallsGetStatfs(StrPas(path),buf) then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=ENOENT;
   Exit;
  end;

 Result:=0;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls statfs (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function fstatfs(fd: int; buf: Pstatfs): int; cdecl;
{Get filesystem statistics}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Path:String;
 Entry:PSyscallsEntry;
begin
 {}
 Result:=-1;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls fstatfs (fd=' + IntToStr(fd) + ' buf=' + PtrToHex(buf) + ')');
 {$ENDIF}

 {Check buf}
 if buf = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EFAULT;
   Exit;
  end;

 {Get Entry}
 Entry:=SyscallsGetEntry(fd);
 if (Entry <> nil) and (Entry^.Source = SYSCALLS_ENTRY_FILE) then
  begin
   {Get Path}
   Path:=FSGetFinalPathNameByHandle(Entry^.Handle,0);

   {Get Statfs}
   if not SyscallsGetStatfs(Path,buf) then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=ENOENT;
     Exit;
    end;

   Result:=0;
  end
 else
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EBADF;
  end;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls fstatfs (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}
{$IFDEF SYSCALLS_LARGE64_FILES}
function statfs64(path: PChar; buf: Pstatfs64): int; cdecl;
{Get filesystem statistics}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 Result:=-1;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls statfs64 (path=' + StrPas(path) + ' buf=' + PtrToHex(buf) + ')');
 {$ENDIF}

 {Check buf}
 if buf = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EFAULT;
   Exit;
  end;

 {Get Statfs64}
 if not SyscallsGetStatfs64(StrPas(path),buf) then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=ENOENT;
   Exit;
  end;

 Result:=0;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls statfs64 (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function fstatfs64(fd: int; buf: Pstatfs64): int; cdecl;
{Get filesystem statistics}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Path:String;
 Entry:PSyscallsEntry;
begin
 {}
 Result:=-1;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls fstatfs64 (fd=' + IntToStr(fd) + ' buf=' + PtrToHex(buf) + ')');
 {$ENDIF}

 {Check buf}
 if buf = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EFAULT;
   Exit;
  end;

 {Get Entry}
 Entry:=SyscallsGetEntry(fd);
 if (Entry <> nil) and (Entry^.Source = SYSCALLS_ENTRY_FILE) then
  begin
   {Get Path}
   Path:=FSGetFinalPathNameByHandle(Entry^.Handle,0);

   {Get Statfs64}
   if not SyscallsGetStatfs64(Path,buf) then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=ENOENT;
     Exit;
    end;

   Result:=0;
  end
 else
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EBADF;
  end;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls fstatfs64 (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{Syscalls Functions (Statvfs)}
function statvfs(path: PChar; buf: Pstatvfs): int; cdecl;
{Get file system information}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 Result:=-1;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls statvfs (path=' + StrPas(path) + ' buf=' + PtrToHex(buf) + ')');
 {$ENDIF}

 {Check buf}
 if buf = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EFAULT;
   Exit;
  end;

 {Get Statvfs}
 if not SyscallsGetStatvfs(StrPas(path),buf) then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=ENOENT;
   Exit;
  end;

 Result:=0;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls statvfs (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function fstatvfs(fd: int; buf: Pstatvfs): int; cdecl;
{Get file system information}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Path:String;
 Entry:PSyscallsEntry;
begin
 {}
 Result:=-1;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls fstatvfs (fd=' + IntToStr(fd) + ' buf=' + PtrToHex(buf) + ')');
 {$ENDIF}

 {Check buf}
 if buf = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EFAULT;
   Exit;
  end;

 {Get Entry}
 Entry:=SyscallsGetEntry(fd);
 if (Entry <> nil) and (Entry^.Source = SYSCALLS_ENTRY_FILE) then
  begin
   {Get Path}
   Path:=FSGetFinalPathNameByHandle(Entry^.Handle,0);

   {Get Statvfs}
   if not SyscallsGetStatvfs(Path,buf) then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=ENOENT;
     Exit;
    end;

   Result:=0;
  end
 else
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EBADF;
  end;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls fstatvfs (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}
{$IFDEF SYSCALLS_LARGE64_FILES}
function statvfs64(path: PChar; buf: Pstatvfs64): int; cdecl;
{Get file system information}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 Result:=-1;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls statvfs64 (path=' + StrPas(path) + ' buf=' + PtrToHex(buf) + ')');
 {$ENDIF}

 {Check buf}
 if buf = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EFAULT;
   Exit;
  end;

 {Get Statvfs64}
 if not SyscallsGetStatvfs64(StrPas(path),buf) then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=ENOENT;
   Exit;
  end;

 Result:=0;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls statvfs64 (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function fstatvfs64(fd: int; buf: Pstatvfs64): int; cdecl;
{Get file system information}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Path:String;
 Entry:PSyscallsEntry;
begin
 {}
 Result:=-1;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls fstatvfs64 (fd=' + IntToStr(fd) + ' buf=' + PtrToHex(buf) + ')');
 {$ENDIF}

 {Check buf}
 if buf = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EFAULT;
   Exit;
  end;

 {Get Entry}
 Entry:=SyscallsGetEntry(fd);
 if (Entry <> nil) and (Entry^.Source = SYSCALLS_ENTRY_FILE) then
  begin
   {Get Path}
   Path:=FSGetFinalPathNameByHandle(Entry^.Handle,0);

   {Get Statvfs64}
   if not SyscallsGetStatvfs64(Path,buf) then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=ENOENT;
     Exit;
    end;

   Result:=0;
  end
 else
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EBADF;
  end;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls fstatvfs64 (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{Syscalls Functions (Uio)}
function readv(fd: int; iov: Piovec; iovcnt: int): ssize_t; cdecl;
{Read a vector}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Ch:Char;
 Next:PChar;
 ptr:P_reent;
 iovs:Piovecs;
 Total:UInt64;
 Count:LongInt;
 Index:LongInt;
 Buffer:Pointer;
 EndChar:Boolean;
 Entry:PSyscallsEntry;
begin
 {}
 Result:=-1;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls readv (fd=' + IntToStr(fd) + ' iov=' + PtrToHex(iov) + ' iovcnt=' + IntToStr(iovcnt) + ')');
 {$ENDIF}

 if (iovcnt <= 0) or (iovcnt > IOV_MAX) then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
   Exit;
  end;

 {Get vectors}
 iovs:=Piovecs(iov);

 {Check vectors}
 if iovs = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EFAULT;
   Exit;
  end;

 {Check length}
 Total:=0;
 for Index:=0 to iovcnt - 1 do
  begin
   Total:=Total + iovs^[Index].iov_len;
  end;
 if Total > High(ssize_t) then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
   Exit;
  end;

 {Check descriptor}
 Entry:=SyscallsGetEntry(fd);
 if Entry <> nil then
  begin
   {Normal descriptor}
   if Entry^.Source = SYSCALLS_ENTRY_FILE then
    begin
     {Read Vectors}
     Total:=0;
     for Index:=0 to iovcnt - 1 do
      begin
       {Read file}
       Count:=FSFileRead(Entry^.Handle,iovs^[Index].iov_base^,iovs^[Index].iov_len);

       {Check Error}
       if Count < 0 then
        begin
         {Return Error}
         ptr:=__getreent;
         if ptr <> nil then ptr^._errno:=EIO;
         Exit;
        end;

       Total:=Total + Count;
      end;

     Result:=Total;
    end
   {$IFDEF SYSCALLS_EXPORT_SOCKETS}
   else if Entry^.Source = SYSCALLS_ENTRY_SOCKET then
    begin
     {Read Vectors}
     Total:=0;
     for Index:=0 to iovcnt - 1 do
      begin
       {Read socket}
       Count:=Sockets.fprecv(Entry^.Handle,iovs^[Index].iov_base,iovs^[Index].iov_len,0);

       {Check Error}
       if Count = SOCKET_ERROR then
        begin
         {Return Error}
         ptr:=__getreent;
         if ptr <> nil then ptr^._errno:=socket_get_error(Sockets.SocketError());
         Exit;
        end;

       Total:=Total + Count;
      end;

     Result:=Total;
    end
   {$ENDIF}
   else
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EINVAL;
    end;
  end
 else
  begin
   if fd = STDIN_FILENO then
    begin
     {Read Vectors}
     Total:=0;
     for Index:=0 to iovcnt - 1 do
      begin
       {Stdin}
       Count:=0;
       EndChar:=False;
       Next:=PChar(iovs^[Index].iov_base);
       while (Count < iovs^[Index].iov_len) and not(EndChar) do
        begin
         if TextIOReadChar(Ch,nil) then
          begin
           if Ch = #13 then EndChar:=True;

           Next^:=Ch;

           Inc(Next);
           Inc(Count);

           if EndChar and (Count < iovs^[Index].iov_len) then
            begin
             Next^:=#10;

             Inc(Next);
             Inc(Count);
            end;
          end;
        end;

       Total:=Total + Count;
      end;

     Result:=Total;
    end
   else
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EBADF;
    end;
  end;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls readv (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function writev(fd: int; iov: Piovec; iovcnt: int): ssize_t; cdecl;
{Write a vector}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 iovs:Piovecs;
 Total:UInt64;
 Count:LongInt;
 Index:LongInt;
 Entry:PSyscallsEntry;
begin
 {}
 Result:=-1;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls writev (fd=' + IntToStr(fd) + ' iov=' + PtrToHex(iov) + ' iovcnt=' + IntToStr(iovcnt) + ')');
 {$ENDIF}

 if (iovcnt <= 0) or (iovcnt > IOV_MAX) then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
   Exit;
  end;

 {Get vectors}
 iovs:=Piovecs(iov);

 {Check vectors}
 if iovs = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EFAULT;
   Exit;
  end;

 {Check length}
 Total:=0;
 for Index:=0 to iovcnt - 1 do
  begin
   Total:=Total + iovs^[Index].iov_len;
  end;
 if Total > High(ssize_t) then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
   Exit;
  end;

 {Check descriptor}
 Entry:=SyscallsGetEntry(fd);
 if Entry <> nil then
  begin
   {Normal descriptor}
   if Entry^.Source = SYSCALLS_ENTRY_FILE then
    begin
     {Write Vectors}
     Total:=0;
     for Index:=0 to iovcnt - 1 do
      begin
       {Write file}
       Count:=FSFileWrite(Entry^.Handle,iovs^[Index].iov_base^,iovs^[Index].iov_len);

       {Check Error}
       if Count < 0 then
        begin
         {Return Error}
         ptr:=__getreent;
         if ptr <> nil then ptr^._errno:=EIO;
         Exit;
        end;

       Total:=Total + Count;
      end;

     Result:=Total;
    end
   {$IFDEF SYSCALLS_EXPORT_SOCKETS}
   else if Entry^.Source = SYSCALLS_ENTRY_SOCKET then
    begin
     {Write Vectors}
     Total:=0;
     for Index:=0 to iovcnt - 1 do
      begin
       {Write socket}
       Count:=Sockets.fpsend(Entry^.Handle,iovs^[Index].iov_base,iovs^[Index].iov_len,0);

       {Check Error}
       if Result = SOCKET_ERROR then
        begin
         {Return Error}
         ptr:=__getreent;
         if ptr <> nil then ptr^._errno:=socket_get_error(Sockets.SocketError());
         Exit;
        end;

       Total:=Total + Count;
      end;

     Result:=Total;
    end
   {$ENDIF}
   else
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EINVAL;
    end;
  end
 else
  begin
   if (fd = STDOUT_FILENO) or (fd = STDERR_FILENO) then
    begin
     {Write Vectors}
     Total:=0;
     for Index:=0 to iovcnt - 1 do
      begin
       {Stdout or Stderr}
       Count:=TextIOWriteBuffer(PChar(iovs^[Index].iov_base),iovs^[Index].iov_len,nil);

       Total:=Total + Count;

       if Count < iovs^[Index].iov_len then Break;
      end;

     Result:=Total;
    end
   else
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EBADF;
    end;
  end;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls writev (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}
{==============================================================================}
{Syscalls Functions (Pwd)}
function getpwuid(uid: uid_t): Ppasswd; cdecl;
{Search user database for a user ID}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls getpwuid (uid=' + IntToStr(uid) + ')');
 {$ENDIF}

 Result:=nil;
end;

{==============================================================================}
{==============================================================================}
{Syscalls Functions (Grp)}
function getgrgid(gid: gid_t): Pgroup; cdecl;
{Get group database entry for a group ID}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls getgrgid (gid=' + IntToStr(gid) + ')');
 {$ENDIF}

 Result:=nil;
end;

{==============================================================================}
{==============================================================================}
{Syscalls Functions (Sched)}
function sched_yield: int; cdecl;
{Yield the processor}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=-1;

 if ThreadYield = ERROR_SUCCESS then Result:=0;
end;

{==============================================================================}

function sched_getcpu: int; cdecl;
{Determine CPU on which the calling thread is}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=CPUGetCurrent;
end;

{==============================================================================}

function sched_getaffinity(pid: pid_t; cpusetsize: size_t; mask: Pcpu_set_t): int; cdecl;
{Get the CPU affinity mask of a process or thread}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls sched_getaffinity (pid=' + IntToHex(pid,8) + ' cpusetsize=' + IntToStr(cpusetsize) + ' mask' IntToHex(mask,8) + ')');
 {$ENDIF}

 {Check size}
 if cpusetsize <> SizeOf(cpu_set_t) then
  begin
   {Return Error}
   Result:=-1;
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
   Exit;
  end;

 {Check mask}
 if mask = nil then
  begin
   {Return Error}
   Result:=-1;
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
   Exit;
  end;

 {Check pid}
 if pid = 0 then
  begin
   {Get Affinity}
   mask^.__bits[0]:=ThreadGetAffinity(ThreadGetCurrent);
  end
 else
  begin
   {Get Affinity}
   mask^.__bits[0]:=ThreadGetAffinity(pid);
   if mask^.__bits[0] = INVALID_HANDLE_VALUE then
    begin
     Result:=-1;
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=ESRCH;
     Exit;
    end;
  end;

 Result:=0;
end;

{==============================================================================}

function sched_setaffinity(pid: pid_t; cpusetsize: size_t; mask: Pcpu_set_t): int; cdecl;
{Set the CPU affinity mask of a process or thread}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls sched_setaffinity (pid=' + IntToHex(pid,8) + ' cpusetsize=' + IntToStr(cpusetsize) + ' mask' IntToHex(mask,8) + ')');
 {$ENDIF}

 {Check size}
 if cpusetsize <> SizeOf(cpu_set_t) then
  begin
   {Return Error}
   Result:=-1;
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
   Exit;
  end;

 {Check mask}
 if mask = nil then
  begin
   {Return Error}
   Result:=-1;
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
   Exit;
  end;

 {Check pid}
 if pid = 0 then
  begin
   {Set Affinity}
   if ThreadSetAffinity(ThreadGetCurrent,mask^.__bits[0]) = INVALID_HANDLE_VALUE then
    begin
     {Return Error}
     Result:=-1;
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EINVAL;
     Exit;
    end;
  end
 else
  begin
   {Set Affinity}
   if ThreadSetAffinity(pid,mask^.__bits[0]) = INVALID_HANDLE_VALUE then
    begin
     Result:=-1;
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=ESRCH;
     Exit;
    end;
  end;

 Result:=0;
end;

{==============================================================================}

function sched_get_priority_max(policy: int): int; cdecl;
{Get scheduler priority range maximum}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls sched_get_priority_max (policy=' + IntToHex(policy,8) + ')');
 {$ENDIF}

 {Check policy}
 if (policy < SCHED_OTHER) or (policy > SCHED_RR) then
  begin
   {Return Error}
   Result:=-1;
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
   Exit;
  end;

 Result:=THREAD_PRIORITY_CRITICAL;
end;

{==============================================================================}

function sched_get_priority_min(policy: int): int; cdecl;
{Get scheduler priority range minimum}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls sched_get_priority_min (policy=' + IntToHex(policy,8) + ')');
 {$ENDIF}

 {Check policy}
 if (policy < SCHED_OTHER) or (policy > SCHED_RR) then
  begin
   {Return Error}
   Result:=-1;
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
   Exit;
  end;

 Result:=THREAD_PRIORITY_IDLE;
end;

{==============================================================================}
{==============================================================================}
{Syscalls Functions (Dirent)}
function opendir(name: PChar): PDIR; cdecl;
{Open a directory}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Path:String;
 Buffer:PDIR;
 NameBuffer:PChar;
 SearchRec:PFileSearchRec;
begin
 {}
 Result:=nil;

 {Check name}
 if name = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
   Exit;
  end;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls opendir (name=' + StrPas(name) + ')');
 {$ENDIF}

 {Get name}
 Path:=StrPas(name);

 {Check Path}
 if Length(Path) = 0 then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=ENOENT;
   Exit;
  end;
 if FSFileExists(Path) then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=ENOTDIR;
   Exit;
  end;
 if not FSDirectoryExists(Path) then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=ENOENT;
   Exit;
  end;

 {Allocate Buffer}
 Buffer:=AllocMem(SizeOf(DIR) + SizeOf(Tdirent){$IFDEF SYSCALLS_LARGE64_FILES} + SizeOf(Tdirent64){$ENDIF} + ((Length(Path) + 1) * SizeOf(Char)));
 if Buffer = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=ENOMEM;
   Exit;
  end;

 {Allocate Search Record}
 SearchRec:=AllocMem(SizeOf(TFileSearchRec));
 if SearchRec = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=ENOMEM;
   Exit;
  end;

 {Save Path}
 NameBuffer:=PChar(PtrUInt(Buffer) + SizeOf(DIR) + SizeOf(Tdirent){$IFDEF SYSCALLS_LARGE64_FILES} + SizeOf(Tdirent64){$ENDIF});
 StrLCopy(NameBuffer,PChar(Path),Length(Path));

 {Check Path}
 Path:=FSAddSlash(Path,False,True);

 {Find First File}
 if FSFindFirstEx(Path + '*.*',SearchRec^) <> 0 then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=ENOENT;

   {Close Find}
   FSFindCloseEx(SearchRec^);

   {Free Search Record}
   FreeMem(SearchRec);

   {Free Buffer}
   FreeMem(Buffer);
   Exit;
  end;

 {Update Buffer}
 Buffer^.dd_loc:=-1;
 Buffer^.dd_buf:=PByte(SearchRec);

 {Return Buffer}
 Result:=Buffer;
end;

{==============================================================================}

function readdir(dirp: PDIR): Pdirent; cdecl;
{Read a directory}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 dirent:Pdirent;
 SearchRec:PFileSearchRec;
begin
 {}
 Result:=nil;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls readdir (dirp=' + PtrToHex(dirp) + ')');
 {$ENDIF}

 {Check dirp}
 if dirp = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EBADF;
   Exit;
  end;

 {Get Search Record}
 SearchRec:=PFileSearchRec(dirp^.dd_buf);
 if SearchRec = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EBADF;
   Exit;
  end;

 {Check Location}
 if dirp^.dd_loc = -1 then
  begin
   {Get First File}
   dirp^.dd_loc:=0;
  end
 else
  begin
   {Find Next File}
   if FSFindNextEx(SearchRec^) <> 0 then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=ENOENT;
     Exit;
    end;

   Inc(dirp^.dd_loc);
  end;

 {Update dirent}
 dirent:=Pdirent(PtrUInt(dirp) + SizeOf(DIR));
 dirent^.d_ino:=1;
 dirent^.d_off:=dirp^.dd_loc;
 dirent^.d_reclen:=SizeOf(Tdirent);
 if (SearchRec^.FindData.dwFileAttributes and faDirectory) = faDirectory then
  begin
   dirent^.d_type:=DT_DIR;
  end
 else
  begin
   dirent^.d_type:=DT_REG;
  end;
 StrLCopy(dirent^.d_name,SearchRec^.FindData.cFileName,NAME_MAX);

 {Return dirent}
 Result:=dirent;
end;

{==============================================================================}

function readdir_r(dirp: PDIR; entry: Pdirent; _result: PPdirent): int; cdecl;
{Read a directory}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 SearchRec:PFileSearchRec;
begin
 {}
 Result:=EBADF;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls readdir_r (dirp=' + PtrToHex(dirp) + ' entry=' + PtrToHex(entry) + ' _result=' + PtrToHex(_result) + ')');
 {$ENDIF}

 {Check dirp}
 if dirp = nil then Exit;

 {Check entry}
 if entry = nil then Exit;

 {Check _result}
 if _result = nil then Exit;

 {Clear _result}
 _result^:=nil;

 {Get Search Record}
 SearchRec:=PFileSearchRec(dirp^.dd_buf);
 if SearchRec = nil then Exit;

 {Check Location}
 if dirp^.dd_loc = -1 then
  begin
   {Get First File}
   dirp^.dd_loc:=0;
  end
 else
  begin
   {Find Next File}
   if FSFindNextEx(SearchRec^) <> 0 then
    begin
     {Return Error}
     Result:=ENOENT;
     Exit;
    end;

   Inc(dirp^.dd_loc);
  end;

 {Update entry}
 entry^.d_ino:=1;
 entry^.d_off:=dirp^.dd_loc;
 entry^.d_reclen:=SizeOf(Tdirent);
 if (SearchRec^.FindData.dwFileAttributes and faDirectory) = faDirectory then
  begin
   entry^.d_type:=DT_DIR;
  end
 else
  begin
   entry^.d_type:=DT_REG;
  end;
 StrLCopy(entry^.d_name,SearchRec^.FindData.cFileName,NAME_MAX);

 {Update _result}
 _result^:=@entry;

 {Return success}
 Result:=0;
end;

{==============================================================================}

function closedir(dirp: PDIR): int; cdecl;
{Close a directory}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 SearchRec:PFileSearchRec;
begin
 {}
 Result:=-1;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls closedir (dirp=' + PtrToHex(dirp) + ')');
 {$ENDIF}

 {Check dirp}
 if dirp = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EBADF;
   Exit;
  end;

 {Get Search Record}
 SearchRec:=PFileSearchRec(dirp^.dd_buf);
 if SearchRec = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EBADF;
   Exit;
  end;

 {Close Find}
 FSFindCloseEx(SearchRec^);

 {Free Search Record}
 FreeMem(SearchRec);

 {Free Buffer}
 FreeMem(dirp);

 {Return success}
 Result:=0;
end;

{==============================================================================}
{$IFDEF SYSCALLS_LARGE64_FILES}
function readdir64(dirp: PDIR): Pdirent64; cdecl;
{Read a directory}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 dirent:Pdirent64;
 SearchRec:PFileSearchRec;
begin
 {}
 Result:=nil;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls readdir64 (dirp=' + PtrToHex(dirp) + ')');
 {$ENDIF}

 {Check dirp}
 if dirp = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EBADF;
   Exit;
  end;

 {Get Search Record}
 SearchRec:=PFileSearchRec(dirp^.dd_buf);
 if SearchRec = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EBADF;
   Exit;
  end;

 {Check Location}
 if dirp^.dd_loc = -1 then
  begin
   {Get First File}
   dirp^.dd_loc:=0;
  end
 else
  begin
   {Find Next File}
   if FSFindNextEx(SearchRec^) <> 0 then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=ENOENT;
     Exit;
    end;

   Inc(dirp^.dd_loc);
  end;

 {Update dirent}
 dirent:=Pdirent64(PtrUInt(dirp) + SizeOf(DIR) + SizeOf(Tdirent));
 dirent^.d_ino:=1;
 dirent^.d_off:=dirp^.dd_loc;
 dirent^.d_reclen:=SizeOf(Tdirent64);
 if (SearchRec^.FindData.dwFileAttributes and faDirectory) = faDirectory then
  begin
   dirent^.d_type:=DT_DIR;
  end
 else
  begin
   dirent^.d_type:=DT_REG;
  end;
 StrLCopy(dirent^.d_name,SearchRec^.FindData.cFileName,NAME_MAX);

 {Return dirent}
 Result:=dirent;
end;

{==============================================================================}

function readdir64_r(dirp: PDIR; entry: Pdirent64; _result: PPdirent64): int; cdecl;
{Read a directory}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 SearchRec:PFileSearchRec;
begin
 {}
 Result:=EBADF;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls readdir64_r (dirp=' + PtrToHex(dirp) + ' entry=' + PtrToHex(entry) + ' _result=' + PtrToHex(_result) + ')');
 {$ENDIF}

 {Check dirp}
 if dirp = nil then Exit;

 {Check entry}
 if entry = nil then Exit;

 {Check _result}
 if _result = nil then Exit;

 {Clear _result}
 _result^:=nil;

 {Get Search Record}
 SearchRec:=PFileSearchRec(dirp^.dd_buf);
 if SearchRec = nil then Exit;

 {Check Location}
 if dirp^.dd_loc = -1 then
  begin
   {Get First File}
   dirp^.dd_loc:=0;
  end
 else
  begin
   {Find Next File}
   if FSFindNextEx(SearchRec^) <> 0 then
    begin
     {Return Error}
     Result:=ENOENT;
     Exit;
    end;

   Inc(dirp^.dd_loc);
  end;

 {Update entry}
 entry^.d_ino:=1;
 entry^.d_off:=dirp^.dd_loc;
 entry^.d_reclen:=SizeOf(Tdirent64);
 if (SearchRec^.FindData.dwFileAttributes and faDirectory) = faDirectory then
  begin
   entry^.d_type:=DT_DIR;
  end
 else
  begin
   entry^.d_type:=DT_REG;
  end;
 StrLCopy(entry^.d_name,SearchRec^.FindData.cFileName,NAME_MAX);

 {Update _result}
 _result^:=@entry;

 {Return success}
 Result:=0;
end;
{$ENDIF}
{==============================================================================}

procedure seekdir(dirp: PDIR; loc: long); cdecl;
{Set the position of the next readdir call in the directory stream}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Path:String;
 NameBuffer:PChar;
 SearchRec:PFileSearchRec;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls seekdir (dirp=' + PtrToHex(dirp) + ')');
 {$ENDIF}

 {Check dirp}
 if dirp = nil then Exit;

 {Get Search Record}
 SearchRec:=PFileSearchRec(dirp^.dd_buf);
 if SearchRec = nil then Exit;

 {Close Find}
 FSFindCloseEx(SearchRec^);

 {Reset Buffer}
 dirp^.dd_loc:=-1;

 {Get Path}
 NameBuffer:=PChar(PtrUInt(dirp) + SizeOf(DIR) + SizeOf(Tdirent){$IFDEF SYSCALLS_LARGE64_FILES} + SizeOf(Tdirent64){$ENDIF});
 Path:=StrPas(NameBuffer);

 {Check Path}
 Path:=FSAddSlash(Path,False,True);

 {Find First File}
 if FSFindFirstEx(Path + '*.*',SearchRec^) <> 0 then Exit;

 {Find location}
 while dirp^.dd_loc + 1 < loc do
  begin
   if FSFindNextEx(SearchRec^) <> 0 then Exit;

   Inc(dirp^.dd_loc);
  end;
end;

{==============================================================================}

procedure rewinddir(dirp: PDIR); cdecl;
{Reset directory stream}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls rewinddir (dirp=' + PtrToHex(dirp) + ')');
 {$ENDIF}

 {Seek to location zero}
 seekdir(dirp,0);
end;

{==============================================================================}

function telldir(dirp: PDIR): long; cdecl;
{Return current location in directory stream}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 Result:=-1;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls telldir (dirp=' + PtrToHex(dirp) + ')');
 {$ENDIF}

 {Check dirp}
 if dirp = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EBADF;
   Exit;
  end;

 {Get location}
 if dirp^.dd_loc = -1 then
  begin
   Result:=0;
  end
 else
  begin
   Result:=dirp^.dd_loc;
  end;
end;

{==============================================================================}
{==============================================================================}
{Syscalls Functions (Pthread)}
function pthread_attr_init(attr: Ppthread_attr_t): int; cdecl;
{Initialize a thread attributes entry}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check attr}
 if attr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_attr_init (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}

 {Init attr}
 attr^.is_initialized:=1;
 attr^.stackaddr:=nil;
 attr^.stacksize:=THREAD_STACK_DEFAULT_SIZE;
 attr^.contentionscope:=PTHREAD_SCOPE_SYSTEM;
 attr^.inheritsched:=PTHREAD_EXPLICIT_SCHED;
 attr^.schedpolicy:=SCHED_OTHER;
 attr^.schedparam.sched_priority:=THREAD_PRIORITY_DEFAULT;
 {$IFDEF _POSIX_THREAD_GUARDSIZE}
 attr^.guardsize:=MEMORY_PAGE_SIZE;
 {$ENDIF}
 {$IFDEF _POSIX_THREAD_CPUTIME}
 attr^.cputime_clock_allowed:=0;
 {$ENDIF}
 attr^.detachstate:=PTHREAD_CREATE_JOINABLE;

 Result:=0;
end;

{==============================================================================}

function pthread_attr_destroy(attr: Ppthread_attr_t): int; cdecl;
{Destroy a thread attributes entry}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check attr}
 if attr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_attr_destroy (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}

 {Destroy attr}
 attr^.is_initialized:=0;

 Result:=0;
end;

{==============================================================================}

function pthread_attr_getdetachstate(attr: Ppthread_attr_t; detachstate: Pint): int; cdecl;
{Get the detachstate attribute}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check attr}
 if attr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_attr_getdetachstate (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}

 {Check detachstate}
 if detachstate = nil then Exit;

 {Get detachstate}
 detachstate^:=attr^.detachstate;

 Result:=0;
end;

{==============================================================================}

function pthread_attr_setdetachstate(attr: Ppthread_attr_t; detachstate: int): int; cdecl;
{Set the detachstate attribute}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check attr}
 if attr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_attr_setdetachstate (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}

 {Check detachstate}
 if (detachstate < PTHREAD_CREATE_JOINABLE) or (detachstate > PTHREAD_CREATE_DETACHED) then Exit;

 {Set detachstate}
 attr^.detachstate:=detachstate;

 Result:=0;
end;

{==============================================================================}

function pthread_attr_getguardsize(attr: Ppthread_attr_t; guardsize: Psize_t): int; cdecl;
{Get the guardsize attribute}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check attr}
 if attr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_attr_getguardsize (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}

 {$IFDEF _POSIX_THREAD_GUARDSIZE}
 {Check guardsize}
 if guardsize = nil then Exit;

 {Get guardsize}
 guardsize^:=attr^.guardsize;

 Result:=0;
 {$ELSE}
 {Not supported}
 Result:=ENOSYS;
 {$ENDIF}
end;

{==============================================================================}

function pthread_attr_setguardsize(attr: Ppthread_attr_t; guardsize: size_t): int; cdecl;
{Set the guardsize attribute}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check attr}
 if attr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_attr_setguardsize (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}

 {$IFDEF _POSIX_THREAD_GUARDSIZE}
 {Check guardsize}
 if (guardsize > attr^.stacksize) then Exit;

 {Set guardsize}
 attr^.guardsize:=guardsize;

 Result:=0;
 {$ELSE}
 {Not supported}
 Result:=ENOSYS;
 {$ENDIF}
end;

{==============================================================================}

function pthread_attr_getinheritsched(attr: Ppthread_attr_t; inheritsched: Pint): int; cdecl;
{Get the inheritsched attribute}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check attr}
 if attr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_attr_getinheritsched (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}

 {Check inheritsched}
 if inheritsched = nil then Exit;

 {Get inheritsched}
 inheritsched^:=attr^.inheritsched;

 Result:=0;
end;

{==============================================================================}

function pthread_attr_setinheritsched(attr: Ppthread_attr_t; inheritsched: int): int; cdecl;
{Set the inheritsched attribute}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check attr}
 if attr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_attr_setinheritsched (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}

 {Check inheritsched}
 if (inheritsched <> PTHREAD_INHERIT_SCHED) and (inheritsched <> PTHREAD_EXPLICIT_SCHED) then Exit;

 {Set inheritsched}
 attr^.inheritsched:=inheritsched;

 Result:=0;
end;

{==============================================================================}

function pthread_attr_getschedparam(attr: Ppthread_attr_t; param: Psched_param): int; cdecl;
{Get the scheduler param attribute}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check attr}
 if attr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_attr_getschedparam (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}

 {Check param}
 if param = nil then Exit;

 {Get param}
 System.Move(attr^.schedparam,param^,SizeOf(Tsched_param));

 Result:=0;
end;

{==============================================================================}

function pthread_attr_setschedparam(attr: Ppthread_attr_t; param: Psched_param): int; cdecl;
{Set the scheduler param attribute}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 MaxPriority:int;
 MinPriority:int;
begin
 {}
 Result:=EINVAL;

 {Check attr}
 if attr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_attr_setschedparam (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}

 {Check param}
 if param = nil then Exit;

 {Get Min/Max}
 MaxPriority:=sched_get_priority_max(attr^.schedpolicy);
 MinPriority:=sched_get_priority_min(attr^.schedpolicy);

 {Check Priority}
 if (param^.sched_priority < MinPriority) or (param^.sched_priority > MaxPriority) then Exit;

 {Set param}
 System.Move(param^,attr^.schedparam,SizeOf(Tsched_param));

 Result:=0;
end;

{==============================================================================}

function pthread_attr_getschedpolicy(attr: Ppthread_attr_t; policy: Pint): int; cdecl;
{Get the scheduler policy attribute}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check attr}
 if attr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_attr_getschedpolicy (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}

 {Check policy}
 if policy = nil then Exit;

 {Get policy}
 policy^:=attr^.schedpolicy;

 Result:=0;
end;

{==============================================================================}

function pthread_attr_setschedpolicy(attr: Ppthread_attr_t; policy: int): int; cdecl;
{Set the scheduler policy attribute}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check attr}
 if attr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_attr_setschedpolicy (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}

 {Check policy}
 if (policy < SCHED_OTHER) or (policy > SCHED_RR) then Exit;

 {Set policy}
 attr^.schedpolicy:=policy;

 Result:=0;
end;

{==============================================================================}

function pthread_attr_getscope(attr: Ppthread_attr_t; contentionscope: Pint): int; cdecl;
{Get the contentionscope attribute}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check attr}
 if attr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_attr_getscope (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}

 {Check contentionscope}
 if contentionscope = nil then Exit;

 {Get contentionscope}
 contentionscope^:=attr^.contentionscope;

 Result:=0;
end;

{==============================================================================}

function pthread_attr_setscope(attr: Ppthread_attr_t; contentionscope: int): int; cdecl;
{Set the contentionscope attribute}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check attr}
 if attr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_attr_setscope (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}

 {Check contentionscope}
 case contentionscope of
  PTHREAD_SCOPE_SYSTEM:begin
    {Set contentionscope}
    attr^.contentionscope:=contentionscope;

    Result:=0;
   end;
  PTHREAD_SCOPE_PROCESS:begin
    Result:=ENOTSUP;
   end;
 end;
end;

{==============================================================================}

function pthread_attr_getstackaddr(attr: Ppthread_attr_t; stackaddr: PPointer): int; cdecl;
{Get the stackaddr attribute}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check attr}
 if attr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_attr_getstackaddr (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}

 {Check stackaddr}
 if stackaddr = nil then Exit;

 {Get stackaddr}
 stackaddr^:=attr^.stackaddr;

 Result:=0;
end;

{==============================================================================}

function pthread_attr_setstackaddr(attr: Ppthread_attr_t; stackaddr: Pointer): int; cdecl;
{Set the stackaddr attribute}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check attr}
 if attr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_attr_setstackaddr (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}

 {Set stackaddr}
 attr^.stackaddr:=stackaddr;

 Result:=0;
end;

{==============================================================================}

function pthread_attr_getstacksize(attr: Ppthread_attr_t; stacksize: Psize_t): int; cdecl;
{Get the stacksize attribute}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check attr}
 if attr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_attr_getstacksize (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}

 {Check stacksize}
 if stacksize = nil then Exit;

 {Get stacksize}
 stacksize^:=attr^.stacksize;

 Result:=0;
end;

{==============================================================================}

function pthread_attr_setstacksize(attr: Ppthread_attr_t; stacksize: size_t): int; cdecl;
{Set the stacksize attribute}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check attr}
 if attr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_attr_setstacksize (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}

 {Check stacksize}
 if stacksize < THREAD_STACK_MINIMUM_SIZE then Exit; {Note this should be PTHREAD_STACK_MIN but that is too small}
 if stacksize > THREAD_STACK_MAXIMUM_SIZE then Exit;

 {Set stacksize}
 attr^.stacksize:=stacksize;

 Result:=0;
end;

{==============================================================================}

procedure pthread_cleanup_push(routine: Tpthread_cleanup_routine; arg: Pointer); cdecl;
{Push thread cancellation clean-up handlers}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Pthread:PSyscallsPthread;
 Cleanup:PSyscallsPthreadCleanup;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_cleanup_push (routine=' + PtrToHex(routine) + ' arg=' + PtrToHex(arg) + ')');
 {$ENDIF}

 {Get Pthread}
 Pthread:=SyscallsGetPthread;
 if Pthread = nil then Exit;

 {Allocate Cleanup}
 Cleanup:=GetMem(SizeOf(TSyscallsPthreadCleanup));
 if Cleanup = nil then Exit;

 {Install Cleanup}
 Cleanup^.Routine:=routine;
 Cleanup^.Arg:=arg;
 Cleanup^.Next:=Pthread^.Cleanup;
 Pthread^.Cleanup:=Cleanup;
end;

{==============================================================================}

procedure pthread_cleanup_pop(execute: int); cdecl;
{Pop thread cancellation clean-up handlers}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Pthread:PSyscallsPthread;
 Cleanup:PSyscallsPthreadCleanup;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_cleanup_pop (execute=' + IntToStr(execute) + ')');
 {$ENDIF}

 {Get Pthread}
 Pthread:=SyscallsGetPthread;
 if Pthread = nil then Exit;

 {Get Cleanup}
 Cleanup:=Pthread^.Cleanup;
 if Cleanup <> nil then
  begin
   {Check Execute and Routine}
   if (execute <> 0) and Assigned(Cleanup^.Routine) then
    begin
     {Call Routine}
     Cleanup^.Routine(Cleanup^.Arg);
    end;

   {Remove Cleanup}
   Pthread^.Cleanup:=Cleanup^.Next;

   {Free Cleanup}
   FreeMem(Cleanup);
  end;
end;

{==============================================================================}

function pthread_cond_init(cond: Ppthread_cond_t; attr: Ppthread_condattr_t): int; cdecl;
{Initialize a condition variable}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Handle:TConditionHandle;
begin
 {}
 Result:=EINVAL;

 {Check cond}
 if cond = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_cond_init (cond=' + PtrToHex(cond) + ')');
 {$ENDIF}

 Result:=EAGAIN;

 {Note: attr not used}

 {Create Condition}
 Handle:=ConditionCreate;
 if Handle = INVALID_HANDLE_VALUE then Exit;

 {Return cond}
 cond^:=Handle;

 Result:=0;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_cond_init (Result=' + IntToStr(Result) + ' cond=' + PtrToHex(cond) + ')');
 {$ENDIF}
end;

{==============================================================================}

function pthread_cond_checkinit(cond: Ppthread_cond_t; attr: Ppthread_condattr_t{$IFDEF SYSCALLS_WARN_UNINITIALIZED}; caller: String{$ENDIF}): int; cdecl;
{Check initialization of a condition variable}

{Note: Internal function, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check cond}
 if cond = nil then Exit;

 {Check cond}
 if cond^ = PTHREAD_COND_INITIALIZER then
  begin
   if MutexLock(SyscallsPthreadLock) <> ERROR_SUCCESS then Exit;
   try
    {Recheck cond (Must be after lock)}
    if cond^ = PTHREAD_COND_INITIALIZER then
     begin
      {Initialize cond}
      Result:=pthread_cond_init(cond,attr);
      if Result <> 0 then Exit;
     end;
   finally
    MutexUnlock(SyscallsPthreadLock);
   end;
  end;

 {Check cond}
 if cond^ = 0 then
  begin
   if MutexLock(SyscallsPthreadLock) <> ERROR_SUCCESS then Exit;
   try
    {Recheck cond (Must be after lock)}
    if cond^ = 0 then
     begin
      {$IFDEF SYSCALLS_WARN_UNINITIALIZED}
      {Uninitialized cond}
      if PLATFORM_LOG_ENABLED then PlatformLogWarn('Uninitialized condition in call to ' + caller);
      {$ENDIF}

      {$IFDEF SYSCALLS_CREATE_UNINITIALIZED}
      {Initialize cond}
      Result:=pthread_cond_init(cond,attr);
      if Result <> 0 then Exit;
      {$ENDIF}
     end;
   finally
    MutexUnlock(SyscallsPthreadLock);
   end;
  end;

 Result:=0;
end;

{==============================================================================}

function pthread_cond_destroy(cond: Ppthread_cond_t): int; cdecl;
{Destroy a condition variable}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check cond}
 if cond = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_cond_destroy (cond=' + PtrToHex(cond) + ')');
 {$ENDIF}

 {Destroy Condition}
 if ConditionDestroy(TConditionHandle(cond^)) <> ERROR_SUCCESS then Exit;

 {Invalidate cond}
 cond^:=0; {Not INVALID_HANDLE_VALUE to allow detection of PTHREAD_COND_INITIALIZER}

 Result:=0;
end;

{==============================================================================}

function pthread_cond_broadcast(cond: Ppthread_cond_t): int; cdecl;
{Broadcast (Signal all) a condition variable}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check cond}
 if cond = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_cond_broadcast (cond=' + PtrToHex(cond) + ')');
 {$ENDIF}

 {Check cond}
 Result:=pthread_cond_checkinit(cond,nil{$IFDEF SYSCALLS_WARN_UNINITIALIZED},'pthread_cond_broadcast'{$ENDIF});
 if Result <> 0 then Exit;

 {Wake All Condition}
 if ConditionWakeAll(TConditionHandle(cond^)) <> ERROR_SUCCESS then Exit;

 Result:=0;
end;

{==============================================================================}

function pthread_cond_signal(cond: Ppthread_cond_t): int; cdecl;
{Signal a condition variable}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check cond}
 if cond = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_cond_signal (cond=' + PtrToHex(cond) + ')');
 {$ENDIF}

 {Check cond}
 Result:=pthread_cond_checkinit(cond,nil{$IFDEF SYSCALLS_WARN_UNINITIALIZED},'pthread_cond_signal'{$ENDIF});
 if Result <> 0 then Exit;

 {Wake Condition}
 if ConditionWake(TConditionHandle(cond^)) <> ERROR_SUCCESS then Exit;

 Result:=0;
end;

{==============================================================================}

function pthread_cond_wait(cond: Ppthread_cond_t; mutex: Ppthread_mutex_t): int; cdecl;
{Wait on a condition variable}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Flags:LongWord;
 ResultCode:LongWord;
begin
 {}
 Result:=EINVAL;

 {Check cond}
 if cond = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_cond_wait (cond=' + PtrToHex(cond) + ' mutex=' + PtrToHex(mutex) + ')');
 {$ENDIF}

 {Check cond}
 Result:=pthread_cond_checkinit(cond,nil{$IFDEF SYSCALLS_WARN_UNINITIALIZED},'pthread_cond_wait'{$ENDIF});
 if Result <> 0 then Exit;

 {Wait Condition Mutex}
 ResultCode:=ConditionWaitMutex(TConditionHandle(cond^),TMutexHandle(mutex^),INFINITE);
 if ResultCode = ERROR_SUCCESS then
  begin
   Result:=0;
  end
 else if ResultCode = ERROR_WAIT_TIMEOUT then
  begin
   Result:=ETIMEDOUT;
  end;

 {Check Cancellation}
 Flags:=ThreadGetFlags(ThreadGetCurrent);
 if (Flags and (THREAD_FLAG_CANCELLED or THREAD_FLAG_CANCEL_DISABLE)) = (THREAD_FLAG_CANCELLED) then
  begin
   SyscallsPthreadEnd(PTHREAD_CANCELED);
  end;
end;

{==============================================================================}

function pthread_cond_timedwait(cond: Ppthread_cond_t; mutex: Ppthread_mutex_t; abstime: Ptimespec): int; cdecl;
{Wait on a condition variable with timeout}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Flags:LongWord;
 Timeout:LongWord;
 Current:Ttimespec;
 Relative:Ttimespec;
 ResultCode:LongWord;
begin
 {}
 Result:=EINVAL;

 {Check cond}
 if cond = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_cond_timedwait (cond=' + PtrToHex(cond) + ' mutex=' + PtrToHex(mutex) + ')');
 {$ENDIF}

 {Check mutex}
 if mutex = nil then Exit;

 {Check abstime}
 if abstime = nil then Exit;

 {Get Timeout}
 Timeout:=INFINITE;
 if clock_gettime(CLOCK_REALTIME,@Current) = 0 then
  begin
   Relative.tv_nsec:=abstime^.tv_nsec - Current.tv_nsec;
   Relative.tv_sec:=abstime^.tv_sec - Current.tv_sec;
   if Relative.tv_nsec < 0 then
    begin
     Relative.tv_nsec:=Relative.tv_nsec + 1000000000;
     Relative.tv_sec:=Relative.tv_sec - 1;
    end;

   if Relative.tv_sec < 0 then Exit;

   Timeout:=(Relative.tv_sec * 1000) + (Relative.tv_nsec div 1000000);
  end;

 {Check cond}
 Result:=pthread_cond_checkinit(cond,nil{$IFDEF SYSCALLS_WARN_UNINITIALIZED},'pthread_cond_timedwait'{$ENDIF});
 if Result <> 0 then Exit;

 {Wait Condition Mutex}
 ResultCode:=ConditionWaitMutex(TConditionHandle(cond^),TMutexHandle(mutex^),Timeout);
 if ResultCode = ERROR_SUCCESS then
  begin
   Result:=0;
  end
 else if ResultCode = ERROR_WAIT_TIMEOUT then
  begin
   Result:=ETIMEDOUT;
  end;

 {Check Cancellation}
 Flags:=ThreadGetFlags(ThreadGetCurrent);
 if (Flags and (THREAD_FLAG_CANCELLED or THREAD_FLAG_CANCEL_DISABLE)) = (THREAD_FLAG_CANCELLED) then
  begin
   SyscallsPthreadEnd(PTHREAD_CANCELED);
  end;
end;

{==============================================================================}

function pthread_condattr_init(attr: Ppthread_condattr_t): int; cdecl;
{Initialize a condition variable attributes entry}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check attr}
 if attr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_condattr_init (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}

 {Init attr}
 attr^.is_initialized:=1;
 attr^.clock:=0;
 {$IFDEF _POSIX_THREAD_PROCESS_SHARED}
 attr^.process_shared:=PTHREAD_PROCESS_PRIVATE;
 {$ENDIF}

 Result:=0;
end;

{==============================================================================}

function pthread_condattr_destroy(attr: Ppthread_condattr_t): int; cdecl;
{Destroy a condition variable attributes entry}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check attr}
 if attr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_condattr_destroy (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}

 {Destroy attr}
 attr^.is_initialized:=0;

 Result:=0;
end;

{==============================================================================}

function pthread_condattr_getpshared(attr: Ppthread_condattr_t; pshared: Pint): int; cdecl;
{Get the process-shared condition variable attribute}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check attr}
 if attr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_condattr_getpshared (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}

 {Check pshared}
 if pshared = nil then Exit;

 {$IFDEF _POSIX_THREAD_PROCESS_SHARED}
 {Get pshared}
 pshared^:=attr^.process_shared;

 Result:=0;
 {$ELSE}

 Result:=ENOSYS;
 {$ENDIF}
end;

{==============================================================================}

function pthread_condattr_setpshared(attr: Ppthread_condattr_t; pshared: int): int; cdecl;
{Set the process-shared condition variable attribute}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check attr}
 if attr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_condattr_setpshared (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}

 {Check pshared}
 if (pshared <> PTHREAD_PROCESS_PRIVATE) and (pshared <> PTHREAD_PROCESS_SHARED) then Exit;

 {$IFDEF _POSIX_THREAD_PROCESS_SHARED}
 {Set pshared}
 attr^.process_shared:=pshared;

 Result:=0;
 {$ELSE}

 Result:=ENOSYS;
 {$ENDIF}
end;

{==============================================================================}

function pthread_create(thread: Ppthread_t; attr: Ppthread_attr_t; start_routine: Tpthread_start_routine; arg: Pointer): int; cdecl;
{Create a new thread}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Flags:LongWord;
 Priority:LongWord;
 StackSize:LongWord;
 ThreadID:TThreadID;
 Data:PSyscallsPthreadData;
begin
 {}
 Result:=EINVAL;

 {Check thread}
 if thread = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_create (thread=' + PtrToHex(thread) + ' attr=' + PtrToHex(attr) + ' start_routine=' + PtrToHex(start_routine) + ' arg=' + PtrToHex(arg) + ')');
 {$ENDIF}

 {Check attr}
 if attr = nil then
  begin
   Flags:=THREAD_FLAG_PERSIST;
   Priority:=THREAD_PRIORITY_DEFAULT;
   StackSize:=THREAD_STACK_DEFAULT_SIZE;
  end
 else
  begin
   StackSize:=attr^.stacksize;
   Priority:=attr^.schedparam.sched_priority;
   Flags:=THREAD_FLAG_NONE;
   if attr^.detachstate = PTHREAD_CREATE_JOINABLE then
    begin
     Flags:=THREAD_FLAG_PERSIST;
    end;
  end;

 {Allocate Data}
 Data:=GetMem(SizeOf(TSyscallsPthreadData));
 Data^.Routine:=start_routine;
 Data^.Arg:=arg;

 Result:=EAGAIN;

 {Create Thread}
 thread^:=SysBeginThreadEx(nil,StackSize,TThreadFunc(@SyscallsPthreadStart),Data,THREAD_CREATE_SUSPENDED,Priority,CPU_AFFINITY_ALL,CPU_ID_ALL,SYSCALLS_THREAD_NAME,ThreadID);
 if thread^ = pthread_t(INVALID_HANDLE_VALUE) then Exit;

 {Update Thread}
 ThreadSetFlags(TThreadHandle(thread^),Flags);

 {Resume Thread}
 ThreadResume(TThreadHandle(thread^));

 Result:=0;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_create (Result=' + IntToStr(Result) + ' thread=' + PtrToHex(thread) + ')');
 {$ENDIF}
end;

{==============================================================================}

function pthread_cancel(thread: pthread_t): int; cdecl;
{Send a cancellation request to a thread}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Flags:LongWord;
 State:LongWord;
begin
 {}
 Result:=ESRCH;

 {Check thread}
 if thread = pthread_t(INVALID_HANDLE_VALUE) then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_cancel (thread=' + IntToHex(thread,8) + ')');
 {$ENDIF}

 Result:=EINVAL;

 {Get Flags}
 Flags:=ThreadGetFlags(TThreadHandle(thread));
 if Flags = LongWord(INVALID_HANDLE_VALUE) then Exit;

 {Check Flags}
 if (Flags and THREAD_FLAG_CANCELLED) = 0 then
  begin
   {Not Cancelled}
   {Update Flags}
   if ThreadAddFlags(TThreadHandle(thread),THREAD_FLAG_CANCELLED) <> ERROR_SUCCESS then Exit;

   {Check Flags}
   if (Flags and THREAD_FLAG_CANCEL_DISABLE) = 0 then
    begin
     {Not Disabled}
     {Get State}
     State:=ThreadGetState(TThreadHandle(thread));
     case State of
      THREAD_STATE_SUSPENDED:begin
        {Resume Thread}
        if ThreadResume(TThreadHandle(thread)) <> ERROR_SUCCESS then Exit;
       end;
      THREAD_STATE_SLEEP,THREAD_STATE_WAIT,THREAD_STATE_WAIT_TIMEOUT,THREAD_STATE_RECEIVE,THREAD_STATE_RECEIVE_TIMEOUT:begin
        {Wake Thread}
        if ThreadWake(TThreadHandle(thread)) <> ERROR_SUCCESS then Exit;
       end;
     end;
    end;
  end;

 Result:=0;
end;

{==============================================================================}

function pthread_detach(thread: pthread_t): int; cdecl;
{Detach a thread}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Flags:LongWord;
 State:LongWord;
begin
 {}
 Result:=ESRCH;

 {Check thread}
 if thread = pthread_t(INVALID_HANDLE_VALUE) then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_detach (thread=' + IntToHex(thread,8) + ')');
 {$ENDIF}

 Result:=EINVAL;

 {Get Flags}
 Flags:=ThreadGetFlags(TThreadHandle(thread));
 if Flags = LongWord(INVALID_HANDLE_VALUE) then Exit;

 {Check Flags}
 if (Flags and THREAD_FLAG_PERSIST) = 0 then Exit;

 {Update Flags}
 if ThreadRemoveFlags(TThreadHandle(thread),THREAD_FLAG_PERSIST) <> ERROR_SUCCESS then Exit;

 {Get State}
 State:=ThreadGetState(TThreadHandle(thread));
 if State = THREAD_STATE_TERMINATED then
  begin
   {Destroy Thread}
   ThreadDestroy(TThreadHandle(thread));
  end;

 Result:=0;
end;

{==============================================================================}

procedure pthread_exit(value_ptr: Pointer); cdecl;
{Terminate calling thread}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_exit (value_ptr=' + PtrToHex(value_ptr) + ')');
 {$ENDIF}

 {Call Thread End}
 SyscallsPthreadEnd(value_ptr);
end;

{==============================================================================}

function pthread_equal(t1: pthread_t; t2: pthread_t): int; cdecl;
{Compare thread IDs}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=0;

 {Check t1}
 if t1 = pthread_t(INVALID_HANDLE_VALUE) then Exit;

 {Check t2}
 if t2 = pthread_t(INVALID_HANDLE_VALUE) then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_equal (t1=' + IntToHex(t1,8) + ' t2=' + IntToHex(t2,8) + ')');
 {$ENDIF}

 {Compare t1 and t2}
 if t1 <> t2 then Exit;

 Result:=1;
end;

{==============================================================================}

function pthread_join(thread: pthread_t; value_ptr: PPointer): int; cdecl;
{Join with a terminated thread}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Flags:LongWord;
 State:LongWord;
begin
 {}
 Result:=ESRCH;

 {Check thread}
 if thread = pthread_t(INVALID_HANDLE_VALUE) then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_join (thread=' + IntToHex(thread,8) + ')');
 {$ENDIF}

 Result:=EINVAL;

 {Get Flags}
 Flags:=ThreadGetFlags(TThreadHandle(thread));
 if Flags = LongWord(INVALID_HANDLE_VALUE) then Exit;

 {Check Flags}
 if (Flags and THREAD_FLAG_PERSIST) = 0 then Exit;

 {Check Cancellation}
 Flags:=ThreadGetFlags(ThreadGetCurrent);
 if (Flags and (THREAD_FLAG_CANCELLED or THREAD_FLAG_CANCEL_DISABLE)) = (THREAD_FLAG_CANCELLED) then
  begin
   SyscallsPthreadEnd(PTHREAD_CANCELED);
  end;

 {Wait Terminate}
 if ThreadWaitTerminate(TThreadHandle(thread),INFINITE) <> ERROR_SUCCESS then
  begin
   {Check Cancellation}
   Flags:=ThreadGetFlags(ThreadGetCurrent);
   if (Flags and (THREAD_FLAG_CANCELLED or THREAD_FLAG_CANCEL_DISABLE)) = (THREAD_FLAG_CANCELLED) then
    begin
     SyscallsPthreadEnd(PTHREAD_CANCELED);
    end;

   Exit;
  end;

 {Check value_ptr}
 if value_ptr <> nil then
  begin
   {Get ExitCode}
   value_ptr^:=Pointer(ThreadGetExitCode(TThreadHandle(thread)));
  end;

 {Update Flags}
 if ThreadRemoveFlags(TThreadHandle(thread),THREAD_FLAG_PERSIST) <> ERROR_SUCCESS then Exit;

 {Get State}
 State:=ThreadGetState(TThreadHandle(thread));
 if State = THREAD_STATE_TERMINATED then
  begin
   {Destroy Thread}
   ThreadDestroy(TThreadHandle(thread));
  end;

 Result:=0;
end;

{==============================================================================}

function pthread_self: pthread_t; cdecl;
{Get calling thread's ID}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=pthread_t(ThreadGetCurrent);

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_self (Result=' + IntToHex(Result,8) + ')');
 {$ENDIF}
end;

{==============================================================================}

procedure pthread_yield; cdecl;
{Yield the processor}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 ThreadYield;
end;

{==============================================================================}

function pthread_getconcurrency: int; cdecl;
{Get the level of concurrency}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=SyscallsPthreadConcurrency;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_getconcurrency (Result=' + IntToStr(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function pthread_setconcurrency(new_level: int): int; cdecl;
{Set the level of concurrency}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=0;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_setconcurrency (new_level=' + IntToStr(new_level) + ')');
 {$ENDIF}

 SyscallsPthreadConcurrency:=new_level;
end;

{==============================================================================}

function pthread_getschedparam(thread: pthread_t; policy: Pint; param: Psched_param): int; cdecl;
{Get scheduling policy and parameters of a thread}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Priority:LongWord;
begin
 {}
 Result:=ESRCH;

 {Check thread}
 if thread = pthread_t(INVALID_HANDLE_VALUE) then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_getschedparam (thread=' + IntToHex(thread,8) + ')');
 {$ENDIF}

 Result:=EINVAL;

 {Check policy}
 if policy = nil then Exit;

 {Check param}
 if param = nil then Exit;

 {Get Priority}
 Priority:=ThreadGetPriority(TThreadHandle(thread));

 {Return policy}
 policy^:=SCHED_OTHER;

 {Return param}
 param^.sched_priority:=Priority;

 Result:=0;
end;

{==============================================================================}

function pthread_setschedparam(thread: pthread_t; policy: int; param: Psched_param): int; cdecl;
{Set scheduling policy and parameters of a thread}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 MaxPriority:int;
 MinPriority:int;
begin
 {}
 Result:=ESRCH;

 {Check thread}
 if thread = pthread_t(INVALID_HANDLE_VALUE) then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_setschedparam (thread=' + IntToHex(thread,8) + ')');
 {$ENDIF}

 Result:=EINVAL;

 {Check param}
 if param = nil then Exit;

 {Get Min/Max}
 MaxPriority:=sched_get_priority_max(SCHED_OTHER);
 MinPriority:=sched_get_priority_min(SCHED_OTHER);

 {Check Priority}
 if (param^.sched_priority < MinPriority) or (param^.sched_priority > MaxPriority) then Exit;

 {Set Priority}
 if ThreadSetPriority(TThreadHandle(thread),param^.sched_priority) = LongWord(INVALID_HANDLE_VALUE) then Exit;

 Result:=0;
end;

{==============================================================================}

function pthread_setschedprio(thread: pthread_t; prio: int): int; cdecl;
{Set scheduling priority of a thread}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 MaxPriority:int;
 MinPriority:int;
begin
 {}
 Result:=ESRCH;

 {Check thread}
 if thread = pthread_t(INVALID_HANDLE_VALUE) then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_setschedprio (thread=' + IntToHex(thread,8) + ')');
 {$ENDIF}

 Result:=EINVAL;

 {Get Min/Max}
 MaxPriority:=sched_get_priority_max(SCHED_OTHER);
 MinPriority:=sched_get_priority_min(SCHED_OTHER);

 {Check Priority}
 if (prio < MinPriority) or (prio > MaxPriority) then Exit;

 {Set Priority}
 if ThreadSetPriority(TThreadHandle(thread),prio) = LongWord(INVALID_HANDLE_VALUE) then Exit;

 Result:=0;
end;

{==============================================================================}

function pthread_getcpuclockid(thread: pthread_t; var clock_id: clockid_t): int; cdecl;
{Retrieve ID of a thread's CPU time clock}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=ESRCH;

 {Check thread}
 if thread = pthread_t(INVALID_HANDLE_VALUE) then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_getcpuclockid (thread=' + IntToHex(thread,8) + ')');
 {$ENDIF}

 Result:=CLOCK_THREAD_CPUTIME_ID;
end;

{==============================================================================}

function pthread_key_create(key: Ppthread_key_t; destructor_routine: Tpthread_destructor_routine): int; cdecl;
{Create a thread-specific data key (TLS Index)}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check key}
 if key = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_key_create (key=' + PtrToHex(key) + ' destructor_routine=' + PtrToHex(destructor_routine) + ')');
 {$ENDIF}

 Result:=EAGAIN;

 if MutexLock(SyscallsPthreadLock) <> ERROR_SUCCESS then Exit;
 try
  {Create TLS Index}
  key^:=ThreadAllocTlsIndex;
  if key^ = TLS_OUT_OF_INDEXES then Exit;

  {Save Destructor}
  SyscallsKeyDestructor[key^]:=destructor_routine;

  Result:=0;

  {$IFDEF SYSCALLS_DEBUG}
  if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_key_create (Result=' + IntToStr(Result) + ' key=' + PtrToHex(key) + ')');
  {$ENDIF}
 finally
  MutexUnlock(SyscallsPthreadLock);
 end;
end;

{==============================================================================}

function pthread_key_delete(key: pthread_key_t): int; cdecl;
{Delete a thread-specific data key (TLS Index)}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_key_delete (key=' + IntToHex(key,8) + ')');
 {$ENDIF}

 if MutexLock(SyscallsPthreadLock) <> ERROR_SUCCESS then Exit;
 try
  {Destroy TLS Index}
  if ThreadReleaseTlsIndex(key) <> ERROR_SUCCESS then Exit;

  {Clear Destructor}
  SyscallsKeyDestructor[key]:=nil;

  Result:=0;
 finally
  MutexUnlock(SyscallsPthreadLock);
 end;
end;

{==============================================================================}

function pthread_getspecific(key: pthread_key_t): Pointer; cdecl;
{Get a thread-specific data value (TLS Value)}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=nil;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_getspecific (key=' + IntToHex(key,8) + ')');
 {$ENDIF}

 {Get TLS Value}
 Result:=ThreadGetTlsValue(key);
end;

{==============================================================================}

function pthread_setspecific(key: pthread_key_t; value: Pointer): int; cdecl;
{Set a thread-specific data value (TLS Value)}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_setspecific (key=' + IntToHex(key,8) + ' value=' + PtrToHex(value) + ')');
 {$ENDIF}

 {Set TLS Value}
 if ThreadSetTlsValue(key,value) <> ERROR_SUCCESS then Exit;

 Result:=0;
end;

{==============================================================================}

function pthread_mutex_init(mutex: Ppthread_mutex_t; attr: Ppthread_mutexattr_t): int; cdecl;
{Initialize a mutex}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Flags:LongWord;
 Handle:TMutexHandle;
begin
 {}
 Result:=EINVAL;

 {Check mutex}
 if mutex = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_mutex_init (mutex=' + PtrToHex(mutex) + ')');
 {$ENDIF}

 Result:=EAGAIN;

 {Check attr}
 if attr = nil then
  begin
   Flags:=MUTEX_FLAG_NONE;
  end
 else
  begin
   Flags:=MUTEX_FLAG_NONE;
   {$IFDEF _UNIX98_THREAD_MUTEX_ATTRIBUTES}
   if attr^._type = PTHREAD_MUTEX_RECURSIVE then
    begin
     Flags:=MUTEX_FLAG_RECURSIVE;
    end
   else if attr^._type = PTHREAD_MUTEX_ERRORCHECK then
    begin
     Flags:=MUTEX_FLAG_ERRORCHECK;
    end;
   {$ENDIF}
  end;

 {Create Mutex}
 Handle:=MutexCreateEx(False,MUTEX_DEFAULT_SPINCOUNT,Flags);
 if Handle = INVALID_HANDLE_VALUE then Exit;

 {Return mutex}
 mutex^:=Handle;

 Result:=0;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_mutex_init (Result=' + IntToStr(Result) + ' mutex=' + PtrToHex(mutex) + ')');
 {$ENDIF}
end;

{==============================================================================}

function pthread_mutex_checkinit(mutex: Ppthread_mutex_t; attr: Ppthread_mutexattr_t{$IFDEF SYSCALLS_WARN_UNINITIALIZED}; caller: String{$ENDIF}): int; cdecl;
{Check initialization of a mutex}

{Note: Internal function, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check mutex}
 if mutex = nil then Exit;

 {Check mutex}
 if mutex^ = PTHREAD_MUTEX_INITIALIZER then
  begin
   if MutexLock(SyscallsPthreadLock) <> ERROR_SUCCESS then Exit;
   try
    {Recheck mutex (Must be after lock)}
    if mutex^ = PTHREAD_MUTEX_INITIALIZER then
     begin
      {Initialize mutex}
      Result:=pthread_mutex_init(mutex,attr);
      if Result <> 0 then Exit;
     end;
   finally
    MutexUnlock(SyscallsPthreadLock);
   end;
  end;

 {Check mutex}
 if mutex^ = 0 then
  begin
   if MutexLock(SyscallsPthreadLock) <> ERROR_SUCCESS then Exit;
   try
    {Recheck mutex (Must be after lock)}
    if mutex^ = 0 then
     begin
      {$IFDEF SYSCALLS_WARN_UNINITIALIZED}
      {Uninitialized mutex}
      if PLATFORM_LOG_ENABLED then PlatformLogWarn('Uninitialized mutex in call to ' + caller);
      {$ENDIF}

      {$IFDEF SYSCALLS_CREATE_UNINITIALIZED}
      {Initialize mutex}
      Result:=pthread_mutex_init(mutex,attr);
      if Result <> 0 then Exit;
      {$ENDIF}
     end;
   finally
    MutexUnlock(SyscallsPthreadLock);
   end;
  end;

 Result:=0;
end;

{==============================================================================}

function pthread_mutex_destroy(mutex: Ppthread_mutex_t): int; cdecl;
{Destroy a mutex}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check mutex}
 if mutex = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_mutex_destroy (mutex=' + PtrToHex(mutex) + ')');
 {$ENDIF}

 {Destroy Mutex}
 if MutexDestroy(TMutexHandle(mutex^)) <> ERROR_SUCCESS then Exit;

 {Invalidate mutex}
 mutex^:=0; {Not INVALID_HANDLE_VALUE to allow detection of PTHREAD_MUTEX_INITIALIZER}

 Result:=0;
end;

{==============================================================================}

function pthread_mutex_lock(mutex: Ppthread_mutex_t): int; cdecl;
{Lock a mutex}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ResultCode:LongWord;
begin
 {}
 Result:=EINVAL;

 {Check mutex}
 if mutex = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_mutex_lock (mutex=' + PtrToHex(mutex) + ')');
 {$ENDIF}

 {Check mutex}
 Result:=pthread_mutex_checkinit(mutex,nil{$IFDEF SYSCALLS_WARN_UNINITIALIZED},'pthread_mutex_lock'{$ENDIF});
 if Result <> 0 then Exit;

 {Lock Mutex}
 ResultCode:=MutexLock(TMutexHandle(mutex^));
 if ResultCode = ERROR_SUCCESS then
  begin
   Result:=0;
  end
 else if ResultCode = ERROR_ALREADY_OWNER then //To do //Implement this in MutexLock if flags is MUTEX_FLAG_ERRORCHECK
  begin
   Result:=EDEADLK;
  end;
end;

{==============================================================================}

function pthread_mutex_trylock(mutex: Ppthread_mutex_t): int; cdecl;
{Try to lock a mutex}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ResultCode:LongWord;
begin
 {}
 Result:=EINVAL;

 {Check mutex}
 if mutex = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_mutex_trylock (mutex=' + PtrToHex(mutex) + ')');
 {$ENDIF}

 {Check mutex}
 Result:=pthread_mutex_checkinit(mutex,nil{$IFDEF SYSCALLS_WARN_UNINITIALIZED},'pthread_mutex_trylock'{$ENDIF});
 if Result <> 0 then Exit;

 {Try Lock Mutex}
 ResultCode:=MutexTryLock(TMutexHandle(mutex^));
 if ResultCode = ERROR_SUCCESS then
  begin
   Result:=0;
  end
 else if ResultCode = ERROR_LOCKED then
  begin
   Result:=EBUSY;
  end;
end;

{==============================================================================}

function pthread_mutex_unlock(mutex: Ppthread_mutex_t): int; cdecl;
{Unlock a mutex}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ResultCode:LongWord;
begin
 {}
 Result:=EINVAL;

 {Check mutex}
 if mutex = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_mutex_unlock (mutex=' + PtrToHex(mutex) + ')');
 {$ENDIF}

 {Check mutex}
 Result:=pthread_mutex_checkinit(mutex,nil{$IFDEF SYSCALLS_WARN_UNINITIALIZED},'pthread_mutex_unlock'{$ENDIF});
 if Result <> 0 then Exit;

 {Unlock Mutex}
 ResultCode:=MutexUnlock(TMutexHandle(mutex^));
 if ResultCode = ERROR_SUCCESS then
  begin
   Result:=0;
  end
 else if ResultCode = ERROR_NOT_LOCKED then
  begin
   Result:=EPERM;
  end
 else if ResultCode = ERROR_NOT_OWNER then
  begin
   Result:=EPERM;
  end;
end;

{==============================================================================}

function pthread_mutex_setprioceiling(mutex: Ppthread_mutex_t; prioceiling: int; old_ceiling: Pint): int; cdecl;
{Set the priority ceiling of a mutex}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check mutex}
 if mutex = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_mutex_setprioceiling (mutex=' + PtrToHex(mutex) + ')');
 {$ENDIF}

 {Check mutex}
 Result:=pthread_mutex_checkinit(mutex,nil{$IFDEF SYSCALLS_WARN_UNINITIALIZED},'pthread_mutex_setprioceiling'{$ENDIF});
 if Result <> 0 then Exit;

 {$IFDEF _POSIX_THREAD_PRIO_PROTECT}
 {Not supported}
 Result:=ENOSYS;
 {$ELSE}

 Result:=ENOSYS;
 {$ENDIF}
end;

{==============================================================================}

function pthread_mutex_getprioceiling(mutex: Ppthread_mutex_t; prioceiling: Pint): int; cdecl;
{Get the priority ceiling of a mutex}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check mutex}
 if mutex = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_mutex_getprioceiling (mutex=' + PtrToHex(mutex) + ')');
 {$ENDIF}

 {Check mutex}
 Result:=pthread_mutex_checkinit(mutex,nil{$IFDEF SYSCALLS_WARN_UNINITIALIZED},'pthread_mutex_getprioceiling'{$ENDIF});
 if Result <> 0 then Exit;

 {$IFDEF _POSIX_THREAD_PRIO_PROTECT}
 {Not supported}
 Result:=ENOSYS;
 {$ELSE}

 Result:=ENOSYS;
 {$ENDIF}
end;

{==============================================================================}

procedure pthread_mutex_unlock_internal(mutex: Ppthread_mutex_t); cdecl;
{Unlock a mutex (Compatible with Tpthread_cleanup_routine)}

{Note: Internal function, not intended to be called by applications}
begin
 {}
 pthread_mutex_unlock(mutex);
end;

{==============================================================================}

function pthread_mutexattr_init(attr: Ppthread_mutexattr_t): int; cdecl;
{Initialize a mutex attributes entry}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check attr}
 if attr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_mutexattr_init (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}

 {Init attr}
 attr^.is_initialized:=1;
 {$IFDEF _POSIX_THREAD_PROCESS_SHARED}
 attr^.process_shared:=PTHREAD_PROCESS_PRIVATE;
 {$ENDIF}
 {$IFDEF _POSIX_THREAD_PRIO_PROTECT}
 attr^.prio_ceiling:=0;
 attr^.protocol:=0;
 {$ENDIF}
 {$IFDEF _UNIX98_THREAD_MUTEX_ATTRIBUTES}
 attr^._type:=PTHREAD_MUTEX_DEFAULT;
 {$ENDIF}
 attr^.recursive:=0;

 Result:=0;
end;

{==============================================================================}

function pthread_mutexattr_destroy(attr: Ppthread_mutexattr_t): int; cdecl;
{Destroy a mutex attributes entry}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check attr}
 if attr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_mutexattr_destroy (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}

 {Destroy attr}
 attr^.is_initialized:=0;

 Result:=0;
end;

{==============================================================================}

function pthread_mutexattr_getprioceiling(attr: Ppthread_mutexattr_t; prioceiling: Pint): int; cdecl;
{Get the prioceiling attribute of the mutex attributes entry}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check attr}
 if attr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_mutexattr_getprioceiling (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}

 {Check prioceiling}
 if prioceiling = nil then Exit;

 {$IFDEF _POSIX_THREAD_PRIO_PROTECT}
 {Get prioceiling}
 prioceiling^:=attr^.prio_ceiling;

 Result:=0;
 {$ELSE}

 Result:=ENOSYS;
 {$ENDIF}
end;

{==============================================================================}

function pthread_mutexattr_setprioceiling(attr: Ppthread_mutexattr_t; prioceiling: int): int; cdecl;
{Set the prioceiling attribute of the mutex attributes entry}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check attr}
 if attr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_mutexattr_setprioceiling (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}

 {$IFDEF _POSIX_THREAD_PRIO_PROTECT}
 {Set prioceiling}
 attr^.prio_ceiling:=prioceiling;

 Result:=0;
 {$ELSE}

 Result:=ENOSYS;
 {$ENDIF}
end;

{==============================================================================}

function pthread_mutexattr_getprotocol(attr: Ppthread_mutexattr_t; protocol: Pint): int; cdecl;
{Get the protocol attribute of the mutex attributes entry}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check attr}
 if attr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_mutexattr_getprotocol (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}

 {Check protocol}
 if protocol = nil then Exit;

 {$IFDEF _POSIX_THREAD_PRIO_PROTECT}
 {Get protocol}
 protocol^:=attr^.protocol;

 Result:=0;
 {$ELSE}

 Result:=ENOSYS;
 {$ENDIF}
end;

{==============================================================================}

function pthread_mutexattr_setprotocol(attr: Ppthread_mutexattr_t; protocol: int): int; cdecl;
{Set the protocol attribute of the mutex attributes entry}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check attr}
 if attr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_mutexattr_setprotocol (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}

 {$IFDEF _POSIX_THREAD_PRIO_PROTECT}
 {Set protocol}
 attr^.protocol:=protocol;

 Result:=0;
 {$ELSE}

 Result:=ENOSYS;
 {$ENDIF}
end;

{==============================================================================}

function pthread_mutexattr_getpshared(attr: Ppthread_mutexattr_t; pshared: Pint): int; cdecl;
{Get the process-shared attribute of the mutex attributes entry}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check attr}
 if attr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_mutexattr_getpshared (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}

 {Check pshared}
 if pshared = nil then Exit;

 {$IFDEF _POSIX_THREAD_PROCESS_SHARED}
 {Get pshared}
 pshared^:=attr^.process_shared;

 Result:=0;
 {$ELSE}

 Result:=ENOSYS;
 {$ENDIF}
end;

{==============================================================================}

function pthread_mutexattr_setpshared(attr: Ppthread_mutexattr_t; pshared: int): int; cdecl;
{Set the process-shared attribute of the mutex attributes entry}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check attr}
 if attr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_mutexattr_setpshared (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}

 {Check pshared}
 if (pshared <> PTHREAD_PROCESS_PRIVATE) and (pshared <> PTHREAD_PROCESS_SHARED) then Exit;

 {$IFDEF _POSIX_THREAD_PROCESS_SHARED}
 {Set pshared}
 attr^.process_shared:=pshared;

 Result:=0;
 {$ELSE}

 Result:=ENOSYS;
 {$ENDIF}
end;

{==============================================================================}

function pthread_mutexattr_gettype(attr: Ppthread_mutexattr_t; _type: Pint): int; cdecl;
{Get the type attribute of the mutex attributes entry}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check attr}
 if attr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_mutexattr_gettype (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}

 {Check _type}
 if _type = nil then Exit;

 {$IFDEF _UNIX98_THREAD_MUTEX_ATTRIBUTES}
 {Get _type}
 _type^:=attr^._type;

 Result:=0;
 {$ELSE}

 Result:=ENOSYS;
 {$ENDIF}
end;

{==============================================================================}

function pthread_mutexattr_settype(attr: Ppthread_mutexattr_t; _type: int): int; cdecl;
{Set the type attribute of the mutex attributes entry}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check attr}
 if attr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_mutexattr_settype (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}

 {Check _type}
 if (_type <> PTHREAD_MUTEX_NORMAL) and (_type <> PTHREAD_MUTEX_RECURSIVE) and (_type <> PTHREAD_MUTEX_ERRORCHECK) and (_type <> PTHREAD_MUTEX_DEFAULT) then Exit;

 {$IFDEF _UNIX98_THREAD_MUTEX_ATTRIBUTES}
 {Set _type}
 attr^._type:=_type;

 Result:=0;
 {$ELSE}

 Result:=ENOSYS;
 {$ENDIF}
end;

{==============================================================================}

function pthread_once(once_control: Ppthread_once_t; init_routine: Tpthread_init_routine): int; cdecl;
{Dynamic package initialisation}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 Result:=EINVAL;

 {Check once_control and init_routine}
 if (once_control = nil) or not Assigned(init_routine) then
  begin
   {Return Error (Some callers incorrectly check errno on failure)}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;

   Exit;
  end;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_once (once_control=' + PtrToHex(once_control) + ' init_routine=' + PtrToHex(init_routine) + ')');
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_once (is_initialized=' + IntToStr(once_control^.is_initialized) + ' init_executed=' + IntToStr(once_control^.init_executed) + ')');
 {$ENDIF}

 {Update is_initialized}
 once_control^.is_initialized:=1;

 {Check init_executed}
 if once_control^.init_executed = 0 then
  begin
   if MutexLock(SyscallsPthreadLock) <> ERROR_SUCCESS then Exit;

   {Recheck init_executed (Must be after lock)}
   if once_control^.init_executed = 0 then
    begin
     {Add mutex unlock cleanup}
     pthread_cleanup_push(Tpthread_cleanup_routine(@pthread_mutex_unlock_internal),@SyscallsPthreadLock);

     {Call init_routine}
     init_routine();

     {Update is_initialized (Must be after init_routine)}
     once_control^.init_executed:=1;

     {Remove mutex unlock cleanup}
     pthread_cleanup_pop(0);
    end;

   MutexUnlock(SyscallsPthreadLock);
  end;

 Result:=0;
end;

{==============================================================================}

function pthread_spin_init(spinlock: Ppthread_spinlock_t; pshared: Pint): int; cdecl;
{Initialize a spin lock}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Handle:TSpinHandle;
begin
 {}
 Result:=EINVAL;

 {Check spinlock}
 if spinlock = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_spin_init (spinlock=' + PtrToHex(spinlock) + ')');
 {$ENDIF}

 Result:=EAGAIN;

 {Note: pshared not used}

 {Create Spin}
 Handle:=SpinCreate;
 if Handle = INVALID_HANDLE_VALUE then Exit;

 {Return spinlock}
 spinlock^:=Handle;

 Result:=0;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_spin_init (Result=' + IntToStr(Result) + ' spinlock=' + PtrToHex(spinlock) + ')');
 {$ENDIF}
end;

{==============================================================================}

function pthread_spin_destroy(spinlock: Ppthread_spinlock_t): int; cdecl;
{Destroy a spin lock}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check spinlock}
 if spinlock = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_spin_destroy (spinlock=' + PtrToHex(spinlock) + ')');
 {$ENDIF}

 Result:=EBUSY;

 {Check Owner}
 if SpinOwner(TSpinHandle(spinlock^)) <> INVALID_HANDLE_VALUE then Exit;

 Result:=EINVAL;

 {Destroy Spin}
 if SpinDestroy(TSpinHandle(spinlock^)) <> ERROR_SUCCESS then Exit;

 {Invalidate spinlock}
 spinlock^:=INVALID_HANDLE_VALUE;

 Result:=0;
end;

{==============================================================================}

function pthread_spin_lock(_spinlock: Ppthread_spinlock_t): int; cdecl;
{Lock a spin lock object}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ResultCode:LongWord;
begin
 {}
 Result:=EINVAL;

 {Check spinlock}
 if _spinlock = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_spin_lock (spinlock=' + PtrToHex(_spinlock) + ')');
 {$ENDIF}

 {Check spinlock}
 if (_spinlock^ = 0) or (_spinlock^ = INVALID_HANDLE_VALUE) then
  begin
   {$IFDEF SYSCALLS_WARN_UNINITIALIZED}
   {Uninitialized spinlock}
   if PLATFORM_LOG_ENABLED then PlatformLogWarn('Uninitialized spinlock in call to pthread_spin_lock');
   {$ENDIF}

   {$IFDEF SYSCALLS_CREATE_UNINITIALIZED}
   {Initialize spinlock}
   Result:=pthread_spin_init(_spinlock,nil);
   if Result <> 0 then Exit;
   {$ENDIF}
  end;

 {Check Owner}
 if SpinOwner(TSpinHandle(_spinlock^)) = ThreadGetCurrent then
  begin
   Result:=EDEADLK;
  end
 else
  begin
   {Lock Spin}
   ResultCode:=SpinLock(TSpinHandle(_spinlock^));
   if ResultCode = ERROR_SUCCESS then
    begin
     Result:=0;
    end;
  end;
end;

{==============================================================================}

function pthread_spin_trylock(_spinlock: Ppthread_spinlock_t): int; cdecl;
{Try to lock a spin lock object}

{Note: Use of pthread_spin_trylock is discouraged as there is no underlying SpinTryLock function}
{      therefore it is possible to encounter a race condition between multiple calling threads}
{      Use of an alternative lock type such as a mutex or a rwlock is the recommended option}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ResultCode:LongWord;
begin
 {}
 Result:=EINVAL;

 {Check spinlock}
 if _spinlock = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_spin_trylock (spinlock=' + PtrToHex(_spinlock) + ')');
 {$ENDIF}

 {Check spinlock}
 if (_spinlock^ = 0) or (_spinlock^ = INVALID_HANDLE_VALUE) then
  begin
   {$IFDEF SYSCALLS_WARN_UNINITIALIZED}
   {Uninitialized spinlock}
   if PLATFORM_LOG_ENABLED then PlatformLogWarn('Uninitialized spinlock in call to pthread_spin_trylock');
   {$ENDIF}

   {$IFDEF SYSCALLS_CREATE_UNINITIALIZED}
   {Initialize spinlock}
   Result:=pthread_spin_init(_spinlock,nil);
   if Result <> 0 then Exit;
   {$ENDIF}
  end;

 {Check Owner}
 if SpinOwner(TSpinHandle(_spinlock^)) = ThreadGetCurrent then
  begin
   Result:=EDEADLK;
  end
 else if SpinOwner(TSpinHandle(_spinlock^)) <> INVALID_HANDLE_VALUE then
  begin
   Result:=EBUSY;
  end
 else
  begin
   {Lock Spin}
   ResultCode:=SpinLock(TSpinHandle(_spinlock^));
   if ResultCode = ERROR_SUCCESS then
    begin
     Result:=0;
    end
  end;
end;

{==============================================================================}

function pthread_spin_unlock(spinlock: Ppthread_spinlock_t): int; cdecl;
{Unlock a spin lock object}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ResultCode:LongWord;
begin
 Result:=EINVAL;

 {Check spinlock}
 if spinlock = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_spin_unlock (spinlock=' + PtrToHex(spinlock) + ')');
 {$ENDIF}

 {Check spinlock}
 if (spinlock^ = 0) or (spinlock^ = INVALID_HANDLE_VALUE) then
  begin
   {$IFDEF SYSCALLS_WARN_UNINITIALIZED}
   {Uninitialized spinlock}
   if PLATFORM_LOG_ENABLED then PlatformLogWarn('Uninitialized spinlock in call to pthread_spin_unlock');
   {$ENDIF}

   {$IFDEF SYSCALLS_CREATE_UNINITIALIZED}
   {Initialize spinlock}
   Result:=pthread_spin_init(spinlock,nil);
   if Result <> 0 then Exit;
   {$ENDIF}
  end;

 {Check Owner}
 if SpinOwner(TSpinHandle(spinlock^)) <> ThreadGetCurrent then
  begin
   Result:=EPERM;
  end
 else
  begin
   {Unlock Spin}
   ResultCode:=SpinUnlock(TSpinHandle(spinlock^));
   if ResultCode = ERROR_SUCCESS then
    begin
     Result:=0;
    end
  end;
end;

{==============================================================================}

function pthread_rwlock_init(rwlock: Ppthread_rwlock_t ; attr: Ppthread_rwlockattr_t): int; cdecl;
{Initialize a read-write lock}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Handle:TSynchronizerHandle;
begin
 {}
 Result:=EINVAL;

 {Check rwlock}
 if rwlock = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_rwlock_init (rwlock=' + PtrToHex(rwlock) + ')');
 {$ENDIF}

 Result:=EAGAIN;

 {Note: attr not used}

 {Create Synchronizer}
 Handle:=SynchronizerCreate;
 if Handle = INVALID_HANDLE_VALUE then Exit;

 {Return rwlock}
 rwlock^:=Handle;

 Result:=0;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_rwlock_init (Result=' + IntToStr(Result) + ' rwlock=' + PtrToHex(rwlock) + ')');
 {$ENDIF}
end;

{==============================================================================}

function pthread_rwlock_checkinit(rwlock: Ppthread_rwlock_t ; attr: Ppthread_rwlockattr_t{$IFDEF SYSCALLS_WARN_UNINITIALIZED}; caller: String{$ENDIF}): int; cdecl;
{Check initialization of a read-write lock}

{Note: Internal function, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check rwlock}
 if rwlock = nil then Exit;

 {Check rwlock}
 if rwlock^ = PTHREAD_RWLOCK_INITIALIZER then
  begin
   if MutexLock(SyscallsPthreadLock) <> ERROR_SUCCESS then Exit;
   try
    {Recheck rwlock (Must be after lock)}
    if rwlock^ = PTHREAD_RWLOCK_INITIALIZER then
     begin
      {Initialize rwlock}
      Result:=pthread_rwlock_init(rwlock,attr);
      if Result <> 0 then Exit;
     end;
   finally
    MutexUnlock(SyscallsPthreadLock);
   end;
  end;

 {Check rwlock}
 if rwlock^ = 0 then
  begin
   if MutexLock(SyscallsPthreadLock) <> ERROR_SUCCESS then Exit;
   try
    {Recheck rwlock (Must be after lock)}
    if rwlock^ = 0 then
     begin
      {$IFDEF SYSCALLS_WARN_UNINITIALIZED}
      {Uninitialized rwlock}
      if PLATFORM_LOG_ENABLED then PlatformLogWarn('Uninitialized rwlock in call to ' + caller);
      {$ENDIF}

      {$IFDEF SYSCALLS_CREATE_UNINITIALIZED}
      {Initialize rwlock}
      Result:=pthread_rwlock_init(rwlock,attr);
      if Result <> 0 then Exit;
      {$ENDIF}
     end;
   finally
    MutexUnlock(SyscallsPthreadLock);
   end;
  end;

 Result:=0;
end;

{==============================================================================}

function pthread_rwlock_destroy(rwlock: Ppthread_rwlock_t): int; cdecl;
{Destroy a read-write lock}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check rwlock}
 if rwlock = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_rwlock_destroy (rwlock=' + PtrToHex(rwlock) + ')');
 {$ENDIF}

 {Destroy Synchronizer}
 if SynchronizerDestroy(TSynchronizerHandle(rwlock^)) <> ERROR_SUCCESS then Exit;

 {Invalidate rwlock}
 rwlock^:=0; {Not INVALID_HANDLE_VALUE to allow detection of PTHREAD_RWLOCK_INITIALIZER}

 Result:=0;
end;

{==============================================================================}

function pthread_rwlock_rdlock(rwlock: Ppthread_rwlock_t): int; cdecl;
{Lock a read-write lock for reading}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ResultCode:LongWord;
begin
 {}
 Result:=EINVAL;

 {Check rwlock}
 if rwlock = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_rwlock_rdlock (rwlock=' + PtrToHex(rwlock) + ')');
 {$ENDIF}

 {Check rwlock}
 Result:=pthread_rwlock_checkinit(rwlock,nil{$IFDEF SYSCALLS_WARN_UNINITIALIZED},'pthread_rwlock_rdlock'{$ENDIF});
 if Result <> 0 then Exit;

 {Check Owner}
 if SynchronizerWriterOwner(TSynchronizerHandle(rwlock^)) = ThreadGetCurrent then
  begin
   Result:=EDEADLK;
  end
 else
  begin
   {Lock Synchronizer}
   ResultCode:=SynchronizerReaderLock(TSynchronizerHandle(rwlock^));
   if ResultCode = ERROR_SUCCESS then
    begin
     Result:=0;
    end;
  end;
end;

{==============================================================================}

function pthread_rwlock_wrlock(rwlock: Ppthread_rwlock_t): int; cdecl;
{Lock a read-write lock for writing}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ResultCode:LongWord;
begin
 {}
 Result:=EINVAL;

 {Check rwlock}
 if rwlock = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_rwlock_wrlock (rwlock=' + PtrToHex(rwlock) + ')');
 {$ENDIF}

 {Check rwlock}
 Result:=pthread_rwlock_checkinit(rwlock,nil{$IFDEF SYSCALLS_WARN_UNINITIALIZED},'pthread_rwlock_wrlock'{$ENDIF});
 if Result <> 0 then Exit;

 {Check Last}
 if SynchronizerReaderLast(TSynchronizerHandle(rwlock^)) = ThreadGetCurrent then
  begin
   Result:=EDEADLK;
  end
 else
  begin
   {Lock Synchronizer}
   ResultCode:=SynchronizerWriterLock(TSynchronizerHandle(rwlock^));
   if ResultCode = ERROR_SUCCESS then
    begin
     Result:=0;
    end;
  end;
end;

{==============================================================================}

function pthread_rwlock_tryrdlock(rwlock: Ppthread_rwlock_t): int; cdecl;
{Try to lock a read-write lock for reading}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ResultCode:LongWord;
begin
 {}
 Result:=EINVAL;

 {Check rwlock}
 if rwlock = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_rwlock_tryrdlock (rwlock=' + PtrToHex(rwlock) + ')');
 {$ENDIF}

 {Check rwlock}
 Result:=pthread_rwlock_checkinit(rwlock,nil{$IFDEF SYSCALLS_WARN_UNINITIALIZED},'pthread_rwlock_tryrdlock'{$ENDIF});
 if Result <> 0 then Exit;

 {Check Owner}
 if SynchronizerWriterOwner(TSynchronizerHandle(rwlock^)) = ThreadGetCurrent then
  begin
   Result:=EDEADLK;
  end
 else
  begin
   {Try Lock Synchronizer}
   ResultCode:=SynchronizerReaderLockEx(TSynchronizerHandle(rwlock^),0);
   if ResultCode = ERROR_SUCCESS then
    begin
     Result:=0;
    end
   else if ResultCode = ERROR_WAIT_TIMEOUT then
    begin
     Result:=EBUSY;
    end;
  end;
end;

{==============================================================================}

function pthread_rwlock_trywrlock(rwlock: Ppthread_rwlock_t): int; cdecl;
{Try to lock a read-write lock for writing}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ResultCode:LongWord;
begin
 {}
 Result:=EINVAL;

 {Check rwlock}
 if rwlock = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_rwlock_trywrlock (rwlock=' + PtrToHex(rwlock) + ')');
 {$ENDIF}

 {Check rwlock}
 Result:=pthread_rwlock_checkinit(rwlock,nil{$IFDEF SYSCALLS_WARN_UNINITIALIZED},'pthread_rwlock_trywrlock'{$ENDIF});
 if Result <> 0 then Exit;

 {Check Last}
 if SynchronizerReaderLast(TSynchronizerHandle(rwlock^)) = ThreadGetCurrent then
  begin
   Result:=EDEADLK;
  end
 else
  begin
   {Try Lock Synchronizer}
   ResultCode:=SynchronizerWriterLockEx(TSynchronizerHandle(rwlock^),0);
   if ResultCode = ERROR_SUCCESS then
    begin
     Result:=0;
    end
   else if ResultCode = ERROR_WAIT_TIMEOUT then
    begin
     Result:=EBUSY;
    end;
  end;
end;

{==============================================================================}

function pthread_rwlock_unlock(rwlock: Ppthread_rwlock_t): int; cdecl;
{Unlock a read-write lock}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ResultCode:LongWord;
begin
 {}
 Result:=EINVAL;

 {Check rwlock}
 if rwlock = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_rwlock_unlock (rwlock=' + PtrToHex(rwlock) + ')');
 {$ENDIF}

 {Check rwlock}
 Result:=pthread_rwlock_checkinit(rwlock,nil{$IFDEF SYSCALLS_WARN_UNINITIALIZED},'pthread_rwlock_unlock'{$ENDIF});
 if Result <> 0 then Exit;

 {Check Owner}
 if SynchronizerWriterOwner(TSynchronizerHandle(rwlock^)) = ThreadGetCurrent then
  begin
   {Unlock Synchronizer}
   ResultCode:=SynchronizerWriterUnlock(TSynchronizerHandle(rwlock^));
   if ResultCode = ERROR_SUCCESS then
    begin
     Result:=0;
    end
   else if ResultCode = ERROR_NOT_LOCKED then
    begin
     Result:=EPERM;
    end
   else if ResultCode = ERROR_NOT_OWNER then
    begin
     Result:=EPERM;
    end;
  end
 else
  begin
   {Unlock Synchronizer}
   ResultCode:=SynchronizerReaderUnlock(TSynchronizerHandle(rwlock^));
   if ResultCode = ERROR_SUCCESS then
    begin
     Result:=0;
    end
   else if ResultCode = ERROR_NOT_LOCKED then
    begin
     Result:=EPERM;
    end;
  end;
end;

{==============================================================================}

function pthread_rwlockattr_init(attr: Ppthread_rwlockattr_t): int; cdecl;
{Initialize a read-write lock attributes entry}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check attr}
 if attr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_rwlockattr_init (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}

 {Init attr}
 attr^.is_initialized:=1;
 {$IFDEF _POSIX_THREAD_PROCESS_SHARED}
 attr^.process_shared:=PTHREAD_PROCESS_PRIVATE;
 {$ENDIF}

 Result:=0;
end;

{==============================================================================}

function pthread_rwlockattr_destroy(attr: Ppthread_rwlockattr_t): int; cdecl;
{Destroy a read-write lock attributes entry}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check attr}
 if attr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_rwlockattr_destroy (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}

 {Destroy attr}
 attr^.is_initialized:=0;

 Result:=0;
end;

{==============================================================================}

function pthread_rwlockattr_getpshared(attr: Ppthread_rwlockattr_t; pshared: Pint): int; cdecl;
{Get the process-shared attribute of the read-write lock attributes entry}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check attr}
 if attr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_mutexattr_getpshared (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}

 {Check pshared}
 if pshared = nil then Exit;

 {$IFDEF _POSIX_THREAD_PROCESS_SHARED}
 {Get pshared}
 pshared^:=attr^.process_shared;

 Result:=0;
 {$ELSE}

 Result:=ENOSYS;
 {$ENDIF}
end;

{==============================================================================}

function pthread_rwlockattr_setpshared(attr: Ppthread_rwlockattr_t; pshared: int): int; cdecl;
{Set the process-shared attribute of the read-write lock attributes entry}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 {Check attr}
 if attr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_mutexattr_setpshared (attr=' + PtrToHex(attr) + ')');
 {$ENDIF}

 {Check pshared}
 if (pshared <> PTHREAD_PROCESS_PRIVATE) and (pshared <> PTHREAD_PROCESS_SHARED) then Exit;

 {$IFDEF _POSIX_THREAD_PROCESS_SHARED}
 {Set pshared}
 attr^.process_shared:=pshared;

 Result:=0;
 {$ELSE}

 Result:=ENOSYS;
 {$ENDIF}
end;

{==============================================================================}

function pthread_setcancelstate(state: int; oldstate: Pint): int; cdecl;
{Set cancelability state for the current thread}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Flags:LongWord;
begin
 {}
 Result:=EINVAL;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_setcancelstate (state=' + IntToStr(state) + ')');
 {$ENDIF}

 {Check state}
 if (state < PTHREAD_CANCEL_ENABLE) or (state > PTHREAD_CANCEL_DISABLE) then Exit;

 {Get Flags}
 Flags:=ThreadGetFlags(ThreadGetCurrent);
 if (Flags and THREAD_FLAG_CANCEL_DISABLE) = 0 then
  begin
   {Cancel Enabled}
   {Get oldstate}
   if oldstate <> nil then oldstate^:=PTHREAD_CANCEL_ENABLE;

   {Check State}
   if state = PTHREAD_CANCEL_DISABLE then
    begin
     ThreadAddFlags(ThreadGetCurrent,THREAD_FLAG_CANCEL_DISABLE);
    end;
  end
 else
  begin
   {Cancel Disabled}
   {Get oldstate}
   if oldstate <> nil then oldstate^:=PTHREAD_CANCEL_DISABLE;

   {Check State}
   if state = PTHREAD_CANCEL_ENABLE then
    begin
     ThreadRemoveFlags(ThreadGetCurrent,THREAD_FLAG_CANCEL_DISABLE);
    end;
  end;

 {Check Cancelled/Enabled/Asynchronous}
 Flags:=ThreadGetFlags(ThreadGetCurrent);
 if (Flags and (THREAD_FLAG_CANCELLED or THREAD_FLAG_CANCEL_DISABLE or THREAD_FLAG_CANCEL_ASYNCHRONOUS)) = (THREAD_FLAG_CANCELLED or THREAD_FLAG_CANCEL_ASYNCHRONOUS) then
  begin
   SyscallsPthreadEnd(PTHREAD_CANCELED);
  end;

 Result:=0;
end;

{==============================================================================}

function pthread_setcanceltype(_type: int; oldtype: Pint): int; cdecl;
{Set cancelability type for the current thread}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Flags:LongWord;
begin
 {}
 Result:=EINVAL;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_setcanceltype (type=' + IntToStr(_type) + ')');
 {$ENDIF}

 {Check type}
 if (_type < PTHREAD_CANCEL_DEFERRED) or (_type > PTHREAD_CANCEL_ASYNCHRONOUS) then Exit;

 {Get Flags}
 Flags:=ThreadGetFlags(ThreadGetCurrent);
 if (Flags and THREAD_FLAG_CANCEL_ASYNCHRONOUS) = 0 then
  begin
   {Cancel Deferred}
   {Get oldtype}
   if oldtype <> nil then oldtype^:=PTHREAD_CANCEL_DEFERRED;

   {Check Type}
   if _type = PTHREAD_CANCEL_ASYNCHRONOUS then
    begin
     ThreadAddFlags(ThreadGetCurrent,THREAD_FLAG_CANCEL_ASYNCHRONOUS);
    end;
  end
 else
  begin
   {Cancel Asynchronous}
   {Get oldtype}
   if oldtype <> nil then oldtype^:=PTHREAD_CANCEL_ASYNCHRONOUS;

   {Check Type}
   if _type = PTHREAD_CANCEL_DEFERRED then
    begin
     ThreadRemoveFlags(ThreadGetCurrent,THREAD_FLAG_CANCEL_ASYNCHRONOUS);
    end;
  end;

 {Check Cancelled/Enabled/Asynchronous}
 Flags:=ThreadGetFlags(ThreadGetCurrent);
 if (Flags and (THREAD_FLAG_CANCELLED or THREAD_FLAG_CANCEL_DISABLE or THREAD_FLAG_CANCEL_ASYNCHRONOUS)) = (THREAD_FLAG_CANCELLED or THREAD_FLAG_CANCEL_ASYNCHRONOUS) then
  begin
   SyscallsPthreadEnd(PTHREAD_CANCELED);
  end;

 Result:=0;
end;

{==============================================================================}

procedure pthread_testcancel; cdecl;
{Test if the current thread is cancelled}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 Flags:LongWord;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls pthread_testcancel');
 {$ENDIF}

 {Check Cancelled/Enabled}
 Flags:=ThreadGetFlags(ThreadGetCurrent);
 if (Flags and (THREAD_FLAG_CANCELLED or THREAD_FLAG_CANCEL_DISABLE)) = (THREAD_FLAG_CANCELLED) then
  begin
   SyscallsPthreadEnd(PTHREAD_CANCELED);
  end;
end;

{==============================================================================}
{==============================================================================}
{Syscalls Functions (Semaphore)}
function sem_close(sem: Psem_t): int; cdecl;
{Close a named semaphore}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Entry:PHandleEntry;
 Handle:TSemaphoreHandle;
 ResultCode:LongWord;
begin
 {}
 Result:=-1;

 {Check sem}
 if sem = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls sem_close (sem=' + PtrToHex(sem) + ')');
 {$ENDIF}

 {Get Handle}
 Entry:=HandleGet(sem^);
 if Entry = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;

   Exit;
  end;

 {Get Semaphore}
 Handle:=Entry^.Data;

 {Destroy Handle}
 ResultCode:=HandleDestroy(sem^);
 if ResultCode = ERROR_SUCCESS then
  begin
   {Destroy Semaphore}
   SemaphoreDestroy(Handle);

   {Update sem}
   sem^:=0;

   {Return Result}
   Result:=0;
  end
 else if ResultCode = ERROR_IN_USE then
  begin
   {Update sem}
   sem^:=0;

   {Return Result}
   Result:=0;
  end
 else
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
  end;
end;

{==============================================================================}

function sem_destroy(sem: Psem_t): int; cdecl;
{Destroy an unnamed semaphore}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Entry:PHandleEntry;
 Handle:TSemaphoreHandle;
 ResultCode:LongWord;
begin
 {}
 Result:=-1;

 {Check sem}
 if sem = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls sem_destroy (sem=' + PtrToHex(sem) + ')');
 {$ENDIF}

 {Get Handle}
 Entry:=HandleGet(sem^);
 if Entry = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;

   Exit;
  end;

 {Get Semaphore}
 Handle:=Entry^.Data;

 {Destroy Handle}
 ResultCode:=HandleDestroy(sem^);
 if ResultCode = ERROR_SUCCESS then
  begin
   {Destroy Semaphore}
   SemaphoreDestroy(Handle);

   {Update sem}
   sem^:=0;

   {Return Result}
   Result:=0;
  end
 else if ResultCode = ERROR_IN_USE then
  begin
   {Update sem}
   sem^:=0;

   {Return Result}
   Result:=0;
  end
 else
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
  end;
end;

{==============================================================================}

function sem_getvalue(sem: Psem_t; sval: Pint): int; cdecl;
{Get the value of a semaphore}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Entry:PHandleEntry;
begin
 {}
 Result:=-1;

 {Check sem}
 if sem = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls sem_getvalue (sem=' + PtrToHex(sem) + ')');
 {$ENDIF}

 {Check sval}
 if sval = nil then Exit;

 {Get Handle}
 Entry:=HandleGet(sem^);
 if Entry = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;

   Exit;
  end;

 {Get Semaphore Count}
 sval^:=SemaphoreCount(Entry^.Data);

 Result:=0;
end;

{==============================================================================}

function sem_init(sem: Psem_t; pshared: int; value: uint): int; cdecl;
{Initialize an unnamed semaphore}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Entry:PHandleEntry;
 Handle:TSemaphoreHandle;
begin
 {}
 Result:=-1;

 {Check sem}
 if sem = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls sem_init (sem=' + PtrToHex(sem) + ' value=' + IntToStr(value) + ')');
 {$ENDIF}

 {Note: pshared not used}

 {Check value}
 if value > SEM_VALUE_MAX then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;

   Exit;
  end;

 {Create Semaphore}
 Handle:=SemaphoreCreate(value);
 if Handle = INVALID_HANDLE_VALUE then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;

   Exit;
  end;

 {Create Handle}
 Entry:=HandleCreateEx('',HANDLE_FLAG_NONE,Handle,HANDLE_TYPE_SEMAPHORE);
 if Entry = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;

   Exit;
  end;

 {Return sem}
 sem^:=Entry^.Handle;

 Result:=0;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls sem_init (Result=' + IntToStr(Result) + ' sem=' + PtrToHex(sem) + ')');
 {$ENDIF}
end;

{==============================================================================}

function sem_open(name: PChar; oflag: int): Psem_t; cdecl;
{Initialize and open a named semaphore}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=sem_open_ext(name,oflag,0,0);
end;

{==============================================================================}

function sem_open_ext(name: PChar; oflag: int; mode: mode_t; value: uint): Psem_t; cdecl;
{Initialize and open a named semaphore}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Current:THandle;
 Entry:PHandleEntry;
 Handle:TSemaphoreHandle;
begin
 {}
 Result:=SEM_FAILED;

 {Check name}
 if name = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls sem_open_ext (name=' + StrPas(name) + ' oflag=' + IntToHex(oflag,8) + ' value=' + IntToStr(value) + ')');
 {$ENDIF}

 {Note: mode not used}

 {Open Handle}
 Current:=HandleOpen(name);
 if Current = INVALID_HANDLE_VALUE then
  begin
   {Check Flags}
   if (oflag and O_CREAT) = 0 then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=ENOENT;

     Exit;
    end;

   {Check value}
   if value > SEM_VALUE_MAX then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EINVAL;

     Exit;
    end;

   {Create Semaphore}
   Handle:=SemaphoreCreate(value);
   if Handle = INVALID_HANDLE_VALUE then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EINVAL;

     Exit;
    end;

   {Create Handle}
   Entry:=HandleCreateEx(name,HANDLE_FLAG_NAMED,Handle,HANDLE_TYPE_SEMAPHORE);
   if Entry = nil then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EINVAL;

     Exit;
    end;

   {Return Result}
   Result:=@Entry^.Handle;
  end
 else
  begin
   {Check Type}
   Entry:=HandleGet(Current);
   if (Entry <> nil) and (Entry^.HandleType <> HANDLE_TYPE_SEMAPHORE) then
    begin
     {Close Handle}
     HandleClose(Current);

     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EACCES;

     Exit;
    end;

   {Check Flags}
   if (oflag and (O_CREAT or O_EXCL)) = (O_CREAT or O_EXCL) then
    begin
     {Close Handle}
     HandleClose(Current);

     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EEXIST;

     Exit;
    end;

   {Return Result}
   Result:=@Entry^.Handle;
  end;
end;

{==============================================================================}

function sem_post(sem: Psem_t): int; cdecl;
{Unlock (Signal) a semaphore}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Entry:PHandleEntry;
begin
 {}
 Result:=-1;

 {Check sem}
 if sem = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls sem_post (sem=' + PtrToHex(sem) + ')');
 {$ENDIF}

 {Get Handle}
 Entry:=HandleGet(sem^);
 if Entry = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;

   Exit;
  end;

 {Post Semaphore}
 if SemaphoreSignal(Entry^.Data) <> ERROR_SUCCESS then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;

   Exit;
  end;

 Result:=0;
end;

{==============================================================================}

function sem_timedwait(sem: Psem_t; abs_timeout: Ptimespec): int; cdecl;
{Lock (Wait for) a semaphore with a timeout}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Entry:PHandleEntry;
 Timeout:LongWord;
 Current:Ttimespec;
 Relative:Ttimespec;
 ResultCode:LongWord;
begin
 {}
 Result:=-1;

 {Check sem}
 if sem = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls sem_timedwait (sem=' + PtrToHex(sem) + ')');
 {$ENDIF}

 {Check abs timeout}
 if abs_timeout = nil then Exit;

 {Get Timeout}
 Timeout:=INFINITE;
 if clock_gettime(CLOCK_REALTIME,@Current) = 0 then
  begin
   Relative.tv_nsec:=abs_timeout^.tv_nsec - Current.tv_nsec;
   Relative.tv_sec:=abs_timeout^.tv_sec - Current.tv_sec;
   if Relative.tv_nsec < 0 then
    begin
     Relative.tv_nsec:=Relative.tv_nsec + 1000000000;
     Relative.tv_sec:=Relative.tv_sec - 1;
    end;

   if Relative.tv_sec < 0 then Exit;

   Timeout:=(Relative.tv_sec * 1000) + (Relative.tv_nsec div 1000000);
  end;

 {Get Handle}
 Entry:=HandleGet(sem^);
 if Entry = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;

   Exit;
  end;

 {Wait Semaphore}
 ResultCode:=SemaphoreWaitEx(Entry^.Data,Timeout);
 if ResultCode = ERROR_SUCCESS then
  begin
   Result:=0;
  end
 else if ResultCode = ERROR_WAIT_TIMEOUT then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=ETIMEDOUT;
  end
 else
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
  end;
end;

{==============================================================================}

function sem_trywait(sem: Psem_t): int; cdecl;
{Try to lock (Wait for) a semaphore}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Entry:PHandleEntry;
 ResultCode:LongWord;
begin
 {}
 Result:=-1;

 {Check sem}
 if sem = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls sem_trywait (sem=' + PtrToHex(sem) + ')');
 {$ENDIF}

 {Get Handle}
 Entry:=HandleGet(sem^);
 if Entry = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;

   Exit;
  end;

 {Wait Semaphore}
 ResultCode:=SemaphoreWaitEx(Entry^.Data,0);
 if ResultCode = ERROR_SUCCESS then
  begin
   Result:=0;
  end
 else if ResultCode = ERROR_WAIT_TIMEOUT then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EAGAIN;
  end
 else
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
  end;
end;

{==============================================================================}

function sem_unlink(name: PChar): int; cdecl;
{Remove a named semaphore}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Entry:PHandleEntry;
 Handle:TSemaphoreHandle;
 ResultCode:LongWord;
begin
 {}
 Result:=-1;

 {Check name}
 if name = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls sem_unlink (name=' + StrPas(name) + ')');
 {$ENDIF}

 {Find Handle}
 Entry:=HandleFind(name);
 if Entry = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=ENOENT;

   Exit;
  end;

 {Get Semaphore}
 Handle:=Entry^.Data;

 {Destroy Handle}
 ResultCode:=HandleDestroy(Entry^.Handle);
 if ResultCode = ERROR_SUCCESS then
  begin
   {Destroy Semaphore}
   SemaphoreDestroy(Handle);

   {Return Result}
   Result:=0;
  end
 else if ResultCode = ERROR_IN_USE then
  begin
   {Return Result}
   Result:=0;
  end
 else
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
  end;
end;

{==============================================================================}

function sem_wait(sem: Psem_t): int; cdecl;
{Lock (Wait for) a semaphore}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Entry:PHandleEntry;
begin
 {}
 Result:=-1;

 {Check sem}
 if sem = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls sem_wait (sem=' + PtrToHex(sem) + ')');
 {$ENDIF}

 {Get Handle}
 Entry:=HandleGet(sem^);
 if Entry = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;

   Exit;
  end;

 {Wait Semaphore}
 if SemaphoreWait(Entry^.Data) <> ERROR_SUCCESS then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;

   Exit;
  end;

 Result:=0;
end;

{==============================================================================}
{==============================================================================}
{Syscalls Functions (Sockets)}
{$IFDEF SYSCALLS_EXPORT_SOCKETS}
function socket_get_error(error: int): int;
{Map a Socket error to a POSIX error}

{Note: Internal function, not intended to be called by applications}
begin
 {}
 Result:=EINVAL;

 case error of
  {Windows Sockets definitions of regular Microsoft C error constants}
  WSAEINTR..WSAEMFILE:Result:=error - WSABASEERR;

  {Windows Sockets definitions of regular Berkeley error constants}
  WSAEWOULDBLOCK:Result:=EWOULDBLOCK;
  WSAEINPROGRESS:Result:=EINPROGRESS;
  WSAEALREADY:Result:=EALREADY;
  WSAENOTSOCK:Result:=ENOTSOCK;
  WSAEDESTADDRREQ:Result:=EDESTADDRREQ;
  WSAEMSGSIZE:Result:=EMSGSIZE;
  WSAEPROTOTYPE:Result:=EPROTOTYPE;
  WSAENOPROTOOPT:Result:=ENOPROTOOPT;
  WSAEPROTONOSUPPORT:Result:=EPROTONOSUPPORT;
  WSAESOCKTNOSUPPORT:Result:=ESOCKTNOSUPPORT;
  WSAEOPNOTSUPP:Result:=EOPNOTSUPP;
  WSAEPFNOSUPPORT:Result:=EPFNOSUPPORT;
  WSAEAFNOSUPPORT:Result:=EAFNOSUPPORT;
  WSAEADDRINUSE:Result:=EADDRINUSE;
  WSAEADDRNOTAVAIL:Result:=EADDRNOTAVAIL;
  WSAENETDOWN:Result:=ENETDOWN;
  WSAENETUNREACH:Result:=ENETUNREACH;
  WSAENETRESET:Result:=ENETRESET;
  WSAECONNABORTED:Result:=ECONNABORTED;
  WSAECONNRESET:Result:=ECONNRESET;
  WSAENOBUFS:Result:=ENOBUFS;
  WSAEISCONN:Result:=EISCONN;
  WSAENOTCONN:Result:=ENOTCONN;
  WSAESHUTDOWN:Result:=ESHUTDOWN;
  WSAETOOMANYREFS:Result:=ETOOMANYREFS;
  WSAETIMEDOUT:Result:=ETIMEDOUT;
  WSAECONNREFUSED:Result:=ECONNREFUSED;
  WSAELOOP:Result:=ELOOP;
  WSAENAMETOOLONG:Result:=ENAMETOOLONG;
  WSAEHOSTDOWN:Result:=EHOSTDOWN;
  WSAEHOSTUNREACH:Result:=EHOSTUNREACH;
  WSAENOTEMPTY:Result:=ENOTEMPTY;
  WSAEPROCLIM:Result:=EPROCLIM;
  WSAEUSERS:Result:=EUSERS;
  WSAEDQUOT:Result:=EDQUOT;
  WSAESTALE:Result:=ESTALE;
  WSAEREMOTE:Result:=EREMOTE;
  WSAEDISCON:Result:=ENOTCONN;

  {Extended Windows Sockets error constant definitions}
  WSASYSNOTREADY:Result:=EIO;
  WSAVERNOTSUPPORTED:Result:=ENOTSUP;
  WSANOTINITIALISED:Result:=EIO;

  WSAENOMORE:Result:=ENOMEM;
  WSAECANCELLED:Result:=ECANCELED;
  WSAEINVALIDPROCTABLE:Result:=EINVAL;
  WSAEINVALIDPROVIDER:Result:=EINVAL;
  WSAEPROVIDERFAILEDINIT:Result:=EFAULT;
  WSASYSCALLFAILURE:Result:=EFAULT;
  WSASERVICE_NOT_FOUND:Result:=ESRCH;
  WSATYPE_NOT_FOUND:Result:=ESRCH;
  WSA_E_NO_MORE:Result:=ENOMEM;
  WSA_E_CANCELLED:Result:=ECANCELED;
  WSAEREFUSED:Result:=ECONNREFUSED;

  WSA_INVALID_PARAMETER:Result:=ENOSPC;
 end;
end;

{==============================================================================}

function socket_get_db_error(error: int): int;
{Map a Socket error to a NetDB error returned by gethostbyaddr, gethostbyname etc}

{Note: Internal function, not intended to be called by applications}
begin
 {}
 Result:=NO_RECOVERY;

 case error of
  WSAHOST_NOT_FOUND:Result:=HOST_NOT_FOUND;
  WSATRY_AGAIN:Result:=TRY_AGAIN;
  WSANO_RECOVERY:Result:=NO_RECOVERY;
  WSANO_DATA:Result:=NO_DATA;
 end;
end;

{==============================================================================}

function socket_get_eai_error(error: int): int;
{Map a Socket error to a EAI error returned by getaddrinfo and getnameinfo}

{Note: Internal function, not intended to be called by applications}
begin
 {}
 Result:=EAI_SYSTEM;

 case error of
  {Windows Sockets definitions of RFC 3493 error constants}
  WSATRY_AGAIN:Result:=EAI_AGAIN;
  WSAEINVAL:Result:=EAI_BADFLAGS;
  WSANO_RECOVERY:Result:=EAI_FAIL;
  WSAEAFNOSUPPORT:Result:=EAI_FAMILY;
  WSA_NOT_ENOUGH_MEMORY:Result:=EAI_MEMORY;
  WSAHOST_NOT_FOUND:Result:=EAI_NONAME;
  WSATYPE_NOT_FOUND:Result:=EAI_SERVICE;
  WSAESOCKTNOSUPPORT:Result:=EAI_SOCKTYPE;
 end;
end;

{==============================================================================}

function socket_accept(socket: int; address: P_sockaddr; address_len: Psocklen_t): int; cdecl;
{Accept a new connection on a socket}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Handle:TSocket;
 SockAddr:PSockAddr;
 SockAddrBuf:LongInt;
 SockAddrLen:PLongInt;
 Entry:PSyscallsEntry;
begin
 {}
 Result:=SOCKET_ERROR;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls accept (socket=' + IntToHex(socket,8) + ' address=' + PtrToHex(address) + ' address_len=' + PtrToHex(address_len) + ')');
 {$ENDIF}

 {Get Entry}
 Entry:=SyscallsGetEntry(socket);
 if (Entry <> nil) and (Entry^.Source = SYSCALLS_ENTRY_SOCKET) then
  begin
   {Allocate Address}
   if not SyscallsAllocateWinsock(address,address_len,@SockAddrBuf,SockAddr,SockAddrLen) then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EINVAL;
     Exit;
    end;

   {Accept Socket}
   Handle:=Sockets.fpaccept(Entry^.Handle,SockAddr,SockAddrLen);
   if Handle = Integer(INVALID_SOCKET) then
    begin
     {Free Address}
     if SockAddr <> nil then FreeMem(SockAddr);

     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=socket_get_error(Sockets.SocketError());
     Exit;
    end;

   {Add Entry}
   Entry:=SyscallsAddEntry(Handle,SYSCALLS_ENTRY_SOCKET,SYSCALLS_INVALID_FILENO,SYSCALLS_INVALID_FILENO);
   if Entry = nil then
    begin
     {Close Socket}
     Sockets.CloseSocket(Handle);

     {Free Address}
     if SockAddr <> nil then FreeMem(SockAddr);

     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=ENOMEM;
     Exit;
    end;

   {Convert Address}
   if not SyscallsWinsockToSockAddr(SockAddr,SockAddrLen,address,address_len) then
    begin
     {Close Socket}
     Sockets.CloseSocket(Handle);

     {Free Address}
     if SockAddr <> nil then FreeMem(SockAddr);

     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EFAULT;
     Exit;
    end;

   {Free Address}
   if SockAddr <> nil then FreeMem(SockAddr);

   {Return Result}
   Result:=Entry^.Number;
  end
 else
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EBADF;
  end;
end;

{==============================================================================}

function socket_bind(socket: int; const address: P_sockaddr; address_len: socklen_t): int; cdecl;
{Bind a name to a socket}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 SockAddr:PSockAddr;
 SockAddrBuf:LongInt;
 SockAddrLen:PLongInt;
 Entry:PSyscallsEntry;
begin
 {}
 Result:=SOCKET_ERROR;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls bind (socket=' + IntToHex(socket,8) + ' address=' + PtrToHex(address) + ' address_len=' + IntToStr(address_len) + ')');
 {$ENDIF}

 {Get Entry}
 Entry:=SyscallsGetEntry(socket);
 if (Entry <> nil) and (Entry^.Source = SYSCALLS_ENTRY_SOCKET) then
  begin
   {Allocate Address}
   if (address = nil) or not SyscallsAllocateWinsock(address,@address_len,@SockAddrBuf,SockAddr,SockAddrLen) then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EINVAL;
     Exit;
    end;

   {Convert Address}
   if not SyscallsSockAddrToWinsock(address,@address_len,SockAddr,SockAddrLen) then
    begin
     {Free Address}
     if SockAddr <> nil then FreeMem(SockAddr);

     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EFAULT;
     Exit;
    end;

   {Bind Socket}
   Result:=Sockets.fpbind(Entry^.Handle,SockAddr,SockAddrLen^);
   if Result = SOCKET_ERROR then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=socket_get_error(Sockets.SocketError());
    end;

   {Free Address}
   if SockAddr <> nil then FreeMem(SockAddr);
  end
 else
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EBADF;
  end;
end;

{==============================================================================}

function socket_connect(socket: int; const address: P_sockaddr; address_len: socklen_t): int; cdecl;
{Connect a socket}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 SockAddr:PSockAddr;
 SockAddrBuf:LongInt;
 SockAddrLen:PLongInt;
 Entry:PSyscallsEntry;
begin
 {}
 Result:=SOCKET_ERROR;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls connect (socket=' + IntToHex(socket,8) + ' address=' + PtrToHex(address) + ' address_len=' + IntToStr(address_len) + ')');
 {$ENDIF}

 {Get Entry}
 Entry:=SyscallsGetEntry(socket);
 if (Entry <> nil) and (Entry^.Source = SYSCALLS_ENTRY_SOCKET) then
  begin
   {Allocate Address}
   if (address = nil) or not SyscallsAllocateWinsock(address,@address_len,@SockAddrBuf,SockAddr,SockAddrLen) then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EINVAL;
     Exit;
    end;

   {Convert Address}
   if not SyscallsSockAddrToWinsock(address,@address_len,SockAddr,SockAddrLen) then
    begin
     {Free Address}
     if SockAddr <> nil then FreeMem(SockAddr);

     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EFAULT;
     Exit;
    end;

   {Connect Socket}
   Result:=Sockets.fpconnect(Entry^.Handle,SockAddr,SockAddrLen^);
   if Result = SOCKET_ERROR then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=socket_get_error(Sockets.SocketError());
    end;

   {Free Address}
   if SockAddr <> nil then FreeMem(SockAddr);
  end
 else
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EBADF;
  end;
end;

{==============================================================================}

function socket_getpeername(socket: int; address: P_sockaddr; address_len: Psocklen_t): int; cdecl;
{Get the name of the peer socket}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 SockAddr:PSockAddr;
 SockAddrBuf:LongInt;
 SockAddrLen:PLongInt;
 Entry:PSyscallsEntry;
begin
 {}
 Result:=SOCKET_ERROR;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls getpeername (socket=' + IntToHex(socket,8) + ' address=' + PtrToHex(address) + ' address_len=' + PtrToHex(address_len) + ')');
 {$ENDIF}

 {Get Entry}
 Entry:=SyscallsGetEntry(socket);
 if (Entry <> nil) and (Entry^.Source = SYSCALLS_ENTRY_SOCKET) then
  begin
   {Allocate Address}
   if (address = nil) or not SyscallsAllocateWinsock(address,address_len,@SockAddrBuf,SockAddr,SockAddrLen) then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EINVAL;
     Exit;
    end;

   {Get Peer Name}
   Result:=Sockets.fpgetpeername(Entry^.Handle,SockAddr,SockAddrLen);
   if Result = SOCKET_ERROR then
    begin
     {Free Address}
     if SockAddr <> nil then FreeMem(SockAddr);

     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=socket_get_error(Sockets.SocketError());
     Exit;
    end;

   {Convert Address}
   if not SyscallsWinsockToSockAddr(SockAddr,SockAddrLen,address,address_len) then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EFAULT;
    end;

   {Free Address}
   if SockAddr <> nil then FreeMem(SockAddr);
  end
 else
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EBADF;
  end;
end;

{==============================================================================}

function socket_getsockname(socket: int; address: P_sockaddr; address_len: Psocklen_t): int; cdecl;
{Get the socket name}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 SockAddr:PSockAddr;
 SockAddrBuf:LongInt;
 SockAddrLen:PLongInt;
 Entry:PSyscallsEntry;
begin
 {}
 Result:=SOCKET_ERROR;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls getsockname (socket=' + IntToHex(socket,8) + ' address=' + PtrToHex(address) + ' address_len=' + PtrToHex(address_len) + ')');
 {$ENDIF}

 {Get Entry}
 Entry:=SyscallsGetEntry(socket);
 if (Entry <> nil) and (Entry^.Source = SYSCALLS_ENTRY_SOCKET) then
  begin
   {Allocate Address}
   if (address = nil) or not SyscallsAllocateWinsock(address,address_len,@SockAddrBuf,SockAddr,SockAddrLen) then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EINVAL;
     Exit;
    end;

   {Get Sock Name}
   Result:=Sockets.fpgetsockname(Entry^.Handle,SockAddr,SockAddrLen);
   if Result = SOCKET_ERROR then
    begin
     {Free Address}
     if SockAddr <> nil then FreeMem(SockAddr);

     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=socket_get_error(Sockets.SocketError());
     Exit;
    end;

   {Convert Address}
   if not SyscallsWinsockToSockAddr(SockAddr,SockAddrLen,address,address_len) then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EFAULT;
    end;

   {Free Address}
   if SockAddr <> nil then FreeMem(SockAddr);
  end
 else
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EBADF;
  end;
end;

{==============================================================================}

function socket_getsockopt(socket: int; level, option_name: int; option_value: Pointer; option_len: Psocklen_t): int; cdecl;
{Get the socket options}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Entry:PSyscallsEntry;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls getsockopt (socket=' + IntToHex(socket,8) + ' level=' + IntToStr(level) + ' option_name=' + IntToStr(option_name) + ' option_value=' + PtrToHex(option_value) + ' option_len=' + PtrToHex(option_len) + ')');
 {$ENDIF}

 {Get Entry}
 Entry:=SyscallsGetEntry(socket);
 if (Entry <> nil) and (Entry^.Source = SYSCALLS_ENTRY_SOCKET) then
  begin
   {Get Socket Option}
   Result:=Sockets.fpgetsockopt(Entry^.Handle,level,option_name,option_value,psocklen(option_len));
   if Result = SOCKET_ERROR then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=socket_get_error(Sockets.SocketError());
    end;
  end
 else
  begin
   Result:=SOCKET_ERROR;

   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EBADF;
  end;
end;

{==============================================================================}

function socket_listen(socket: int; backlog: int): int; cdecl;
{Listen for socket connections and limit the queue of incoming connections}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Entry:PSyscallsEntry;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls listen (socket=' + IntToHex(socket,8) + ' backlog=' + IntToStr(backlog) + ')');
 {$ENDIF}

 {Get Entry}
 Entry:=SyscallsGetEntry(socket);
 if (Entry <> nil) and (Entry^.Source = SYSCALLS_ENTRY_SOCKET) then
  begin
   {Listen Socket}
   Result:=Sockets.fplisten(Entry^.Handle,backlog);
   if Result = SOCKET_ERROR then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=socket_get_error(Sockets.SocketError());
    end;
  end
 else
  begin
   Result:=SOCKET_ERROR;

   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EBADF;
  end;
end;

{==============================================================================}

function socket_recv(socket: int; buffer: Pointer; len: size_t; flags: int): ssize_t; cdecl;
{Receive a message from a connected socket}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Entry:PSyscallsEntry;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls recv (socket=' + IntToHex(socket,8) + ' buffer=' + PtrToHex(buffer) + ' len=' + IntToStr(len) + ' flags=' + IntToHex(flags,8) + ')');
 {$ENDIF}

 {Get Entry}
 Entry:=SyscallsGetEntry(socket);
 if (Entry <> nil) and (Entry^.Source = SYSCALLS_ENTRY_SOCKET) then
  begin
   {Recv Socket}
   Result:=Sockets.fprecv(Entry^.Handle,buffer,len,flags);
   if Result = SOCKET_ERROR then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=socket_get_error(Sockets.SocketError());
    end;
  end
 else
  begin
   Result:=SOCKET_ERROR;

   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EBADF;
  end;
end;

{==============================================================================}

function socket_recvfrom(socket: int; buffer: Pointer; len: size_t; flags: int; address: P_sockaddr; address_len: Psocklen_t): ssize_t; cdecl;
{Receive a message from a socket}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 SockAddr:PSockAddr;
 SockAddrBuf:LongInt;
 SockAddrLen:PLongInt;
 Entry:PSyscallsEntry;
begin
 {}
 Result:=SOCKET_ERROR;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls recv (socket=' + IntToHex(socket,8) + ' buffer=' + PtrToHex(buffer) + ' len=' + IntToStr(len) + ' flags=' + IntToHex(flags,8) + ' address=' + PtrToHex(address) + ' address_len=' + PtrToHex(address_len) + ')');
 {$ENDIF}

 {Get Entry}
 Entry:=SyscallsGetEntry(socket);
 if (Entry <> nil) and (Entry^.Source = SYSCALLS_ENTRY_SOCKET) then
  begin
   {Allocate Address}
   if not SyscallsAllocateWinsock(address,address_len,@SockAddrBuf,SockAddr,SockAddrLen) then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EINVAL;
     Exit;
    end;

   {Recv From Socket}
   Result:=Sockets.fprecvfrom(Entry^.Handle,buffer,len,flags,SockAddr,SockAddrLen);
   if Result = SOCKET_ERROR then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=socket_get_error(Sockets.SocketError());
     Exit;
    end;

   {Convert Address}
   if not SyscallsWinsockToSockAddr(SockAddr,SockAddrLen,address,address_len) then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EFAULT;
    end;

   {Free Address}
   if SockAddr <> nil then FreeMem(SockAddr);
  end
 else
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EBADF;
  end;
end;

{==============================================================================}

function socket_recvmsg(socket: int; msg: Pmsghdr; flags: int): ssize_t; cdecl;
{Receive a message from a socket}
{Note: The msg_control and msg_controllen fields of msg parameter are currently ignored}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Count:ssize_t;
 Total:ssize_t;
 Status:ssize_t;
 Vector:Piovec;
 SockAddr:PSockAddr;
 SockAddrBuf:LongInt;
 SockAddrLen:PLongInt;
 Entry:PSyscallsEntry;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls recvmsg (socket=' + IntToHex(socket,8) + ' msg=' + PtrToHex(msg) + ' flags=' + IntToHex(flags,8) + ')');
 {$ENDIF}

 {Get Entry}
 Entry:=SyscallsGetEntry(socket);
 if (Entry <> nil) and (Entry^.Source = SYSCALLS_ENTRY_SOCKET) then
  begin
   {Check Message}
   if msg = nil then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EFAULT;
     Exit;
    end;

   {Check Vector and Length}
   if (msg^.msg_iov = nil) or (msg^.msg_iovlen = 0) then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EINVAL;
     Exit;
    end;

   {Check Name and Namelen}
   if (msg^.msg_name = nil) and (msg^.msg_namelen <> 0) then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EINVAL;
     Exit;
    end;

   {Check Control Buffer and Length}
   if (msg^.msg_control = nil) and (msg^.msg_controllen <> 0) then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EINVAL;
     Exit;
    end;

   {Allocate Address}
   if not SyscallsAllocateWinsock(msg^.msg_name,@msg^.msg_namelen,@SockAddrBuf,SockAddr,SockAddrLen) then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EINVAL;
     Exit;
    end;

   {Get Start}
   Count:=0;
   Total:=0;
   Vector:=msg^.msg_iov;

   {Process Vectors}
   while Count < msg^.msg_iovlen do
    begin
     {Check Vector}
     if Vector^.iov_base = nil then
      begin
       {Return Error}
       ptr:=__getreent;
       if ptr <> nil then ptr^._errno:=EFAULT;
       Exit;
      end;

     {Receive Vector}
     Status:=Sockets.fprecvfrom(Entry^.Handle,Vector^.iov_base,Vector^.iov_len,flags,SockAddr,SockAddrLen);
     if Status = SOCKET_ERROR then
      begin
       {Return Error}
       ptr:=__getreent;
       if ptr <> nil then ptr^._errno:=socket_get_error(Sockets.SocketError());
       Exit;
      end;

     {Update Total}
     Inc(Total,Status);

     {Check Received}
     if Status < Vector^.iov_len then Break;

     {Get Next}
     Inc(Count);
     Inc(Vector);
    end;

   {Convert Address}
   if not SyscallsWinsockToSockAddr(SockAddr,SockAddrLen,msg^.msg_name,@msg^.msg_namelen) then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EFAULT;
    end;

   {Free Address}
   if SockAddr <> nil then FreeMem(SockAddr);

   {Return Result}
   Result:=Total;
  end
 else
  begin
   Result:=SOCKET_ERROR;

   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EBADF;
  end;
end;

{==============================================================================}

function socket_send(socket: int; const buffer: Pointer; len: size_t; flags: int): ssize_t; cdecl;
{Send a message on a socket}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Entry:PSyscallsEntry;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls send (socket=' + IntToHex(socket,8) + ' buffer=' + PtrToHex(buffer) + ' len=' + IntToStr(len) + ' flags=' + IntToHex(flags,8) + ')');
 {$ENDIF}

 {Get Entry}
 Entry:=SyscallsGetEntry(socket);
 if (Entry <> nil) and (Entry^.Source = SYSCALLS_ENTRY_SOCKET) then
  begin
   {Send Socket}
   Result:=Sockets.fpsend(Entry^.Handle,buffer,len,flags);
   if Result = SOCKET_ERROR then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=socket_get_error(Sockets.SocketError());
    end;
  end
 else
  begin
   Result:=SOCKET_ERROR;

   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EBADF;
  end;
end;

{==============================================================================}

function socket_sendto(socket: int; const buffer: Pointer; len: size_t; flags: int; dest_addr: P_sockaddr; dest_len: socklen_t): ssize_t; cdecl;
{Send a message on a socket}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 SockAddr:PSockAddr;
 SockAddrBuf:LongInt;
 SockAddrLen:PLongInt;
 Entry:PSyscallsEntry;
begin
 {}
 Result:=SOCKET_ERROR;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls sendto (socket=' + IntToHex(socket,8) + ' buffer=' + PtrToHex(buffer) + ' len=' + IntToStr(len) + ' flags=' + IntToHex(flags,8) + ' dest_addr=' + PtrToHex(dest_addr) + ' dest_len=' + IntToStr(dest_len) + ')');
 {$ENDIF}

 {Get Entry}
 Entry:=SyscallsGetEntry(socket);
 if (Entry <> nil) and (Entry^.Source = SYSCALLS_ENTRY_SOCKET) then
  begin
   {Allocate Address}
   if not SyscallsAllocateWinsock(dest_addr,@dest_len,@SockAddrBuf,SockAddr,SockAddrLen) then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EINVAL;
     Exit;
    end;

   {Convert Address}
   if not SyscallsSockAddrToWinsock(dest_addr,@dest_len,SockAddr,SockAddrLen) then
    begin
     {Free Address}
     if SockAddr <> nil then FreeMem(SockAddr);

     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EFAULT;
     Exit;
    end;

   {Send To Socket}
   Result:=Sockets.fpsendto(Entry^.Handle,buffer,len,flags,SockAddr,SockAddrLen^);
   if Result = SOCKET_ERROR then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=socket_get_error(Sockets.SocketError());
    end;

   {Free Address}
   if SockAddr <> nil then FreeMem(SockAddr);
  end
 else
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EBADF;
  end;
end;

{==============================================================================}

function socket_sendmsg(socket: int; const msg: Pmsghdr; flags: int): ssize_t; cdecl;
{Send a message on a socket}
{Note: The msg_control and msg_controllen fields of msg parameter are currently ignored}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Count:ssize_t;
 Total:ssize_t;
 Status:ssize_t;
 Vector:Piovec;
 SockAddr:PSockAddr;
 SockAddrBuf:LongInt;
 SockAddrLen:PLongInt;
 Entry:PSyscallsEntry;
begin
 {}
 Result:=SOCKET_ERROR;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls sendmsg (socket=' + IntToHex(socket,8) + ' msg=' + PtrToHex(msg) + ' flags=' + IntToHex(flags,8) + ')');
 {$ENDIF}

 {Get Entry}
 Entry:=SyscallsGetEntry(socket);
 if (Entry <> nil) and (Entry^.Source = SYSCALLS_ENTRY_SOCKET) then
  begin
   {Check Message}
   if msg = nil then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EFAULT;
     Exit;
    end;

   {Check Vector and Length}
   if (msg^.msg_iov = nil) or (msg^.msg_iovlen = 0) then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EINVAL;
     Exit;
    end;

   {Check Name and Namelen}
   if (msg^.msg_name = nil) and (msg^.msg_namelen <> 0) then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EINVAL;
     Exit;
    end;

   {Check Control Buffer and Length}
   if (msg^.msg_control = nil) and (msg^.msg_controllen <> 0) then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EINVAL;
     Exit;
    end;

   {Allocate Address}
   if not SyscallsAllocateWinsock(msg^.msg_name,@msg^.msg_namelen,@SockAddrBuf,SockAddr,SockAddrLen) then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EINVAL;
     Exit;
    end;

   {Convert Address}
   if not SyscallsSockAddrToWinsock(msg^.msg_name,@msg^.msg_namelen,SockAddr,SockAddrLen) then
    begin
     {Free Address}
     if SockAddr <> nil then FreeMem(SockAddr);

     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EFAULT;
     Exit;
    end;

   {Get Start}
   Count:=0;
   Total:=0;
   Vector:=msg^.msg_iov;

   {Process Vectors}
   while Count < msg^.msg_iovlen do
    begin
     {Check Vector}
     if Vector^.iov_base = nil then
      begin
       {Return Error}
       ptr:=__getreent;
       if ptr <> nil then ptr^._errno:=EFAULT;
       Exit;
      end;

     {Send Vector}
     Status:=Sockets.fpsendto(Entry^.Handle,Vector^.iov_base,Vector^.iov_len,flags,SockAddr,SockAddrLen^);
     if Status = SOCKET_ERROR then
      begin
       {Return Error}
       ptr:=__getreent;
       if ptr <> nil then ptr^._errno:=socket_get_error(Sockets.SocketError());
       Exit;
      end;

     {Update Total}
     Inc(Total,Status);

     {Check Sent}
     if Status < Vector^.iov_len then Break;

     {Get Next}
     Inc(Count);
     Inc(Vector);
    end;

   {Free Address}
   if SockAddr <> nil then FreeMem(SockAddr);

   {Return Result}
   Result:=Total;
  end
 else
  begin
   Result:=SOCKET_ERROR;

   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EBADF;
  end;
end;

{==============================================================================}

function socket_setsockopt(socket: int; level, option_name: int; const option_value: Pointer; option_len: socklen_t): int; cdecl;
{Set the socket options}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Entry:PSyscallsEntry;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls setsockopt (socket=' + IntToHex(socket,8) + ' level=' + IntToStr(level) + ' option_name=' + IntToStr(option_name) + ' option_value=' + PtrToHex(option_value) + ' option_len=' + IntToStr(option_len) + ')');
 {$ENDIF}

 {Get Entry}
 Entry:=SyscallsGetEntry(socket);
 if (Entry <> nil) and (Entry^.Source = SYSCALLS_ENTRY_SOCKET) then
  begin
   {Set Socket Option}
   Result:=Sockets.fpsetsockopt(Entry^.Handle,level,option_name,option_value,option_len);
   if Result = SOCKET_ERROR then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=socket_get_error(Sockets.SocketError());
    end;
  end
 else
  begin
   Result:=SOCKET_ERROR;

   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EBADF;
  end;
end;

{==============================================================================}

function socket_shutdown(socket: int; how: int): int; cdecl;
{Shut down socket send and receive operations}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Entry:PSyscallsEntry;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls shutdown (socket=' + IntToHex(socket,8) + ' how=' + IntToStr(how) + ')');
 {$ENDIF}

 {Get Entry}
 Entry:=SyscallsGetEntry(socket);
 if (Entry <> nil) and (Entry^.Source = SYSCALLS_ENTRY_SOCKET) then
  begin
   {Shutdown Socket}
   Result:=Sockets.fpshutdown(Entry^.Handle,how);
   if Result = SOCKET_ERROR then
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=socket_get_error(Sockets.SocketError());
    end;
  end
 else
  begin
   Result:=SOCKET_ERROR;

   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EBADF;
  end;
end;

{==============================================================================}

function socket_socket(domain, sockettype, protocol: int): int; cdecl;
{Create an endpoint for communication}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Handle:TSocket;
 Entry:PSyscallsEntry;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls socket (domain=' + IntToStr(domain) + ' type=' + IntToStr(sockettype) + ' protocol=' + IntToStr(protocol) + ')');
 {$ENDIF}

 Result:=SOCKET_ERROR;

 {Create Socket}
 Handle:=Sockets.fpsocket(domain,sockettype,protocol);
 if Handle = Integer(INVALID_SOCKET) then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=socket_get_error(Sockets.SocketError());
   Exit;
  end;

 {Add Entry}
 Entry:=SyscallsAddEntry(Handle,SYSCALLS_ENTRY_SOCKET,SYSCALLS_INVALID_FILENO,SYSCALLS_INVALID_FILENO);
 if Entry = nil then
  begin
   {Close Socket}
   Sockets.CloseSocket(Handle);

   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=ENOMEM;
   Exit;
  end;

 {Return Result}
 Result:=Entry^.Number;
end;

{==============================================================================}

function socket_socketpair(domain, sockettype, protocol: int; socket_vector: Pint): int; cdecl;
{Create a pair of connected sockets}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Pair:TSockArray;
 Entry1:PSyscallsEntry;
 Entry2:PSyscallsEntry;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls socketpair (domain=' + IntToStr(domain) + ' type=' + IntToStr(sockettype) + ' protocol=' + IntToStr(protocol) + ' socket_vector=' + PtrToHex(socket_vector) + ')');
 {$ENDIF}

 {Create Socket Pair}
 Result:=Sockets.fpsocketpair(domain,sockettype,protocol,@Pair[1]);
 if Result = SOCKET_ERROR then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=socket_get_error(Sockets.SocketError());
   Exit;
  end;

 {Add First Entry}
 Entry1:=SyscallsAddEntry(Pair[1],SYSCALLS_ENTRY_SOCKET,SYSCALLS_INVALID_FILENO,SYSCALLS_INVALID_FILENO);
 if Entry1 = nil then
  begin
   {Close Socket}
   Sockets.CloseSocket(Pair[1]);

   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=ENOMEM;
   Exit;
  end;

 {Add Second Entry}
 Entry2:=SyscallsAddEntry(Pair[2],SYSCALLS_ENTRY_SOCKET,SYSCALLS_INVALID_FILENO,SYSCALLS_INVALID_FILENO);
 if Entry2 = nil then
  begin
   {Remove First Entry}
   SyscallsRemoveEntry(Entry1);

   {Close Sockets}
   Sockets.CloseSocket(Pair[1]);
   Sockets.CloseSocket(Pair[2]);

   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=ENOMEM;
   Exit;
  end;

 {Return Results}
 socket_vector[0]:=Entry1^.Number;
 socket_vector[1]:=Entry2^.Number;
end;

{==============================================================================}

function socket_select(nfds: int; readfds, writefds, exceptfds: Pfd_set; timeout: Ptimeval): int; cdecl;
{Perform synchronous I/O multiplexing on one or more sockets}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 fd:int;
 ptr:P_reent;
 Count:u_int;
 ReadFDSet:TFDSet;
 WriteFDSet:TFDSet;
 ExceptFDSet:TFDSet;
 Entry:PSyscallsEntry;
 TimeVal:Sockets.TTimeVal;
 TimePtr:Sockets.PTimeVal;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls select (nfds=' + IntToStr(nfds) + ')');
 {$ENDIF}

 Result:=SOCKET_ERROR;

 {Check Nfds}
 if nfds < 0 then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
   Exit;
  end;
 if nfds > FD_SETSIZE then nfds:=FD_SETSIZE;

 {Check Read/Write/Except FDs}
 if (readfds = nil) and (writefds = nil) and (exceptfds = nil) then
  begin
   if timeout <> nil then
    begin
     {Sleep}
     ThreadSleep((timeout^.tv_sec * 1000) + (timeout^.tv_usec div 1000));

     {Return Zero}
     Result:=0;
    end
   else
    begin
     {Return Error}
     ptr:=__getreent;
     if ptr <> nil then ptr^._errno:=EINVAL;
    end;

   Exit;
  end;

 {Clear Read/Write/Except FDs}
 fpFD_ZERO(ReadFDSet);
 fpFD_ZERO(WriteFDSet);
 fpFD_ZERO(ExceptFDSet);

 {Convert Read/Write/Except FDs}
 for fd:=0 to nfds - 1 do
  begin
   {Check Read FDs}
   if (readfds <> nil) and (FD_ISSET(fd,readfds^) = 1) then
    begin
     {Get Entry}
     Entry:=SyscallsGetEntry(fd);
     if (Entry <> nil) and (Entry^.Source = SYSCALLS_ENTRY_SOCKET) then
      begin
       {Set Read FD}
       fpFD_SET(Entry^.Handle,ReadFDSet);
      end;
    end;

   {Check Write FDs}
   if (writefds <> nil) and (FD_ISSET(fd,writefds^) = 1) then
    begin
     {Get Entry}
     Entry:=SyscallsGetEntry(fd);
     if (Entry <> nil) and (Entry^.Source = SYSCALLS_ENTRY_SOCKET) then
      begin
       {Set Write FD}
       fpFD_SET(Entry^.Handle,WriteFDSet);
      end;
    end;

   {Check Except FDs}
   if (exceptfds <> nil) and (FD_ISSET(fd,exceptfds^) = 1) then
    begin
     {Get Entry}
     Entry:=SyscallsGetEntry(fd);
     if (Entry <> nil) and (Entry^.Source = SYSCALLS_ENTRY_SOCKET) then
      begin
       {Set Except FD}
       fpFD_SET(Entry^.Handle,ExceptFDSet);
      end;
    end;
  end;

 {Check Timeout}
 TimePtr:=nil;
 if timeout <> nil then
  begin
   {Convert Timeout}
   TimeVal.tv_sec:=timeout^.tv_sec;
   TimeVal.tv_usec:=timeout^.tv_usec;

   TimePtr:=@TimeVal;
  end;

 {Select Socket}
 Result:=Sockets.fpselect(nfds,@ReadFDSet,@WriteFDSet,@ExceptFDSet,TimePtr);
 if Result = SOCKET_ERROR then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=socket_get_error(Sockets.SocketError());
   Exit;
  end;

 if readfds <> nil then
  begin
   {Clear Read FDs}
   FD_ZERO(readfds^);

   {Update Read FDs}
   if ReadFDSet.fd_count > 0 then
    begin
     for Count:=0 to ReadFDSet.fd_count - 1 do
      begin
       {Find Entry}
       Entry:=SyscallsFindEntry(ReadFDSet.fd_array[Count]);
       if (Entry <> nil) and (Entry^.Source = SYSCALLS_ENTRY_SOCKET) then
        begin
         {Set Read FD}
         FD_SET(Entry^.Number,readfds^);
        end;
      end;
    end;
  end;

 if writefds <> nil then
  begin
   {Clear Write FDs}
   FD_ZERO(writefds^);

   {Update Write FDs}
   if WriteFDSet.fd_count > 0 then
    begin
     for Count:=0 to WriteFDSet.fd_count - 1 do
      begin
       {Find Entry}
       Entry:=SyscallsFindEntry(WriteFDSet.fd_array[Count]);
       if (Entry <> nil) and (Entry^.Source = SYSCALLS_ENTRY_SOCKET) then
        begin
         {Set Write FD}
         FD_SET(Entry^.Number,writefds^);
        end;
      end;
    end;
  end;

 if exceptfds <> nil then
  begin
   {Clear Except FDs}
   FD_ZERO(exceptfds^);

   {Update Except FDs}
   if ExceptFDSet.fd_count > 0 then
    begin
     for Count:=0 to ExceptFDSet.fd_count - 1 do
      begin
       {Find Entry}
       Entry:=SyscallsFindEntry(ExceptFDSet.fd_array[Count]);
       if (Entry <> nil) and (Entry^.Source = SYSCALLS_ENTRY_SOCKET) then
        begin
         {Set Except FD}
         FD_SET(Entry^.Number,exceptfds^);
        end;
      end;
    end;
  end;
end;

{==============================================================================}

function socket_htonl(hostlong: uint32_t): uint32_t; cdecl;
{Convert values between host and network byte order}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=Sockets.htonl(hostlong);
end;

{==============================================================================}

function socket_htons(hostshort: uint16_t): uint16_t; cdecl;
{Convert values between host and network byte order}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=Sockets.htons(hostshort);
end;

{==============================================================================}

function socket_ntohl(netlong: uint32_t): uint32_t; cdecl;
{Convert values between host and network byte order}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=Sockets.ntohl(netlong);
end;

{==============================================================================}

function socket_ntohs(netshort: uint16_t): uint16_t; cdecl;
{Convert values between host and network byte order}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=Sockets.ntohs(netshort);
end;

{==============================================================================}

function socket_inet_addr(cp: PChar): in_addr_t; cdecl;
{IPv4 address manipulation}
{Note: Address will be returned in network order}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=Sockets.Inet_Addr(cp);
end;
{==============================================================================}

function socket_inet_ntoa(inaddr: T_in_addr): PChar; cdecl;
{IPv4 address manipulation}
{Note: Address will be in network order}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=Sockets.Inet_Ntoa(TInAddr(inaddr));
end;

{==============================================================================}

function socket_inet_aton(cp: PChar; inaddr: P_in_addr): int; cdecl;
{IPv4 address manipulation}
{Note: Address will be returned in network order}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 Result:=Sockets.Inet_Aton(cp,PInAddr(inaddr));
 if Result = 0 then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=socket_get_error(Sockets.SocketError());
  end;
end;

{==============================================================================}

function socket_inet_pton(af: int; src: PChar; dst: Pointer): int; cdecl;
{Convert IPv4 and IPv6 addresses from text to binary form}
{Note: Dest will be returned in network order where applicable}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 Result:=Sockets.Inet_Pton(af,src,dst);
 if Result = SOCKET_ERROR then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=socket_get_error(Sockets.SocketError());
  end;
end;

{==============================================================================}

function socket_inet_ntop(af: int; src: Pointer; dst: PChar; size: socklen_t): PChar; cdecl;
{Convert IPv4 and IPv6 addresses from binary to text form}
{Note: Source will be in network order where applicable}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 Result:=Sockets.Inet_Ntop(af,src,dst,size);
 if Result = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=socket_get_error(Sockets.SocketError());
  end;
end;

{==============================================================================}

function socket_gethostbyaddr(addr: Pointer; len: socklen_t; family: int): P_hostent; cdecl;
{Network host database functions}
{Note: Address will be in network order where applicable}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 HostEnt:PHostEnt;
 Netdb:PSyscallsNetdb;
begin
 {}
 Result:=nil;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls gethostbyaddr (addr=' + PtrToHex(addr) + ' len=' + IntToStr(len) + ' family=' + IntToStr(family) + ')');
 {$ENDIF}

 HostEnt:=Sockets.GetHostByAddr(addr,len,family);
 if HostEnt <> nil then
  begin
   {Get TLS Value}
   Netdb:=ThreadGetTlsValue(SyscallsNetdbIndex);
   if Netdb = nil then
    begin
     {Allocate TLS Value}
     Netdb:=AllocMem(SyscallsNetdbSize);
     if Netdb = nil then Exit;

     {$IFDEF SYSCALLS_DEBUG}
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls gethostbyaddr (Allocated Netdb=' + PtrToHex(Netdb) + ')');
     {$ENDIF}

     {Set TLS Value}
     if ThreadSetTlsValue(SyscallsNetdbIndex,Netdb) <> ERROR_SUCCESS then Exit;
    end;

   {Get Host Ent}
   Result:=@Netdb^.HostEnt;

   {Update Host Ent}
   Result^.h_name:=HostEnt^.h_name;
   Result^.h_aliases:=HostEnt^.h_aliases;
   Result^.h_addrtype:=HostEnt^.h_addrtype;
   Result^.h_length:=HostEnt^.h_length;
   Result^.h_addr_list:=HostEnt^.h_addr_list;
  end
 else
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=socket_get_db_error(Sockets.SocketError());
  end;
end;

{==============================================================================}

function socket_gethostbyname(name: PChar): P_hostent; cdecl;
{Network host database functions}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 HostEnt:PHostEnt;
 Netdb:PSyscallsNetdb;
begin
 {}
 Result:=nil;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls gethostbyname (name=' + StrPas(name) + ')');
 {$ENDIF}

 HostEnt:=Sockets.GetHostByName(name);
 if HostEnt <> nil then
  begin
   {Get TLS Value}
   Netdb:=ThreadGetTlsValue(SyscallsNetdbIndex);
   if Netdb = nil then
    begin
     {Allocate TLS Value}
     Netdb:=AllocMem(SyscallsNetdbSize);
     if Netdb = nil then Exit;

     {$IFDEF SYSCALLS_DEBUG}
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls gethostbyname (Allocated Netdb=' + PtrToHex(Netdb) + ')');
     {$ENDIF}

     {Set TLS Value}
     if ThreadSetTlsValue(SyscallsNetdbIndex,Netdb) <> ERROR_SUCCESS then Exit;
    end;

   {Get Host Ent}
   Result:=@Netdb^.HostEnt;

   {Update Host Ent}
   Result^.h_name:=HostEnt^.h_name;
   Result^.h_aliases:=HostEnt^.h_aliases;
   Result^.h_addrtype:=HostEnt^.h_addrtype;
   Result^.h_length:=HostEnt^.h_length;
   Result^.h_addr_list:=HostEnt^.h_addr_list;
  end
 else
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=socket_get_db_error(Sockets.SocketError());
  end;
end;

{==============================================================================}

function socket_getnetbyaddr(net: uint32_t; family: int): P_netent; cdecl;
{Network database functions}
{Note: Net will be in host order where applicable}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 Addr:TInAddr;
 NetEnt:PNetEnt;
 Netdb:PSyscallsNetdb;
begin
 {}
 Result:=nil;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls getnetbyaddr (net=' + IntToHex(net,8) + ' family=' + IntToStr(family) + ')');
 {$ENDIF}

 {Convert to network order}
 Addr.S_addr:=htonl(net);

 NetEnt:=Sockets.GetNetByAddr(@Addr,SizeOf(TInAddr),family);
 if NetEnt <> nil then
  begin
   {Get TLS Value}
   Netdb:=ThreadGetTlsValue(SyscallsNetdbIndex);
   if Netdb = nil then
    begin
     {Allocate TLS Value}
     Netdb:=AllocMem(SyscallsNetdbSize);
     if Netdb = nil then Exit;

     {$IFDEF SYSCALLS_DEBUG}
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls getnetbyaddr (Allocated Netdb=' + PtrToHex(Netdb) + ')');
     {$ENDIF}

     {Set TLS Value}
     if ThreadSetTlsValue(SyscallsNetdbIndex,Netdb) <> ERROR_SUCCESS then Exit;
    end;

   {Get Net Ent}
   Result:=@Netdb^.NetEnt;

   {Update Net Ent}
   Result^.n_name:=NetEnt^.n_name;
   Result^.n_aliases:=NetEnt^.n_aliases;
   Result^.n_addrtype:=NetEnt^.n_addrtype;
   Result^.n_net:=ntohl(NetEnt^.n_net); {Convert to host order}
  end
 else
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=socket_get_db_error(Sockets.SocketError());
  end;
end;

{==============================================================================}

function socket_getnetbyname(name: PChar): P_netent; cdecl;
{Network database functions}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 NetEnt:PNetEnt;
 Netdb:PSyscallsNetdb;
begin
 {}
 Result:=nil;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls getnetbyname (name=' + StrPas(name) + ')');
 {$ENDIF}

 NetEnt:=Sockets.GetNetByName(name);
 if NetEnt <> nil then
  begin
   {Get TLS Value}
   Netdb:=ThreadGetTlsValue(SyscallsNetdbIndex);
   if Netdb = nil then
    begin
     {Allocate TLS Value}
     Netdb:=AllocMem(SyscallsNetdbSize);
     if Netdb = nil then Exit;

     {$IFDEF SYSCALLS_DEBUG}
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls getnetbyname (Allocated Netdb=' + PtrToHex(Netdb) + ')');
     {$ENDIF}

     {Set TLS Value}
     if ThreadSetTlsValue(SyscallsNetdbIndex,Netdb) <> ERROR_SUCCESS then Exit;
    end;

   {Get Net Ent}
   Result:=@Netdb^.NetEnt;

   {Update Net Ent}
   Result^.n_name:=NetEnt^.n_name;
   Result^.n_aliases:=NetEnt^.n_aliases;
   Result^.n_addrtype:=NetEnt^.n_addrtype;
   Result^.n_net:=ntohl(NetEnt^.n_net); {Convert to host order}
  end
 else
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=socket_get_db_error(Sockets.SocketError());
  end;
end;

{==============================================================================}

function socket_getservbyport(port: int; proto: PChar): P_servent; cdecl;
{Network services database functions}
{Note: Port will be in network order}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 ServEnt:PServEnt;
 Netdb:PSyscallsNetdb;
begin
 {}
 Result:=nil;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls getservbyport (port=' + IntToStr(port) + ' proto=' + StrPas(proto) + ')');
 {$ENDIF}

 ServEnt:=Sockets.GetServByPort(port,proto);
 if ServEnt <> nil then
  begin
   {Get TLS Value}
   Netdb:=ThreadGetTlsValue(SyscallsNetdbIndex);
   if Netdb = nil then
    begin
     {Allocate TLS Value}
     Netdb:=AllocMem(SyscallsNetdbSize);
     if Netdb = nil then Exit;

     {$IFDEF SYSCALLS_DEBUG}
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls getservbyport (Allocated Netdb=' + PtrToHex(Netdb) + ')');
     {$ENDIF}

     {Set TLS Value}
     if ThreadSetTlsValue(SyscallsNetdbIndex,Netdb) <> ERROR_SUCCESS then Exit;
    end;

   {Get Serv Ent}
   Result:=@Netdb^.ServEnt;

   {Update Serv Ent}
   Result^.s_name:=ServEnt^.s_name;
   Result^.s_aliases:=ServEnt^.s_aliases;
   Result^.s_port:=ServEnt^.s_port;
   Result^.s_proto:=ServEnt^.s_proto;
  end
 else
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=socket_get_db_error(Sockets.SocketError());
  end;
end;

{==============================================================================}

function socket_getservbyname(name, proto: PChar): P_servent; cdecl;
{Network services database functions}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 ServEnt:PServEnt;
 Netdb:PSyscallsNetdb;
begin
 {}
 Result:=nil;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls getservbyname (name=' + StrPas(name) + ' proto=' + StrPas(proto) + ')');
 {$ENDIF}

 ServEnt:=Sockets.GetServByName(name,proto);
 if ServEnt <> nil then
  begin
   {Get TLS Value}
   Netdb:=ThreadGetTlsValue(SyscallsNetdbIndex);
   if Netdb = nil then
    begin
     {Allocate TLS Value}
     Netdb:=AllocMem(SyscallsNetdbSize);
     if Netdb = nil then Exit;

     {$IFDEF SYSCALLS_DEBUG}
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls getservbyname (Allocated Netdb=' + PtrToHex(Netdb) + ')');
     {$ENDIF}

     {Set TLS Value}
     if ThreadSetTlsValue(SyscallsNetdbIndex,Netdb) <> ERROR_SUCCESS then Exit;
    end;

   {Get Serv Ent}
   Result:=@Netdb^.ServEnt;

   {Update Serv Ent}
   Result^.s_name:=ServEnt^.s_name;
   Result^.s_aliases:=ServEnt^.s_aliases;
   Result^.s_port:=ServEnt^.s_port;
   Result^.s_proto:=ServEnt^.s_proto;
  end
 else
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=socket_get_db_error(Sockets.SocketError());
  end;
end;

{==============================================================================}

function socket_getprotobynumber(proto: int): P_protoent; cdecl;
{Network protocol database functions}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 ProtoEnt:PProtoEnt;
 Netdb:PSyscallsNetdb;
begin
 {}
 Result:=nil;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls getprotobynumber (proto=' + IntToStr(proto) + ')');
 {$ENDIF}

 ProtoEnt:=Sockets.GetProtoByNumber(proto);
 if ProtoEnt <> nil then
  begin
   {Get TLS Value}
   Netdb:=ThreadGetTlsValue(SyscallsNetdbIndex);
   if Netdb = nil then
    begin
     {Allocate TLS Value}
     Netdb:=AllocMem(SyscallsNetdbSize);
     if Netdb = nil then Exit;

     {$IFDEF SYSCALLS_DEBUG}
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls getprotobynumber (Allocated Netdb=' + PtrToHex(Netdb) + ')');
     {$ENDIF}

     {Set TLS Value}
     if ThreadSetTlsValue(SyscallsNetdbIndex,Netdb) <> ERROR_SUCCESS then Exit;
    end;

   {Get Proto Ent}
   Result:=@Netdb^.ProtoEnt;

   {Update Proto Ent}
   Result^.p_name:=ProtoEnt^.p_name;
   Result^.p_aliases:=ProtoEnt^.p_aliases;
   Result^.p_proto:=ProtoEnt^.p_proto;
  end
 else
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=socket_get_db_error(Sockets.SocketError());
  end;
end;

{==============================================================================}

function socket_getprotobyname(name: PChar): P_protoent; cdecl;
{Network protocol database functions}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 ProtoEnt:PProtoEnt;
 Netdb:PSyscallsNetdb;
begin
 {}
 Result:=nil;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls getprotobyname (name=' + StrPas(name) + ')');
 {$ENDIF}

 ProtoEnt:=Sockets.GetProtoByName(name);
 if ProtoEnt <> nil then
  begin
   {Get TLS Value}
   Netdb:=ThreadGetTlsValue(SyscallsNetdbIndex);
   if Netdb = nil then
    begin
     {Allocate TLS Value}
     Netdb:=AllocMem(SyscallsNetdbSize);
     if Netdb = nil then Exit;

     {$IFDEF SYSCALLS_DEBUG}
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls getprotobyname (Allocated Netdb=' + PtrToHex(Netdb) + ')');
     {$ENDIF}

     {Set TLS Value}
     if ThreadSetTlsValue(SyscallsNetdbIndex,Netdb) <> ERROR_SUCCESS then Exit;
    end;

   {Get Proto Ent}
   Result:=@Netdb^.ProtoEnt;

   {Update Proto Ent}
   Result^.p_name:=ProtoEnt^.p_name;
   Result^.p_aliases:=ProtoEnt^.p_aliases;
   Result^.p_proto:=ProtoEnt^.p_proto;
  end
 else
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=socket_get_db_error(Sockets.SocketError());
  end;
end;

{==============================================================================}

function socket_getaddrinfo(node: PChar; service: PChar; hints: P_addrinfo; res: PP_addrinfo): int; cdecl;
{Network address and service translation}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 addr:P_addrinfo;
 last:P_addrinfo;
 AddrInfo:PAddrInfo;
 NextInfo:PAddrInfo;
 HintsInfo:PAddrInfo;
 SockAddr:P_sockaddr;
 SockAddrBuf:socklen_t;
 SockAddrLen:Psocklen_t;
begin
 {}
 Result:=EAI_SYSTEM;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls getaddrinfo (node=' + StrPas(node) + ' service=' + StrPas(service) + ')');
 {$ENDIF}

 {Check Result}
 if res = nil then
  begin
   {Return Error}
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
   Exit;
  end;

 {Set Defaults}
 res^:=nil;
 last:=nil;
 AddrInfo:=nil;
 HintsInfo:=nil;

 {Check Hints}
 if hints <> nil then
  begin
   Result:=EAI_MEMORY;

   {Allocate Hints}
   HintsInfo:=AllocMem(SizeOf(TAddrInfo));
   if HintsInfo = nil then Exit;

   {Update Hints}
   HintsInfo^.ai_flags:=hints^.ai_flags;
   HintsInfo^.ai_family:=hints^.ai_family;
   HintsInfo^.ai_socktype:=hints^.ai_socktype;
   HintsInfo^.ai_protocol:=hints^.ai_protocol;
  end;

 {Get Address Info}
 Result:=Sockets.GetAddrInfo(node,service,HintsInfo,AddrInfo);
 if Result <> ERROR_SUCCESS then Result:=socket_get_eai_error(Result);

 {Check Info}
 if AddrInfo <> nil then
  begin
   {Get Next}
   NextInfo:=AddrInfo;
   while NextInfo <> nil do
    begin
     {Get Info}
     AddrInfo:=NextInfo;

     {Allocate Info}
     addr:=AllocMem(SizeOf(T_addrinfo));
     if addr = nil then Break;

     {Update Info}
     addr^.ai_flags:=AddrInfo^.ai_flags;
     addr^.ai_family:=AddrInfo^.ai_family;
     addr^.ai_socktype:=AddrInfo^.ai_socktype;
     addr^.ai_protocol:=AddrInfo^.ai_protocol;
     addr^.ai_canonname:=AddrInfo^.ai_canonname;

     {Allocate Address}
     if SyscallsAllocateSockAddr(AddrInfo^.ai_addr,@AddrInfo^.ai_addrlen,@SockAddrBuf,SockAddr,SockAddrLen) then
      begin
       {Convert Address}
       if SyscallsWinsockToSockAddr(AddrInfo^.ai_addr,@AddrInfo^.ai_addrlen,SockAddr,SockAddrLen) then
        begin
         addr^.ai_addrlen:=SockAddrLen^;
         addr^.ai_addr:=SockAddr;
        end;
      end;

     {Link Info}
     if res^ = nil then res^:=addr;
     if last <> nil then last^.ai_next:=addr;
     last:=addr;

     {Get Next}
     NextInfo:=AddrInfo^.ai_next;

     {Free Info}
     AddrInfo^.ai_canonname:=nil;
     AddrInfo^.ai_next:=nil;
     Sockets.FreeAddrInfo(AddrInfo);
    end;
  end;

 {Free Hints}
 if HintsInfo <> nil then FreeMem(HintsInfo);
end;

{==============================================================================}

function socket_getnameinfo(addr: P_sockaddr; addrlen: socklen_t; host: PChar; hostlen: socklen_t; serv: PChar; servlen: socklen_t; flags: int): int; cdecl;
{Address-to-name  translation  in protocol-independent manner}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
 SockAddr:PSockAddr;
 SockAddrBuf:LongInt;
 SockAddrLen:PLongInt;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls getnameinfo (addr = ' + PtrToHex(addr) + ' addrlen = ' + IntToStr(addrlen) + ' hostlen = ' + IntToStr(hostlen) + ' servlen = ' + IntToStr(servlen) + ' flags = ' + IntToHex(flags,8) + ')');
 {$ENDIF}

 {Allocate Address}
 if (addr = nil) or not SyscallsAllocateWinsock(addr,@addrlen,@SockAddrBuf,SockAddr,SockAddrLen) then
  begin
   {Return Error}
   Result:=EAI_SYSTEM;
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EINVAL;
   Exit;
  end;

 {Convert Address}
 if not SyscallsSockAddrToWinsock(addr,@addrlen,SockAddr,SockAddrLen) then
  begin
   {Free Address}
   if SockAddr <> nil then FreeMem(SockAddr);

   {Return Error}
   Result:=EAI_SYSTEM;
   ptr:=__getreent;
   if ptr <> nil then ptr^._errno:=EFAULT;
   Exit;
  end;

 {Get Name Info}
 Result:=Sockets.GetNameInfo(SockAddr,SockAddrLen^,host,hostlen,serv,servlen,flags);
 if Result <> ERROR_SUCCESS then Result:=socket_get_eai_error(Result);

 {Free Address}
 if SockAddr <> nil then FreeMem(SockAddr);
end;

{==============================================================================}

function socket_gai_strerror(ecode: int): PChar; cdecl;
{Return an error message for an error code returned by getaddrinfo or getnameinfo}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 if (ecode < 0) or (ecode > EAI_MAX) then ecode:=EAI_MAX;

 Result:=PChar(EAI_STRERROR[ecode]);
end;

{==============================================================================}

procedure socket_freeaddrinfo(res: P_addrinfo); cdecl;
{Network address and service translation}

{Note: Exported function for use by C libraries, not intended to be called by applications}
var
 ptr:P_reent;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls freeaddrinfo (res = ' + PtrToHex(res) + ')');
 {$ENDIF}

 {Set Error}
 ptr:=__getreent;
 if ptr <> nil then ptr^._errno:=EFAULT;

 {Check Info}
 if res = nil then Exit;

 {Check Next}
 if res^.ai_next <> nil then
  begin
   {Free Next}
   socket_freeaddrinfo(res^.ai_next);
  end;

 {Free Name}
 if res^.ai_canonname <> nil then
  begin
   FreeMem(res^.ai_canonname);
  end;

 {Free Addr}
 if res^.ai_addr <> nil then
  begin
   FreeMem(res^.ai_addr);
  end;

 {Free Info}
 FreeMem(res);

 {Set Success}
 if ptr <> nil then ptr^._errno:=0;
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{Syscalls Functions (Setjmp)}
function _setjmp(var env: jmp_buf): int; cdecl;
{Save information about the calling environment for later use by _longjmp}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _setjmp');
 {$ENDIF}

 Result:=setjmp(env);
end;

{==============================================================================}

procedure _longjmp(var env: jmp_buf; val: int); cdecl;
{Uses the information saved in env to transfer control back to the point where _setjmp was called}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls _longjmp');
 {$ENDIF}

 longjmp(env,val);
end;

{==============================================================================}
{==============================================================================}
{Syscalls Functions (Non Standard)}
procedure msleep(msecs: uint); cdecl;
{Sleep for a specified number of milliseconds}

{Note: Does not support interruption by signal}
{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls msleep (msecs=' + IntToStr(msecs) + ')');
 {$ENDIF}

 ThreadSleep(msecs);
end;

{==============================================================================}

function gettid: pid_t; cdecl;
{Get thread identification}

{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 Result:=ThreadGetCurrent;
end;

{==============================================================================}
{==============================================================================}
{Syscalls Helper Functions}
procedure __malloc_lock(ptr: P_reent); cdecl;
{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 {Check reent}
 if ptr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls __malloc_lock (ptr=' + PtrToHex(ptr) + ')');
 {$ENDIF}

 {Lock Mutex}
 MutexLock(SyscallsMallocLock);
end;

{==============================================================================}

procedure __malloc_unlock(ptr: P_reent); cdecl;
{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 {Check reent}
 if ptr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls __malloc_unlock (ptr=' + PtrToHex(ptr) + ')');
 {$ENDIF}

 {Unlock Mutex}
 MutexUnlock(SyscallsMallocLock);
end;

{==============================================================================}

procedure __env_lock(ptr: P_reent); cdecl;
{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 {Check reent}
 if ptr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls __env_lock (ptr=' + PtrToHex(ptr) + ')');
 {$ENDIF}

 {Lock Mutex}
 MutexLock(SyscallsEnvLock);
end;

{==============================================================================}

procedure __env_unlock(ptr: P_reent); cdecl;
{Note: Exported function for use by C libraries, not intended to be called by applications}
begin
 {}
 {Check reent}
 if ptr = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls __env_unlock (ptr=' + PtrToHex(ptr) + ')');
 {$ENDIF}

 {Unlock Mutex}
 MutexUnlock(SyscallsEnvLock);
end;

{==============================================================================}
{==============================================================================}
{Syscalls Macro Functions (Ioctl)}
function _IOC(dir,_type,nr,size: LongWord): LongWord;
begin
 {}
 Result:=(dir shl _IOC_DIRSHIFT) or (_type shl _IOC_TYPESHIFT) or (nr shl _IOC_NRSHIFT) or (size shl _IOC_SIZESHIFT);
end;

{==============================================================================}

function _IO(_type,nr: LongWord): LongWord;
begin
 {}
 Result:=_IOC(_IOC_NONE,_type,nr,0);
end;

{==============================================================================}

function _IOR(_type,nr,size: LongWord): LongWord;
begin
 {}
 Result:=_IOC(_IOC_READ,_type,nr,size);
end;

{==============================================================================}

function _IOW(_type,nr,size: LongWord): LongWord;
begin
 {}
 Result:=_IOC(_IOC_WRITE,_type,nr,size);
end;

{==============================================================================}

function _IOWR(_type,nr,size: LongWord): LongWord;
begin
 {}
 Result:=_IOC(_IOC_READ or _IOC_WRITE,_type,nr,size);
end;

{==============================================================================}

function _IOC_DIR(nr: LongWord): LongWord;
begin
 {}
 Result:=(nr shr _IOC_DIRSHIFT) and _IOC_DIRMASK;
end;

{==============================================================================}

function _IOC_TYPE(nr: LongWord): LongWord;
begin
 {}
 Result:=(nr shr _IOC_TYPESHIFT) and _IOC_TYPEMASK;
end;

{==============================================================================}

function _IOC_NR(nr: LongWord): LongWord;
begin
 {}
 Result:=(nr shr _IOC_NRSHIFT) and _IOC_NRMASK;
end;

{==============================================================================}

function _IOC_SIZE(nr: LongWord): LongWord;
begin
 {}
 Result:=(nr shr _IOC_SIZESHIFT) and _IOC_SIZEMASK;
end;

{==============================================================================}
{$IFDEF SYSCALLS_EXPORT_SOCKETS}
{Syscalls Macro Functions (FD sets)}
function FD_CLR(fdno: int; var nset: Tfd_set): int;
begin
 {}
 Result:=-1;

 if (fdno < 0) or (fdno >= FD_SETSIZE) then Exit;

 nset.fds_bits[fdno shr FDSET_SHIFT]:=nset.fds_bits[fdno shr FDSET_SHIFT] and not fd_mask(1 shl (fdno and FDSET_MASK));

 Result:=0;
end;

{==============================================================================}

function FD_ISSET(fdno: int; const nset: Tfd_set): int;
begin
 {}
 Result:=-1;

 if (fdno < 0) or (fdno >= FD_SETSIZE) then Exit;

 if ((nset.fds_bits[fdno shr FDSET_SHIFT]) and fd_mask(1 shl (fdno and FDSET_MASK))) <> 0 then
  Result:=1
 else
  Result:=0;
end;

{==============================================================================}

function FD_SET(fdno: int; var nset: Tfd_set): int;
begin
 {}
 Result:=-1;

 if (fdno < 0) or (fdno >= FD_SETSIZE) then Exit;

 nset.fds_bits[fdno shr FDSET_SHIFT]:=nset.fds_bits[fdno shr FDSET_SHIFT] or fd_mask(1 shl (fdno and FDSET_MASK));

 Result:=0;
end;

{==============================================================================}

function FD_ZERO(out nset: Tfd_set): int;
var
 i: LongInt;
begin
 {}
 for i:=0 to (FD_SETSIZE div NFDBITS) - 1 do nset.fds_bits[i]:=0;

 Result:=0;
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{Syscalls Internal Functions}
function SyscallsGetStat(Handle:THandle;stat:Pstat):Boolean;
var
 Attributes:Integer;
 CreateTime:SysUtils.FILETIME;
 AccessTime:SysUtils.FILETIME;
 WriteTime:SysUtils.FILETIME;
begin
 {}
 Result:=False;

 {Check Handle}
 if Handle = INVALID_HANDLE_VALUE then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Get Stat (Handle=' + HandleToHex(Handle) + ')');
 {$ENDIF}

 {Check stat}
 if stat = nil then Exit;

 {Get stat}
 FillChar(stat^,SizeOf(Tstat),0);
 stat^.st_mode:=_S_IFREG;
 Attributes:=FSFileGetAttrEx(Handle);
 if (Attributes <> -1) and ((Attributes and faDirectory) <> 0) then
  begin
   stat^.st_mode:=_S_IFDIR;
  end;
 stat^.st_mode:=stat^.st_mode or _S_IREAD or _S_IWRITE or S_IEXEC;
 stat^.st_size:=FSFileSize(Handle);
 if FSGetFileTime(Handle,@CreateTime,@AccessTime,@WriteTime) then
  begin
   stat^.st_ctime.tv_sec:=(Int64(CreateTime) - TIME_TICKS_TO_1970) div TIME_TICKS_PER_SECOND;
   stat^.st_ctime.tv_nsec:=((Int64(CreateTime) - TIME_TICKS_TO_1970) mod TIME_TICKS_PER_SECOND) * 100;
   stat^.st_atime.tv_sec:=(Int64(AccessTime) - TIME_TICKS_TO_1970) div TIME_TICKS_PER_SECOND;
   stat^.st_atime.tv_nsec:=((Int64(AccessTime) - TIME_TICKS_TO_1970) mod TIME_TICKS_PER_SECOND) * 100;
   stat^.st_mtime.tv_sec:=(Int64(WriteTime) - TIME_TICKS_TO_1970) div TIME_TICKS_PER_SECOND;
   stat^.st_mtime.tv_nsec:=((Int64(WriteTime) - TIME_TICKS_TO_1970) mod TIME_TICKS_PER_SECOND) * 100;
  end;

 {Return Result}
 Result:=True;
end;

{==============================================================================}

function SyscallsGetStat64(Handle:THandle;stat64:Pstat64):Boolean;
var
 Attributes:Integer;
 CreateTime:SysUtils.FILETIME;
 AccessTime:SysUtils.FILETIME;
 WriteTime:SysUtils.FILETIME;
begin
 {}
 Result:=False;

 {Check Handle}
 if Handle = INVALID_HANDLE_VALUE then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Get Stat64 (Handle=' + HandleToHex(Handle) + ')');
 {$ENDIF}

 {Check stat64}
 if stat64 = nil then Exit;

 {Get stat64}
 FillChar(stat64^,SizeOf(Tstat64),0);
 stat64^.st_mode:=_S_IFREG;
 Attributes:=FSFileGetAttrEx(Handle);
 if (Attributes <> -1) and ((Attributes and faDirectory) <> 0) then
  begin
   stat64^.st_mode:=_S_IFDIR;
  end;
 stat64^.st_mode:=stat64^.st_mode or _S_IREAD or _S_IWRITE or S_IEXEC;
 stat64^.st_size:=FSFileSize(Handle);
 if FSGetFileTime(Handle,@CreateTime,@AccessTime,@WriteTime) then
  begin
   stat64^.st_ctime.tv_sec:=(Int64(CreateTime) - TIME_TICKS_TO_1970) div TIME_TICKS_PER_SECOND;
   stat64^.st_ctime.tv_nsec:=((Int64(CreateTime) - TIME_TICKS_TO_1970) mod TIME_TICKS_PER_SECOND) * 100;
   stat64^.st_atime.tv_sec:=(Int64(AccessTime) - TIME_TICKS_TO_1970) div TIME_TICKS_PER_SECOND;
   stat64^.st_atime.tv_nsec:=((Int64(AccessTime) - TIME_TICKS_TO_1970) mod TIME_TICKS_PER_SECOND) * 100;
   stat64^.st_mtime.tv_sec:=(Int64(WriteTime) - TIME_TICKS_TO_1970) div TIME_TICKS_PER_SECOND;
   stat64^.st_mtime.tv_nsec:=((Int64(WriteTime) - TIME_TICKS_TO_1970) mod TIME_TICKS_PER_SECOND) * 100;
  end;

 {Return Result}
 Result:=True;
end;

{==============================================================================}

function SyscallsGetStatfs(const Path:String;statfs:Pstatfs):Boolean;
var
 Volume:String;
 DriveData:TDriveData;
 ClusterSize:LongWord;
 TotalClusterCount:Int64;
 FreeClusterCount:Int64;
begin
 {}
 Result:=False;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Get Statfs (Path=' + Path + ')');
 {$ENDIF}

 {Check statfs}
 if statfs = nil then Exit;

 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Get Volume (or Drive)}
 Volume:=FileSysDriver.GetPathVolume(Path);
 if Volume = '' then Exit;

 {Get Volume Data}
 DriveData:=FileSysDriver.GetVolumeData(Volume);

 {Get Volume Information}
 if not FileSysDriver.GetDriveInformation(Volume,ClusterSize,TotalClusterCount,FreeClusterCount) then Exit;

 {Get statfs}
 FillChar(statfs^,SizeOf(Tstatfs),0);
 case DriveData.FileSysType of
  {FAT}
  fsFAT12,
  fsFAT16,
  fsFAT32,
  fsEXFAT:statfs^.f_type:=MSDOS_SUPER_MAGIC;
  {NTFS}
  fsHPFS,
  fsNTFS,
  fsNTFS5,
  fsNTFS51:statfs^.f_type:=NTFS_SB_MAGIC;
  {EXTFS}
  fsEXT2:statfs^.f_type:=EXT2_SUPER_MAGIC;
  fsEXT3:statfs^.f_type:=EXT3_SUPER_MAGIC;
  fsEXT4:statfs^.f_type:=EXT4_SUPER_MAGIC;
 end;
 statfs^.f_bsize:=ClusterSize;
 statfs^.f_blocks:=TotalClusterCount;
 statfs^.f_bfree:=FreeClusterCount;
 statfs^.f_bavail:=FreeClusterCount;
 if (DriveData.Attributes and vaReadOnly) <> 0 then statfs^.f_flags:=ST_RDONLY;
 statfs^.f_namelen:=DriveData.MaxFile;

 Result:=True;
end;

{==============================================================================}
{$IFDEF SYSCALLS_LARGE64_FILES}
function SyscallsGetStatfs64(const Path:String;statfs64:Pstatfs64):Boolean;
var
 Volume:String;
 DriveData:TDriveData;
 ClusterSize:LongWord;
 TotalClusterCount:Int64;
 FreeClusterCount:Int64;
begin
 {}
 Result:=False;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Get Statfs64 (Path=' + Path + ')');
 {$ENDIF}

 {Check statfs64}
 if statfs64 = nil then Exit;

 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Get Volume (or Drive)}
 Volume:=FileSysDriver.GetPathVolume(Path);
 if Volume = '' then Exit;

 {Get Volume Data}
 DriveData:=FileSysDriver.GetVolumeData(Volume);

 {Get Volume Information}
 if not FileSysDriver.GetDriveInformation(Volume,ClusterSize,TotalClusterCount,FreeClusterCount) then Exit;

 {Get statfs64}
 FillChar(statfs64^,SizeOf(Tstatfs64),0);
 case DriveData.FileSysType of
  {FAT}
  fsFAT12,
  fsFAT16,
  fsFAT32,
  fsEXFAT:statfs64^.f_type:=MSDOS_SUPER_MAGIC;
  {NTFS}
  fsHPFS,
  fsNTFS,
  fsNTFS5,
  fsNTFS51:statfs64^.f_type:=NTFS_SB_MAGIC;
  {EXTFS}
  fsEXT2:statfs64^.f_type:=EXT2_SUPER_MAGIC;
  fsEXT3:statfs64^.f_type:=EXT3_SUPER_MAGIC;
  fsEXT4:statfs64^.f_type:=EXT4_SUPER_MAGIC;
 end;
 statfs64^.f_bsize:=ClusterSize;
 statfs64^.f_blocks:=TotalClusterCount;
 statfs64^.f_bfree:=FreeClusterCount;
 statfs64^.f_bavail:=FreeClusterCount;
 if (DriveData.Attributes and vaReadOnly) <> 0 then statfs64^.f_flags:=ST_RDONLY;
 statfs64^.f_namelen:=DriveData.MaxFile;

 Result:=True;
end;
{$ENDIF}
{==============================================================================}

function SyscallsGetStatvfs(const Path:String;statvfs:Pstatvfs):Boolean;
var
 Volume:String;
 DriveData:TDriveData;
 ClusterSize:LongWord;
 TotalClusterCount:Int64;
 FreeClusterCount:Int64;
begin
 {}
 Result:=False;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Get Statvfs (Path=' + Path + ')');
 {$ENDIF}

 {Check statvfs}
 if statvfs = nil then Exit;

 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Get Volume (or Drive)}
 Volume:=FileSysDriver.GetPathVolume(Path);
 if Volume = '' then Exit;

 {Get Volume Data}
 DriveData:=FileSysDriver.GetVolumeData(Volume);

 {Get Volume Information}
 if not FileSysDriver.GetDriveInformation(Volume,ClusterSize,TotalClusterCount,FreeClusterCount) then Exit;

 {Get statvfs}
 FillChar(statvfs^,SizeOf(Tstatfs),0);
 statvfs^.f_bsize:=ClusterSize;
 statvfs^.f_frsize:=ClusterSize;
 statvfs^.f_blocks:=TotalClusterCount;
 statvfs^.f_bfree:=FreeClusterCount;
 statvfs^.f_bavail:=FreeClusterCount;
 if (DriveData.Attributes and vaReadOnly) <> 0 then statvfs^.f_flag:=ST_RDONLY;
 statvfs^.f_namemax:=DriveData.MaxFile;

 Result:=True;
end;

{==============================================================================}
{$IFDEF SYSCALLS_LARGE64_FILES}
function SyscallsGetStatvfs64(const Path:String;statvfs64:Pstatvfs64):Boolean;
var
 Volume:String;
 DriveData:TDriveData;
 ClusterSize:LongWord;
 TotalClusterCount:Int64;
 FreeClusterCount:Int64;
begin
 {}
 Result:=False;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Get Statvfs64 (Path=' + Path + ')');
 {$ENDIF}

 {Check statvfs64}
 if statvfs64 = nil then Exit;

 {Check Driver}
 if FileSysDriver = nil then Exit;

 {Get Volume (or Drive)}
 Volume:=FileSysDriver.GetPathVolume(Path);
 if Volume = '' then Exit;

 {Get Volume Data}
 DriveData:=FileSysDriver.GetVolumeData(Volume);

 {Get Volume Information}
 if not FileSysDriver.GetDriveInformation(Volume,ClusterSize,TotalClusterCount,FreeClusterCount) then Exit;

 {Get statvfs64}
 FillChar(statvfs64^,SizeOf(Tstatfs),0);
 statvfs64^.f_bsize:=ClusterSize;
 statvfs64^.f_frsize:=ClusterSize;
 statvfs64^.f_blocks:=TotalClusterCount;
 statvfs64^.f_bfree:=FreeClusterCount;
 statvfs64^.f_bavail:=FreeClusterCount;
 if (DriveData.Attributes and vaReadOnly) <> 0 then statvfs64^.f_flag:=ST_RDONLY;
 statvfs64^.f_namemax:=DriveData.MaxFile;

 Result:=True;
end;
{$ENDIF}
{==============================================================================}

function SyscallsGetEntry(Number:LongWord):PSyscallsEntry;
var
 First:PSyscallsEntry;
 Next:PSyscallsEntry;
begin
 {}
 Result:=nil;

 {Check Number}
 if Number > SYSCALLS_TABLE_MAX then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Get Entry (Number=' + IntToStr(Number) + ')');
 {$ENDIF}

 {Lock Table}
 if MutexLock(SyscallsTableLock) <> ERROR_SUCCESS then Exit;

 {Get First}
 First:=SyscallsTable.Entries[Number and SYSCALLS_TABLE_MASK];
 if First <> nil then
  begin
   Next:=First;
   while Next <> nil do
    begin
     {Check Number}
     if Next^.Number = Number then
      begin
       Result:=Next;
       Break;
      end;

     Next:=Next^.Next;
    end;
  end;

 {Unlock Table}
 MutexUnlock(SyscallsTableLock);

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Get Entry (Result=' + PtrToHex(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function SyscallsFindEntry(Handle:THandle):PSyscallsEntry;
var
 Count:LongWord;
 First:PSyscallsEntry;
 Next:PSyscallsEntry;
begin
 {}
 Result:=nil;

 {Check Handle}
 if Handle = INVALID_HANDLE_VALUE then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Find Entry (Handle=' + HandleToHex(Handle) + ')');
 {$ENDIF}

 {Lock Table}
 if MutexLock(SyscallsTableLock) <> ERROR_SUCCESS then Exit;

 {Check Entries}
 for Count:=0 to SYSCALLS_TABLE_MASK do
  begin
   {Get First}
   First:=SyscallsTable.Entries[Count];
   if First <> nil then
    begin
     Next:=First;
     while Next <> nil do
      begin
       {Check Handle}
       if Next^.Handle = Handle then
        begin
         Result:=Next;
         Break;
        end;

       Next:=Next^.Next;
      end;
    end;
  end;

 {Unlock Table}
 MutexUnlock(SyscallsTableLock);

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Find Entry (Result=' + PtrToHex(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function SyscallsAddEntry(Handle:THandle;Source,Origin,Number:LongWord):PSyscallsEntry;

 procedure SyscallsIncrementNext;
 begin
  {Update Next}
  Inc(SyscallsTable.Next);

  {Check Next}
  if SyscallsTable.Next > SYSCALLS_TABLE_MAX then
   begin
    SyscallsTable.Next:=SYSCALLS_TABLE_MIN;
   end;

  {Check Next}
  if SyscallsTable.Next < SYSCALLS_TABLE_MIN then
   begin
    SyscallsTable.Next:=SYSCALLS_TABLE_MIN;
   end;
 end;

var
 Start:LongWord;
 First:PSyscallsEntry;
 Next:PSyscallsEntry;
 Entry:PSyscallsEntry;
begin
 {}
 Result:=nil;

 {Check Handle}
 if Handle = INVALID_HANDLE_VALUE then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Add Entry (Handle=' + HandleToHex(Handle) + ')');
 {$ENDIF}

 {Lock Table}
 if MutexLock(SyscallsTableLock) <> ERROR_SUCCESS then Exit;

 {Check Number}
 if Number = SYSCALLS_INVALID_FILENO then
  begin
   {Check Origin}
   if Origin <> SYSCALLS_INVALID_FILENO then
    begin
     if (Origin >= SYSCALLS_TABLE_MIN) and (Origin < SYSCALLS_TABLE_MAX) then
      begin
       {Update Next}
       SyscallsTable.Next:=Origin;
      end;
    end;

   {Get Start}
   Start:=SyscallsTable.Next;

   {Find Next}
   Next:=SyscallsGetEntry(SyscallsTable.Next);
   while Next <> nil do
    begin
     {Increment Next}
     SyscallsIncrementNext;

     {Check Next}
     if SyscallsTable.Next = Start then Break;

     {Find Next}
     Next:=SyscallsGetEntry(SyscallsTable.Next);
    end;

   {Check Next}
   if Next = nil then
    begin
     {Create Entry}
     Next:=AllocMem(SizeOf(TSyscallsEntry));
     if Next <> nil then
      begin
       {Update Entry}
       Next^.Number:=SyscallsTable.Next;
       Next^.Handle:=Handle;
       Next^.Source:=Source;
       Next^.Prev:=nil;

       {Get First}
       First:=SyscallsTable.Entries[Next^.Number and SYSCALLS_TABLE_MASK];

       {Link Entry}
       Next^.Next:=First;
       if First <> nil then First^.Prev:=Next;
       SyscallsTable.Entries[Next^.Number and SYSCALLS_TABLE_MASK]:=Next;

       {Increment Count}
       Inc(SyscallsTable.Count);

       {Increment Next}
       SyscallsIncrementNext;

       {$IFDEF SYSCALLS_DEBUG}
       if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Add Entry Number=' + IntToStr(Next^.Number));
       {$ENDIF}

       {Return Result}
       Result:=Next;
      end;
    end;
  end
 else
  begin
   {Find Entry}
   Entry:=SyscallsGetEntry(Number);

   {Check Entry}
   if Entry = nil then
    begin
     {Create Entry}
     Entry:=AllocMem(SizeOf(TSyscallsEntry));
     if Entry <> nil then
      begin
       {Update Entry}
       Entry^.Number:=Number;
       Entry^.Handle:=Handle;
       Entry^.Source:=Source;
       Entry^.Prev:=nil;

       {Get First}
       First:=SyscallsTable.Entries[Entry^.Number and SYSCALLS_TABLE_MASK];

       {Link Entry}
       Entry^.Next:=First;
       if First <> nil then First^.Prev:=Entry;
       SyscallsTable.Entries[Entry^.Number and SYSCALLS_TABLE_MASK]:=Entry;

       {Increment Count}
       Inc(SyscallsTable.Count);
      end;
    end
   else
    begin
     {Update Entry}
     Entry^.Handle:=Handle;
     Entry^.Source:=Source;
    end;

   {$IFDEF SYSCALLS_DEBUG}
   if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Add Entry Number=' + IntToStr(Number));
   {$ENDIF}

   {Return Result}
   Result:=Entry;
  end;

 {Unlock Table}
 MutexUnlock(SyscallsTableLock);

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Add Entry (Result=' + PtrToHex(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function SyscallsRemoveEntry(Entry:PSyscallsEntry):Boolean;
var
 Prev:PSyscallsEntry;
 Next:PSyscallsEntry;
begin
 {}
 Result:=False;

 {Check Entry}
 if Entry = nil then Exit;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Remove Entry (Entry=' + PtrToHex(Entry) + ')');
 {$ENDIF}

 {Lock Table}
 if MutexLock(SyscallsTableLock) <> ERROR_SUCCESS then Exit;

 {Get Prev/Next}
 Prev:=Entry^.Prev;
 Next:=Entry^.Next;

 {Unlink Entry}
 if Prev = nil then
  begin
   SyscallsTable.Entries[Entry^.Number and SYSCALLS_TABLE_MASK]:=Next;
   if Next <> nil then
    begin
     Next^.Prev:=nil;
    end;
  end
 else
  begin
   Prev^.Next:=Next;
   if Next <> nil then
    begin
     Next^.Prev:=Prev;
    end;
  end;

 {Decrement Count}
 Dec(SyscallsTable.Count);

 {Destroy Entry}
 FreeMem(Entry);

 {Return Result}
 Result:=True;

 {Unlock Table}
 MutexUnlock(SyscallsTableLock);
end;

{==============================================================================}

function SyscallsInitializeHeap:Boolean;
var
 PageTableEntry:TPageTableEntry;
begin
 {}
 Result:=False;

 {Check Page Size}
 if MEMORY_PAGE_SIZE = 0 then Exit;

 {Check Block Size (Must be a power of 2)}
 if (SYSCALLS_HEAP_BLOCKSIZE = 0) or ((SYSCALLS_HEAP_BLOCKSIZE and (SYSCALLS_HEAP_BLOCKSIZE - 1)) <> 0) then
  begin
   {Default to 1MB}
   SYSCALLS_HEAP_BLOCKSIZE:=SIZE_1M;
  end;

 {Check Block Size (Must be at least page size)}
 if SYSCALLS_HEAP_BLOCKSIZE < MEMORY_PAGE_SIZE then
  begin
   {Default to Page Size}
   SYSCALLS_HEAP_BLOCKSIZE:=MEMORY_PAGE_SIZE;
  end;

 {Check Block Base (Must be a multiple of page size)}
 if (SYSCALLS_HEAP_BLOCKSIZE mod MEMORY_PAGE_SIZE) <> 0 then
  begin
   SYSCALLS_HEAP_BLOCKSIZE:=SYSCALLS_HEAP_BLOCKSIZE - (SYSCALLS_HEAP_BLOCKSIZE mod MEMORY_PAGE_SIZE);
   if SYSCALLS_HEAP_BLOCKSIZE = 0 then SYSCALLS_HEAP_BLOCKSIZE:=MEMORY_PAGE_SIZE;
  end;

 {Check Heap Min (Must be a multiple of block size)}
 if (SYSCALLS_HEAP_MIN mod SYSCALLS_HEAP_BLOCKSIZE) <> 0 then
  begin
   SYSCALLS_HEAP_MIN:=SYSCALLS_HEAP_MIN - (SYSCALLS_HEAP_MIN mod SYSCALLS_HEAP_BLOCKSIZE);
   if SYSCALLS_HEAP_MIN = 0 then SYSCALLS_HEAP_MIN:=SYSCALLS_HEAP_BLOCKSIZE;
  end;

 {Check Heap Max (Must be a multiple of block size)}
 if (SYSCALLS_HEAP_MAX mod SYSCALLS_HEAP_BLOCKSIZE) <> 0 then
  begin
   SYSCALLS_HEAP_MAX:=SYSCALLS_HEAP_MAX - (SYSCALLS_HEAP_MAX mod SYSCALLS_HEAP_BLOCKSIZE);
   if SYSCALLS_HEAP_MAX = 0 then SYSCALLS_HEAP_MAX:=SYSCALLS_HEAP_BLOCKSIZE;
  end;

 {Check Heap Base (Must be a multiple of page size)}
 if (SYSCALLS_HEAP_BASE mod MEMORY_PAGE_SIZE) <> 0 then
  begin
   SYSCALLS_HEAP_BASE:=SYSCALLS_HEAP_BASE - (SYSCALLS_HEAP_BASE mod MEMORY_PAGE_SIZE);
  end;

 {Create First Block}
 SyscallsHeapFirst:=AllocMem(SizeOf(TSyscallsHeapBlock));
 if SyscallsHeapFirst = nil then
  begin
   if PLATFORM_LOG_ENABLED then PlatformLogError('Failed to create Syscalls Heap block');
   Exit;
  end;

 {Allocate First Block}
 SyscallsHeapFirst^.PhysicalAddress:=PtrUInt(GetAlignedMem(SYSCALLS_HEAP_MIN,MEMORY_PAGE_SIZE));
 if SyscallsHeapFirst^.PhysicalAddress = 0 then
  begin
   if PLATFORM_LOG_ENABLED then PlatformLogError('Failed to allocate Syscalls Heap block');
   Exit;
  end;

 {Check Heap Base}
 if SYSCALLS_HEAP_BASE = 0 then
  begin
   {Static Heap}
   {Update Block}
   SyscallsHeapFirst^.VirtualAddress:=SyscallsHeapFirst^.PhysicalAddress;
   SyscallsHeapFirst^.Size:=SYSCALLS_HEAP_MIN;
   SyscallsHeapFirst^.Used:=0;
   SyscallsHeapFirst^.Prev:=nil;
   SyscallsHeapFirst^.Next:=nil;
  end
 else
  begin
   {Dynamic Heap}
   {Check Block}
   PageTableGetEntry(SyscallsHeapFirst^.PhysicalAddress,PageTableEntry);
   if PageTableEntry.Size <> MEMORY_PAGE_SIZE then
    begin
     {Map Block}
     PageTableEntry.Size:=MEMORY_PAGE_SIZE;
     while PageTableEntry.PhysicalAddress < (SyscallsHeapFirst^.PhysicalAddress + SYSCALLS_HEAP_MIN) do
      begin
       PageTableSetEntry(PageTableEntry);

       Inc(PageTableEntry.VirtualAddress,MEMORY_PAGE_SIZE);
       Inc(PageTableEntry.PhysicalAddress,MEMORY_PAGE_SIZE);
      end;
    end;

   {Remap Block}
   PageTableGetEntry(SyscallsHeapFirst^.PhysicalAddress,PageTableEntry);
   PageTableEntry.VirtualAddress:=SYSCALLS_HEAP_BASE;
   PageTableEntry.Size:=MEMORY_PAGE_SIZE;
   while PageTableEntry.VirtualAddress < (SYSCALLS_HEAP_BASE + SYSCALLS_HEAP_MIN) do
    begin
     PageTableSetEntry(PageTableEntry);

     Inc(PageTableEntry.VirtualAddress,MEMORY_PAGE_SIZE);
     Inc(PageTableEntry.PhysicalAddress,MEMORY_PAGE_SIZE);
    end;

   {Clean Cache}
   CleanDataCacheRange(SyscallsHeapFirst^.PhysicalAddress,SYSCALLS_HEAP_MIN);

   {Invalidate Cache}
   InvalidateDataCacheRange(SyscallsHeapFirst^.VirtualAddress,SYSCALLS_HEAP_MIN);

   {Update Block}
   SyscallsHeapFirst^.VirtualAddress:=SYSCALLS_HEAP_BASE;
   SyscallsHeapFirst^.Size:=SYSCALLS_HEAP_MIN;
   SyscallsHeapFirst^.Used:=0;
   SyscallsHeapFirst^.Prev:=nil;
   SyscallsHeapFirst^.Next:=nil;
  end;

 {Get Last Block}
 SyscallsHeapLast:=SyscallsHeapFirst;

 {Get Size and End}
 SyscallsHeapEnd:=Pointer(SyscallsHeapFirst^.VirtualAddress);
 SyscallsHeapSize:=SyscallsHeapFirst^.Size;

 {Initialize Lock}
 SyscallsHeapLock:=MutexCreateEx(False,MUTEX_DEFAULT_SPINCOUNT,MUTEX_FLAG_RECURSIVE);
 if SyscallsHeapLock = INVALID_HANDLE_VALUE then
  begin
   if PLATFORM_LOG_ENABLED then PlatformLogError('Failed to create Syscalls Heap lock');
   Exit;
  end;

 Result:=True;
end;

{==============================================================================}

function SyscallsIncreaseHeap(Size:LongWord):Pointer;
var
 Remain:LongWord;
 Address:Pointer;
 Prev:PSyscallsHeapBlock;
 Block:PSyscallsHeapBlock;
 PageTableEntry:TPageTableEntry;
begin
 {}
 Result:=nil;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Increase Heap (Size=' + IntToStr(Size) + ')');
 {$ENDIF}

 {Lock Heap}
 if MutexLock(SyscallsHeapLock) <> ERROR_SUCCESS then Exit;

 {Check Base}
 if SYSCALLS_HEAP_BASE = 0 then
  begin
   {Static Heap}
   {Get Last Block}
   Block:=SyscallsHeapLast;
   if Block <> nil then
    begin
     {$IFDEF SYSCALLS_DEBUG}
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  Block.PhysicalAddress=' + AddrToHex(Block^.PhysicalAddress));
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  Block.Size=' + IntToStr(Block^.Size));
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  Block.Used=' + IntToStr(Block^.Used));
     {$ENDIF}

     {Check Block Used}
     if (Block^.Used + Size) <= Block^.Size then
      begin
       {Return End}
       Result:=SyscallsHeapEnd;

       {Update Used}
       Inc(Block^.Used,Size);

       {Update End}
       Inc(SyscallsHeapEnd,Size);
      end;

     {$IFDEF SYSCALLS_DEBUG}
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  HeapEnd=' + PtrToHex(SyscallsHeapEnd));
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  HeapSize=' + IntToStr(SyscallsHeapSize));
     {$ENDIF}
    end;
  end
 else
  begin
   {Dynamic Heap}
   Address:=nil;

   {Get Last Block}
   Block:=SyscallsHeapLast;
   while Block <> nil do
    begin
     {$IFDEF SYSCALLS_DEBUG}
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  Block.PhysicalAddress=' + AddrToHex(Block^.PhysicalAddress));
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  Block.VirtualAddress=' + AddrToHex(Block^.VirtualAddress));
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  Block.Size=' + IntToStr(Block^.Size));
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  Block.Used=' + IntToStr(Block^.Used));
     {$ENDIF}

     {Get Remain}
     Remain:=Size;

     {Check Block Used}
     if (Block^.Used + Remain) > Block^.Size then
      begin
       {Update Remain}
       Remain:=Block^.Size - Block^.Used;
      end;

     {Check Remain}
     if Remain > 0 then
      begin
       {Get End}
       if Address = nil then Address:=SyscallsHeapEnd;

       {Update Used}
       Inc(Block^.Used,Remain);

       {Update End}
       Inc(SyscallsHeapEnd,Remain);

       {$IFDEF SYSCALLS_DEBUG}
       if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  HeapEnd=' + PtrToHex(SyscallsHeapEnd));
       if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  HeapSize=' + IntToStr(SyscallsHeapSize));
       {$ENDIF}

       {Update Size}
       Dec(Size,Remain);

       {Check Complete}
       if Size = 0 then Break;
      end
     else
      begin
       {Add New Block}
       {$IFDEF SYSCALLS_DEBUG}
       if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls New Heap Block');
       {$ENDIF}

       {Check Max}
       if SyscallsHeapSize >= SYSCALLS_HEAP_MAX then
        begin
         {Failure}
         Address:=nil;
         Break;
        end;

       {Get Prev}
       Prev:=Block;

       {Create Block}
       Block:=AllocMem(SizeOf(TSyscallsHeapBlock));
       if Block = nil then
        begin
         {Failure}
         Address:=nil;
         Break;
        end;

       {Allocate Block}
       Block^.PhysicalAddress:=PtrUInt(GetAlignedMem(SYSCALLS_HEAP_BLOCKSIZE,MEMORY_PAGE_SIZE));
       if Block^.PhysicalAddress = 0 then
        begin
         {Failure}
         Address:=nil;
         Break;
        end;

       {Check Block}
       PageTableGetEntry(Block^.PhysicalAddress,PageTableEntry);
       if PageTableEntry.Size <> MEMORY_PAGE_SIZE then
        begin
         {Map Block}
         PageTableEntry.Size:=MEMORY_PAGE_SIZE;
         while PageTableEntry.PhysicalAddress < (Block^.PhysicalAddress + SYSCALLS_HEAP_BLOCKSIZE) do
          begin
           PageTableSetEntry(PageTableEntry);

           Inc(PageTableEntry.VirtualAddress,MEMORY_PAGE_SIZE);
           Inc(PageTableEntry.PhysicalAddress,MEMORY_PAGE_SIZE);
          end;
        end;

       {Remap Block}
       PageTableGetEntry(Block^.PhysicalAddress,PageTableEntry);
       PageTableEntry.VirtualAddress:=PtrUInt(SyscallsHeapEnd);
       PageTableEntry.Size:=MEMORY_PAGE_SIZE;
       while PageTableEntry.VirtualAddress < (PtrUInt(SyscallsHeapEnd) + SYSCALLS_HEAP_BLOCKSIZE) do
        begin
         PageTableSetEntry(PageTableEntry);

         Inc(PageTableEntry.VirtualAddress,MEMORY_PAGE_SIZE);
         Inc(PageTableEntry.PhysicalAddress,MEMORY_PAGE_SIZE);
        end;

       {Clean Cache}
       CleanDataCacheRange(Block^.PhysicalAddress,SYSCALLS_HEAP_BLOCKSIZE);

       {Invalidate Cache}
       InvalidateDataCacheRange(Block^.VirtualAddress,SYSCALLS_HEAP_BLOCKSIZE);

       {Update Block}
       Block^.VirtualAddress:=PtrUInt(SyscallsHeapEnd);
       Block^.Size:=SYSCALLS_HEAP_BLOCKSIZE;
       Block^.Used:=0;
       Block^.Prev:=Prev;
       Block^.Next:=nil;

       {Link Block}
       Prev^.Next:=Block;
       SyscallsHeapLast:=Block;

       {Update Size}
       Inc(SyscallsHeapSize,SYSCALLS_HEAP_BLOCKSIZE);

       {$IFDEF SYSCALLS_DEBUG}
       if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  HeapEnd=' + PtrToHex(SyscallsHeapEnd));
       if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  HeapSize=' + IntToStr(SyscallsHeapSize));
       {$ENDIF}
      end;
    end;

   {Return End}
   Result:=Address;
  end;

 {Unlock Heap}
 MutexUnlock(SyscallsHeapLock);
end;

{==============================================================================}

function SyscallsDecreaseHeap(Size:LongWord):Pointer;
var
 Block:PSyscallsHeapBlock;
begin
 {}
 Result:=nil;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Decrease Heap (Size=' + IntToStr(Size) + ')');
 {$ENDIF}

 {Lock Heap}
 if MutexLock(SyscallsHeapLock) <> ERROR_SUCCESS then Exit;

 {Check Base}
 if SYSCALLS_HEAP_BASE = 0 then
  begin
   {Static Heap}
   {Get Last Block}
   Block:=SyscallsHeapLast;
   if Block <> nil then
    begin
     {Check Block Used}
     if Block^.Used >= Size then
      begin
       {Return End}
       Result:=SyscallsHeapEnd;

       {Update Used}
       Dec(Block^.Used,Size);

       {Update End}
       Dec(SyscallsHeapEnd,Size);
      end;

     {$IFDEF SYSCALLS_DEBUG}
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  HeapEnd=' + PtrToHex(SyscallsHeapEnd));
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  HeapSize=' + IntToStr(SyscallsHeapSize));
     {$ENDIF}
    end;
  end
 else
  begin
   {Dynamic Heap}
   {Get Last Block}
   Block:=SyscallsHeapLast;
   if Block <> nil then
    begin
     {Check Block Used}
     if Block^.Used >= Size then
      begin
       {Return End}
       Result:=SyscallsHeapEnd;

       {Update Used}
       Dec(Block^.Used,Size);

       {Update End}
       Dec(SyscallsHeapEnd,Size);
      end;
     {Do not allow decrease beyond the last block}

     {$IFDEF SYSCALLS_DEBUG}
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  HeapEnd=' + PtrToHex(SyscallsHeapEnd));
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls  HeapSize=' + IntToStr(SyscallsHeapSize));
     {$ENDIF}
    end;
  end;

 {Unlock Heap}
 MutexUnlock(SyscallsHeapLock);
end;

{==============================================================================}

function SyscallsGetPthread:PSyscallsPthread;
var
 Pthread:PSyscallsPthread;
begin
 {}
 Result:=nil;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Get Pthread (Thread=' + HandleToHex(ThreadGetCurrent) + ')');
 {$ENDIF}

 {Get TLS Value}
 Pthread:=ThreadGetTlsValue(SyscallsPThreadIndex);
 if Pthread = nil then
  begin
   {Allocate TLS Value}
   Pthread:=AllocMem(SyscallsPthreadSize);
   if Pthread = nil then Exit;

   {$IFDEF SYSCALLS_DEBUG}
   if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Get Pthread (Allocated Pthread=' + PtrToHex(Pthread) + ')');
   {$ENDIF}

   {Set TLS Value}
   if ThreadSetTlsValue(SyscallsPThreadIndex,Pthread) <> ERROR_SUCCESS then Exit;

   {Initialize Pthread structure}
   Pthread^.Cleanup:=nil;
  end;

 {Return Result}
 Result:=Pthread;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Get Pthread (Result=' + PtrToHex(Result) + ')');
 {$ENDIF}
end;

{==============================================================================}

function SyscallsPthreadStart(Data:PSyscallsPthreadData):PtrInt;
var
 Routine:Tpthread_start_routine;
 Arg:Pointer;
 Value:Pointer;
begin
 {}
 Result:=0;

 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Pthread Start (Thread=' + HandleToHex(ThreadGetCurrent) + ' Data=' + PtrToHex(Data) + ')');
 {$ENDIF}

 {Save the Parameters}
 Routine:=Data^.Routine;
 Arg:=Data^.Arg;

 {Free the Data}
 FreeMem(Data);

 if Assigned(Routine) then
  begin
   {Call Start Function}
   Value:=Routine(Arg);

   {Call Thread End}
   SyscallsPthreadEnd(Value);
  end;
end;

{==============================================================================}

procedure SyscallsPthreadEnd(Value:Pointer);
var
 Count:LongWord;
 Data:Pointer;
 Pthread:PSyscallsPthread;
 Cleanup:PSyscallsPthreadCleanup;
begin
 {}
 {$IFDEF SYSCALLS_DEBUG}
 if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Pthread End (Thread=' + HandleToHex(ThreadGetCurrent) + ' Value=' + PtrToHex(Value) + ')');
 {$ENDIF}

 {Call Key Destructors}
 for Count:=0 to THREAD_TLS_MAXIMUM - 1 do
  begin
   {Check Key Destructor}
   if Assigned(SyscallsKeyDestructor[Count]) then
    begin
     {Get TLS Value}
     Data:=ThreadGetTlsValue(Count);
     if Data <> nil then
      begin
       {Clear TLS Value}
       ThreadSetTlsValue(Count,nil);

       {$IFDEF SYSCALLS_DEBUG}
       if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Pthread End (Key=' + IntToHex(Count,8) + ' Destructor=' + PtrToHex(SyscallsKeyDestructor[Count]) + ' Data=' + PtrToHex(Data) + ')');
       {$ENDIF}

       {Call Key Destructor}
       SyscallsKeyDestructor[Count](Data);
      end;
    end;
  end;

 {Get Pthread}
 Pthread:=SyscallsGetPthread;
 if Pthread <> nil then
  begin
   {Call Cleanup Handlers}
   Cleanup:=Pthread^.Cleanup;
   while Cleanup <> nil do
    begin
     {$IFDEF SYSCALLS_DEBUG}
     if PLATFORM_LOG_ENABLED then PlatformLogDebug('Syscalls Pthread End (Cleanup=' + PtrToHex(Cleanup) + ' Routine=' + PtrToHex(Cleanup^.Routine) + ' Arg=' + PtrToHex(Cleanup^.Arg) + ')');
     {$ENDIF}

     {Check Routine}
     if Assigned(Cleanup^.Routine) then
      begin
       {Call Routine}
       Cleanup^.Routine(Cleanup^.Arg);
      end;

     {Remove Cleanup}
     Pthread^.Cleanup:=Cleanup^.Next;

     {Free Cleanup}
     FreeMem(Cleanup);

     {Get Next}
     Cleanup:=Pthread^.Cleanup;
    end;

   {Clear TLS Value}
   ThreadSetTlsValue(SyscallsPThreadIndex,nil);

   {Free TLS Value}
   FreeMem(Pthread);
  end;

 {Call End Thread}
 EndThread(PtrUInt(Value));
end;

{==============================================================================}

function SyscallsEnvironmentSet(const Name,Value:String):LongWord;
var
 Count:LongWord;
 Index:LongWord;
 Buffer:String;
begin
 {}
 Result:=ERROR_INVALID_PARAMETER;

 {Check Name}
 if Length(Name) = 0 then Exit;

 {Lock Mutex}
 MutexLock(SyscallsEnvLock);
 try
  {Get Existing Count}
  Count:=EnvironmentCount(False);

  {Find Existing Index}
  Index:=EnvironmentIndex(Name);

  {Check Count and Index}
  if environ[Count] <> nil then Exit;
  if (Index > 0) and (environ[Index - 1] = nil) then Exit;

  {Check System Handler}
  if Assigned(SyscallsEnvSetHandler) then
   begin
    {Call System Handler}
    Result:=SyscallsEnvSetHandler(Name,Value);
    if Result <> ERROR_SUCCESS then Exit;
   end;

  {Check for Delete}
  if Length(Value) = 0 then
   begin
    if Index > 0 then
     begin
      {Delete Value}
      StrDispose(environ[Index - 1]);

      {Move Values}
      while Index < Count do
       begin
        environ[Index - 1]:=environ[Index];

        Inc(Index);
       end;

      {Mark End}
      environ[Index - 1]:=nil;
     end;
   end
  else
   begin
    {Get Buffer}
    Buffer:=Name + '=' + Value;

    if Index = 0 then
     begin
      Result:=ERROR_NOT_ENOUGH_MEMORY;

      {Check Count}
      if Count >= ENVIRONMENT_STRING_COUNT then Exit;

      {Add Value}
      environ[Count]:=StrNew(PAnsiChar(AnsiString(Buffer)));

      {Mark End}
      environ[Count + 1]:=nil;
     end
    else
     begin
      {Update Value}
      StrDispose(environ[Index - 1]);

      environ[Index - 1]:=StrNew(PAnsiChar(AnsiString(Buffer)));
     end;
   end;

  Result:=ERROR_SUCCESS;
 finally
  {Unlock Mutex}
  MutexUnlock(SyscallsEnvLock);
 end;
end;

{==============================================================================}
{$IFDEF SYSCALLS_EXPORT_SOCKETS}
function SyscallsSockAddrToWinsock(Source:P_sockaddr;SourceLen:Psocklen_t;Dest:PSockAddr;DestLen:PLongint):Boolean;
{Convert a BSD or POSIX sockets socket address to a Winsock socket address}
begin
 {}
 Result:=False;

 {Check Source and Dest}
 if (Source <> nil) and (Dest <> nil) then
  begin
   {Check Source and Dest Length}
   if (SourceLen = nil) or (DestLen = nil) then Exit;

   {Check Family}
   case Source^.sa_family of
    AF_INET:begin
      {Check Source Length}
      if SourceLen^ < SizeOf(T_sockaddr_in) then Exit;

      {Convert Length}
      DestLen^:=SourceLen^;

      {Convert IPv4 Address}
      Dest^.sin_family:=P_sockaddr_in(Source)^.sin_family;
      Dest^.sin_port:=P_sockaddr_in(Source)^.sin_port;
      Dest^.sin_addr.S_addr:=P_sockaddr_in(Source)^.sin_addr.s_addr;
     end;
    AF_INET6:begin
      {Check Source Length}
      if SourceLen^ < SizeOf(T_sockaddr_in6) then Exit;

      {Convert Length}
      DestLen^:=SourceLen^;

      {Convert IPv6 Address}
      PSockAddrIn6(Dest)^.sin6_family:=P_sockaddr_in6(Source)^.sin6_family;
      PSockAddrIn6(Dest)^.sin6_port:=P_sockaddr_in6(Source)^.sin6_port;
      PSockAddrIn6(Dest)^.sin6_flowinfo:=P_sockaddr_in6(Source)^.sin6_flowinfo;
      PSockAddrIn6(Dest)^.sin6_addr.u6_addr32:=P_sockaddr_in6(Source)^.sin6_addr.u6_addr32;
      PSockAddrIn6(Dest)^.sin6_scope_id:=P_sockaddr_in6(Source)^.sin6_scope_id;
     end;
    else
     Exit;
   end;
  end;

 Result:=True;
end;

{==============================================================================}

function SyscallsWinsockToSockAddr(Source:PSockAddr;SourceLen:PLongint;Dest:P_sockaddr;DestLen:Psocklen_t):Boolean;
{Convert a Winsock socket address to a BSD or POSIX sockets socket address}
begin
 {}
 Result:=False;

 {Check Source and Dest}
 if (Source <> nil) and (Dest <> nil) then
  begin
   {Check Source and Dest Length}
   if (SourceLen = nil) or (DestLen = nil) then Exit;

   {Check Family}
   case Source^.sa_family of
    AF_INET:begin
      {Check Source Length}
      if SourceLen^ < SizeOf(TSockAddrIn) then Exit;

      {Convert Length}
      DestLen^:=SourceLen^;

      {Convert IPv4 Address}
      P_sockaddr_in(Dest)^.sin_len:=SizeOf(T_sockaddr_in);
      P_sockaddr_in(Dest)^.sin_family:=Source^.sin_family;
      P_sockaddr_in(Dest)^.sin_port:=Source^.sin_port;
      P_sockaddr_in(Dest)^.sin_addr.s_addr:=Source^.sin_addr.S_addr;
     end;
    AF_INET6:begin
      {Check Source Length}
      if SourceLen^ < SizeOf(TSockAddrIn6) then Exit;

      {Convert Length}
      DestLen^:=SourceLen^;

      {Convert IPv6 Address}
      P_sockaddr_in6(Dest)^.sin6_len:=SizeOf(T_sockaddr_in6);
      P_sockaddr_in6(Dest)^.sin6_family:=PSockAddrIn6(Source)^.sin6_family;
      P_sockaddr_in6(Dest)^.sin6_port:=PSockAddrIn6(Source)^.sin6_port;
      P_sockaddr_in6(Dest)^.sin6_flowinfo:=PSockAddrIn6(Source)^.sin6_flowinfo;
      P_sockaddr_in6(Dest)^.sin6_addr.u6_addr32:=PSockAddrIn6(Source)^.sin6_addr.u6_addr32;
      P_sockaddr_in6(Dest)^.sin6_scope_id:=PSockAddrIn6(Source)^.sin6_scope_id;
     end;
    else
     Exit;
   end;
  end;

 Result:=True;
end;

{==============================================================================}

function SyscallsAllocateWinsock(Source:P_sockaddr;SourceLen:Psocklen_t;DestBuf:PLongInt;var Dest:PSockAddr;var DestLen:PLongint):Boolean;
{Allocate a Winsock socket address appropriate for the supplied BSD or POSIX sockets socket address}
begin
 {}
 Result:=False;

 {Set Defaults}
 Dest:=nil;
 DestLen:=DestBuf;

 {Check Buffer}
 if DestBuf = nil then Exit;

 {Set Defaults}
 DestLen^:=0;

 {Check Source}
 if Source <> nil then
  begin
   {Check Source Length}
   if (SourceLen = nil) or (SourceLen^ <= 0) then Exit;

   {Set Length}
   DestLen^:=SourceLen^;

   {Allocate Address}
   Dest:=AllocMem(DestLen^);
   if Dest = nil then Exit;

   {Copy Family}
   Dest^.sa_family:=Source^.sa_family;
  end;

 Result:=True;
end;

{==============================================================================}

function SyscallsAllocateSockAddr(Source:PSockAddr;SourceLen:PLongint;DestBuf:Psocklen_t;var Dest:P_sockaddr;var DestLen:Psocklen_t):Boolean;
{Allocate a BSD or POSIX sockets socket address appropriate for the supplied Winsock socket address}
begin
 {}
 Result:=False;

 {Set Defaults}
 Dest:=nil;
 DestLen:=DestBuf;

 {Check Buffer}
 if DestBuf = nil then Exit;

 {Set Defaults}
 DestLen^:=0;

 {Check Source}
 if Source <> nil then
  begin
   {Check Source Length}
   if (SourceLen = nil) or (SourceLen^ <= 0) then Exit;

   {Set Length}
   DestLen^:=SourceLen^;

   {Allocate Address}
   Dest:=AllocMem(DestLen^);
   if Dest = nil then Exit;

   {Copy Family}
   Dest^.sa_family:=Source^.sa_family;
  end;

 Result:=True;
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}

initialization
 SyscallsInit;

{==============================================================================}

finalization
 SyscallsQuit;

{==============================================================================}
{==============================================================================}

end.

