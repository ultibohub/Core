{
Ultibo Library API interface unit.

Copyright (C) 2025 - SoftOz Pty Ltd.

Arch
====

 <All>

Boards
======

 <All>

Licence
=======

 LGPLv2.1 with static linking exception (See COPYING.modifiedLGPL.txt)

Credits
=======

 Information for this unit was obtained from:


References
==========

API
===

 This unit provides the API interface for external libraries to call Ultibo core
 functions. The external libraries can be written in C, C++, Assembler or any other
 language that supports calling external functions (even Free Pascal itself).

 The functions in this unit are explicitly defined for the purpose of interfacing
 with external libraries. If you are using Free Pascal and Lazarus then you should
 not call the functions in this unit, instead you should call the relevant functions
 in the core units that this unit includes (eg Console, GPIO, UART, Threads etc).

 If you are developing a library in another language and need to call Ultibo core
 functions then you should include this unit in the main Ultibo project that links
 your library in order to expose all of the required functions.

 This unit will NOT be documented, see the documentation for each of the core units
 for information on what each function does and how to use it.

 The Free Pascal RTL functions are not exported by this unit, most languages will have
 their own RTL support (eg the C language has libc) to provide common functionality
 that is not specific to Ultibo core.

 Note: By default all (most) of the API_EXPORT_* defines are enabled in the file
 GlobalDefines.inc so including this unit will make an image that may be larger
 than expected. If you need to reduce the size of your image to the minimum based
 only on the features that you use then you should turn off any of the API_EXPORT_*
 that are not required for your project.

}

{$mode delphi} {Default to Delphi compatible syntax}
{$H+}          {Default to AnsiString}
{$inline on}   {Allow use of Inline procedures}

unit API;

interface

{==============================================================================}
{Global definitions} {Must be prior to uses}
{$INCLUDE GlobalDefines.inc}

uses
  GlobalConfig,
  GlobalConst,
  GlobalTypes,

  {$IFDEF API_EXPORT_PLATFORM}
  Platform,
  {$ENDIF}

  {$IFDEF API_EXPORT_THREADS}
  Threads,
  {$ENDIF}

  {$IFDEF API_EXPORT_HEAP}
  HeapManager,
  {$ENDIF}

  {$IFDEF API_EXPORT_DEVICE_TREE}
  DeviceTree,
  {$ENDIF}

  {$IFDEF API_EXPORT_DEVICES}
  Devices,
  {$ENDIF}

  {$IFDEF API_EXPORT_CONSOLE}
  Console,
  {$ENDIF}

  {$IFDEF API_EXPORT_LOGGING}
  Logging,
  {$ENDIF}

  {$IFDEF API_EXPORT_DMA}
  DMA,
  {$ENDIF}

  {$IFDEF API_EXPORT_PCI}
  PCI,
  {$ENDIF}

  {$IFDEF API_EXPORT_USB}
  USB,
  {$ENDIF}

  {$IFDEF API_EXPORT_MMC}
  MMC,
  {$ENDIF}

  {$IFDEF API_EXPORT_SPI}
  SPI,
  {$ENDIF}

  {$IFDEF API_EXPORT_I2C}
  I2C,
  {$ENDIF}

  {$IFDEF API_EXPORT_PWM}
  PWM,
  {$ENDIF}

  {$IFDEF API_EXPORT_PCM}
  I2S,
  {$ENDIF}

  {$IFDEF API_EXPORT_GPIO}
  GPIO,
  {$ENDIF}

  {$IFDEF API_EXPORT_UART}
  UART,
  {$ENDIF}

  {$IFDEF API_EXPORT_SERIAL}
  Serial,
  {$ENDIF}

  {$IFDEF API_EXPORT_RTC}
  RTC,
  {$ENDIF}

  {$IFDEF API_EXPORT_FONT}
  Font,
  {$ENDIF}

  {$IFDEF API_EXPORT_FRAMEBUFFER}
  Framebuffer,
  {$ENDIF}

  {$IFDEF API_EXPORT_GRAPHICSCONSOLE}
  GraphicsConsole,
  {$ENDIF}

  {$IFDEF API_EXPORT_HID}
  HID,
  {$ENDIF}

  {$IFDEF API_EXPORT_KEYMAP}
  Keymap,
  {$ENDIF}

  {$IFDEF API_EXPORT_KEYBOARD}
  Keyboard,
  {$ENDIF}

  {$IFDEF API_EXPORT_MOUSE}
  Mouse,
  {$ENDIF}

  {$IFDEF API_EXPORT_TOUCH}
  Touch,
  {$ENDIF}

  {$IFDEF API_EXPORT_JOYSTICK}
  Joystick,
  {$ENDIF}

  {$IFDEF API_EXPORT_STORAGE}
  Storage,
  {$ENDIF}

  {$IFDEF API_EXPORT_NETWORK}
  Network,
  {$ENDIF}

  {$IFDEF API_EXPORT_TIMEZONE}
  Timezone,
  {$ENDIF}

  {$IFDEF API_EXPORT_LOCALE}
  Locale,
  {$ENDIF}

  {$IFDEF API_EXPORT_UNICODE}
  Unicode,
  {$ENDIF}

  {$IFDEF API_EXPORT_TFTFRAMEBUFFER}
  TFTFramebuffer,
  {$ENDIF}

  {$IFDEF API_EXPORT_FILESYSTEM}
  FileSystem,
  {$ENDIF}

  {$IFDEF API_EXPORT_WINSOCK}
  Winsock,
  {$ENDIF}

  {$IFDEF API_EXPORT_WINSOCK2}
  Winsock2,
  {$ENDIF}

  {$IFDEF API_EXPORT_IPHLPAPI}
  Iphlpapi,
  {$ENDIF}

  {$IFDEF API_EXPORT_ULTIBO}
  Security,
  Ultibo,
  {$ENDIF}

  SysUtils;

{==============================================================================}
{const}
 {API specific constants}

{==============================================================================}
{type}
 {API specific types}

type
 {GlobalTypes}
 {Display Settings}
 TDISPLAY_SETTINGS = TDisplaySettings;

{$IFDEF API_EXPORT_PLATFORM}
type
 {Platform}
 {Counter Entry Types}
 counter_event_cb = TCounterCallback;

 {Interrupt Request (IRQ/FIQ) Types}
 interrupt_handler = TInterruptHandler;
 interrupt_ex_handler = TInterruptExHandler;
 shared_interrupt_handler = TSharedInterruptHandler;

 {Inter Processor Interrupt (IPI) Types}
 ipi_handler = TIPIHandler;

 {System Call (Software Interrupt or SWI) Types}
 system_call_handler = TSystemCallHandler;
 system_call_ex_handler = TSystemCallExHandler;

 {Interrupt Entry Types}
 TINTERRUPT_ENTRY = TInterruptEntry;

 {System Call Entry Types}
 TSYSTEM_CALL_ENTRY = TSystemCallEntry;

 {Handle Entry Types}
 handle_enumerate_cb = THandleEnumerate;
 PHANDLE_ENTRY = PHandleEntry;

 {Shutdown Entry Types}
 shutdown_cb = TShutdownCallback;

 {GPIO Types}
 gpio_event_cb = TGPIOCallback;

 {DMA Types}
 PDMA_DATA = PDMAData;

 {System Types}
 TIRQ_MASK = TIRQMask;
 TFIQ_MASK = TFIQMask;
 TIRQ_FIQ_MASK = TIRQFIQMask;
 TABORT_MASK = TAbortMask;

 {Page Table Entry Types}
 TPAGE_TABLE_ENTRY = TPageTableEntry;
{$ENDIF}

{$IFDEF API_EXPORT_THREADS}
type
 {Threads}
 {Handle Types}
 SPIN_HANDLE = TSpinHandle;
 MUTEX_HANDLE = TMutexHandle;
 CRITICAL_SECTION_HANDLE = TCriticalSectionHandle;
 SEMAPHORE_HANDLE = TSemaphoreHandle;
 SYNCHRONIZER_HANDLE = TSynchronizerHandle;
 CONDITION_HANDLE = TConditionHandle;
 COMPLETION_HANDLE = TCompletionHandle;
 LIST_HANDLE = TListHandle;
 QUEUE_HANDLE = TQueueHandle;
 THREAD_HANDLE = TThreadHandle;
 MESSAGESLOT_HANDLE = TMessageslotHandle;
 MAILSLOT_HANDLE = TMailslotHandle;
 BUFFER_HANDLE = TBufferHandle;
 EVENT_HANDLE = TEventHandle;
 TIMER_HANDLE = TTimerHandle;
 WORKER_HANDLE = TWorkerHandle;

 {List Entry Types}
 PLIST_ELEMENT = PListElement;

 {Thread Entry Types}
 thread_start_proc = TThreadStart;
 thread_end_proc = TThreadEnd;

 TTHREAD_MESSAGE = TMessage;
 PTHREAD_SNAPSHOT = PThreadSnapshot;

 TTHREAD_ID = TThreadID;
 thread_func = TThreadFunc;

 {Timer Entry Types}
 timer_event_proc = TTimerEvent;

 {Worker Entry Types}
 worker_task_proc = TWorkerTask;
 worker_cb = TWorkerCallback;

 {Tasker Entry Types}
 PTASKER_TASK = PTaskerTask;
{$ENDIF}

{$IFDEF API_EXPORT_HEAP}
type
 {Heap}
 THEAP_STATUS = THeapStatus;
 TFPC_HEAP_STATUS = TFPCHeapStatus;

 {Heap Manager Types}
 {$IFDEF HEAP_STATISTICS}
 THEAP_STATISTICS = THeapStatistics;
 {$ENDIF}
 PHEAP_SNAPSHOT = PHeapSnapshot;
{$ENDIF}

{$IFDEF API_EXPORT_DEVICE_TREE}
type
 {Device Tree}
 {Device Tree Types}
 dtb_log_output_cb = TDTBLogOutput;
 dtb_decode_value_cb = TDTBDecodeValue;
{$ENDIF}

{$IFDEF API_EXPORT_DEVICES}
type
 {Devices}
 {Device Types}
 PDEVICE_FIRMWARE = PDeviceFirmware;
 PNOTIFIER_TASK = PNotifierTask;
 PNOTIFIER_RETRY = PNotifierRetry;
 device_enumerate_cb = TDeviceEnumerate;
 device_notification_cb = TDeviceNotification;
 device_firmware_handler = TDeviceFirmwareHandler;

 {Driver Types}
 driver_enumerate_cb = TDriverEnumerate;

 {Clock Types}
 TCLOCK_DEVICE = TClockDevice;
 PCLOCK_DEVICE = PClockDevice;
 PCLOCK_PROPERTIES = PClockProperties;
 clock_enumerate_cb = TClockEnumerate;
 clock_notification_cb = TClockNotification;

 {Timer Types}
 TTIMER_DEVICE = TTimerDevice;
 PTIMER_DEVICE = PTimerDevice;
 PTIMER_WAITER = PTimerWaiter;
 PTIMER_PROPERTIES = PTimerProperties;
 timer_cb = TTimerCallback;
 timer_enumerate_cb = TTimerEnumerate;
 timer_notification_cb = TTimerNotification;

 {Random Types}
 TRANDOM_DEVICE = TRandomDevice;
 PRANDOM_DEVICE = PRandomDevice;
 random_enumerate_cb = TRandomEnumerate;
 random_notification_cb = TRandomNotification;

 {Mailbox Types}
 TMAILBOX_DEVICE = TMailboxDevice;
 PMAILBOX_DEVICE = PMailboxDevice;
 mailbox_enumerate_cb = TMailboxEnumerate;
 mailbox_notification_cb = TMailboxNotification;

 {Watchdog Types}
 TWATCHDOG_DEVICE = TWatchdogDevice;
 PWATCHDOG_DEVICE = PWatchdogDevice;
 watchdog_enumerate_cb = TWatchdogEnumerate;
 watchdog_notification_cb = TWatchdogNotification;
{$ENDIF}

{$IFDEF API_EXPORT_CONSOLE}
type
 {Console}
 {Console Types}
 WINDOW_HANDLE = TWindowHandle;

 TCONSOLE_RECT = TConsoleRect;
 TCONSOLE_POINT = TConsolePoint;

 CURSOR_MODE = TCursorMode;
 CURSOR_STATE = TCursorState;
 CURSOR_SHAPE = TCursorShape;

 PCONSOLE_CHAR = PConsoleChar;
 PCONSOLE_CARET = PConsoleCaret;
 PCONSOLE_DEVICE = PConsoleDevice;
 PCONSOLE_WINDOW = PConsoleWindow;
 PCONSOLE_PROPERTIES = PConsoleProperties;

 console_enumerate_cb = TConsoleEnumerate;
 console_notification_cb = TConsoleNotification;

 PWINDOW_PROPERTIES = PWindowProperties;

 console_window_enumerate_cb = TConsoleWindowEnumerate;
 console_window_completion_cb = TConsoleWindowCompletion;
{$ENDIF}

{$IFDEF API_EXPORT_LOGGING}
type
 PLOGGING_DEVICE = PLoggingDevice;

 logging_enumerate_cb = TLoggingEnumerate;
 logging_notification_cb = TLoggingNotification;
{$ENDIF}

{$IFDEF API_EXPORT_DMA}
type
 PDMA_HOST = PDMAHost;
 PDMA_PROPERTIES = PDMAProperties;

 dma_enumerate_cb = TDMAEnumerate;
 dma_notification_cb = TDMANotification;

 PDMA_REQUEST = PDMARequest;

 dma_request_completed_cb = TDMARequestCompleted;
{$ENDIF}

{$IFDEF API_EXPORT_PCI}
//To Do
{$ENDIF}

{$IFDEF API_EXPORT_USB}
type
 PUSB_HOST = PUSBHost;
 PUSB_DEVICE = PUSBDevice;
 PUSB_ALTERNATE = PUSBAlternate;
 PUSB_INTERFACE = PUSBInterface;
 PUSB_CONFIGURATION = PUSBConfiguration;

 usb_device_bind_proc = TUSBDeviceBind;
 usb_device_unbind_proc = TUSBDeviceUnbind;
 usb_device_enumerate_cb = TUSBDeviceEnumerate;
 usb_device_notification_cb = TUSBDeviceNotification;

 PUSB_DRIVER = PUSBDriver;
 PUSB_REQUEST = PUSBRequest;

 usb_driver_enumerate_cb = TUSBDriverEnumerate;

 usb_host_enumerate_cb = TUSBHostEnumerate;
 usb_host_notification_cb = TUSBHostNotification;

 usb_request_completed_cb = TUSBRequestCompleted;

 PUSB_HUB = PUSBHub;
 PUSB_PORT = PUSBPort;

 usb_hub_enumerate_cb = TUSBHubEnumerate;
 usb_hub_notification_cb = TUSBHubNotification;

 PUSB_DEVICE_DESCRIPTOR = PUSBDeviceDescriptor;
 PUSB_ENDPOINT_DESCRIPTOR = PUSBEndpointDescriptor;
 PUSB_INTERFACE_DESCRIPTOR = PUSBInterfaceDescriptor;
 PUSB_CONFIGURATION_DESCRIPTOR = PUSBConfigurationDescriptor;

 TUSB_STRING_DESCRIPTOR_LANGIDS = TUSBStringDescriptorLANGIDs;

 usb_log_output_proc = TUSBLogOutput;
{$ENDIF}

{$IFDEF API_EXPORT_MMC}
type
 PMMC_DEVICE = PMMCDevice;
 PMMC_COMMAND = PMMCCommand;

 mmc_enumerate_cb = TMMCEnumerate;
 mmc_notification_cb = TMMCNotification;

 PSDHCI_HOST = PSDHCIHost;

 sdhci_enumerate_cb = TSDHCIEnumerate;
 sdhci_notification_cb = TSDHCINotification;

 PSDIO_FUNCTION = PSDIOFunction;
 PSDIO_DRIVER = PSDIODriver;

 sdio_interrupt_handler = TSDIOInterruptHandler;
 sdio_function_enumerate_cb = TSDIOFunctionEnumerate;

 sdio_driver_enumerate_cb = TSDIODriverEnumerate;
{$ENDIF}

{$IFDEF API_EXPORT_SPI}
type
 PSPI_DEVICE = PSPIDevice;
 PSPI_PROPERTIES = PSPIProperties;

 spi_enumerate_cb = TSPIEnumerate;
 spi_notification_cb = TSPINotification;
{$ENDIF}

{$IFDEF API_EXPORT_I2C}
type
 PI2C_DEVICE = PI2CDevice;
 PI2C_PROPERTIES = PI2CProperties;

 i2c_enumerate_cb = TI2CEnumerate;
 i2c_notification_cb = TI2CNotification;
{$ENDIF}

{$IFDEF API_EXPORT_PWM}
type
 PPWM_DEVICE = PPWMDevice;
 PPWM_PROPERTIES = PPWMProperties;

 pwm_enumerate_cb = TPWMEnumerate;
 pwm_notification_cb = TPWMNotification;
{$ENDIF}

{$IFDEF API_EXPORT_PCM}
//To Do
{$ENDIF}

{$IFDEF API_EXPORT_GPIO}
type
 PGPIO_PIN = PGPIOPin;
 PGPIO_EVENT = PGPIOEvent;
 PGPIO_DEVICE = PGPIODevice;
 PGPIO_PROPERTIES = PGPIOProperties;

 gpio_enumerate_cb = TGPIOEnumerate;
 gpio_notification_cb = TGPIONotification;
{$ENDIF}

{$IFDEF API_EXPORT_UART}
type
 PUART_DEVICE = PUARTDevice;
 PUART_PROPERTIES = PUARTProperties;

 uart_enumerate_cb = TUARTEnumerate;
 uart_notification_cb = TUARTNotification;
{$ENDIF}

{$IFDEF API_EXPORT_SERIAL}
type
 PSERIAL_DEVICE = PSerialDevice;
 PSERIAL_BUFFER = PSerialBuffer;
 PSERIAL_PROPERTIES = PSerialProperties;

 serial_enumerate_cb = TSerialEnumerate;
 serial_notification_cb = TSerialNotification;
{$ENDIF}

{$IFDEF API_EXPORT_RTC}
type
 PRTC_DEVICE = PRTCDevice;
 PRTC_PROPERTIES = PRTCProperties;

 rtc_enumerate_cb = TRTCEnumerate;
 rtc_notification_cb = TRTCNotification;
{$ENDIF}

{$IFDEF API_EXPORT_FONT}
type
 FONT_HANDLE = TFontHandle;

 PFONT_DATA = PFontData;
 PFONT_HEADER = PFontHeader;
 PFONT_UNICODE = PFontUnicode;

 PFONT_ENTRY = PFontEntry;
 PFONT_PROPERTIES = PFontProperties;

 font_enumerate_cb = TFontEnumerate;
{$ENDIF}

{$IFDEF API_EXPORT_FRAMEBUFFER}
type
 PFRAMEBUFFER_DEVICE = PFramebufferDevice;
 PFRAMEBUFFER_PALETTE = PFramebufferPalette;
 PFRAMEBUFFER_PROPERTIES = PFramebufferProperties;

 framebuffer_enumerate_cb = TFramebufferEnumerate;
 framebuffer_notification_cb = TFramebufferNotification;
{$ENDIF}

{$IFDEF API_EXPORT_GRAPHICSCONSOLE}
type
 PGRAPHICS_WINDOW = PGraphicsWindow;

 graphics_window_enumerate_cb = console_window_enumerate_cb;
{$ENDIF}

{$IFDEF API_EXPORT_HID}
type
 PHID_DEVICE = PHIDDevice;
 PHID_CONSUMER = PHIDConsumer;
 
 PHID_STATE = PHIDState;
 PHID_STACK = PHIDStack;
 
 PHID_USAGE = PHIDUsage;
 PHID_REPORT = PHIDReport;
 PHID_REPORTS = PHIDReports;
 PHID_COLLECTION = PHIDCollection;
 PHID_COLLECTIONS = PHIDCollections;
 
 PHID_FIELD = PHIDField;
 PHID_DEFINITION = PHIDDefinition;
 
 PHID_REPORT_DESCRIPTOR = PHIDReportDescriptor;
 PHID_PHYSICAL_DESCRIPTOR_SET = PHIDPhysicalDescriptorSet;
 PHID_PHYSICAL_DESCRIPTOR_SET0 = PHIDPhysicalDescriptorSet0;
 
 hid_device_enumerate_cb = THIDDeviceEnumerate;
 hid_device_notification_cb = THIDDeviceNotification;
 hid_consumer_enumerate_cb = THIDConsumerEnumerate;
{$ENDIF}

{$IFDEF API_EXPORT_KEYMAP}
type
 KEYMAP_HANDLE = TKeymapHandle;

 PKEYMAP_DATA = PKeymapData;
 PKEYMAP_HEADER = PKeymapHeader;
 PKEYMAP_CAPSKEYS = PKeymapCapskeys;
 PKEYMAP_DEADKEYS = PKeymapDeadkeys;

 PKEYMAP_ENTRY = PKeymapEntry;
 PKEYMAP_PROPERTIES = PKeymapProperties;

 keymap_enumerate_cb = TKeymapEnumerate;
{$ENDIF}

{$IFDEF API_EXPORT_KEYBOARD}
type
 PKEYBOARD_DATA = PKeyboardData;
 PKEYBOARD_DEVICE = PKeyboardDevice;

 keyboard_enumerate_cb = TKeyboardEnumerate;
 keyboard_notification_cb = TKeyboardNotification;
{$ENDIF}

{$IFDEF API_EXPORT_MOUSE}
type
 PMOUSE_DATA = PMouseData;
 PMOUSE_DEVICE = PMouseDevice;
 PMOUSE_PROPERTIES = PMouseProperties;

 mouse_enumerate_cb = TMouseEnumerate;
 mouse_notification_cb = TMouseNotification;
{$ENDIF}

{$IFDEF API_EXPORT_TOUCH}
type
 PTOUCH_DATA = PTouchData;
 PTOUCH_DEVICE = PTouchDevice;
 PTOUCH_PROPERTIES = PTouchProperties;

 touch_event_cb = TTouchEvent;
 touch_enumerate_cb = TTouchEnumerate;
 touch_notification_cb = TTouchNotification;
{$ENDIF}

{$IFDEF API_EXPORT_JOYSTICK}
 PJOYSTICK_DATA = PJoystickData;
 PJOYSTICK_DEVICE = PJoystickDevice;
 PJOYSTICK_PROPERTIES = PJoystickProperties;
 
 joystick_event_cb = TJoystickEvent;
 joystick_enumerate_cb = TJoystickEnumerate;
 joystick_notification_cb = TJoystickNotification;
{$ENDIF}

{$IFDEF API_EXPORT_STORAGE}
type
 PSTORAGE_DEVICE = PStorageDevice;

 storage_enumerate_cb = TStorageEnumerate;
 storage_notification_cb = TStorageNotification;
{$ENDIF}

{$IFDEF API_EXPORT_NETWORK}
type
 PNETWORK_ENTRY = PNetworkEntry;
 PNETWORK_DEVICE = PNetworkDevice;

 THARDWARE_ADDRESS = THardwareAddress;

 network_enumerate_cb = TNetworkEnumerate;
 network_notification_cb = TNetworkNotification;

 PNETWORK_EVENT = PNetworkEvent;

 network_event_callback_cb = TNetworkEventCallback;
{$ENDIF}

{$IFDEF API_EXPORT_TIMEZONE}
type
 PTIMEZONE_DATA = PTimezoneData;
 PTIMEZONE_ENTRY = PTimezoneEntry;

 timezone_enumerate_cb = TTimezoneEnumerate;
{$ENDIF}

{$IFDEF API_EXPORT_LOCALE}
type
 PCODE_PAGE = PCodePage;
 PCODE_TABLE = PCodeTable;
 PTRANS_TABLE = PTransTable;
 PLOWER_TABLE = PLowerTable;
 PUPPER_TABLE = PUpperTable;
{$ENDIF}

{$IFDEF API_EXPORT_UNICODE}
{type}
{$ENDIF}

{$IFDEF API_EXPORT_TFTFRAMEBUFFER}
type
 PTFT_FRAMEBUFFER = PTFTFramebuffer;
{$ENDIF}

{$IFDEF API_EXPORT_FILESYSTEM}
type
 TMEDIA_TYPE = TMediaType;
 TFLOPPY_TYPE = TFloppyType;
 TIMAGE_TYPE = TImageType;
 TCACHE_STATE = TCacheState;
 TCACHE_MODE = TCacheMode;

 TFILE_SEARCH_REC = TFileSearchRec;
{$ENDIF}

{$IFDEF API_EXPORT_WINSOCK}
{type}
{$ENDIF}

{$IFDEF API_EXPORT_WINSOCK2}
{type}
{$ENDIF}

{$IFDEF API_EXPORT_IPHLPAPI}
{type}
{$ENDIF}

{$IFDEF API_EXPORT_ULTIBO}
type
 TDRIVE_TYPE = TDriveType;
 TDRIVE_DATA = TDriveData;
 
 TFILE_SYS_TYPE = TFileSysType;
{$ENDIF}

{==============================================================================}
{var}
 {API specific variables}

{==============================================================================}
{Initialization Functions}
procedure APIInit;

{==============================================================================}
{API Functions}

{==============================================================================}
{Platform Functions}
{$IFDEF API_EXPORT_PLATFORM}
{Device Tree Functions}
function device_tree_valid: BOOL; stdcall; public name 'device_tree_valid';
function device_tree_get_base: SIZE_T; stdcall; public name 'device_tree_get_base';
function device_tree_get_size: uint32_t; stdcall; public name 'device_tree_get_size';

function device_tree_read(const path, name: PCHAR; buffer: PVOID; var size: uint32_t): uint32_t; stdcall; public name 'device_tree_read';
function device_tree_read32(const path, name: PCHAR; var value: uint32_t): uint32_t; stdcall; public name 'device_tree_read32';
function device_tree_read64(const path, name: PCHAR; var value: uint64_t): uint32_t; stdcall; public name 'device_tree_read64';
function device_tree_read_string(const path, name: PCHAR; value: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'device_tree_read_string';

{Boot Functions}
procedure boot_blink; stdcall; public name 'boot_blink';
procedure boot_output(value: uint32_t); stdcall; public name 'boot_output';
procedure boot_console_start; stdcall; public name 'boot_console_start';
procedure boot_console_write(const value: PCHAR); stdcall; public name 'boot_console_write';
procedure boot_console_write_ex(const value: PCHAR; x, y: uint32_t); stdcall; public name 'boot_console_write_ex';
function boot_console_get_x: uint32_t; stdcall; public name 'boot_console_get_x';
function boot_console_get_y: uint32_t; stdcall; public name 'boot_console_get_y';

{LED Functions}
procedure power_led_enable; stdcall; public name 'power_led_enable';
procedure power_led_on; stdcall; public name 'power_led_on';
procedure power_led_off; stdcall; public name 'power_led_off';

procedure activity_led_enable; stdcall; public name 'activity_led_enable';
procedure activity_led_on; stdcall; public name 'activity_led_on';
procedure activity_led_off; stdcall; public name 'activity_led_off';

{Counter Functions (Timer device)}
function counter_available: BOOL; stdcall; public name 'counter_available';

function counter_read: uint32_t; stdcall; public name 'counter_read';
function counter_read64: int64_t; stdcall; public name 'counter_read64';
function counter_wait: uint32_t; stdcall; public name 'counter_wait';
function counter_event(callback: counter_event_cb; data: PVOID): uint32_t; stdcall; public name 'counter_event';
function counter_cancel: uint32_t; stdcall; public name 'counter_cancel';

function counter_get_rate: uint32_t; stdcall; public name 'counter_get_rate';
function counter_set_rate(rate: uint32_t): uint32_t; stdcall; public name 'counter_set_rate';

function counter_get_interval: uint32_t; stdcall; public name 'counter_get_interval';
function counter_set_interval(interval: uint32_t): uint32_t; stdcall; public name 'counter_set_interval';

{Mailbox Functions}
function mailbox_receive(mailbox, channel: uint32_t): uint32_t; stdcall; public name 'mailbox_receive';
procedure mailbox_send(mailbox, channel, data: uint32_t); stdcall; public name 'mailbox_send';

function mailbox_call(mailbox, channel, data: uint32_t; var response: uint32_t): uint32_t; stdcall; public name 'mailbox_call';
function mailbox_call_ex(mailbox, channel, data: uint32_t; var response: uint32_t; timeout: uint32_t): uint32_t; stdcall; public name 'mailbox_call_ex';
function mailbox_property_call(mailbox, channel: uint32_t; data: PVOID; var response: uint32_t): uint32_t; stdcall; public name 'mailbox_property_call';
function mailbox_property_call_ex(mailbox, channel: uint32_t; data: PVOID; var response: uint32_t; timeout: uint32_t): uint32_t; stdcall; public name 'mailbox_property_call_ex';

function mailbox_property_tag(tag: uint32_t; data: PVOID; size: uint32_t): uint32_t; stdcall; public name 'mailbox_property_tag';

{Random Number Functions}
function random_available: BOOL; stdcall; public name 'random_available';

procedure random_seed(seed: uint32_t); stdcall; public name 'random_seed';

function random_read_longint(limit: int32_t): int32_t; stdcall; public name 'random_read_longint';
function random_read_int64(limit: int64_t): int64_t; stdcall; public name 'random_read_int64';
function random_read_double: double_t; stdcall; public name 'random_read_double';
function random_read_extended: double_t; stdcall; public name 'random_read_extended';

{Watchdog Functions}
function watchdog_available: BOOL; stdcall; public name 'watchdog_available';

function watchdog_start(milliseconds: uint32_t): uint32_t; stdcall; public name 'watchdog_start';
function watchdog_stop: uint32_t; stdcall; public name 'watchdog_stop';
function watchdog_refresh(milliseconds: uint32_t): uint32_t; stdcall; public name 'watchdog_refresh';

{Interrupt Request (IRQ) Functions}
function request_irq(cpuid, number: uint32_t; handler: interrupt_handler; parameter: PVOID): uint32_t; stdcall; public name 'request_irq';
function release_irq(cpuid, number: uint32_t; handler: interrupt_handler; parameter: PVOID): uint32_t; stdcall; public name 'release_irq';
function request_ex_irq(cpuid, number: uint32_t; handler: interrupt_handler; handler_ex: interrupt_ex_handler; parameter: PVOID): uint32_t; stdcall; public name 'request_ex_irq';
function release_ex_irq(cpuid, number: uint32_t; handler: interrupt_handler; handler_ex: interrupt_ex_handler; parameter: PVOID): uint32_t; stdcall; public name 'release_ex_irq';

{Fast Interrupt Request (FIQ) Functions}
function request_fiq(cpuid, number: uint32_t; handler: interrupt_handler; parameter: PVOID): uint32_t; stdcall; public name 'request_fiq';
function release_fiq(cpuid, number: uint32_t; handler: interrupt_handler; parameter: PVOID): uint32_t; stdcall; public name 'release_fiq';
function request_ex_fiq(cpuid, number: uint32_t; handler: interrupt_handler; handler_ex: interrupt_ex_handler; parameter: PVOID): uint32_t; stdcall; public name 'request_ex_fiq';
function release_ex_fiq(cpuid, number: uint32_t; handler: interrupt_handler; handler_ex: interrupt_ex_handler; parameter: PVOID): uint32_t; stdcall; public name 'release_ex_fiq';

{Inter Processor Interrupt (IPI) Functions}
function request_ipi(cpuid, number: uint32_t; handler: ipi_handler; parameter: PVOID): uint32_t; stdcall; public name 'request_ipi';
function release_ipi(cpuid, number: uint32_t; handler: ipi_handler; parameter: PVOID): uint32_t; stdcall; public name 'release_ipi';

{Interrupt Register/Deregister Functions}
function register_interrupt(number, mask, priority, flags: uint32_t; handler: shared_interrupt_handler; parameter: PVOID): uint32_t; stdcall; public name 'register_interrupt';
function deregister_interrupt(number, mask, priority, flags: uint32_t; handler: shared_interrupt_handler; parameter: PVOID): uint32_t; stdcall; public name 'deregister_interrupt';

{System Call (Software Interrupt or SWI) Functions}
procedure system_call(number: uint32_t; param1, param2, param3: SIZE_T); stdcall; public name 'system_call';

function register_system_call(number: uint32_t; handler: system_call_handler): uint32_t; stdcall; public name 'register_system_call';
function deregister_system_call(number: uint32_t; handler: system_call_handler): uint32_t; stdcall; public name 'deregister_system_call';
function register_system_call_ex(cpuid, number: uint32_t; handler: system_call_handler; handler_ex: system_call_ex_handler): uint32_t; stdcall; public name 'register_system_call_ex';
function deregister_system_call_ex(cpuid, number: uint32_t; handler: system_call_handler; handler_ex: system_call_ex_handler): uint32_t; stdcall; public name 'deregister_system_call_ex';

{Interrupt Entry Functions}
function get_interrupt_count: uint32_t; stdcall; public name 'get_interrupt_count';
function get_interrupt_start: uint32_t; stdcall; public name 'get_interrupt_start';
function get_interrupt_entry(number, instance: uint32_t; var interrupt: TINTERRUPT_ENTRY): uint32_t; stdcall; public name 'get_interrupt_entry';

{Local Interrupt Entry Functions}
function get_local_interrupt_count: uint32_t; stdcall; public name 'get_local_interrupt_count';
function get_local_interrupt_start: uint32_t; stdcall; public name 'get_local_interrupt_start';
function get_local_interrupt_entry(cpuid, number, instance: uint32_t; var interrupt: TINTERRUPT_ENTRY): uint32_t; stdcall; public name 'get_local_interrupt_entry';

{Software Interrupt Entry (IPI) Functions}
function get_software_interrupt_count: uint32_t; stdcall; public name 'get_software_interrupt_count';
function get_software_interrupt_start: uint32_t; stdcall; public name 'get_software_interrupt_start';
function get_software_interrupt_entry(cpuid, number, instance: uint32_t; var interrupt: TINTERRUPT_ENTRY): uint32_t; stdcall; public name 'get_software_interrupt_entry';

{System Call Entry Functions}
function get_system_call_count: uint32_t; stdcall; public name 'get_system_call_count';
function get_system_call_entry(number: uint32_t): TSYSTEM_CALL_ENTRY; stdcall; public name 'get_system_call_entry';

{System Functions}
function system_restart(delay: uint32_t): uint32_t; stdcall; public name 'system_restart';
function system_shutdown(delay: uint32_t): uint32_t; stdcall; public name 'system_shutdown';

function system_register_shutdown(callback: TShutdownCallback; parameter: PVOID; timeout: uint32_t): uint32_t; stdcall; public name 'system_register_shutdown';
function system_deregister_shutdown(callback: TShutdownCallback; parameter: PVOID): uint32_t; stdcall; public name 'system_deregister_shutdown';

function system_get_uptime: int64_t; stdcall; public name 'system_get_uptime';
function system_get_command_line(commandline: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'system_get_command_line';
function system_get_environment: PVOID; stdcall; public name 'system_get_environment';

function system_date_to_string(date: double_t; value: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'system_date_to_string';
function system_time_to_string(time: double_t; value: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'system_time_to_string';
function system_date_time_to_string(datetime: double_t; value: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'system_date_time_to_string';
function system_interval_to_string(interval: double_t; value: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'system_interval_to_string';

{CPU Functions}
function cpu_get_arch: uint32_t; stdcall; public name 'cpu_get_arch';
function cpu_get_type: uint32_t; stdcall; public name 'cpu_get_type';
function cpu_get_boot: uint32_t; stdcall; public name 'cpu_get_boot';
function cpu_get_mask: uint32_t; stdcall; public name 'cpu_get_mask';
function cpu_get_count: uint32_t; stdcall; public name 'cpu_get_count';
function cpu_get_mode: uint32_t; stdcall; public name 'cpu_get_mode';
function cpu_get_state: uint32_t; stdcall; public name 'cpu_get_state';
function cpu_get_group: uint32_t; stdcall; public name 'cpu_get_group';
function cpu_get_current: uint32_t; stdcall; public name 'cpu_get_current';
function cpu_get_memory(var address: SIZE_T; var length: uint64_t): uint32_t; stdcall; public name 'cpu_get_memory';
function cpu_get_percentage(cpuid: uint32_t): double_t; stdcall; public name 'cpu_get_percentage';
function cpu_get_utilization(cpuid: uint32_t): uint32_t; stdcall; public name 'cpu_get_utilization';

function cpu_get_model: uint32_t; stdcall; public name 'cpu_get_model';
function cpu_get_revision: uint32_t; stdcall; public name 'cpu_get_revision';
function cpu_get_description(description: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'cpu_get_description';

{FPU Functions}
function fpu_get_type: uint32_t; stdcall; public name 'fpu_get_type';
function fpu_get_state: uint32_t; stdcall; public name 'fpu_get_state';

{GPU Functions}
function gpu_get_type: uint32_t; stdcall; public name 'gpu_get_type';
function gpu_get_state: uint32_t; stdcall; public name 'gpu_get_state';
function gpu_get_memory(var address: SIZE_T; var length: uint64_t): uint32_t; stdcall; public name 'gpu_get_memory';

{Cache Functions}
function l1_cache_get_type: uint32_t; stdcall; public name 'l1_cache_get_type';
function l1_data_cache_get_size: uint32_t; stdcall; public name 'l1_data_cache_get_size';
function l1_data_cache_get_linesize: uint32_t; stdcall; public name 'l1_data_cache_get_linesize';
function l1_instruction_cache_get_size: uint32_t; stdcall; public name 'l1_instruction_cache_get_size';
function l1_instruction_cache_get_linesize: uint32_t; stdcall; public name 'l1_instruction_cache_get_linesize';

function l2_cache_get_type: uint32_t; stdcall; public name 'l2_cache_get_type';
function l2_cache_get_size: uint32_t; stdcall; public name 'l2_cache_get_size';
function l2_cache_get_linesize: uint32_t; stdcall; public name 'l2_cache_get_linesize';

{Version Functions}
procedure version_get_info(var major, minor, revision: uint32_t); stdcall; public name 'version_get_info';
function version_get_date(date: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'version_get_date';
function version_get_name(name: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'version_get_name';
function version_get_version(version: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'version_get_version';

{Board Functions}
function board_get_type: uint32_t; stdcall; public name 'board_get_type';
function board_get_model: uint32_t; stdcall; public name 'board_get_model';
function board_get_serial: int64_t; stdcall; public name 'board_get_serial';
function board_get_revision: uint32_t; stdcall; public name 'board_get_revision';
function board_get_mac_address(address: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'board_get_mac_address';

{Chip Functions}
function chip_get_revision: uint32_t; stdcall; public name 'chip_get_revision';

{Firmware Functions}
function firmware_get_revision: uint32_t; stdcall; public name 'firmware_get_revision';
function firmware_get_throttled: uint32_t; stdcall; public name 'firmware_get_throttled';

{Machine Functions}
function machine_get_type: uint32_t; stdcall; public name 'machine_get_type';

{Memory Functions}
function memory_get_base: SIZE_T; stdcall; public name 'memory_get_base';
function memory_get_size: uint64_t; stdcall; public name 'memory_get_size';

function memory_get_pagesize: uint32_t; stdcall; public name 'memory_get_pagesize';
function memory_get_large_pagesize: uint32_t; stdcall; public name 'memory_get_large_pagesize';

function memory_get_section_size: uint32_t; stdcall; public name 'memory_get_section_size';
function memory_get_large_section_size: uint32_t; stdcall; public name 'memory_get_large_section_size';

{Power Functions}
function power_on(powerid: uint32_t): uint32_t; stdcall; public name 'power_on';
function power_off(powerid: uint32_t): uint32_t; stdcall; public name 'power_off';

function power_get_wait(powerid: uint32_t): uint32_t; stdcall; public name 'power_get_wait';
function power_get_state(powerid: uint32_t): uint32_t; stdcall; public name 'power_get_state';
function power_set_state(powerid, state: uint32_t; wait: BOOL): uint32_t; stdcall; public name 'power_set_state';

{Clock Functions}
function clock_ticks: uint32_t; stdcall; public name 'clock_ticks';
function clock_seconds: uint32_t; stdcall; public name 'clock_seconds';

function clock_milliseconds: int64_t; stdcall; public name 'clock_milliseconds';
function clock_microseconds: int64_t; stdcall; public name 'clock_microseconds';
function clock_nanoseconds: int64_t; stdcall; public name 'clock_nanoseconds';

function clock_get_time: int64_t; stdcall; public name 'clock_get_time';
function clock_set_time(const time: int64_t; rtc: BOOL): int64_t; stdcall; public name 'clock_set_time';

function clock_get_count: uint32_t; stdcall; public name 'clock_get_count';
function clock_get_total: int64_t; stdcall; public name 'clock_get_total';

function clock_update_offset: uint32_t; stdcall; public name 'clock_update_offset';

function clock_get_rate(clockid: uint32_t): uint32_t; stdcall; public name 'clock_get_rate';
function clock_set_rate(clockid, rate: uint32_t; turbo: BOOL): uint32_t; stdcall; public name 'clock_set_rate';

function clock_get_state(clockid: uint32_t): uint32_t; stdcall; public name 'clock_get_state';
function clock_set_state(clockid, state: uint32_t): uint32_t; stdcall; public name 'clock_set_state';

function clock_get_min_rate(clockid: uint32_t): uint32_t; stdcall; public name 'clock_get_min_rate';
function clock_get_max_rate(clockid: uint32_t): uint32_t; stdcall; public name 'clock_get_max_rate';

function clock_get_measured_rate(clockid: uint32_t): uint32_t; stdcall; public name 'clock_get_measured_rate';

{Turbo Functions}
function turbo_get_state(turboid: uint32_t): uint32_t; stdcall; public name 'turbo_get_state';
function turbo_set_state(turboid, state: uint32_t): uint32_t; stdcall; public name 'turbo_set_state';

{Voltage Functions}
function voltage_get_value(voltageid: uint32_t): uint32_t; stdcall; public name 'voltage_get_value';
function voltage_set_value(voltageid, value: uint32_t): uint32_t; stdcall; public name 'voltage_set_value';

function voltage_get_min_value(voltageid: uint32_t): uint32_t; stdcall; public name 'voltage_get_min_value';
function voltage_get_max_value(voltageid: uint32_t): uint32_t; stdcall; public name 'voltage_get_max_value';

{Temperature Functions}
function temperature_get_current(temperatureid: uint32_t): uint32_t; stdcall; public name 'temperature_get_current';
function temperature_get_maximum(temperatureid: uint32_t): uint32_t; stdcall; public name 'temperature_get_maximum';

{GPU Memory Functions}
function gpu_memory_allocate(length, alignment, flags: uint32_t): THANDLE; stdcall; public name 'gpu_memory_allocate';
function gpu_memory_release(handle: THANDLE): uint32_t; stdcall; public name 'gpu_memory_release';
function gpu_memory_lock(handle: THANDLE): uint32_t; stdcall; public name 'gpu_memory_lock';
function gpu_memory_unlock(handle: THANDLE): uint32_t; stdcall; public name 'gpu_memory_unlock';

{GPU Misc Functions}
function gpu_execute_code(address: PVOID; r0, r1, r2, r3, r4, r5: uint32_t): uint32_t; stdcall; public name 'gpu_execute_code';

function dispmanx_handle_get(resource: THANDLE): THANDLE; stdcall; public name 'dispmanx_handle_get';
function edid_block_get(block: uint32_t; buffer: PVOID; length: uint32_t): uint32_t; stdcall; public name 'edid_block_get';

{Framebuffer Functions}
function framebuffer_available: BOOL; stdcall; public name 'framebuffer_available';

function framebuffer_allocate(alignment: uint32_t; var address, length: uint32_t): uint32_t; stdcall; public name 'framebuffer_allocate';
function framebuffer_release: uint32_t; stdcall; public name 'framebuffer_release';
function framebuffer_set_state(state: uint32_t): uint32_t; stdcall; public name 'framebuffer_set_state';

function framebuffer_get_dimensions(var width, height, top, bottom, left, right: uint32_t): uint32_t; stdcall; public name 'framebuffer_get_dimensions';

function framebuffer_get_physical(var width, height: uint32_t): uint32_t; stdcall; public name 'framebuffer_get_physical';
function framebuffer_set_physical(var width, height: uint32_t): uint32_t; stdcall; public name 'framebuffer_set_physical';
function framebuffer_test_physical(var width, height: uint32_t): uint32_t; stdcall; public name 'framebuffer_test_physical';

function framebuffer_get_virtual(var width, height: uint32_t): uint32_t; stdcall; public name 'framebuffer_get_virtual';
function framebuffer_set_virtual(var width, height: uint32_t): uint32_t; stdcall; public name 'framebuffer_set_virtual';
function framebuffer_test_virtual(var width, height: uint32_t): uint32_t; stdcall; public name 'framebuffer_test_virtual';

function framebuffer_get_depth(var depth: uint32_t): uint32_t; stdcall; public name 'framebuffer_get_depth';
function framebuffer_set_depth(var depth: uint32_t): uint32_t; stdcall; public name 'framebuffer_set_depth';
function framebuffer_test_depth(var depth: uint32_t): uint32_t; stdcall; public name 'framebuffer_test_depth';

function framebuffer_get_pixel_order(var order: uint32_t): uint32_t; stdcall; public name 'framebuffer_get_pixel_order';
function framebuffer_set_pixel_order(var order: uint32_t): uint32_t; stdcall; public name 'framebuffer_set_pixel_order';
function framebuffer_test_pixel_order(var order: uint32_t): uint32_t; stdcall; public name 'framebuffer_test_pixel_order';

function framebuffer_get_alpha_mode(var mode: uint32_t): uint32_t; stdcall; public name 'framebuffer_get_alpha_mode';
function framebuffer_set_alpha_mode(var mode: uint32_t): uint32_t; stdcall; public name 'framebuffer_set_alpha_mode';
function framebuffer_test_alpha_mode(var mode: uint32_t): uint32_t; stdcall; public name 'framebuffer_test_alpha_mode';

function framebuffer_get_pitch: uint32_t; stdcall; public name 'framebuffer_get_pitch';

function framebuffer_get_offset(var x, y: uint32_t): uint32_t; stdcall; public name 'framebuffer_get_offset';
function framebuffer_set_offset(var x, y: uint32_t): uint32_t; stdcall; public name 'framebuffer_set_offset';
function framebuffer_test_offset(var x, y: uint32_t): uint32_t; stdcall; public name 'framebuffer_test_offset';

function framebuffer_get_overscan(var top, bottom, left, right: uint32_t): uint32_t; stdcall; public name 'framebuffer_get_overscan';
function framebuffer_set_overscan(var top, bottom, left, right: uint32_t): uint32_t; stdcall; public name 'framebuffer_set_overscan';
function framebuffer_test_overscan(var top, bottom, left, right: uint32_t): uint32_t; stdcall; public name 'framebuffer_test_overscan';

function framebuffer_get_palette(buffer: PVOID; length: uint32_t): uint32_t; stdcall; public name 'framebuffer_get_palette';
function framebuffer_set_palette(start, count: uint32_t; buffer: PVOID; length: uint32_t): uint32_t; stdcall; public name 'framebuffer_set_palette';
function framebuffer_test_palette(start, count: uint32_t; buffer: PVOID; length: uint32_t): uint32_t; stdcall; public name 'framebuffer_test_palette';

function framebuffer_get_layer(var layer: int32_t): uint32_t; stdcall; public name 'framebuffer_get_layer';
function framebuffer_set_layer(var layer: int32_t): uint32_t; stdcall; public name 'framebuffer_set_layer';
function framebuffer_test_layer(var layer: int32_t): uint32_t; stdcall; public name 'framebuffer_test_layer';

function framebuffer_test_vsync: uint32_t; stdcall; public name 'framebuffer_test_vsync';
function framebuffer_set_vsync: uint32_t; stdcall; public name 'framebuffer_set_vsync';

function framebuffer_set_backlight(brightness: uint32_t): uint32_t; stdcall; public name 'framebuffer_set_backlight';

function framebuffer_get_num_displays(var numdisplays: uint32_t): uint32_t; stdcall; public name 'framebuffer_get_num_displays';
function framebuffer_get_display_id(displaynum: uint32_t): uint32_t; stdcall; public name 'framebuffer_get_display_id';
function framebuffer_set_display_num(displaynum: uint32_t): uint32_t; stdcall; public name 'framebuffer_set_display_num';
function framebuffer_get_display_settings(displaynum: uint32_t; var displaysettings: TDISPLAY_SETTINGS): uint32_t; stdcall; public name 'framebuffer_get_display_settings';
function framebuffer_display_id_to_name(displayid: uint32_t; name: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'framebuffer_display_id_to_name';

{Touch Functions}
function touch_get_buffer(var address: SIZE_T): uint32_t; stdcall; public name 'touch_get_buffer';
function touch_set_buffer(address: SIZE_T): uint32_t; stdcall; public name 'touch_set_buffer';

{Cursor Functions}
function cursor_set_default: uint32_t; stdcall; public name 'cursor_set_default';
function cursor_set_info(width, height, hotspotx, hotspoty: uint32_t; pixels: PVOID; length: uint32_t): uint32_t; stdcall; public name 'cursor_set_info';
function cursor_set_state(enabled: BOOL; x, y: uint32_t; relative: BOOL): uint32_t; stdcall; public name 'cursor_set_state';

{DMA Functions}
function dma_available: BOOL; stdcall; public name 'dma_available';

function dma_transfer(data: PDMA_DATA; direction, peripheral: uint32_t): uint32_t; stdcall; public name 'dma_transfer';

function dma_fill_memory(dest: PVOID; size: uint32_t; value: Byte): uint32_t; stdcall; public name 'dma_fill_memory';
function dma_copy_memory(source, dest: PVOID; size: uint32_t): uint32_t; stdcall; public name 'dma_copy_memory';

function dma_read_peripheral(address, dest: PVOID; size, peripheral: uint32_t): uint32_t; stdcall; public name 'dma_read_peripheral';
function dma_write_peripheral(source, address: PVOID; size, peripheral: uint32_t): uint32_t; stdcall; public name 'dma_write_peripheral';

function dma_allocate_buffer(size: uint32_t): PVOID; stdcall; public name 'dma_allocate_buffer';
function dma_allocate_buffer_ex(var size: uint32_t): PVOID; stdcall; public name 'dma_allocate_buffer_ex';
function dma_release_buffer(buffer: PVOID): uint32_t; stdcall; public name 'dma_release_buffer';

function dma_get_channels: uint32_t; stdcall; public name 'dma_get_channels';

{Handle Functions}
function handle_create(data: THANDLE; _type: uint32_t): THANDLE; stdcall; public name 'handle_create';
function handle_create_ex(const name: PCHAR; flags: uint32_t; data: THANDLE; _type: uint32_t): PHANDLE_ENTRY;  stdcall; public name 'handle_create_ex';
function handle_destroy(handle: THANDLE): uint32_t; stdcall; public name 'handle_destroy';

function handle_get(handle: THANDLE): PHANDLE_ENTRY; stdcall; public name 'handle_get';
function handle_find(const name: PCHAR): PHANDLE_ENTRY; stdcall; public name 'handle_find';
function handle_enumerate(callback: handle_enumerate_cb; data: PVOID): uint32_t; stdcall; public name 'handle_enumerate';

function handle_open(const name: PCHAR): THANDLE; stdcall; public name 'handle_open';
function handle_close(handle: THANDLE): uint32_t; stdcall; public name 'handle_close';
function handle_duplicate(handle: THANDLE): THANDLE; stdcall; public name 'handle_duplicate';

{GPIO Functions}
function gpio_available: BOOL; stdcall; public name 'gpio_available';

function gpio_read(reg: uint32_t): uint32_t; stdcall; public name 'gpio_read';
procedure gpio_write(reg, value: uint32_t); stdcall; public name 'gpio_write';

function gpio_input_get(pin: uint32_t): uint32_t; stdcall; public name 'gpio_input_get';
function gpio_input_wait(pin, trigger, timeout: uint32_t): uint32_t; stdcall; public name 'gpio_input_wait';
function gpio_input_event(pin, trigger, timeout: uint32_t; callback: gpio_event_cb; data: PVOID): uint32_t; stdcall; public name 'gpio_input_event';

function gpio_output_set(pin, level: uint32_t): uint32_t; stdcall; public name 'gpio_output_set';

function gpio_level_get(pin: uint32_t): uint32_t; stdcall; public name 'gpio_level_get';
function gpio_level_set(pin, level: uint32_t): uint32_t; stdcall; public name 'gpio_level_set';

function gpio_pull_get(pin: uint32_t): uint32_t; stdcall; public name 'gpio_pull_get';
function gpio_pull_select(pin, mode: uint32_t): uint32_t; stdcall; public name 'gpio_pull_select';

function gpio_function_get(pin: uint32_t): uint32_t; stdcall; public name 'gpio_function_get';
function gpio_function_select(pin, mode: uint32_t): uint32_t; stdcall; public name 'gpio_function_select';

{Virtual gpio_ Functions}
function virtual_gpio_input_get(pin: uint32_t): uint32_t; stdcall; public name 'virtual_gpio_input_get';
function virtual_gpio_output_set(pin, level: uint32_t): uint32_t; stdcall; public name 'virtual_gpio_output_set';

function virtual_gpio_level_get(pin: uint32_t): uint32_t; stdcall; public name 'virtual_gpio_level_get';
function virtual_gpio_level_set(pin, level: uint32_t): uint32_t; stdcall; public name 'virtual_gpio_level_set';

function virtual_gpio_function_get(pin: uint32_t): uint32_t; stdcall; public name 'virtual_gpio_function_get';
function virtual_gpio_function_select(pin, mode: uint32_t): uint32_t; stdcall; public name 'virtual_gpio_function_select';

{SPI Functions}
function spi_available: BOOL; stdcall; public name 'spi_available';

function spi_start(mode, clockrate, clockphase, clockpolarity: uint32_t): uint32_t; stdcall; public name 'spi_start';
function spi_stop: uint32_t; stdcall; public name 'spi_stop';

function spi_read(chipselect: uint16_t; dest: PVOID; size: uint32_t; var count: uint32_t): uint32_t; stdcall; public name 'spi_read';
function spi_write(chipselect: uint16_t; source: PVOID; size: uint32_t; var count: uint32_t): uint32_t; stdcall; public name 'spi_write';
function spi_write_read(chipselect: uint16_t; source, dest: PVOID; size: uint32_t; var count: uint32_t): uint32_t; stdcall; public name 'spi_write_read';

function spi_get_mode: uint32_t; stdcall; public name 'spi_get_mode';
function spi_set_mode(mode: uint32_t): uint32_t; stdcall; public name 'spi_set_mode';

function spi_get_clock_rate(chipselect: uint16_t): uint32_t; stdcall; public name 'spi_get_clock_rate';
function spi_set_clock_rate(chipselect: uint16_t; clockrate: uint32_t): uint32_t; stdcall; public name 'spi_set_clock_rate';

function spi_get_clock_phase: uint32_t; stdcall; public name 'spi_get_clock_phase';
function spi_set_clock_phase(clockphase: uint32_t): uint32_t; stdcall; public name 'spi_set_clock_phase';

function spi_get_clock_polarity: uint32_t; stdcall; public name 'spi_get_clock_polarity';
function spi_set_clock_polarity(clockpolarity: uint32_t): uint32_t; stdcall; public name 'spi_set_clock_polarity';

function spi_get_select_polarity(chipselect: uint16_t): uint32_t; stdcall; public name 'spi_get_select_polarity';
function spi_set_select_polarity(chipselect: uint16_t; selectpolarity: uint32_t): uint32_t; stdcall; public name 'spi_set_select_polarity';

function spi_get_description(id: uint32_t; description: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'spi_get_description';

{I2C Functions}
function i2c_available: BOOL; stdcall; public name 'i2c_available';

function i2c_start(rate: uint32_t): uint32_t; stdcall; public name 'i2c_start';
function i2c_stop: uint32_t; stdcall; public name 'i2c_stop';

function i2c_read(address: uint16_t; buffer: PVOID; size: uint32_t; var count: uint32_t): uint32_t; stdcall; public name 'i2c_read';
function i2c_write(address: uint16_t; buffer: PVOID; size: uint32_t; var count: uint32_t): uint32_t; stdcall; public name 'i2c_write';
function i2c_write_read(address: uint16_t; initial: PVOID; len: uint32_t; data: PVOID; size: uint32_t; var count: uint32_t): uint32_t; stdcall; public name 'i2c_write_read';
function i2c_write_write(address: uint16_t; initial: PVOID; len: uint32_t; data: PVOID; size: uint32_t; var count: uint32_t): uint32_t; stdcall; public name 'i2c_write_write';

function i2c_get_rate: uint32_t; stdcall; public name 'i2c_get_rate';
function i2c_set_rate(rate: uint32_t): uint32_t; stdcall; public name 'i2c_set_rate';

function i2c_get_address: uint16_t; stdcall; public name 'i2c_get_address';
function i2c_set_address(address: uint16_t): uint32_t; stdcall; public name 'i2c_set_address';

function i2c_get_description(id: uint32_t; description: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'i2c_get_description';
function i2c_slave_get_description(id: uint32_t; description: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'i2c_slave_get_description';

{PWM Functions}
function pwm_available: BOOL; stdcall; public name 'pwm_available';

function pwm_start: uint32_t; stdcall; public name 'pwm_start';
function pwm_stop: uint32_t; stdcall; public name 'pwm_stop';

function pwm_write(value: uint32_t): uint32_t; stdcall; public name 'pwm_write';

function pwm_set_mode(mode: uint32_t): uint32_t; stdcall; public name 'pwm_set_mode';
function pwm_set_range(range: uint32_t): uint32_t; stdcall; public name 'pwm_set_range';
function pwm_set_frequency(frequency: uint32_t): uint32_t; stdcall; public name 'pwm_set_frequency';

function pwm_configure(dutyns, periodns: uint32_t): uint32_t; stdcall; public name 'pwm_configure';

function pwm_get_description(id, channel: uint32_t; description: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'pwm_get_description';

{RTC Functions}
function rtc_available: BOOL; stdcall; public name 'rtc_available';

function rtc_get_time: int64_t; stdcall; public name 'rtc_get_time';
function rtc_set_time(const time: int64_t): int64_t; stdcall; public name 'rtc_set_time';

{UART Functions}
function uart_get_description(id: uint32_t; description: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'uart_get_description';

{Serial Functions}
function serial_available: BOOL; stdcall; public name 'serial_available';

function serial_open(baudrate, databits, stopbits, parity, flowcontrol, receivedepth, transmitdepth: uint32_t): uint32_t; stdcall; public name 'serial_open';
function serial_close: uint32_t; stdcall; public name 'serial_close';

function serial_read(buffer: PVOID; size: uint32_t; var count: uint32_t): uint32_t; stdcall; public name 'serial_read';
function serial_write(buffer: PVOID; size: uint32_t; var count: uint32_t): uint32_t; stdcall; public name 'serial_write';

{Peripheral Functions}
function peripheral_get_base: SIZE_T; stdcall; public name 'peripheral_get_base';
function peripheral_get_size: uint32_t; stdcall; public name 'peripheral_get_size';

function peripheral_read(base, reg: uint32_t): uint32_t; stdcall; public name 'peripheral_read';
procedure peripheral_write(base, reg, value: uint32_t); stdcall; public name 'peripheral_write';

function local_peripheral_get_base: SIZE_T; stdcall; public name 'local_peripheral_get_base';
function local_peripheral_get_size: uint32_t; stdcall; public name 'local_peripheral_get_size';

{System Functions}
function get_sp: SIZE_T; stdcall; public name 'get_sp';
function get_pc: SIZE_T; stdcall; public name 'get_pc';

function get_irq: BOOL; stdcall; public name 'get_irq';
procedure enable_irq; stdcall; public name 'enable_irq';
procedure disable_irq; stdcall; public name 'disable_irq';
function save_irq: TIRQ_MASK; stdcall; public name 'save_irq';
function restore_irq(irqmask: TIRQ_MASK): TIRQ_MASK; stdcall; public name 'restore_irq';

function get_fiq: BOOL; stdcall; public name 'get_fiq';
procedure enable_fiq; stdcall; public name 'enable_fiq';
procedure disable_fiq; stdcall; public name 'disable_fiq';
function save_fiq: TFIQ_MASK; stdcall; public name 'save_fiq';
function restore_fiq(fiqmask: TFIQ_MASK): TFIQ_MASK; stdcall; public name 'restore_fiq';

procedure enable_irq_fiq; stdcall; public name 'enable_irq_fiq';
procedure disable_irq_fiq; stdcall; public name 'disable_irq_fiq';
function save_irq_fiq: TIRQ_FIQ_MASK; stdcall; public name 'save_irq_fiq';
function restore_irq_fiq(irqfiqmask: TIRQ_FIQ_MASK): TIRQ_FIQ_MASK; stdcall; public name 'restore_irq_fiq';

function get_abort: BOOL; stdcall; public name 'get_abort';
procedure enable_abort; stdcall; public name 'enable_abort';
procedure disable_abort; stdcall; public name 'disable_abort';
function save_abort: TABORT_MASK; stdcall; public name 'save_abort';
function restore_abort(abortmask: TABORT_MASK): TABORT_MASK; stdcall; public name 'restore_abort';

procedure halt_cpu; stdcall; public name 'halt_cpu';
procedure pause_cpu; stdcall; public name 'pause_cpu';

function halt_thread(exitcode: uint32_t): uint32_t; stdcall; public name 'halt_thread';

procedure send_event; stdcall; public name 'send_event';
procedure wait_for_event; stdcall; public name 'wait_for_event';
procedure wait_for_interrupt; stdcall; public name 'wait_for_interrupt';

procedure read_memory_barrier; stdcall; public name 'read_memory_barrier';
procedure write_memory_barrier; stdcall; public name 'write_memory_barrier';

procedure data_memory_barrier; stdcall; public name 'data_memory_barrier';
procedure data_synchronization_barrier; stdcall; public name 'data_synchronization_barrier';
procedure instruction_memory_barrier; stdcall; public name 'instruction_memory_barrier';

procedure invalidate_tlb; stdcall; public name 'invalidate_tlb';
procedure invalidate_data_tlb; stdcall; public name 'invalidate_data_tlb';
procedure invalidate_instruction_tlb; stdcall; public name 'invalidate_instruction_tlb';

procedure invalidate_cache; stdcall; public name 'invalidate_cache';
procedure clean_data_cache; stdcall; public name 'clean_data_cache';
procedure invalidate_data_cache; stdcall; public name 'invalidate_data_cache';
procedure clean_and_invalidate_data_cache; stdcall; public name 'clean_and_invalidate_data_cache';
procedure invalidate_instruction_cache; stdcall; public name 'invalidate_instruction_cache';

procedure clean_data_cache_range(address: SIZE_T; size: uint32_t); stdcall; public name 'clean_data_cache_range';
procedure invalidate_data_cache_range(address: SIZE_T; size: uint32_t); stdcall; public name 'invalidate_data_cache_range';
procedure clean_and_invalidate_data_cache_range(address: SIZE_T; size: uint32_t); stdcall; public name 'clean_and_invalidate_data_cache_range';
procedure invalidate_instruction_cache_range(address: SIZE_T; size: uint32_t); stdcall; public name 'invalidate_instruction_cache_range';

procedure flush_prefetch_buffer; stdcall; public name 'flush_prefetch_buffer';

procedure flush_branch_target_cache; stdcall; public name 'flush_branch_target_cache';

procedure context_switch(oldstack, newstack: PVOID; newthread: TTHREADHANDLE); stdcall; public name 'context_switch';
procedure context_switch_irq(oldstack, newstack: PVOID; newthread: TTHREADHANDLE); stdcall; public name 'context_switch_irq';
procedure context_switch_fiq(oldstack, newstack: PVOID; newthread: TTHREADHANDLE); stdcall; public name 'context_switch_fiq';
procedure context_switch_swi(oldstack, newstack: PVOID; newthread: TTHREADHANDLE); stdcall; public name 'context_switch_swi';

function interlocked_or(var target: int32_t; value: int32_t): int32_t; stdcall; public name 'interlocked_or';
function interlocked_xor(var target: int32_t; value: int32_t): int32_t; stdcall; public name 'interlocked_xor';
function interlocked_and(var target: int32_t; value: int32_t): int32_t; stdcall; public name 'interlocked_and';

function interlocked_decrement(var target: int32_t): int32_t; stdcall; public name 'interlocked_decrement';
function interlocked_increment(var target: int32_t): int32_t; stdcall; public name 'interlocked_increment';
function interlocked_exchange(var target: int32_t; source: int32_t): int32_t; stdcall; public name 'interlocked_exchange';
function interlocked_add_exchange(var target: int32_t; source: int32_t): int32_t; stdcall; public name 'interlocked_add_exchange';
function interlocked_compare_exchange(var target: int32_t; source, compare: int32_t): int32_t; stdcall; public name 'interlocked_compare_exchange';

function page_table_get_levels: uint32_t; stdcall; public name 'page_table_get_levels';

function page_directory_get_base: SIZE_T; stdcall; public name 'page_directory_get_base';
function page_directory_get_size: uint32_t; stdcall; public name 'page_directory_get_size';

function page_table_get_base: SIZE_T; stdcall; public name 'page_table_get_base';
function page_table_get_size: uint32_t; stdcall; public name 'page_table_get_size';

procedure page_table_get_entry(address: SIZE_T; var entry: TPAGE_TABLE_ENTRY); stdcall; public name 'page_table_get_entry';
function page_table_set_entry(const entry: TPAGE_TABLE_ENTRY): uint32_t; stdcall; public name 'page_table_set_entry';

function page_table_get_page_size(address: SIZE_T): uint32_t; stdcall; public name 'page_table_get_page_size';
function page_table_get_page_flags(address: SIZE_T): uint32_t; stdcall; public name 'page_table_get_page_flags';
{$IFDEF CPU32}
function page_table_get_page_range(address: SIZE_T): uint32_t; stdcall; public name 'page_table_get_page_range';
{$ENDIF CPU32}
function page_table_get_page_physical(address: SIZE_T): SIZE_T; stdcall; public name 'page_table_get_page_physical';

function page_tables_get_address: SIZE_T; stdcall; public name 'page_tables_get_address';
function page_tables_get_length: uint32_t; stdcall; public name 'page_tables_get_length';
function page_tables_get_count: uint32_t; stdcall; public name 'page_tables_get_count';
function page_tables_get_shift: uint32_t; stdcall; public name 'page_tables_get_shift';

function page_tables_get_next: SIZE_T; stdcall; public name 'page_tables_get_next';
function page_tables_get_used: uint32_t; stdcall; public name 'page_tables_get_used';
function page_tables_get_free: uint32_t; stdcall; public name 'page_tables_get_free';

function vector_table_get_base: SIZE_T; stdcall; public name 'vector_table_get_base';
function vector_table_get_size: uint32_t; stdcall; public name 'vector_table_get_size';
function vector_table_get_count: uint32_t; stdcall; public name 'vector_table_get_count';
function vector_table_get_entry(number: uint32_t): SIZE_T; stdcall; public name 'vector_table_get_entry';
function vector_table_set_entry(number: uint32_t; address: SIZE_T): uint32_t; stdcall; public name 'vector_table_set_entry';

{Console Functions}
function console_get_key(var ch: CHAR; userdata: PVOID): BOOL; stdcall; public name 'console_get_key';
function console_peek_key(var ch: CHAR; userdata: PVOID): BOOL; stdcall; public name 'console_peek_key';

function console_write_char(ch: CHAR; userdata: PVOID): BOOL; stdcall; public name 'console_write_char';
function console_read_char(var ch: CHAR; userdata: PVOID): BOOL; stdcall; public name 'console_read_char';
function console_read_widechar(var ch: WIDECHAR; userdata: PVOID): BOOL; stdcall; public name 'console_read_widechar';

function console_hide_mouse(userdata: PVOID): BOOL; stdcall; public name 'console_hide_mouse';
function console_show_mouse(x, y: uint32_t; userdata: PVOID): BOOL; stdcall; public name 'console_show_mouse';
function console_read_mouse(var x, y, buttons: uint32_t; userdata: PVOID): BOOL; stdcall; public name 'console_read_mouse';

{CodePage Functions}
function codepage_to_widechar(ch: CHAR): WIDECHAR; stdcall; public name 'codepage_to_widechar';
function widechar_to_codepage(ch: WIDECHAR): CHAR; stdcall; public name 'widechar_to_codepage';

{Name Functions}
function host_get_name(name: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'host_get_name';
function host_set_name(const name: PCHAR): BOOL; stdcall; public name 'host_set_name';
function host_get_domain(domain: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'host_get_domain';
function host_set_domain(const domain: PCHAR): BOOL; stdcall; public name 'host_set_domain';

{Module Functions}
function module_load(const name: PCHAR): THANDLE; stdcall; public name 'module_load';
function module_load_ex(const name: PCHAR; flags: uint32_t): THANDLE; stdcall; public name 'module_load_ex';
function module_unload(handle: THANDLE): BOOL; stdcall; public name 'module_unload';
function module_get_name(handle: THANDLE; name: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'module_get_name';

{Symbol Functions}
function symbol_add(handle: THANDLE; const name: PCHAR; address: SIZE_T): BOOL; stdcall; public name 'symbol_add';
function symbol_remove(handle: THANDLE; const name: PCHAR): BOOL; stdcall; public name 'symbol_remove';
function symbol_get_address(handle: THANDLE; const name: PCHAR): SIZE_T; stdcall; public name 'symbol_get_address';

{Logging Functions}
procedure logging_output(const text: PCHAR); stdcall; public name 'logging_output';
procedure logging_output_ex(facility, severity: uint32_t; const tag, content: PCHAR); stdcall; public name 'logging_output_ex';

{Environment Functions}
function environment_get(const name: PCHAR; value: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'environment_get';
function environment_set(const name, value: PCHAR): uint32_t; stdcall; public name 'environment_set';
function environment_count(reset: BOOL): uint32_t; stdcall; public name 'environment_count';
function environment_index(const name: PCHAR): uint32_t; stdcall; public name 'environment_index';
function environment_string(index: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'environment_string';

{Utility Functions}
function first_bit_set(value: uint32_t): uint32_t; stdcall; public name 'first_bit_set';
function last_bit_set(value: uint32_t): uint32_t; stdcall; public name 'last_bit_set';
function count_leading_zeros(value: uint32_t): uint32_t; stdcall; public name 'count_leading_zeros';
function count_trailing_zeros(value: uint32_t): uint32_t; stdcall; public name 'count_trailing_zeros';

function physical_to_ioaddress(address: PVOID): SIZE_T; stdcall; public name 'physical_to_ioaddress';
function ioaddress_to_physical(address: PVOID): SIZE_T; stdcall; public name 'ioaddress_to_physical';

function physical_to_busaddress(address: PVOID): SIZE_T; stdcall; public name 'physical_to_busaddress';
function busaddress_to_physical(address: PVOID): SIZE_T; stdcall; public name 'busaddress_to_physical';

procedure nanosecond_delay(nanoseconds: uint32_t); stdcall; public name 'nanosecond_delay';
procedure microsecond_delay(microseconds: uint32_t); stdcall; public name 'microsecond_delay';
procedure millisecond_delay(milliseconds: uint32_t); stdcall; public name 'millisecond_delay';

procedure nanosecond_delay_ex(nanoseconds: uint32_t; wait: BOOL); stdcall; public name 'nanosecond_delay_ex';
procedure microsecond_delay_ex(microseconds: uint32_t; wait: BOOL); stdcall; public name 'microsecond_delay_ex';
procedure millisecond_delay_ex(milliseconds: uint32_t; wait: BOOL); stdcall; public name 'millisecond_delay_ex';

{RTL Functions}
function get_tick_count:uint32_t; stdcall; public name 'get_tick_count';
function get_tick_count64:uint64_t; stdcall; public name 'get_tick_count64';
{$ENDIF}
{==============================================================================}
{Threads Functions}
{$IFDEF API_EXPORT_THREADS}
{Spin Functions}
function spin_create: SPIN_HANDLE; stdcall; public name 'spin_create';
function spin_create_ex(initialowner: BOOL): SPIN_HANDLE; stdcall; public name 'spin_create_ex';
function spin_destroy(spin: SPIN_HANDLE): uint32_t; stdcall; public name 'spin_destroy';

function spin_owner(spin: SPIN_HANDLE): THREAD_HANDLE; stdcall; public name 'spin_owner';

function spin_lock(spin: SPIN_HANDLE): uint32_t; stdcall; public name 'spin_lock';
function spin_unlock(spin: SPIN_HANDLE): uint32_t; stdcall; public name 'spin_unlock';

function spin_lock_irq(spin: SPIN_HANDLE): uint32_t; stdcall; public name 'spin_lock_irq';
function spin_unlock_irq(spin: SPIN_HANDLE): uint32_t; stdcall; public name 'spin_unlock_irq';

function spin_lock_fiq(spin: SPIN_HANDLE): uint32_t; stdcall; public name 'spin_lock_fiq';
function spin_unlock_fiq(spin: SPIN_HANDLE): uint32_t; stdcall; public name 'spin_unlock_fiq';

function spin_lock_irq_fiq(spin: SPIN_HANDLE): uint32_t; stdcall; public name 'spin_lock_irq_fiq';
function spin_unlock_irq_fiq(spin: SPIN_HANDLE): uint32_t; stdcall; public name 'spin_unlock_irq_fiq';

function spin_lock_preempt(spin: SPIN_HANDLE): uint32_t; stdcall; public name 'spin_lock_preempt';
function spin_unlock_preempt(spin: SPIN_HANDLE): uint32_t; stdcall; public name 'spin_unlock_preempt';

function spin_check_irq(spin: SPIN_HANDLE): BOOL; stdcall; public name 'spin_check_irq';
function spin_check_fiq(spin: SPIN_HANDLE): BOOL; stdcall; public name 'spin_check_fiq';

function spin_exchange_irq(spin1, spin2: SPIN_HANDLE): uint32_t; stdcall; public name 'spin_exchange_irq';
function spin_exchange_fiq(spin1, spin2: SPIN_HANDLE): uint32_t; stdcall; public name 'spin_exchange_fiq';

{Mutex Functions}
function mutex_create: MUTEX_HANDLE; stdcall; public name 'mutex_create';
function mutex_create_ex(initialowner: BOOL; spincount: uint32_t; flags: uint32_t): MUTEX_HANDLE; stdcall; public name 'mutex_create_ex';
function mutex_destroy(mutex: MUTEX_HANDLE): uint32_t; stdcall; public name 'mutex_destroy';

function mutex_flags(mutex: MUTEX_HANDLE): uint32_t; stdcall; public name 'mutex_flags';
function mutex_count(mutex: MUTEX_HANDLE): uint32_t; stdcall; public name 'mutex_count';
function mutex_owner(mutex: MUTEX_HANDLE): THREAD_HANDLE; stdcall; public name 'mutex_owner';

function mutex_lock(mutex: MUTEX_HANDLE): uint32_t; stdcall; public name 'mutex_lock';
function mutex_unlock(mutex: MUTEX_HANDLE): uint32_t; stdcall; public name 'mutex_unlock';
function mutex_try_lock(mutex: MUTEX_HANDLE): uint32_t; stdcall; public name 'mutex_try_lock';

{Critical Section Functions}
function critical_section_create: CRITICAL_SECTION_HANDLE; stdcall; public name 'critical_section_create';
function critical_section_create_ex(initialowner: BOOL; spincount: uint32_t): CRITICAL_SECTION_HANDLE; stdcall; public name 'critical_section_create_ex';
function critical_section_destroy(criticalsection: CRITICAL_SECTION_HANDLE): uint32_t; stdcall; public name 'critical_section_destroy';

function critical_section_count(criticalsection: CRITICAL_SECTION_HANDLE): uint32_t; stdcall; public name 'critical_section_count';
function critical_section_owner(criticalsection: CRITICAL_SECTION_HANDLE): THREAD_HANDLE; stdcall; public name 'critical_section_owner';
function critical_section_set_spin_count(criticalsection: CRITICAL_SECTION_HANDLE; spincount: uint32_t): uint32_t; stdcall; public name 'critical_section_set_spin_count';

function critical_section_lock(criticalsection: CRITICAL_SECTION_HANDLE): uint32_t; stdcall; public name 'critical_section_lock';
function critical_section_lock_ex(criticalsection: CRITICAL_SECTION_HANDLE; timeout: uint32_t): uint32_t; stdcall; public name 'critical_section_lock_ex';
function critical_section_unlock(criticalsection: CRITICAL_SECTION_HANDLE): uint32_t; stdcall; public name 'critical_section_unlock';
function critical_section_try_lock(criticalsection: CRITICAL_SECTION_HANDLE): uint32_t; stdcall; public name 'critical_section_try_lock';

{Semaphore Functions}
function semaphore_create(count: uint32_t): SEMAPHORE_HANDLE; stdcall; public name 'semaphore_create';
function semaphore_create_ex(count, maximum: uint32_t; flags: uint32_t): SEMAPHORE_HANDLE; stdcall; public name 'semaphore_create_ex';
function semaphore_destroy(semaphore: SEMAPHORE_HANDLE): uint32_t; stdcall; public name 'semaphore_destroy';

function semaphore_count(semaphore: SEMAPHORE_HANDLE): uint32_t; stdcall; public name 'semaphore_count';

function semaphore_wait(semaphore: SEMAPHORE_HANDLE): uint32_t; stdcall; public name 'semaphore_wait';
function semaphore_wait_ex(semaphore: SEMAPHORE_HANDLE; timeout: uint32_t): uint32_t; stdcall; public name 'semaphore_wait_ex';
function semaphore_signal(semaphore: SEMAPHORE_HANDLE): uint32_t; stdcall; public name 'semaphore_signal';
function semaphore_signal_ex(semaphore: SEMAPHORE_HANDLE; count: uint32_t; previous: Puint32_t): uint32_t; stdcall; public name 'semaphore_signal_ex';

{Synchronizer Functions}
function synchronizer_create: SYNCHRONIZER_HANDLE; stdcall; public name 'synchronizer_create';
function synchronizer_create_ex(initialreader, initialwriter: BOOL): SYNCHRONIZER_HANDLE; stdcall; public name 'synchronizer_create_ex';
function synchronizer_destroy(synchronizer: SYNCHRONIZER_HANDLE): uint32_t; stdcall; public name 'synchronizer_destroy';

function synchronizer_reader_count(synchronizer: SYNCHRONIZER_HANDLE): uint32_t; stdcall; public name 'synchronizer_reader_count';
function synchronizer_reader_last(synchronizer: SYNCHRONIZER_HANDLE): THREAD_HANDLE; stdcall; public name 'synchronizer_reader_last';

function synchronizer_reader_lock(synchronizer: SYNCHRONIZER_HANDLE): uint32_t; stdcall; public name 'synchronizer_reader_lock';
function synchronizer_reader_lock_ex(synchronizer: SYNCHRONIZER_HANDLE; timeout: uint32_t): uint32_t; stdcall; public name 'synchronizer_reader_lock_ex';
function synchronizer_reader_unlock(synchronizer: SYNCHRONIZER_HANDLE): uint32_t; stdcall; public name 'synchronizer_reader_unlock';
function synchronizer_reader_convert(synchronizer: SYNCHRONIZER_HANDLE): uint32_t; stdcall; public name 'synchronizer_reader_convert';
function synchronizer_reader_convert_ex(synchronizer: SYNCHRONIZER_HANDLE; timeout: uint32_t): uint32_t; stdcall; public name 'synchronizer_reader_convert_ex';

function synchronizer_writer_count(synchronizer: SYNCHRONIZER_HANDLE): uint32_t; stdcall; public name 'synchronizer_writer_count';
function synchronizer_writer_owner(synchronizer: SYNCHRONIZER_HANDLE): THREAD_HANDLE; stdcall; public name 'synchronizer_writer_owner';

function synchronizer_writer_lock(synchronizer: SYNCHRONIZER_HANDLE): uint32_t; stdcall; public name 'synchronizer_writer_lock';
function synchronizer_writer_lock_ex(synchronizer: SYNCHRONIZER_HANDLE; timeout: uint32_t): uint32_t; stdcall; public name 'synchronizer_writer_lock_ex';
function synchronizer_writer_unlock(synchronizer: SYNCHRONIZER_HANDLE): uint32_t; stdcall; public name 'synchronizer_writer_unlock';
function synchronizer_writer_convert(synchronizer: SYNCHRONIZER_HANDLE): uint32_t; stdcall; public name 'synchronizer_writer_convert';

{Condition Functions}
function condition_create: CONDITION_HANDLE; stdcall; public name 'condition_create';
function condition_destroy(condition: CONDITION_HANDLE): uint32_t; stdcall; public name 'condition_destroy';

function condition_wait(condition: CONDITION_HANDLE; timeout: uint32_t): uint32_t; stdcall; public name 'condition_wait';
function condition_wait_mutex(condition: CONDITION_HANDLE; mutex: MUTEX_HANDLE; timeout: uint32_t): uint32_t; stdcall; public name 'condition_wait_mutex';
function condition_wait_synchronizer(condition: CONDITION_HANDLE; synchronizer: SYNCHRONIZER_HANDLE; flags: uint32_t; timeout: uint32_t): uint32_t; stdcall; public name 'condition_wait_synchronizer';
function condition_wait_critical_section(condition: CONDITION_HANDLE; criticalsection: CRITICAL_SECTION_HANDLE; timeout: uint32_t): uint32_t; stdcall; public name 'condition_wait_critical_section';

function condition_wake(condition: CONDITION_HANDLE): uint32_t; stdcall; public name 'condition_wake';
function condition_wake_all(condition: CONDITION_HANDLE): uint32_t; stdcall; public name 'condition_wake_all';

{Completion Functions}
function completion_create(flags: uint32_t): COMPLETION_HANDLE; stdcall; public name 'completion_create';
function completion_destroy(completion: COMPLETION_HANDLE): uint32_t; stdcall; public name 'completion_destroy';

function completion_state(completion: COMPLETION_HANDLE): uint32_t; stdcall; public name 'completion_state';

function completion_wait(completion: COMPLETION_HANDLE; timeout: uint32_t): uint32_t; stdcall; public name 'completion_wait';
function completion_try_wait(completion: COMPLETION_HANDLE): uint32_t; stdcall; public name 'completion_try_wait';

function completion_reset(completion: COMPLETION_HANDLE): uint32_t; stdcall; public name 'completion_reset';
function completion_complete(completion: COMPLETION_HANDLE): uint32_t; stdcall; public name 'completion_complete';
function completion_complete_all(completion: COMPLETION_HANDLE): uint32_t; stdcall; public name 'completion_complete_all';

{List Functions}
function list_create: LIST_HANDLE; stdcall; public name 'list_create';
function list_create_ex(listtype: uint32_t; flags: uint32_t): LIST_HANDLE; stdcall; public name 'list_create_ex';
function list_destroy(list: LIST_HANDLE): uint32_t; stdcall; public name 'list_destroy';

function list_count(list: LIST_HANDLE): uint32_t; stdcall; public name 'list_count';

function list_add_first(list: LIST_HANDLE; element: PLIST_ELEMENT): uint32_t; stdcall; public name 'list_add_first';
function list_add_last(list: LIST_HANDLE; element: PLIST_ELEMENT): uint32_t; stdcall; public name 'list_add_last';

function list_get_thread(list: LIST_HANDLE; thread: THREAD_HANDLE): PLIST_ELEMENT; stdcall; public name 'list_get_thread';

function list_get_first(list: LIST_HANDLE): PLIST_ELEMENT; stdcall; public name 'list_get_first';
function list_get_first_ex(list: LIST_HANDLE; remove: BOOL): PLIST_ELEMENT; stdcall; public name 'list_get_first_ex';
function list_get_last(list: LIST_HANDLE): PLIST_ELEMENT; stdcall; public name 'list_get_last';
function list_get_last_ex(list: LIST_HANDLE; remove: BOOL): PLIST_ELEMENT; stdcall; public name 'list_get_last_ex';

function list_insert(list: LIST_HANDLE; previous, element: PLIST_ELEMENT): uint32_t; stdcall; public name 'list_insert';
function list_remove(list: LIST_HANDLE; element: PLIST_ELEMENT): uint32_t; stdcall; public name 'list_remove';

function list_is_empty(list: LIST_HANDLE): BOOL; stdcall; public name 'list_is_empty';
function list_not_empty(list: LIST_HANDLE): BOOL; stdcall; public name 'list_not_empty';

function list_lock(list: LIST_HANDLE): uint32_t; stdcall; public name 'list_lock';
function list_unlock(list: LIST_HANDLE): uint32_t; stdcall; public name 'list_unlock';

{Queue Functions}
function queue_create: QUEUE_HANDLE; stdcall; public name 'queue_create';
function queue_create_ex(queuetype: uint32_t; flags: uint32_t): QUEUE_HANDLE; stdcall; public name 'queue_create_ex';
function queue_destroy(queue: QUEUE_HANDLE): uint32_t; stdcall; public name 'queue_destroy';

function queue_count(queue: QUEUE_HANDLE): uint32_t; stdcall; public name 'queue_count';

function queue_enqueue(queue: QUEUE_HANDLE; thread: THREAD_HANDLE): uint32_t; stdcall; public name 'queue_enqueue';
function queue_dequeue(queue: QUEUE_HANDLE): THREAD_HANDLE; stdcall; public name 'queue_dequeue';

function queue_first_key(queue: QUEUE_HANDLE): int; stdcall; public name 'queue_first_key';
function queue_last_key(queue: QUEUE_HANDLE): int; stdcall; public name 'queue_last_key';

function queue_insert_key(queue: QUEUE_HANDLE; thread: THREAD_HANDLE; key: int): uint32_t; stdcall; public name 'queue_insert_key';
function queue_delete_key(queue: QUEUE_HANDLE; thread: THREAD_HANDLE): uint32_t; stdcall; public name 'queue_delete_key';
function queue_increment_key(queue: QUEUE_HANDLE): int; stdcall; public name 'queue_increment_key';
function queue_decrement_key(queue: QUEUE_HANDLE): int; stdcall; public name 'queue_decrement_key';

function queue_is_empty(queue: QUEUE_HANDLE): BOOL; stdcall; public name 'queue_is_empty';
function queue_not_empty(queue: QUEUE_HANDLE): BOOL; stdcall; public name 'queue_not_empty';

function queue_lock(queue: QUEUE_HANDLE): uint32_t; stdcall; public name 'queue_lock';
function queue_unlock(queue: QUEUE_HANDLE): uint32_t; stdcall; public name 'queue_unlock';

{Thread Functions}
function thread_create(startproc: thread_start_proc; stacksize, priority: uint32_t; const name: PCHAR; parameter: PVOID): THREAD_HANDLE; stdcall; public name 'thread_create';
function thread_create_ex(startproc: thread_start_proc; stacksize, priority, affinity, cpu: uint32_t; const name: PCHAR; parameter: PVOID): THREAD_HANDLE; stdcall; public name 'thread_create_ex';
function thread_destroy(thread: THREAD_HANDLE): uint32_t; stdcall; public name 'thread_destroy';

function thread_get_current: THREAD_HANDLE; stdcall; public name 'thread_get_current';
function thread_set_current(thread: THREAD_HANDLE): uint32_t; stdcall; public name 'thread_set_current';

function thread_get_name(thread: THREAD_HANDLE; name: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'thread_get_name';
function thread_set_name(thread: THREAD_HANDLE; const name: PCHAR): uint32_t; stdcall; public name 'thread_set_name';

function thread_get_cpu(thread: THREAD_HANDLE): uint32_t; stdcall; public name 'thread_get_cpu';
function thread_set_cpu(thread: THREAD_HANDLE; cpu: uint32_t): uint32_t; stdcall; public name 'thread_set_cpu';

function thread_get_state(thread: THREAD_HANDLE): uint32_t; stdcall; public name 'thread_get_state';

function thread_get_flags(thread: THREAD_HANDLE): uint32_t; stdcall; public name 'thread_get_flags';
function thread_set_flags(thread: THREAD_HANDLE; flags: uint32_t): uint32_t; stdcall; public name 'thread_set_flags';
function thread_add_flags(thread: THREAD_HANDLE; flags: uint32_t): uint32_t; stdcall; public name 'thread_add_flags';
function thread_remove_flags(thread: THREAD_HANDLE; flags: uint32_t): uint32_t; stdcall; public name 'thread_remove_flags';

function thread_get_locale(thread: THREAD_HANDLE): LCID; stdcall; public name 'thread_get_locale';
function thread_set_locale(thread: THREAD_HANDLE; locale: LCID): uint32_t; stdcall; public name 'thread_set_locale';

function thread_get_times(thread: THREAD_HANDLE; var createtime, exittime, kerneltime: int64_t): uint32_t; stdcall; public name 'thread_get_times';
function thread_get_switch_count(thread: THREAD_HANDLE; var switchcount: int64_t): uint32_t; stdcall; public name 'thread_get_switch_count';

function thread_get_stack_free: uint32_t; stdcall; public name 'thread_get_stack_free';
function thread_get_stack_size(thread: THREAD_HANDLE): uint32_t; stdcall; public name 'thread_get_stack_size';
function thread_get_stack_base(thread: THREAD_HANDLE): SIZE_T; stdcall; public name 'thread_get_stack_base';
function thread_set_stack_base(thread: THREAD_HANDLE; stackbase: SIZE_T): uint32_t; stdcall; public name 'thread_set_stack_base';
function thread_get_stack_pointer(thread: THREAD_HANDLE): SIZE_T; stdcall; public name 'thread_get_stack_pointer';

function thread_get_exit_code(thread: THREAD_HANDLE): uint32_t; stdcall; public name 'thread_get_exit_code';

function thread_get_affinity(thread: THREAD_HANDLE): uint32_t; stdcall; public name 'thread_get_affinity';
function thread_set_affinity(thread: THREAD_HANDLE; affinity: uint32_t): uint32_t; stdcall; public name 'thread_set_affinity';

function thread_get_priority(thread: THREAD_HANDLE): uint32_t; stdcall; public name 'thread_get_priority';
function thread_set_priority(thread: THREAD_HANDLE; priority: uint32_t): uint32_t; stdcall; public name 'thread_set_priority';

function thread_get_last_error: uint32_t; stdcall; public name 'thread_get_last_error';
procedure thread_set_last_error(lasterror: uint32_t); stdcall; public name 'thread_set_last_error';
function thread_set_last_error_ex(lasterror: uint32_t): uint32_t; stdcall; public name 'thread_set_last_error_ex';

function thread_get_wait_result: uint32_t; stdcall; public name 'thread_get_wait_result';
function thread_get_receive_result: uint32_t; stdcall; public name 'thread_get_receive_result';

function thread_get_tls_index(tlsindex: uint32_t): uint32_t; stdcall; public name 'thread_get_tls_index';
function thread_alloc_tls_index: uint32_t; stdcall; public name 'thread_alloc_tls_index';
function thread_alloc_tls_index_ex(flags: uint32_t): uint32_t; stdcall; public name 'thread_alloc_tls_index_ex';
function thread_release_tls_index(tlsindex: uint32_t): uint32_t; stdcall; public name 'thread_release_tls_index';
function thread_get_tls_value(tlsindex: uint32_t): PVOID; stdcall; public name 'thread_get_tls_value';
function thread_set_tls_value(tlsindex: uint32_t; tlsvalue: PVOID): uint32_t; stdcall; public name 'thread_set_tls_value';

function thread_get_tls_pointer(thread: THREAD_HANDLE): PVOID; stdcall; public name 'thread_get_tls_pointer';
function thread_set_tls_pointer(thread: THREAD_HANDLE; tlspointer: PVOID): uint32_t; stdcall; public name 'thread_set_tls_pointer';

function thread_ready(thread: THREAD_HANDLE; reschedule: BOOL): uint32_t; stdcall; public name 'thread_ready';
function thread_timeout(thread: THREAD_HANDLE): uint32_t; stdcall; public name 'thread_timeout';
function thread_wake(thread: THREAD_HANDLE): uint32_t; stdcall; public name 'thread_wake';

function thread_migrate(thread: THREAD_HANDLE; cpu: uint32_t): uint32_t; stdcall; public name 'thread_migrate';

procedure thread_end(exitcode: uint32_t); stdcall; public name 'thread_end';
function thread_halt(exitcode: uint32_t): uint32_t; stdcall; public name 'thread_halt';
function thread_terminate(thread: THREAD_HANDLE; exitcode: uint32_t): uint32_t; stdcall; public name 'thread_terminate';

function thread_yield: uint32_t; stdcall; public name 'thread_yield';
function thread_sleep(milliseconds: uint32_t): uint32_t; stdcall; public name 'thread_sleep';

function thread_wait(list: LIST_HANDLE; lock: SPIN_HANDLE; flags: uint32_t): uint32_t; stdcall; public name 'thread_wait';
function thread_wait_ex(list: LIST_HANDLE; lock: SPIN_HANDLE; flags, timeout: uint32_t): uint32_t; stdcall; public name 'thread_wait_ex';
function thread_release(list: LIST_HANDLE): uint32_t; stdcall; public name 'thread_release';
function thread_abandon(list: LIST_HANDLE): uint32_t; stdcall; public name 'thread_abandon';
function thread_wait_terminate(thread: THREAD_HANDLE; timeout: uint32_t): uint32_t; stdcall; public name 'thread_wait_terminate';

function thread_suspend(thread: THREAD_HANDLE): uint32_t; stdcall; public name 'thread_suspend';
function thread_resume(thread: THREAD_HANDLE): uint32_t; stdcall; public name 'thread_resume';

function thread_wait_message: uint32_t; stdcall; public name 'thread_wait_message';
function thread_send_message(thread: THREAD_HANDLE; const message: TTHREAD_MESSAGE): uint32_t; stdcall; public name 'thread_send_message';
function thread_receive_message(var message: TTHREAD_MESSAGE): uint32_t; stdcall; public name 'thread_receive_message';
function thread_receive_message_ex(var message: TTHREAD_MESSAGE; timeout: uint32_t; remove: BOOL): uint32_t; stdcall; public name 'thread_receive_message_ex';
function thread_abandon_message(thread: THREAD_HANDLE): uint32_t; stdcall; public name 'thread_abandon_message';

function thread_lock(thread: THREAD_HANDLE): uint32_t; stdcall; public name 'thread_lock';
function thread_unlock(thread: THREAD_HANDLE): uint32_t; stdcall; public name 'thread_unlock';

{Scheduler Functions}
function scheduler_check(cpuid: uint32_t): uint32_t; stdcall; public name 'scheduler_check';
function scheduler_wakeup(cpuid: uint32_t): uint32_t; stdcall; public name 'scheduler_wakeup';
function scheduler_expire(cpuid: uint32_t): uint32_t; stdcall; public name 'scheduler_expire';
function scheduler_switch(cpuid: uint32_t; thread: THREAD_HANDLE): THREAD_HANDLE; stdcall; public name 'scheduler_switch';
function scheduler_select(cpuid: uint32_t; thread: THREAD_HANDLE; yield: BOOL): THREAD_HANDLE; stdcall; public name 'scheduler_select';
function scheduler_reschedule(yield: BOOL): uint32_t; stdcall; public name 'scheduler_reschedule';

function scheduler_migration_enable: uint32_t; stdcall; public name 'scheduler_migration_enable';
function scheduler_migration_disable: uint32_t; stdcall; public name 'scheduler_migration_disable';

function scheduler_preempt_enable(cpuid: uint32_t): uint32_t; stdcall; public name 'scheduler_preempt_enable';
function scheduler_preempt_disable(cpuid: uint32_t): uint32_t; stdcall; public name 'scheduler_preempt_disable';

function scheduler_allocation_enable(cpuid: uint32_t): uint32_t; stdcall; public name 'scheduler_allocation_enable';
function scheduler_allocation_disable(cpuid: uint32_t): uint32_t; stdcall; public name 'scheduler_allocation_disable';

{Messageslot Functions}
function messageslot_create: MESSAGESLOT_HANDLE; stdcall; public name 'messageslot_create';
function messageslot_create_ex(maximum: uint32_t; flags: uint32_t): MESSAGESLOT_HANDLE; stdcall; public name 'messageslot_create_ex';
function messageslot_destroy(messageslot: MESSAGESLOT_HANDLE): uint32_t; stdcall; public name 'messageslot_destroy';

function messageslot_count(messageslot: MESSAGESLOT_HANDLE): uint32_t; stdcall; public name 'messageslot_count';

function messageslot_send(messageslot: MESSAGESLOT_HANDLE; const message: TTHREAD_MESSAGE): uint32_t; stdcall; public name 'messageslot_send';
function messageslot_receive(messageslot: MESSAGESLOT_HANDLE; var message: TTHREAD_MESSAGE): uint32_t; stdcall; public name 'messageslot_receive';
function messageslot_receive_ex(messageslot: MESSAGESLOT_HANDLE; var message: TTHREAD_MESSAGE; timeout: uint32_t): uint32_t; stdcall; public name 'messageslot_receive_ex';

{Mailslot Functions}
function mailslot_create(maximum: uint32_t): MAILSLOT_HANDLE; stdcall; public name 'mailslot_create';
function mailslot_destroy(mailslot: MAILSLOT_HANDLE): uint32_t; stdcall; public name 'mailslot_destroy';

function mailslot_count(mailslot: MAILSLOT_HANDLE): uint32_t; stdcall; public name 'mailslot_count';

function mailslot_send(mailslot: MAILSLOT_HANDLE; data: SSIZE_T): uint32_t; stdcall; public name 'mailslot_send';
function mailslot_send_ex(mailslot: MAILSLOT_HANDLE; data: SSIZE_T; timeout: uint32_t): uint32_t; stdcall; public name 'mailslot_send_ex';
function mailslot_receive(mailslot: MAILSLOT_HANDLE): SSIZE_T; stdcall; public name 'mailslot_receive';
function mailslot_receive_ex(mailslot: MAILSLOT_HANDLE; timeout: uint32_t): SSIZE_T; stdcall; public name 'mailslot_receive_ex';

{Buffer Functions}
function buffer_create(size, count: uint32_t): BUFFER_HANDLE; stdcall; public name 'buffer_create';
function buffer_create_ex(size, count, flags: uint32_t): BUFFER_HANDLE; stdcall; public name 'buffer_create_ex';
function buffer_destroy(buffer: BUFFER_HANDLE): uint32_t; stdcall; public name 'buffer_destroy';

function buffer_count(buffer: BUFFER_HANDLE): uint32_t; stdcall; public name 'buffer_count';
function buffer_available(buffer: BUFFER_HANDLE): uint32_t; stdcall; public name 'buffer_available';

function buffer_get(buffer: BUFFER_HANDLE): PVOID; stdcall; public name 'buffer_get';
function buffer_get_ex(buffer: BUFFER_HANDLE; timeout: uint32_t): PVOID; stdcall; public name 'buffer_get_ex';
function buffer_free(buffer: PVOID): uint32_t; stdcall; public name 'buffer_free';

function buffer_iterate(buffer: BUFFER_HANDLE; previous: PVOID): PVOID; stdcall; public name 'buffer_iterate';

{Event Functions}
function event_create(manualreset, initialstate: BOOL): EVENT_HANDLE; stdcall; public name 'event_create';
function event_create_ex(flags: uint32_t): EVENT_HANDLE; stdcall; public name 'event_create_ex';
function event_destroy(event: EVENT_HANDLE): uint32_t; stdcall; public name 'event_destroy';

function event_state(event: EVENT_HANDLE): uint32_t; stdcall; public name 'event_state';

function event_wait(event: EVENT_HANDLE): uint32_t; stdcall; public name 'event_wait';
function event_wait_ex(event: EVENT_HANDLE; timeout: uint32_t): uint32_t; stdcall; public name 'event_wait_ex';

function event_set(event: EVENT_HANDLE): uint32_t; stdcall; public name 'event_set';
function event_reset(event: EVENT_HANDLE): uint32_t; stdcall; public name 'event_reset';
function event_pulse(event: EVENT_HANDLE): uint32_t; stdcall; public name 'event_pulse';

{Timer Functions}
function timer_create(interval: uint32_t; enabled, reschedule: BOOL; event: timer_event_proc; data: PVOID): TIMER_HANDLE; stdcall; public name 'timer_create';
function timer_create_ex(interval, state, flags: uint32_t; event: timer_event_proc; data: PVOID): TIMER_HANDLE; stdcall; public name 'timer_create_ex';
function timer_destroy(timer: TIMER_HANDLE): uint32_t; stdcall; public name 'timer_destroy';

function timer_enable(timer: TIMER_HANDLE): uint32_t; stdcall; public name 'timer_enable';
function timer_enable_ex(timer: TIMER_HANDLE; interval: uint32_t; event: timer_event_proc; data: PVOID): uint32_t; stdcall; public name 'timer_enable_ex';
function timer_disable(timer: TIMER_HANDLE): uint32_t; stdcall; public name 'timer_disable';

function timer_dequeue: TIMER_HANDLE; stdcall; public name 'timer_dequeue';

function timer_first_key: int; stdcall; public name 'timer_first_key';
function timer_insert_key(timer: TIMER_HANDLE; key: int): uint32_t; stdcall; public name 'timer_insert_key';
function timer_delete_key(timer: TIMER_HANDLE): uint32_t; stdcall; public name 'timer_delete_key';
function timer_decrement_key: int; stdcall; public name 'timer_decrement_key';

function timer_is_empty: BOOL; stdcall; public name 'timer_is_empty';
function timer_not_empty: BOOL; stdcall; public name 'timer_not_empty';

function timer_check: uint32_t; stdcall; public name 'timer_check';
function timer_trigger: uint32_t; stdcall; public name 'timer_trigger';

{Worker Functions}
function worker_schedule(interval: uint32_t; task: worker_task_proc; data: PVOID; callback: worker_cb): uint32_t; stdcall; public name 'worker_schedule';
function worker_schedule_ex(interval, flags: uint32_t; task: worker_task_proc; data: PVOID; callback: worker_cb): WORKER_HANDLE; stdcall; public name 'worker_schedule_ex';
function worker_cancel(worker: WORKER_HANDLE): uint32_t; stdcall; public name 'worker_cancel';

function worker_schedule_irq(affinity: uint32_t; task: worker_task_proc; data: PVOID; callback: worker_cb): uint32_t; stdcall; public name 'worker_schedule_irq';
function worker_schedule_irq_ex(affinity, flags: uint32_t; task: worker_task_proc; data: PVOID; callback: worker_cb): uint32_t; stdcall; public name 'worker_schedule_irq_ex';

function worker_schedule_fiq(affinity: uint32_t; task: worker_task_proc; data: PVOID; callback: worker_cb): uint32_t; stdcall; public name 'worker_schedule_fiq';
function worker_schedule_fiq_ex(affinity, flags: uint32_t; task: worker_task_proc; data: PVOID; callback: worker_cb): uint32_t; stdcall; public name 'worker_schedule_fiq_ex';

function worker_increase(count: uint32_t): uint32_t; stdcall; public name 'worker_increase';
function worker_increase_ex(count: uint32_t; priority: BOOL): uint32_t; stdcall; public name 'worker_increase_ex';
function worker_decrease(count: uint32_t): uint32_t; stdcall; public name 'worker_decrease';
function worker_decrease_ex(count: uint32_t; priority: BOOL): uint32_t; stdcall; public name 'worker_decrease_ex';

{Tasker Functions}
function tasker_thread_send_message(thread: THREAD_HANDLE; const message: TTHREAD_MESSAGE): uint32_t; stdcall; public name 'tasker_thread_send_message';
function tasker_messageslot_send(messageslot: MESSAGESLOT_HANDLE; const message: TTHREAD_MESSAGE): uint32_t; stdcall; public name 'tasker_messageslot_send';
function tasker_semaphore_signal(semaphore: SEMAPHORE_HANDLE; count: uint32_t): uint32_t; stdcall; public name 'tasker_semaphore_signal';
function tasker_completion_reset(completion: COMPLETION_HANDLE): uint32_t; stdcall; public name 'tasker_completion_reset';
function tasker_completion_complete(completion: COMPLETION_HANDLE; all: BOOL): uint32_t; stdcall; public name 'tasker_completion_complete';

function tasker_enqueue(task: PTASKER_TASK): uint32_t; stdcall; public name 'tasker_enqueue';
function tasker_dequeue: PTASKER_TASK; stdcall; public name 'tasker_dequeue';

function tasker_check: uint32_t; stdcall; public name 'tasker_check';
function tasker_trigger: uint32_t; stdcall; public name 'tasker_trigger';

{RTL Thread Functions}
function begin_thread(signalaction: PVOID; stacksize: SIZE_T; threadfunction: thread_func; threadparameter: PVOID; creationflags: uint32_t; var threadid: TTHREAD_ID): TTHREAD_ID; stdcall; public name 'begin_thread';
function begin_thread_ex(signalaction: PVOID; stacksize: SIZE_T; threadfunction: thread_func; threadparameter: PVOID; creationflags: uint32_t; priority, affinity, cpu: uint32_t; const name: PCHAR; var threadid: TTHREAD_ID): TTHREAD_ID; stdcall; public name 'begin_thread_ex';

procedure end_thread(exitcode: uint32_t); stdcall; public name 'end_thread';

{==============================================================================}
{Thread Helper Functions}
function spin_get_count: uint32_t; stdcall; public name 'spin_get_count';
function mutex_get_count: uint32_t; stdcall; public name 'mutex_get_count';
function critical_section_get_count: uint32_t; stdcall; public name 'critical_section_get_count';
function semaphore_get_count: uint32_t; stdcall; public name 'semaphore_get_count';
function synchronizer_get_count: uint32_t; stdcall; public name 'synchronizer_get_count';
function condition_get_count: uint32_t; stdcall; public name 'condition_get_count';
function completion_get_count: uint32_t; stdcall; public name 'completion_get_count';
function list_get_count: uint32_t; stdcall; public name 'list_get_count';
function queue_get_count: uint32_t; stdcall; public name 'queue_get_count';
function thread_get_count: uint32_t; stdcall; public name 'thread_get_count';
function thread_tls_get_count: uint32_t; stdcall; public name 'thread_tls_get_count';

function thread_allocate_stack(stacksize: uint32_t): PVOID; stdcall; public name 'thread_allocate_stack';
procedure thread_release_stack(stackbase: PVOID; stacksize: uint32_t); stdcall; public name 'thread_release_stack';
function thread_setup_stack(stackbase: PVOID; startproc: thread_start_proc; returnproc: thread_end_proc; parameter: PVOID): PVOID; stdcall; public name 'thread_setup_stack';

function thread_snapshot_create: PTHREAD_SNAPSHOT; stdcall; public name 'thread_snapshot_create';
function thread_snapshot_destroy(snapshot: PTHREAD_SNAPSHOT): uint32_t; stdcall; public name 'thread_snapshot_destroy';

function messageslot_get_count: uint32_t; stdcall; public name 'messageslot_get_count';
function mailslot_get_count: uint32_t; stdcall; public name 'mailslot_get_count';
function buffer_get_count: uint32_t; stdcall; public name 'buffer_get_count';
function event_get_count: uint32_t; stdcall; public name 'event_get_count';
function timer_get_count: uint32_t; stdcall; public name 'timer_get_count';
function worker_get_count: uint32_t; stdcall; public name 'worker_get_count';
function worker_get_priority_count: uint32_t; stdcall; public name 'worker_get_priority_count';
function tasker_get_count: uint32_t; stdcall; public name 'tasker_get_count';

function list_type_to_string(listtype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'list_type_to_string';
function queue_type_to_string(queuetype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'queue_type_to_string';
function thread_type_to_string(threadtype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'thread_type_to_string';
function thread_state_to_string(threadstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'thread_state_to_string';
function thread_priority_to_string(threadpriority: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'thread_priority_to_string';

{Scheduler Helper Functions}
function scheduler_get_list_flags(listtype: uint32_t): uint32_t; stdcall; public name 'scheduler_get_list_flags';
function scheduler_get_queue_flags(queuetype: uint32_t): uint32_t; stdcall; public name 'scheduler_get_queue_flags';
function scheduler_get_queue_handle(cpuid: uint32_t; queuetype: uint32_t): QUEUE_HANDLE; stdcall; public name 'scheduler_get_queue_handle';
function scheduler_get_queue_handle_ex(cpuid: uint32_t; priority: uint32_t): QUEUE_HANDLE; stdcall; public name 'scheduler_get_queue_handle_ex';
function scheduler_get_thread_count(cpuid: uint32_t): uint32_t; stdcall; public name 'scheduler_get_thread_count';
function scheduler_get_thread_quantum(cpuid: uint32_t): uint32_t; stdcall; public name 'scheduler_get_thread_quantum';
function scheduler_get_thread_handle(cpuid: uint32_t; threadtype: uint32_t): THREAD_HANDLE; stdcall; public name 'scheduler_get_thread_handle';
function scheduler_get_priority_mask(cpuid: uint32_t): uint32_t; stdcall; public name 'scheduler_get_priority_mask';
function scheduler_get_priority_quantum(priority: uint32_t): uint32_t; stdcall; public name 'scheduler_get_priority_quantum';
function scheduler_set_priority_quantum(priority, quantum: uint32_t): uint32_t; stdcall; public name 'scheduler_set_priority_quantum';
function scheduler_get_migration_quantum: uint32_t; stdcall; public name 'scheduler_get_migration_quantum';
function scheduler_get_starvation_quantum(cpuid: uint32_t): uint32_t; stdcall; public name 'scheduler_get_starvation_quantum';

function scheduler_get_thread_next: uint32_t; stdcall; public name 'scheduler_get_thread_next';
function scheduler_get_thread_migration: uint32_t; stdcall; public name 'scheduler_get_thread_migration';

function scheduler_get_thread_preempt(cpuid: uint32_t): uint32_t; stdcall; public name 'scheduler_get_thread_preempt';
function scheduler_get_thread_allocation(cpuid: uint32_t): uint32_t; stdcall; public name 'scheduler_get_thread_allocation';

function scheduler_migration_to_string(migration: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'scheduler_migration_to_string';
function scheduler_preempt_to_string(preempt: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'scheduler_preempt_to_string';
function scheduler_allocation_to_string(allocation: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'scheduler_allocation_to_string';

{Timer Helper Functions}
function timer_get_list_flags: uint32_t; stdcall; public name 'timer_get_list_flags';
function timer_get_messageslot_flags: uint32_t; stdcall; public name 'timer_get_messageslot_flags';

{Worker Helper Functions}
function worker_get_messageslot_flags: uint32_t; stdcall; public name 'worker_get_messageslot_flags';
{$ENDIF}
{==============================================================================}
{HeapManager Functions}
{$IFDEF API_EXPORT_HEAP}
function get_mem(size: SIZE_T): PVOID; stdcall; public name 'get_mem';
function get_mem_ex(size: SIZE_T; flags, affinity: uint32_t): PVOID; stdcall; public name 'get_mem_ex';

function get_aligned_mem(size, alignment: SIZE_T): PVOID; stdcall; public name 'get_aligned_mem';
function get_aligned_mem_ex(size, alignment: SIZE_T; flags, affinity: uint32_t): PVOID; stdcall; public name 'get_aligned_mem_ex';

function get_shared_mem(size: SIZE_T): PVOID; stdcall; public name 'get_shared_mem';
function get_shared_aligned_mem(size, alignment: SIZE_T): PVOID; stdcall; public name 'get_shared_aligned_mem';

function get_local_mem(size: SIZE_T; affinity: uint32_t): PVOID; stdcall; public name 'get_local_mem';
function get_local_aligned_mem(size, alignment: SIZE_T; affinity: uint32_t): PVOID; stdcall; public name 'get_local_aligned_mem';

function get_code_mem(size: SIZE_T; affinity: uint32_t): PVOID; stdcall; public name 'get_code_mem';
function get_code_aligned_mem(size, alignment: SIZE_T; affinity: uint32_t): PVOID; stdcall; public name 'get_code_aligned_mem';

function get_device_mem(size: SIZE_T): PVOID; stdcall; public name 'get_device_mem';
function get_device_aligned_mem(size, alignment: SIZE_T): PVOID; stdcall; public name 'get_device_aligned_mem';

function get_nocache_mem(size: SIZE_T): PVOID; stdcall; public name 'get_nocache_mem';
function get_nocache_aligned_mem(size, alignment: SIZE_T): PVOID; stdcall; public name 'get_nocache_aligned_mem';

function get_nonshared_mem(size: SIZE_T): PVOID; stdcall; public name 'get_nonshared_mem';
function get_nonshared_aligned_mem(size, alignment: SIZE_T): PVOID; stdcall; public name 'get_nonshared_aligned_mem';

function get_irq_mem(size: SIZE_T; affinity: uint32_t): PVOID; stdcall; public name 'get_irq_mem';
function get_irq_aligned_mem(size, alignment: SIZE_T; affinity: uint32_t): PVOID; stdcall; public name 'get_irq_aligned_mem';

function get_fiq_mem(size: SIZE_T; affinity: uint32_t): PVOID; stdcall; public name 'get_fiq_mem';
function get_fiq_aligned_mem(size, alignment: SIZE_T; affinity: uint32_t): PVOID; stdcall; public name 'get_fiq_aligned_mem';

function free_mem(addr: PVOID): SIZE_T; stdcall; public name 'free_mem';
function free_irq_mem(addr: PVOID): SIZE_T; stdcall; public name 'free_irq_mem';
function free_fiq_mem(addr: PVOID): SIZE_T; stdcall; public name 'free_fiq_mem';

function alloc_mem(size: SIZE_T): PVOID; stdcall; public name 'alloc_mem';
function alloc_mem_ex(size: SIZE_T; flags, affinity: uint32_t): PVOID; stdcall; public name 'alloc_mem_ex';
function realloc_mem(var addr: PVOID; size: SIZE_T): PVOID; stdcall; public name 'realloc_mem';
function realloc_mem_ex(var addr: PVOID; size: SIZE_T; flags, affinity: uint32_t): PVOID; stdcall; public name 'realloc_mem_ex';

function alloc_aligned_mem(size, alignment: SIZE_T): PVOID; stdcall; public name 'alloc_aligned_mem';
function alloc_aligned_mem_ex(size, alignment: SIZE_T; flags, affinity: uint32_t): PVOID; stdcall; public name 'alloc_aligned_mem_ex';
function realloc_aligned_mem(var addr: PVOID; size, alignment: SIZE_T): PVOID; stdcall; public name 'realloc_aligned_mem';
function realloc_aligned_mem_ex(var addr: PVOID; size, alignment: SIZE_T; flags, affinity: uint32_t): PVOID; stdcall; public name 'realloc_aligned_mem_ex';

function alloc_shared_mem(size: SIZE_T): PVOID; stdcall; public name 'alloc_shared_mem';
function alloc_shared_aligned_mem(size, alignment: SIZE_T): PVOID; stdcall; public name 'alloc_shared_aligned_mem';
function realloc_shared_mem(var addr: PVOID; size: SIZE_T): PVOID; stdcall; public name 'realloc_shared_mem';
function realloc_shared_aligned_mem(var addr: PVOID; size, alignment: SIZE_T): PVOID; stdcall; public name 'realloc_shared_aligned_mem';

function alloc_local_mem(size: SIZE_T; affinity: uint32_t): PVOID; stdcall; public name 'alloc_local_mem';
function alloc_local_aligned_mem(size, alignment: SIZE_T; affinity: uint32_t): PVOID; stdcall; public name 'alloc_local_aligned_mem';
function realloc_local_mem(var addr: PVOID; size: SIZE_T; affinity: uint32_t): PVOID; stdcall; public name 'realloc_local_mem';
function realloc_local_aligned_mem(var addr: PVOID; size, alignment: SIZE_T; affinity: uint32_t): PVOID; stdcall; public name 'realloc_local_aligned_mem';

function alloc_code_mem(size: SIZE_T; affinity: uint32_t): PVOID; stdcall; public name 'alloc_code_mem';
function alloc_code_aligned_mem(size, alignment: SIZE_T; affinity: uint32_t): PVOID; stdcall; public name 'alloc_code_aligned_mem';
function realloc_code_mem(var addr: PVOID; size: SIZE_T; affinity: uint32_t): PVOID; stdcall; public name 'realloc_code_mem';
function realloc_code_aligned_mem(var addr: PVOID; size, alignment: SIZE_T; affinity: uint32_t): PVOID; stdcall; public name 'realloc_code_aligned_mem';

function alloc_device_mem(size: SIZE_T): PVOID; stdcall; public name 'alloc_device_mem';
function alloc_device_aligned_mem(size, alignment: SIZE_T): PVOID; stdcall; public name 'alloc_device_aligned_mem';
function realloc_device_mem(var addr: PVOID; size: SIZE_T): PVOID; stdcall; public name 'realloc_device_mem';
function realloc_device_aligned_mem(var addr: PVOID; size, alignment: SIZE_T): PVOID; stdcall; public name 'realloc_device_aligned_mem';

function alloc_nocache_mem(size: SIZE_T): PVOID; stdcall; public name 'alloc_nocache_mem';
function alloc_nocache_aligned_mem(size, alignment: SIZE_T): PVOID; stdcall; public name 'alloc_nocache_aligned_mem';
function realloc_nocache_mem(var addr: PVOID; size: SIZE_T): PVOID; stdcall; public name 'realloc_nocache_mem';
function realloc_nocache_aligned_mem(var addr: PVOID; size, alignment: SIZE_T): PVOID; stdcall; public name 'realloc_nocache_aligned_mem';

function alloc_nonshared_mem(size: SIZE_T): PVOID; stdcall; public name 'alloc_nonshared_mem';
function alloc_nonshared_aligned_mem(size, alignment: SIZE_T): PVOID; stdcall; public name 'alloc_nonshared_aligned_mem';
function realloc_nonshared_mem(var addr: PVOID; size: SIZE_T): PVOID; stdcall; public name 'realloc_nonshared_mem';
function realloc_nonshared_aligned_mem(var addr: PVOID; size, alignment: SIZE_T): PVOID; stdcall; public name 'realloc_nonshared_aligned_mem';

function alloc_irq_mem(size: SIZE_T; affinity: uint32_t): PVOID; stdcall; public name 'alloc_irq_mem';
function alloc_irq_aligned_mem(size, alignment: SIZE_T; affinity: uint32_t): PVOID; stdcall; public name 'alloc_irq_aligned_mem';
function realloc_irq_mem(var addr: PVOID; size: SIZE_T; affinity: uint32_t): PVOID; stdcall; public name 'realloc_irq_mem';
function realloc_irq_aligned_mem(var addr: PVOID; size, alignment: SIZE_T; affinity: uint32_t): PVOID; stdcall; public name 'realloc_irq_aligned_mem';

function alloc_fiq_mem(size: SIZE_T; affinity: uint32_t): PVOID; stdcall; public name 'alloc_fiq_mem';
function alloc_fiq_aligned_mem(size, alignment: SIZE_T; affinity: uint32_t): PVOID; stdcall; public name 'alloc_fiq_aligned_mem';
function realloc_fiq_mem(var addr: PVOID; size: SIZE_T; affinity: uint32_t): PVOID; stdcall; public name 'realloc_fiq_mem';
function realloc_fiq_aligned_mem(var addr: PVOID; size, alignment: SIZE_T; affinity: uint32_t): PVOID; stdcall; public name 'realloc_fiq_aligned_mem';

function size_mem(addr: PVOID): SIZE_T; stdcall; public name 'size_mem';
function size_irq_mem(addr: PVOID): SIZE_T; stdcall; public name 'size_irq_mem';
function size_fiq_mem(addr: PVOID): SIZE_T; stdcall; public name 'size_fiq_mem';

function mem_flags(addr: PVOID): uint32_t; stdcall; public name 'mem_flags';
function mem_flags_irq(addr: PVOID): uint32_t; stdcall; public name 'mem_flags_irq';
function mem_flags_fiq(addr: PVOID): uint32_t; stdcall; public name 'mem_flags_fiq';

function get_heap_status: THEAP_STATUS; stdcall; public name 'get_heap_status';
function get_fpc_heap_status: TFPC_HEAP_STATUS; stdcall; public name 'get_fpc_heap_status';
{$IFDEF HEAP_STATISTICS}
function get_heap_statistics: THEAP_STATISTICS; stdcall; public name 'get_heap_statistics';
{$ENDIF}
function get_heap_block_count(state: uint32_t): uint32_t; stdcall; public name 'get_heap_block_count';
function get_heap_block_count_ex(state, flags, affinity: uint32_t): uint32_t; stdcall; public name 'get_heap_block_count_ex';

function get_heap_block_min(state: uint32_t): uint32_t; stdcall; public name 'get_heap_block_min';
function get_heap_block_min_ex(state, flags, affinity: uint32_t): uint32_t; stdcall; public name 'get_heap_block_min_ex';

function get_heap_block_max(state: uint32_t): uint32_t; stdcall; public name 'get_heap_block_max';
function get_heap_block_max_ex(state, flags, affinity: uint32_t): uint32_t; stdcall; public name 'get_heap_block_max_ex';

function create_heap_snapshot(state: uint32_t): PHEAP_SNAPSHOT; stdcall; public name 'create_heap_snapshot';
function create_heap_snapshot_ex(state, flags, affinity: uint32_t): PHEAP_SNAPSHOT; stdcall; public name 'create_heap_snapshot_ex';
function destroy_heap_snapshot(snapshot: PHEAP_SNAPSHOT): uint32_t; stdcall; public name 'destroy_heap_snapshot';
{$ENDIF}
{==============================================================================}
{Device Tree Functions}
{$IFDEF API_EXPORT_DEVICE_TREE}
function device_tree_validate(address: SIZE_T; var size: uint32_t): BOOL; stdcall; public name 'device_tree_validate';

function device_tree_next_node(parent, previous: THANDLE): THANDLE; stdcall; public name 'device_tree_next_node';
function device_tree_next_property(node, previous: THANDLE): THANDLE; stdcall; public name 'device_tree_next_property';

function device_tree_get_node(const path: PCHAR; parent: THANDLE): THANDLE; stdcall; public name 'device_tree_get_node';
function device_tree_get_property(node: THANDLE; const name: PCHAR): THANDLE; stdcall; public name 'device_tree_get_property';

function device_tree_get_node_name(handle: THANDLE; name: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'device_tree_get_node_name';
function device_tree_split_node_name(handle: THANDLE; nodename: PCHAR; namelen: uint32_t; unitaddress: PCHAR; addresslen: uint32_t): uint32_t; stdcall; public name 'device_tree_split_node_name';

function device_tree_get_node_parent(handle: THANDLE): THANDLE; stdcall; public name 'device_tree_get_node_parent';
function device_tree_get_node_reg_cells(handle: THANDLE; var address, size: uint32_t): BOOL; stdcall; public name 'device_tree_get_node_reg_cells';
function device_tree_get_node_range_cells(handle: THANDLE; var parentaddress, nodeaddress, nodesize: uint32_t): BOOL; stdcall; public name 'device_tree_get_node_range_cells';

function device_tree_get_property_name(handle: THANDLE; name: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'device_tree_get_property_name';
function device_tree_split_property_name(handle: THANDLE; uniqueprefix: PCHAR; prefixlen: uint32_t; propertyname: PCHAR; namelen: uint32_t): uint32_t; stdcall; public name 'device_tree_split_property_name';

function device_tree_get_property_value(handle: THANDLE): PVOID; stdcall; public name 'device_tree_get_property_value';
function device_tree_get_property_length(handle: THANDLE): uint32_t; stdcall; public name 'device_tree_get_property_length';

function device_tree_get_property_string(handle: THANDLE; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'device_tree_get_property_string';
function device_tree_get_property_longword(handle: THANDLE): uint32_t; stdcall; public name 'device_tree_get_property_longword';
function device_tree_get_property_quadword(handle: THANDLE): uint64_t; stdcall; public name 'device_tree_get_property_quadword';

{==============================================================================}
{Device Tree Helper Functions}
function device_tree_get_boot_args: PCHAR; stdcall; public name 'device_tree_get_boot_args';
function device_tree_get_ramdisk(var address: SIZE_T; var size: uint64_t): BOOL; stdcall; public name 'device_tree_get_ramdisk';
function device_tree_get_memory(index: uint32_t; {$IFDEF CPU32}var range: uint32_t; {$ENDIF CPU32}var address: SIZE_T; var size: uint64_t): BOOL; stdcall; public name 'device_tree_get_memory';
function device_tree_get_reservation(index: uint32_t; var address: SIZE_T; var size: uint64_t): BOOL; stdcall; public name 'device_tree_get_reservation';

{$IFDEF DEVICE_TREE_ENUMERATION}
function device_tree_log_tree: uint32_t; stdcall; public name 'device_tree_log_tree';
function device_tree_log_tree_ex(node: THANDLE; output: dtb_log_output_cb; decode: dtb_decode_value_cb; data: PVOID): uint32_t; stdcall; public name 'device_tree_log_tree_ex';
{$ENDIF DEVICE_TREE_ENUMERATION}
{$ENDIF}
{==============================================================================}
{Devices Functions}
{$IFDEF API_EXPORT_DEVICES}
function device_create: PDEVICE; stdcall; public name 'device_create';
function device_create_ex(size: uint32_t): PDEVICE; stdcall; public name 'device_create_ex';
function device_destroy(device: PDEVICE): uint32_t; stdcall; public name 'device_destroy';

function device_get_name(device: PDEVICE; name: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'device_get_name';
function device_set_name(device: PDEVICE; const name: PCHAR): uint32_t; stdcall; public name 'device_set_name';

function device_get_description(device: PDEVICE; name: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'device_get_description';
function device_set_description(device: PDEVICE; const description: PCHAR): uint32_t; stdcall; public name 'device_set_description';

function device_register(device: PDEVICE): uint32_t; stdcall; public name 'device_register';
function device_deregister(device: PDEVICE): uint32_t; stdcall; public name 'device_deregister';

function device_find(deviceclass, deviceid: uint32_t): PDEVICE; stdcall; public name 'device_find';
function device_find_by_devicedata(devicedata: PVOID): PDEVICE; stdcall; public name 'device_find_by_devicedata';
function device_find_by_name(const name: PCHAR): PDEVICE; stdcall; public name 'device_find_by_name';
function device_find_by_name_ex(deviceclass: uint32_t; const name: PCHAR): PDEVICE; stdcall; public name 'device_find_by_name_ex';
function device_find_by_description(const description: PCHAR): PDEVICE; stdcall; public name 'device_find_by_description';
function device_find_by_description_ex(deviceclass: uint32_t; const description: PCHAR): PDEVICE; stdcall; public name 'device_find_by_description_ex';
function device_enumerate(deviceclass: uint32_t; callback: device_enumerate_cb; data: PVOID): uint32_t; stdcall; public name 'device_enumerate';

function device_notification(device: PDEVICE; deviceclass: uint32_t; callback: device_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall; public name 'device_notification';

function device_firmware_create(deviceclass: uint32_t; const name: PCHAR; buffer: PVOID; size: uint32_t): BOOL; stdcall; public name 'device_firmware_create';

function device_firmware_register(deviceclass: uint32_t; const name: PCHAR; handler: device_firmware_handler): THANDLE; stdcall; public name 'device_firmware_register';
function device_firmware_deregister(handle: THANDLE): uint32_t; stdcall; public name 'device_firmware_deregister';

function device_firmware_find(deviceclass: uint32_t; const name: PCHAR): PDEVICE_FIRMWARE; stdcall; public name 'device_firmware_find';
function device_firmware_find_by_handle(handle: THANDLE): PDEVICE_FIRMWARE; stdcall; public name 'device_firmware_find_by_handle';

function device_firmware_open(deviceclass: uint32_t; const name: PCHAR; timeout: uint32_t; var handle: THANDLE): uint32_t; stdcall; public name 'device_firmware_open';
function device_firmware_close(handle: THANDLE): uint32_t; stdcall; public name 'device_firmware_close';

function device_firmware_size(handle: THANDLE): int32_t; stdcall; public name 'device_firmware_size';
function device_firmware_seek(handle: THANDLE; position: int32_t): int32_t; stdcall; public name 'device_firmware_seek';
function device_firmware_read(handle: THANDLE; buffer: PVOID; count: int32_t): int32_t; stdcall; public name 'device_firmware_read';

function device_firmware_acquire(deviceclass: uint32_t; const name: PCHAR; timeout: uint32_t; var handle: THANDLE; var buffer: PVOID; var size: uint32_t): uint32_t; stdcall; public name 'device_firmware_acquire';
function device_firmware_release(handle: THANDLE; buffer: PVOID; size: uint32_t): uint32_t; stdcall; public name 'device_firmware_release';

function notifier_allocate(device: PDEVICE; deviceclass: uint32_t; callback: device_notification_cb; data: PVOID; notification, flags: uint32_t): PNOTIFIER; stdcall; public name 'notifier_allocate';
function notifier_release(notifier: PNOTIFIER): uint32_t; stdcall; public name 'notifier_release';

function notifier_find(device: PDEVICE; deviceclass: uint32_t; callback: device_notification_cb; data: PVOID): PNOTIFIER; stdcall; public name 'notifier_find';
function notifier_notify(device: PDEVICE; notification: uint32_t): uint32_t; stdcall; public name 'notifier_notify';

procedure notifier_retry(retry: PNOTIFIER_RETRY); stdcall; public name 'notifier_retry';
procedure notifier_worker(task: PNOTIFIER_TASK); stdcall; public name 'notifier_worker';

{==============================================================================}
{Driver Functions}
function driver_create: PDRIVER; stdcall; public name 'driver_create';
function driver_create_ex(size: uint32_t): PDRIVER; stdcall; public name 'driver_create_ex';
function driver_destroy(driver: PDRIVER): uint32_t; stdcall; public name 'driver_destroy';

function driver_get_name(driver: PDRIVER; name: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'driver_get_name';
function driver_set_name(driver: PDRIVER; const name: PCHAR): uint32_t; stdcall; public name 'driver_set_name';

function driver_register(driver: PDRIVER): uint32_t; stdcall; public name 'driver_register';
function driver_deregister(driver: PDRIVER): uint32_t; stdcall; public name 'driver_deregister';

function driver_find(driverclass, driverid: uint32_t): PDRIVER; stdcall; public name 'driver_find';
function driver_find_by_name(const name: PCHAR): PDRIVER; stdcall; public name 'driver_find_by_name';
function driver_enumerate(driverclass: uint32_t; callback: driver_enumerate_cb; data: PVOID): uint32_t; stdcall; public name 'driver_enumerate';

{==============================================================================}
{Clock Device Functions}
function clock_device_start(clock: PCLOCK_DEVICE): uint32_t; stdcall; public name 'clock_device_start';
function clock_device_stop(clock: PCLOCK_DEVICE): uint32_t; stdcall; public name 'clock_device_stop';

function clock_device_read(clock: PCLOCK_DEVICE): uint32_t; stdcall; public name 'clock_device_read';
function clock_device_read64(clock: PCLOCK_DEVICE): int64_t; stdcall; public name 'clock_device_read64';
function clock_device_write64(clock: PCLOCK_DEVICE; const value: int64_t): uint32_t; stdcall; public name 'clock_device_write64';

function clock_device_get_rate(clock: PCLOCK_DEVICE): uint32_t; stdcall; public name 'clock_device_get_rate';
function clock_device_set_rate(clock: PCLOCK_DEVICE; rate: uint32_t): uint32_t; stdcall; public name 'clock_device_set_rate';

function clock_device_properties(clock: PCLOCK_DEVICE; properties: PCLOCK_PROPERTIES): uint32_t; stdcall; public name 'clock_device_properties';
function clock_device_get_properties(clock: PCLOCK_DEVICE; properties: PCLOCK_PROPERTIES): uint32_t; stdcall; public name 'clock_device_get_properties';

function clock_device_create: PCLOCK_DEVICE; stdcall; public name 'clock_device_create';
function clock_device_create_ex(size: uint32_t): PCLOCK_DEVICE; stdcall; public name 'clock_device_create_ex';
function clock_device_destroy(clock: PCLOCK_DEVICE): uint32_t; stdcall; public name 'clock_device_destroy';

function clock_device_register(clock: PCLOCK_DEVICE): uint32_t; stdcall; public name 'clock_device_register';
function clock_device_deregister(clock: PCLOCK_DEVICE): uint32_t; stdcall; public name 'clock_device_deregister';

function clock_device_find(clockid: uint32_t): PCLOCK_DEVICE; stdcall; public name 'clock_device_find';
function clock_device_find_by_name(const name: PCHAR): PCLOCK_DEVICE; stdcall; public name 'clock_device_find_by_name';
function clock_device_find_by_description(const description: PCHAR): PCLOCK_DEVICE; stdcall; public name 'clock_device_find_by_description';
function clock_device_enumerate(callback: clock_enumerate_cb; data: PVOID): uint32_t; stdcall; public name 'clock_device_enumerate';

function clock_device_notification(clock: PCLOCK_DEVICE; callback: clock_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall; public name 'clock_device_notification';

{==============================================================================}
{Timer Device Functions}
function timer_device_start(timer: PTIMER_DEVICE): uint32_t; stdcall; public name 'timer_device_start';
function timer_device_stop(timer: PTIMER_DEVICE): uint32_t; stdcall; public name 'timer_device_stop';
function timer_device_read(timer: PTIMER_DEVICE): uint32_t; stdcall; public name 'timer_device_read';
function timer_device_read64(timer: PTIMER_DEVICE): int64_t; stdcall; public name 'timer_device_read64';
function timer_device_wait(timer: PTIMER_DEVICE): uint32_t; stdcall; public name 'timer_device_wait';
function timer_device_event(timer: PTIMER_DEVICE; flags: uint32_t; callback: timer_cb; data: PVOID): uint32_t; stdcall; public name 'timer_device_event';
function timer_device_cancel(timer: PTIMER_DEVICE): uint32_t; stdcall; public name 'timer_device_cancel';
function timer_device_get_rate(timer: PTIMER_DEVICE): uint32_t; stdcall; public name 'timer_device_get_rate';
function timer_device_set_rate(timer: PTIMER_DEVICE; rate: uint32_t): uint32_t; stdcall; public name 'timer_device_set_rate';
function timer_device_get_interval(timer: PTIMER_DEVICE): uint32_t; stdcall; public name 'timer_device_get_interval';
function timer_device_set_interval(timer: PTIMER_DEVICE; interval: uint32_t): uint32_t; stdcall; public name 'timer_device_set_interval';

function timer_device_properties(timer: PTIMER_DEVICE; properties: PTIMER_PROPERTIES): uint32_t; stdcall; public name 'timer_device_properties';
function timer_device_get_properties(timer: PTIMER_DEVICE; properties: PTIMER_PROPERTIES): uint32_t; stdcall; public name 'timer_device_get_properties';

function timer_device_create: PTIMER_DEVICE; stdcall; public name 'timer_device_create';
function timer_device_create_ex(size: uint32_t): PTIMER_DEVICE; stdcall; public name 'timer_device_create_ex';
function timer_device_destroy(timer: PTIMER_DEVICE): uint32_t; stdcall; public name 'timer_device_destroy';

function timer_device_register(timer: PTIMER_DEVICE): uint32_t; stdcall; public name 'timer_device_register';
function timer_device_deregister(timer: PTIMER_DEVICE): uint32_t; stdcall; public name 'timer_device_deregister';

function timer_device_find(timerid: uint32_t): PTIMER_DEVICE; stdcall; public name 'timer_device_find';
function timer_device_find_by_name(const name: PCHAR): PTIMER_DEVICE; stdcall; public name 'timer_device_find_by_name';
function timer_device_find_by_description(const description: PCHAR): PTIMER_DEVICE; stdcall; public name 'timer_device_find_by_description';
function timer_device_enumerate(callback: timer_enumerate_cb; data: PVOID): uint32_t; stdcall; public name 'timer_device_enumerate';

function timer_device_notification(timer: PTIMER_DEVICE; callback: timer_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall; public name 'timer_device_notification';

{==============================================================================}
{Random Device Functions}
function random_device_start(random: PRANDOM_DEVICE): uint32_t; stdcall; public name 'random_device_start';
function random_device_stop(random: PRANDOM_DEVICE): uint32_t; stdcall; public name 'random_device_stop';

function random_device_seed(random: PRANDOM_DEVICE; seed: uint32_t): uint32_t; stdcall; public name 'random_device_seed';
function random_device_read_byte(random: PRANDOM_DEVICE): uint8_t; stdcall; public name 'random_device_read_byte';
function random_device_read_word(random: PRANDOM_DEVICE): uint16_t; stdcall; public name 'random_device_read_word';
function random_device_read_longword(random: PRANDOM_DEVICE): uint32_t; stdcall; public name 'random_device_read_longword';
function random_device_read_quadword(random: PRANDOM_DEVICE): int64_t; stdcall; public name 'random_device_read_quadword';
function random_device_read_double(random: PRANDOM_DEVICE): double_t; stdcall; public name 'random_device_read_double';
function random_device_read_extended(random: PRANDOM_DEVICE): double_t; stdcall; public name 'random_device_read_extended';

function random_device_create: PRANDOM_DEVICE; stdcall; public name 'random_device_create';
function random_device_create_ex(size: uint32_t): PRANDOM_DEVICE; stdcall; public name 'random_device_create_ex';
function random_device_destroy(random: PRANDOM_DEVICE): uint32_t; stdcall; public name 'random_device_destroy';

function random_device_register(random: PRANDOM_DEVICE): uint32_t; stdcall; public name 'random_device_register';
function random_device_deregister(random: PRANDOM_DEVICE): uint32_t; stdcall; public name 'random_device_deregister';

function random_device_find(randomid: uint32_t): PRANDOM_DEVICE; stdcall; public name 'random_device_find';
function random_device_find_by_name(const name: PCHAR): PRANDOM_DEVICE; stdcall; public name 'random_device_find_by_name';
function random_device_find_by_description(const description: PCHAR): PRANDOM_DEVICE; stdcall; public name 'random_device_find_by_description';
function random_device_enumerate(callback: random_enumerate_cb; data: PVOID): uint32_t; stdcall; public name 'random_device_enumerate';

function random_device_notification(random: PRANDOM_DEVICE; callback: random_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall; public name 'random_device_notification';

{==============================================================================}
{Mailbox Device Functions}
function mailbox_device_start(mailbox: PMAILBOX_DEVICE): uint32_t; stdcall; public name 'mailbox_device_start';
function mailbox_device_stop(mailbox: PMAILBOX_DEVICE): uint32_t; stdcall; public name 'mailbox_device_stop';
function mailbox_device_receive(mailbox: PMAILBOX_DEVICE; channel: uint32_t): uint32_t; stdcall; public name 'mailbox_device_receive';
function mailbox_device_send(mailbox: PMAILBOX_DEVICE; channel, data: uint32_t): uint32_t; stdcall; public name 'mailbox_device_send';
function mailbox_device_call(mailbox: PMAILBOX_DEVICE; channel, data: uint32_t; var response: uint32_t): uint32_t; stdcall; public name 'mailbox_device_call';
function mailbox_device_get_timeout(mailbox: PMAILBOX_DEVICE): uint32_t; stdcall; public name 'mailbox_device_get_timeout';
function mailbox_device_set_timeout(mailbox: PMAILBOX_DEVICE; timeout: uint32_t): uint32_t; stdcall; public name 'mailbox_device_set_timeout';

function mailbox_device_create: PMAILBOX_DEVICE; stdcall; public name 'mailbox_device_create';
function mailbox_device_create_ex(size: uint32_t): PMAILBOX_DEVICE; stdcall; public name 'mailbox_device_create_ex';
function mailbox_device_destroy(mailbox: PMAILBOX_DEVICE): uint32_t; stdcall; public name 'mailbox_device_destroy';

function mailbox_device_register(mailbox: PMAILBOX_DEVICE): uint32_t; stdcall; public name 'mailbox_device_register';
function mailbox_device_deregister(mailbox: PMAILBOX_DEVICE): uint32_t; stdcall; public name 'mailbox_device_deregister';

function mailbox_device_find(mailboxid: uint32_t): PMAILBOX_DEVICE; stdcall; public name 'mailbox_device_find';
function mailbox_device_find_by_name(const name: PCHAR): PMAILBOX_DEVICE; stdcall; public name 'mailbox_device_find_by_name';
function mailbox_device_find_by_description(const description: PCHAR): PMAILBOX_DEVICE; stdcall; public name 'mailbox_device_find_by_description';
function mailbox_device_enumerate(callback: mailbox_enumerate_cb; data: PVOID): uint32_t; stdcall; public name 'mailbox_device_enumerate';

function mailbox_device_notification(mailbox: PMAILBOX_DEVICE; callback: mailbox_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall; public name 'mailbox_device_notification';

{==============================================================================}
{Watchdog Device Functions}
function watchdog_device_start(watchdog: PWATCHDOG_DEVICE): uint32_t; stdcall; public name 'watchdog_device_start';
function watchdog_device_stop(watchdog: PWATCHDOG_DEVICE): uint32_t; stdcall; public name 'watchdog_device_stop';
function watchdog_device_refresh(watchdog: PWATCHDOG_DEVICE): uint32_t; stdcall; public name 'watchdog_device_refresh';

function watchdog_device_get_remain(watchdog: PWATCHDOG_DEVICE): uint32_t; stdcall; public name 'watchdog_device_get_remain';
function watchdog_device_get_timeout(watchdog: PWATCHDOG_DEVICE): uint32_t; stdcall; public name 'watchdog_device_get_timeout';
function watchdog_device_set_timeout(watchdog: PWATCHDOG_DEVICE; timeout: uint32_t): uint32_t; stdcall; public name 'watchdog_device_set_timeout';

function watchdog_device_create: PWATCHDOG_DEVICE; stdcall; public name 'watchdog_device_create';
function watchdog_device_create_ex(size: uint32_t): PWATCHDOG_DEVICE; stdcall; public name 'watchdog_device_create_ex';
function watchdog_device_destroy(watchdog: PWATCHDOG_DEVICE): uint32_t; stdcall; public name 'watchdog_device_destroy';

function watchdog_device_register(watchdog: PWATCHDOG_DEVICE): uint32_t; stdcall; public name 'watchdog_device_register';
function watchdog_device_deregister(watchdog: PWATCHDOG_DEVICE): uint32_t; stdcall; public name 'watchdog_device_deregister';

function watchdog_device_find(watchdogid: uint32_t): PWATCHDOG_DEVICE; stdcall; public name 'watchdog_device_find';
function watchdog_device_find_by_name(const name: PCHAR): PWATCHDOG_DEVICE; stdcall; public name 'watchdog_device_find_by_name';
function watchdog_device_find_by_description(const description: PCHAR): PWATCHDOG_DEVICE; stdcall; public name 'watchdog_device_find_by_description';
function watchdog_device_enumerate(callback: watchdog_enumerate_cb; data: PVOID): uint32_t; stdcall; public name 'watchdog_device_enumerate';

function watchdog_device_notification(watchdog: PWATCHDOG_DEVICE; callback: watchdog_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall; public name 'watchdog_device_notification';

{==============================================================================}
{Device Helper Functions}
function device_get_count: uint32_t; stdcall; public name 'device_get_count';
function device_check(device: PDEVICE): PDEVICE; stdcall; public name 'device_check';
function notifier_get_count: uint32_t; stdcall; public name 'notifier_get_count';
function notifier_check(notifier: PNOTIFIER): PNOTIFIER; stdcall; public name 'notifier_check';

function device_bus_to_string(devicebus: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'device_bus_to_string';
function device_state_to_string(devicestate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'device_state_to_string';
function device_class_to_string(deviceclass: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'device_class_to_string';

function notification_to_string(notification: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'notification_to_string';

{==============================================================================}
{Driver Helper Functions}
function driver_get_count: uint32_t; stdcall; public name 'driver_get_count';
function driver_check(driver: PDRIVER): PDRIVER; stdcall; public name 'driver_check';

function driver_state_to_string(driverstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'driver_state_to_string';
function driver_class_to_string(driverclass: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'driver_class_to_string';

{==============================================================================}
{Clock Device Helper Functions}
function clock_device_get_count: uint32_t; stdcall; public name 'clock_device_get_count';
function clock_device_get_default: PCLOCK_DEVICE; stdcall; public name 'clock_device_get_default';
function clock_device_set_default(clock: PCLOCK_DEVICE): uint32_t; stdcall; public name 'clock_device_set_default';
function clock_device_check(clock: PCLOCK_DEVICE): PCLOCK_DEVICE; stdcall; public name 'clock_device_check';

function clock_type_to_string(clocktype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'clock_type_to_string';
function clock_state_to_string(clockstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'clock_state_to_string';

{==============================================================================}
{Timer Device Helper Functions}
function timer_device_get_count: uint32_t; stdcall; public name 'timer_device_get_count';
function timer_device_get_default: PTIMER_DEVICE; stdcall; public name 'timer_device_get_default';
function timer_device_set_default(timer: PTIMER_DEVICE): uint32_t; stdcall; public name 'timer_device_set_default';
function timer_device_check(timer: PTIMER_DEVICE): PTIMER_DEVICE; stdcall; public name 'timer_device_check';

function timer_type_to_string(timertype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'timer_type_to_string';
function timer_state_to_string(timerstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'timer_state_to_string';

function timer_device_create_waiter(timer: PTIMER_DEVICE; callback: timer_cb; data: PVOID): PTIMER_WAITER; stdcall; public name 'timer_device_create_waiter';
function timer_device_destroy_waiter(timer: PTIMER_DEVICE; waiter: PTIMER_WAITER): uint32_t; stdcall; public name 'timer_device_destroy_waiter';

function timer_device_register_waiter(timer: PTIMER_DEVICE; waiter: PTIMER_WAITER): uint32_t; stdcall; public name 'timer_device_register_waiter';
function timer_device_deregister_waiter(timer: PTIMER_DEVICE; waiter: PTIMER_WAITER): uint32_t; stdcall; public name 'timer_device_deregister_waiter';

{==============================================================================}
{Random Device Helper Functions}
function random_device_get_count: uint32_t; stdcall; public name 'random_device_get_count';
function random_device_get_default: PRANDOM_DEVICE; stdcall; public name 'random_device_get_default';
function random_device_set_default(random: PRANDOM_DEVICE): uint32_t; stdcall; public name 'random_device_set_default';
function random_device_check(random: PRANDOM_DEVICE): PRANDOM_DEVICE; stdcall; public name 'random_device_check';

function random_type_to_string(randomtype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'random_type_to_string';
function random_state_to_string(randomstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'random_state_to_string';

{==============================================================================}
{Mailbox Device Helper Functions}
function mailbox_device_get_count: uint32_t; stdcall; public name 'mailbox_device_get_count';
function mailbox_device_get_default: PMAILBOX_DEVICE; stdcall; public name 'mailbox_device_get_default';
function mailbox_device_set_default(mailbox: PMAILBOX_DEVICE): uint32_t; stdcall; public name 'mailbox_device_set_default';
function mailbox_device_check(mailbox: PMAILBOX_DEVICE): PMAILBOX_DEVICE; stdcall; public name 'mailbox_device_check';

function mailbox_type_to_string(mailboxtype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'mailbox_type_to_string';
function mailbox_state_to_string(mailboxstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'mailbox_state_to_string';

{==============================================================================}
{Watchdog Device Helper Functions}
function watchdog_device_get_count: uint32_t; stdcall; public name 'watchdog_device_get_count';
function watchdog_device_get_default: PWATCHDOG_DEVICE; stdcall; public name 'watchdog_device_get_default';
function watchdog_device_set_default(watchdog: PWATCHDOG_DEVICE): uint32_t; stdcall; public name 'watchdog_device_set_default';
function watchdog_device_check(watchdog: PWATCHDOG_DEVICE): PWATCHDOG_DEVICE; stdcall; public name 'watchdog_device_check';

function watchdog_type_to_string(watchdogtype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'watchdog_type_to_string';
function watchdog_state_to_string(watchdogstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'watchdog_state_to_string';
{$ENDIF}
{==============================================================================}
{Console Functions}
{$IFDEF API_EXPORT_CONSOLE}
function console_device_open(console: PCONSOLE_DEVICE): uint32_t; stdcall; public name 'console_device_open';
function console_device_close(console: PCONSOLE_DEVICE): uint32_t; stdcall; public name 'console_device_close';

function console_device_clear(console: PCONSOLE_DEVICE; color: uint32_t): uint32_t; stdcall; public name 'console_device_clear';
function console_device_scroll(console: PCONSOLE_DEVICE; x1, y1, x2, y2, count, direction: uint32_t): uint32_t; stdcall; public name 'console_device_scroll';

function console_device_draw_box(console: PCONSOLE_DEVICE; x1, y1, x2, y2, color, width: uint32_t): uint32_t; stdcall; public name 'console_device_draw_box';
function console_device_draw_line(console: PCONSOLE_DEVICE; x1, y1, x2, y2, color, width: uint32_t): uint32_t; stdcall; public name 'console_device_draw_line';
function console_device_plot_line(console: PCONSOLE_DEVICE; x1, y1, x2, y2, color, width: uint32_t): uint32_t; stdcall; public name 'console_device_plot_line';
function console_device_draw_char(console: PCONSOLE_DEVICE; handle: FONT_HANDLE; ch: CHAR; x, y, forecolor, backcolor: uint32_t): uint32_t; stdcall; public name 'console_device_draw_char';
function console_device_draw_text(console: PCONSOLE_DEVICE; handle: FONT_HANDLE; const text: PCHAR; x, y, forecolor, backcolor, len: uint32_t): uint32_t; stdcall; public name 'console_device_draw_text';
function console_device_draw_pixel(console: PCONSOLE_DEVICE; x, y, color: uint32_t): uint32_t; stdcall; public name 'console_device_draw_pixel';
function console_device_draw_block(console: PCONSOLE_DEVICE; x1, y1, x2, y2, color: uint32_t): uint32_t; stdcall; public name 'console_device_draw_block';
function console_device_draw_circle(console: PCONSOLE_DEVICE; x, y, color, width, radius: uint32_t): uint32_t; stdcall; public name 'console_device_draw_circle';
function console_device_draw_image(console: PCONSOLE_DEVICE; x, y: uint32_t; buffer: PVOID; width, height, format, skip: uint32_t): uint32_t; stdcall; public name 'console_device_draw_image';
function console_device_draw_window(console: PCONSOLE_DEVICE; handle: WINDOW_HANDLE; flags: uint32_t): uint32_t; stdcall; public name 'console_device_draw_window';

function console_device_get_pixel(console: PCONSOLE_DEVICE; x, y: uint32_t; var color: uint32_t): uint32_t; stdcall; public name 'console_device_get_pixel';
function console_device_get_image(console: PCONSOLE_DEVICE; x, y: uint32_t; buffer: PVOID; width, height, format, skip: uint32_t): uint32_t; stdcall; public name 'console_device_get_image';

function console_device_put_text(console: PCONSOLE_DEVICE; handle: FONT_HANDLE; const source, dest: TCONSOLE_POINT; buffer: PCONSOLE_CHAR; width, height, skip: uint32_t): uint32_t; stdcall; public name 'console_device_put_text';

function console_device_copy_image(console: PCONSOLE_DEVICE; const source, dest: TCONSOLE_POINT; width, height: uint32_t): uint32_t; stdcall; public name 'console_device_copy_image';

function console_device_add_caret(console: PCONSOLE_DEVICE; width, height, offsetx, offsety: uint32_t): THANDLE; stdcall; public name 'console_device_add_caret';
function console_device_delete_caret(console: PCONSOLE_DEVICE; handle: THANDLE): uint32_t; stdcall; public name 'console_device_delete_caret';
function console_device_update_caret(console: PCONSOLE_DEVICE; handle: THANDLE; x, y: uint32_t; visible, blink: BOOL): uint32_t; stdcall; public name 'console_device_update_caret';
function console_device_update_caret_ex(console: PCONSOLE_DEVICE; handle: THANDLE; x, y, forecolor, backcolor: uint32_t; visible, blink, reverse: BOOL): uint32_t; stdcall; public name 'console_device_update_caret_ex';

function console_device_set_cursor(console: PCONSOLE_DEVICE; width, height: uint32_t; chars: PCHAR): uint32_t; stdcall; public name 'console_device_set_cursor';
function console_device_update_cursor(console: PCONSOLE_DEVICE; enabled: BOOL; x, y: int32_t; relative: BOOL): uint32_t; stdcall; public name 'console_device_update_cursor';

function console_device_get_position(console: PCONSOLE_DEVICE; position: uint32_t; var x1, y1, x2, y2: uint32_t): uint32_t; stdcall; public name 'console_device_get_position';
function console_device_get_properties(console: PCONSOLE_DEVICE; properties: PCONSOLE_PROPERTIES): uint32_t; stdcall; public name 'console_device_get_properties';

function console_device_check_flag(console: PCONSOLE_DEVICE; flag: uint32_t): BOOL; stdcall; public name 'console_device_check_flag';
function console_device_update_flag(console: PCONSOLE_DEVICE; flag: uint32_t; clear: BOOL): uint32_t; stdcall; public name 'console_device_update_flag';

function console_device_get_mode(console: PCONSOLE_DEVICE): uint32_t; stdcall; public name 'console_device_get_mode';
function console_device_get_state(console: PCONSOLE_DEVICE): uint32_t; stdcall; public name 'console_device_get_state';

function console_device_create: PCONSOLE_DEVICE; stdcall; public name 'console_device_create';
function console_device_create_ex(size: uint32_t): PCONSOLE_DEVICE; stdcall; public name 'console_device_create_ex';
function console_device_destroy(console: PCONSOLE_DEVICE): uint32_t; stdcall; public name 'console_device_destroy';

function console_device_register(console: PCONSOLE_DEVICE): uint32_t; stdcall; public name 'console_device_register';
function console_device_deregister(console: PCONSOLE_DEVICE): uint32_t; stdcall; public name 'console_device_deregister';

function console_device_find(consoleid: uint32_t): PCONSOLE_DEVICE; stdcall; public name 'console_device_find';
function console_device_find_by_device(device: PDEVICE): PCONSOLE_DEVICE; stdcall; public name 'console_device_find_by_device';
function console_device_find_by_name(const name: PCHAR): PCONSOLE_DEVICE; stdcall; public name 'console_device_find_by_name';
function console_device_find_by_description(const description: PCHAR): PCONSOLE_DEVICE; stdcall; public name 'console_device_find_by_description';
function console_device_enumerate(callback: console_enumerate_cb; data: PVOID): uint32_t; stdcall; public name 'console_device_enumerate';

function console_device_notification(console: PCONSOLE_DEVICE; callback: console_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall; public name 'console_device_notification';

{==============================================================================}
{Text Console Functions}
function console_window_create(console: PCONSOLE_DEVICE; position: uint32_t; default: BOOL): WINDOW_HANDLE; stdcall; public name 'console_window_create';
function console_window_create_ex(console: PCONSOLE_DEVICE; font: FONT_HANDLE; size, state, mode, position: uint32_t; default: BOOL): WINDOW_HANDLE; stdcall; public name 'console_window_create_ex';
function console_window_destroy(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'console_window_destroy';

function console_window_show(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'console_window_show';
function console_window_hide(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'console_window_hide';

function console_window_activate(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'console_window_activate';
function console_window_deactivate(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'console_window_deactivate';

function console_window_next(console: PCONSOLE_DEVICE; visible: BOOL): WINDOW_HANDLE; stdcall; public name 'console_window_next';
function console_window_previous(console: PCONSOLE_DEVICE; visible: BOOL): WINDOW_HANDLE; stdcall; public name 'console_window_previous';

function console_window_at(console: PCONSOLE_DEVICE; x, y: uint32_t; visible: BOOL): WINDOW_HANDLE; stdcall; public name 'console_window_at';
function console_window_find(console: PCONSOLE_DEVICE; position: uint32_t): WINDOW_HANDLE; stdcall; public name 'console_window_find';
function console_window_enumerate(console: PCONSOLE_DEVICE; callback: console_window_enumerate_cb; data: PVOID): uint32_t; stdcall; public name 'console_window_enumerate';

function console_window_check_flag(handle: WINDOW_HANDLE; flag: uint32_t): BOOL; stdcall; public name 'console_window_check_flag';
function console_window_update_flag(handle: WINDOW_HANDLE; flag: uint32_t; clear: BOOL): uint32_t; stdcall; public name 'console_window_update_flag';

function console_window_get_mode(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'console_window_get_mode';
function console_window_get_state(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'console_window_get_state';

function console_window_get_position(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'console_window_get_position';
function console_window_set_position(handle: WINDOW_HANDLE; position: uint32_t): uint32_t; stdcall; public name 'console_window_set_position';

function console_window_get_properties(handle: WINDOW_HANDLE; properties: PWINDOW_PROPERTIES): uint32_t; stdcall; public name 'console_window_get_properties';

function console_window_get_min_x(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'console_window_get_min_x';
function console_window_get_min_y(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'console_window_get_min_y';
function console_window_get_max_x(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'console_window_get_max_x';
function console_window_get_max_y(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'console_window_get_max_y';

function console_window_get_rect(handle: WINDOW_HANDLE): TCONSOLE_RECT; stdcall; public name 'console_window_get_rect';
function console_window_set_rect(handle: WINDOW_HANDLE; const rect: TCONSOLE_RECT): uint32_t; stdcall; public name 'console_window_set_rect';
function console_window_reset_rect(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'console_window_reset_rect';

function console_window_get_viewport(handle: WINDOW_HANDLE; var x1, y1, x2, y2: uint32_t): uint32_t; stdcall; public name 'console_window_get_viewport';
function console_window_set_viewport(handle: WINDOW_HANDLE; x1, y1, x2, y2: uint32_t): uint32_t; stdcall; public name 'console_window_set_viewport';
function console_window_reset_viewport(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'console_window_reset_viewport';

function console_window_get_x(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'console_window_get_x';
function console_window_set_x(handle: WINDOW_HANDLE; x: uint32_t): uint32_t; stdcall; public name 'console_window_set_x';
function console_window_get_y(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'console_window_get_y';
function console_window_set_y(handle: WINDOW_HANDLE; y: uint32_t): uint32_t; stdcall; public name 'console_window_set_y';

function console_window_get_xy(handle: WINDOW_HANDLE; var x, y: uint32_t): uint32_t; stdcall; public name 'console_window_get_xy';
function console_window_set_xy(handle: WINDOW_HANDLE; x, y: uint32_t): uint32_t; stdcall; public name 'console_window_set_xy';

function console_window_get_point(handle: WINDOW_HANDLE): TCONSOLE_POINT; stdcall; public name 'console_window_get_point';
function console_window_set_point(handle: WINDOW_HANDLE; const point: TCONSOLE_POINT): uint32_t; stdcall; public name 'console_window_set_point';

function console_window_get_cols(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'console_window_get_cols';
function console_window_get_rows(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'console_window_get_rows';

function console_window_get_width(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'console_window_get_width';
function console_window_get_height(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'console_window_get_height';
function console_window_get_format(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'console_window_get_format';

function console_window_get_forecolor(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'console_window_get_forecolor';
function console_window_set_forecolor(handle: WINDOW_HANDLE; color: uint32_t): uint32_t; stdcall; public name 'console_window_set_forecolor';
function console_window_get_backcolor(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'console_window_get_backcolor';
function console_window_set_backcolor(handle: WINDOW_HANDLE; color: uint32_t): uint32_t; stdcall; public name 'console_window_set_backcolor';

function console_window_get_font(handle: WINDOW_HANDLE): FONT_HANDLE; stdcall; public name 'console_window_get_font';
function console_window_set_font(handle: WINDOW_HANDLE; font: FONT_HANDLE): uint32_t; stdcall; public name 'console_window_set_font';

function console_window_get_cursor_xy(handle: WINDOW_HANDLE; var x, y: uint32_t): uint32_t; stdcall; public name 'console_window_get_cursor_xy';
function console_window_set_cursor_xy(handle: WINDOW_HANDLE; x, y: uint32_t): uint32_t; stdcall; public name 'console_window_set_cursor_xy';
function console_window_get_cursor_mode(handle: WINDOW_HANDLE): CURSOR_MODE; stdcall; public name 'console_window_get_cursor_mode';
function console_window_set_cursor_mode(handle: WINDOW_HANDLE; cursormode: CURSOR_MODE): uint32_t; stdcall; public name 'console_window_set_cursor_mode';
function console_window_get_cursor_blink(handle: WINDOW_HANDLE): BOOL; stdcall; public name 'console_window_get_cursor_blink';
function console_window_set_cursor_blink(handle: WINDOW_HANDLE; cursorblink: BOOL): uint32_t; stdcall; public name 'console_window_set_cursor_blink';
function console_window_get_cursor_state(handle: WINDOW_HANDLE): CURSOR_STATE; stdcall; public name 'console_window_get_cursor_state';
function console_window_set_cursor_state(handle: WINDOW_HANDLE; cursorstate: CURSOR_STATE): uint32_t; stdcall; public name 'console_window_set_cursor_state';
function console_window_get_cursor_shape(handle: WINDOW_HANDLE): CURSOR_SHAPE; stdcall; public name 'console_window_get_cursor_shape';
function console_window_set_cursor_shape(handle: WINDOW_HANDLE; cursorshape: CURSOR_SHAPE): uint32_t; stdcall; public name 'console_window_set_cursor_shape';
function console_window_get_cursor_color(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'console_window_get_cursor_color';
function console_window_set_cursor_color(handle: WINDOW_HANDLE; color: uint32_t): uint32_t; stdcall; public name 'console_window_set_cursor_color';
function console_window_get_cursor_reverse(handle: WINDOW_HANDLE): BOOL; stdcall; public name 'console_window_get_cursor_reverse';
function console_window_set_cursor_reverse(handle: WINDOW_HANDLE; cursorreverse: BOOL): uint32_t; stdcall; public name 'console_window_set_cursor_reverse';

function console_window_cursor_on(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'console_window_cursor_on';
function console_window_cursor_off(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'console_window_cursor_off';
function console_window_cursor_line(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'console_window_cursor_line';
function console_window_cursor_bar(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'console_window_cursor_bar';
function console_window_cursor_block(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'console_window_cursor_block';
function console_window_cursor_move(handle: WINDOW_HANDLE; x, y: uint32_t): uint32_t; stdcall; public name 'console_window_cursor_move';
function console_window_cursor_blink(handle: WINDOW_HANDLE; enabled: BOOL): uint32_t; stdcall; public name 'console_window_cursor_blink';
function console_window_cursor_color(handle: WINDOW_HANDLE; color: uint32_t): uint32_t; stdcall; public name 'console_window_cursor_color';
function console_window_cursor_reverse(handle: WINDOW_HANDLE; enabled: BOOL): uint32_t; stdcall; public name 'console_window_cursor_reverse';

function console_window_add_history(handle: WINDOW_HANDLE; const value: PCHAR): uint32_t; stdcall; public name 'console_window_add_history';
function console_window_clear_history(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'console_window_clear_history';
function console_window_first_history(handle: WINDOW_HANDLE; value: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'console_window_first_history';
function console_window_last_history(handle: WINDOW_HANDLE; value: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'console_window_last_history';
function console_window_next_history(handle: WINDOW_HANDLE; value: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'console_window_next_history';
function console_window_previous_history(handle: WINDOW_HANDLE; value: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'console_window_previous_history';
function console_window_current_history(handle: WINDOW_HANDLE; value: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'console_window_current_history';

function console_window_scroll_up(handle: WINDOW_HANDLE; row, lines: uint32_t): uint32_t; stdcall; public name 'console_window_scroll_up';
function console_window_scroll_down(handle: WINDOW_HANDLE; row, lines: uint32_t): uint32_t; stdcall; public name 'console_window_scroll_down';

function console_window_scroll_left(handle: WINDOW_HANDLE; row, col, lines, chars: uint32_t): uint32_t; stdcall; public name 'console_window_scroll_left';
function console_window_scroll_right(handle: WINDOW_HANDLE; row, col, lines, chars: uint32_t): uint32_t; stdcall; public name 'console_window_scroll_right';

function console_window_clear(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'console_window_clear';
function console_window_clear_ex(handle: WINDOW_HANDLE; x1, y1, x2, y2: uint32_t; cursor: BOOL): uint32_t; stdcall; public name 'console_window_clear_ex';

function console_window_write(handle: WINDOW_HANDLE; const text: PCHAR): uint32_t; stdcall; public name 'console_window_write';
function console_window_write_ex(handle: WINDOW_HANDLE; const text: PCHAR; x, y, forecolor, backcolor: uint32_t): uint32_t; stdcall; public name 'console_window_write_ex';

function console_window_write_ln(handle: WINDOW_HANDLE; const text: PCHAR): uint32_t; stdcall; public name 'console_window_write_ln';
function console_window_write_ln_ex(handle: WINDOW_HANDLE; const text: PCHAR; x, y, forecolor, backcolor: uint32_t): uint32_t; stdcall; public name 'console_window_write_ln_ex';

function console_window_write_chr(handle: WINDOW_HANDLE; ch: CHAR): uint32_t; stdcall; public name 'console_window_write_chr';
function console_window_write_chr_ex(handle: WINDOW_HANDLE; ch: CHAR; x, y, forecolor, backcolor: uint32_t): uint32_t; stdcall; public name 'console_window_write_chr_ex';

function console_window_output(handle: WINDOW_HANDLE; const source, dest: TCONSOLE_POINT; buffer: PCONSOLE_CHAR; width, height, skip: uint32_t): uint32_t; stdcall; public name 'console_window_output';

function console_window_read(handle: WINDOW_HANDLE; text: PCHAR; var len: uint32_t): uint32_t; stdcall; public name 'console_window_read';

function console_window_read_ln(handle: WINDOW_HANDLE; text: PCHAR; var len: uint32_t): uint32_t; stdcall; public name 'console_window_read_ln';
function console_window_read_ln_ex(handle: WINDOW_HANDLE; text: PCHAR; var len: uint32_t; prompt: PCHAR; x, y, forecolor, backcolor: uint32_t; scroll, history: BOOL; completion: console_window_completion_cb; data: PVOID): uint32_t; stdcall; public name 'console_window_read_ln_ex';

function console_window_read_chr(handle: WINDOW_HANDLE; var ch: CHAR): uint32_t; stdcall; public name 'console_window_read_chr';
function console_window_read_chr_ex(handle: WINDOW_HANDLE; var ch: CHAR; prompt: PCHAR; x, y, forecolor, backcolor: uint32_t; echo, scroll: BOOL): uint32_t; stdcall; public name 'console_window_read_chr_ex';

{==============================================================================}
{CRT Console Functions}
procedure console_clr_eol; stdcall; public name 'console_clr_eol';
procedure console_clr_scr; stdcall; public name 'console_clr_scr';
procedure console_delay(ms: uint16_t); stdcall; public name 'console_delay';
procedure console_del_line; stdcall; public name 'console_del_line';
procedure console_goto_xy(x, y: int); stdcall; public name 'console_goto_xy';
procedure console_high_video; stdcall; public name 'console_high_video';
procedure console_ins_line; stdcall; public name 'console_ins_line';
function console_keypressed: BOOL; stdcall; public name 'console_keypressed';
procedure console_low_video; stdcall; public name 'console_low_video';
procedure console_norm_video; stdcall; public name 'console_norm_video';
procedure console_no_sound; stdcall; public name 'console_no_sound';
function console_read_key: CHAR; stdcall; public name 'console_read_key';
procedure console_sound(hz: uint16_t); stdcall; public name 'console_sound';
procedure console_text_background(color: uint32_t); stdcall; public name 'console_text_background';
procedure console_text_color(color: uint32_t); stdcall; public name 'console_text_color';
procedure console_text_mode(mode: int); stdcall; public name 'console_text_mode';
function console_where_x: int; stdcall; public name 'console_where_x';
function console_where_y: int; stdcall; public name 'console_where_y';
procedure console_window(x1, y1, x2, y2: int); stdcall; public name 'console_window';
procedure console_scroll_up(row, lines: int); stdcall; public name 'console_scroll_up';
procedure console_scroll_down(row, lines: int); stdcall; public name 'console_scroll_down';

procedure console_write(const text: PCHAR); stdcall; public name 'console_write';
procedure console_write_ln(const text: PCHAR); stdcall; public name 'console_write_ln';
procedure console_write_chr(ch: CHAR); stdcall; public name 'console_write_chr';

procedure console_read(text: PCHAR; var len: uint32_t); stdcall; public name 'console_read';
procedure console_read_ln(text: PCHAR; var len: uint32_t); stdcall; public name 'console_read_ln';
procedure console_read_chr(var ch: CHAR); stdcall; public name 'console_read_chr';

{==============================================================================}
{Console Helper Functions}
function console_device_get_count: uint32_t; stdcall; public name 'console_device_get_count';
function console_device_get_default: PCONSOLE_DEVICE; stdcall; public name 'console_device_get_default';
function console_device_set_default(console: PCONSOLE_DEVICE): uint32_t; stdcall; public name 'console_device_set_default';

function console_device_check(console: PCONSOLE_DEVICE): PCONSOLE_DEVICE; stdcall; public name 'console_device_check';
function console_device_caret_check(console: PCONSOLE_DEVICE; caret: PCONSOLE_CARET): PCONSOLE_CARET; stdcall; public name 'console_device_caret_check';

function console_type_to_string(consoletype: uint32_t; value: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'console_type_to_string';
function console_state_to_string(consolestate: uint32_t; value: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'console_state_to_string';

function console_device_get_default_font: FONT_HANDLE; stdcall; public name 'console_device_get_default_font';

function console_position_to_string(position: uint32_t; value: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'console_position_to_string';

{==============================================================================}
{Text Console Helper Functions}
function console_window_get_count(console: PCONSOLE_DEVICE): uint32_t; stdcall; public name 'console_window_get_count';
function console_window_get_active(console: PCONSOLE_DEVICE): WINDOW_HANDLE; stdcall; public name 'console_window_get_active';
function console_window_get_default(console: PCONSOLE_DEVICE): WINDOW_HANDLE; stdcall; public name 'console_window_get_default';
function console_window_set_default(console: PCONSOLE_DEVICE; handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'console_window_set_default';

function console_window_check(console: PCONSOLE_DEVICE; window: PCONSOLE_WINDOW): PCONSOLE_WINDOW; stdcall; public name 'console_window_check';

function console_window_state_to_string(windowstate: uint32_t; value: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'console_window_state_to_string';
function console_window_mode_to_string(windowmode: uint32_t; value: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'console_window_mode_to_string';

function console_window_get_default_font: FONT_HANDLE; stdcall; public name 'console_window_get_default_font';

function console_window_redirect_output(handle: WINDOW_HANDLE): BOOL; stdcall; public name 'console_window_redirect_output';
{$ENDIF}
{==============================================================================}
{Logging Functions}
{$IFDEF API_EXPORT_LOGGING}
function logging_device_start(logging: PLOGGING_DEVICE): uint32_t; stdcall; public name 'logging_device_start';
function logging_device_stop(logging: PLOGGING_DEVICE): uint32_t; stdcall; public name 'logging_device_stop';

function logging_device_output(logging: PLOGGING_DEVICE; const data: PCHAR): uint32_t; stdcall; public name 'logging_device_output';
function logging_device_output_ex(logging: PLOGGING_DEVICE; facility, severity: uint32_t; const tag, content: PCHAR): uint32_t; stdcall; public name 'logging_device_output_ex';

function logging_device_get_target(logging: PLOGGING_DEVICE; target: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'logging_device_get_target';
function logging_device_set_target(logging: PLOGGING_DEVICE; const target: PCHAR): uint32_t; stdcall; public name 'logging_device_set_target';

function logging_device_create(default: BOOL): PLOGGING_DEVICE; stdcall; public name 'logging_device_create';
function logging_device_create_ex(size: uint32_t; default: BOOL): PLOGGING_DEVICE; stdcall; public name 'logging_device_create_ex';
function logging_device_destroy(logging: PLOGGING_DEVICE): uint32_t; stdcall; public name 'logging_device_destroy';

function logging_device_register(logging: PLOGGING_DEVICE): uint32_t; stdcall; public name 'logging_device_register';
function logging_device_deregister(logging: PLOGGING_DEVICE): uint32_t; stdcall; public name 'logging_device_deregister';

function logging_device_find(loggingid: uint32_t): PLOGGING_DEVICE; stdcall; public name 'logging_device_find';
function logging_device_find_by_type(loggingtype: uint32_t): PLOGGING_DEVICE; stdcall; public name 'logging_device_find_by_type';
function logging_device_find_by_device(device: PDEVICE): PLOGGING_DEVICE; stdcall; public name 'logging_device_find_by_device';
function logging_device_find_by_name(const name: PCHAR): PLOGGING_DEVICE; stdcall; public name 'logging_device_find_by_name';
function logging_device_find_by_description(const description: PCHAR): PLOGGING_DEVICE; stdcall; public name 'logging_device_find_by_description';

function logging_device_enumerate(callback: logging_enumerate_cb; data: PVOID): uint32_t; stdcall; public name 'logging_device_enumerate';

function logging_device_notification(logging: PLOGGING_DEVICE; callback: logging_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall; public name 'logging_device_notification';

{==============================================================================}
{Logging Helper Functions}
function logging_device_get_count: uint32_t; stdcall; public name 'logging_device_get_count';

function logging_device_get_default: PLOGGING_DEVICE; stdcall; public name 'logging_device_get_default';
function logging_device_set_default(logging: PLOGGING_DEVICE): uint32_t; stdcall; public name 'logging_device_set_default';

function logging_device_check(logging: PLOGGING_DEVICE): PLOGGING_DEVICE; stdcall; public name 'logging_device_check';

function logging_type_to_string(loggingtype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'logging_type_to_string';
function logging_state_to_string(loggingstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'logging_state_to_string';

function logging_device_redirect_output(logging: PLOGGING_DEVICE): BOOL; stdcall; public name 'logging_device_redirect_output';

function logging_get_messageslot_flags: uint32_t; stdcall; public name 'logging_get_messageslot_flags';

function logging_console_device_add(console: PCONSOLE_DEVICE): uint32_t; stdcall; public name 'logging_console_device_add';
function logging_console_device_remove(console: PCONSOLE_DEVICE): uint32_t; stdcall; public name 'logging_console_device_remove';
{$ENDIF}
{==============================================================================}
{DMA Host Functions}
{$IFDEF API_EXPORT_DMA}
function dma_host_start(dma: PDMA_HOST): uint32_t; stdcall; public name 'dma_host_start';
function dma_host_stop(dma: PDMA_HOST): uint32_t; stdcall; public name 'dma_host_stop';
function dma_host_reset(dma: PDMA_HOST): uint32_t; stdcall; public name 'dma_host_reset';
function dma_host_properties(dma: PDMA_HOST; properties: PDMA_PROPERTIES): uint32_t; stdcall; public name 'dma_host_properties';

function dma_host_create: PDMA_HOST; stdcall; public name 'dma_host_create';
function dma_host_create_ex(size: uint32_t): PDMA_HOST; stdcall; public name 'dma_host_create_ex';
function dma_host_destroy(dma: PDMA_HOST): uint32_t; stdcall; public name 'dma_host_destroy';

function dma_host_register(dma: PDMA_HOST): uint32_t; stdcall; public name 'dma_host_register';
function dma_host_deregister(dma: PDMA_HOST): uint32_t; stdcall; public name 'dma_host_deregister';

function dma_host_find(dmaid: uint32_t): PDMA_HOST; stdcall; public name 'dma_host_find';
function dma_host_enumerate(callback: dma_enumerate_cb; data: PVOID): uint32_t; stdcall; public name 'dma_host_enumerate';

function dma_host_notification(dma: PDMA_HOST; callback: dma_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall; public name 'dma_host_notification';

{==============================================================================}
{DMA Data Functions}
function dma_data_count(data: PDMA_DATA): uint32_t; stdcall; public name 'dma_data_count';
function dma_data_flags(data: PDMA_DATA): uint32_t; stdcall; public name 'dma_data_flags';
function dma_data_maximum(data: PDMA_DATA): uint32_t; stdcall; public name 'dma_data_maximum';

{==============================================================================}
{DMA Buffer Functions}
function dma_buffer_allocate(dma: PDMA_HOST; size: uint32_t): PVOID; stdcall; public name 'dma_buffer_allocate';
function dma_buffer_allocate_ex(dma: PDMA_HOST; var size: uint32_t): PVOID; stdcall; public name 'dma_buffer_allocate_ex';
function dma_buffer_validate(dma: PDMA_HOST; buffer: PVOID; size: uint32_t): uint32_t; stdcall; public name 'dma_buffer_validate';
function dma_buffer_release(buffer: PVOID): uint32_t; stdcall; public name 'dma_buffer_release';

{==============================================================================}
{DMA Request Functions}
function dma_request_allocate(dma: PDMA_HOST; data: PDMA_DATA; callback: dma_request_completed_cb; driverdata: PVOID; direction, peripheral, flags: uint32_t): PDMA_REQUEST; stdcall; public name 'dma_request_allocate';
function dma_request_release(request: PDMA_REQUEST): uint32_t; stdcall; public name 'dma_request_release';

function dma_request_submit(request: PDMA_REQUEST): uint32_t; stdcall; public name 'dma_request_submit';
function dma_request_cancel(request: PDMA_REQUEST): uint32_t; stdcall; public name 'dma_request_cancel';
procedure dma_request_complete(request: PDMA_REQUEST); stdcall; public name 'dma_request_complete';

{==============================================================================}
{DMA Transfer Functions}
function dma_transfer_request(dma: PDMA_HOST; data: PDMA_DATA; direction, peripheral, flags, timeout: uint32_t): uint32_t; stdcall; public name 'dma_transfer_request';
function dma_transfer_request_ex(dma: PDMA_HOST; data: PDMA_DATA; callback: dma_request_completed_cb; driverdata: PVOID; direction, peripheral, flags: uint32_t): uint32_t; stdcall; public name 'dma_transfer_request_ex';
procedure dma_transfer_request_complete(request: PDMA_REQUEST); stdcall; public name 'dma_transfer_request_complete';

{==============================================================================}
{DMA Helper Functions}
function dma_get_count: uint32_t; stdcall; public name 'dma_get_count';
function dma_host_get_default: PDMA_HOST; stdcall; public name 'dma_host_get_default';
function dma_host_set_default(dma: PDMA_HOST): uint32_t; stdcall; public name 'dma_host_set_default';

function dma_host_check(dma: PDMA_HOST): PDMA_HOST; stdcall; public name 'dma_host_check';

function dma_type_to_string(dmatype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'dma_type_to_string';
function dma_state_to_string(dmastate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'dma_state_to_string';
{$ENDIF}
{==============================================================================}
{PCI Functions}
{$IFDEF API_EXPORT_PCI}
//To Do
{$ENDIF}
{==============================================================================}
{USB Functions}
{$IFDEF API_EXPORT_USB}
function usb_start: uint32_t; stdcall; public name 'usb_start';
function usb_stop: uint32_t; stdcall; public name 'usb_stop';

procedure usb_async_start(host: PUSB_HOST); stdcall; public name 'usb_async_start';

{==============================================================================}
{USB Device, Driver and Host Functions}
//Device Methods
function usb_device_get_address(device: PUSB_DEVICE): uint8_t; stdcall; public name 'usb_device_get_address';
function usb_device_set_address(device: PUSB_DEVICE; address: uint8_t): uint32_t; stdcall; public name 'usb_device_set_address';

function usb_device_get_descriptor(device: PUSB_DEVICE; brequest, bmrequesttype: uint8_t; wvalue, windex: uint16_t; data: PVOID; length: uint16_t): uint32_t; stdcall; public name 'usb_device_get_descriptor';

function usb_device_get_device_descriptor(device: PUSB_DEVICE; data: PVOID; length: uint16_t): uint32_t; stdcall; public name 'usb_device_get_device_descriptor';

function usb_device_create_device_descriptor(device: PUSB_DEVICE; length: uint16_t): uint32_t; stdcall; public name 'usb_device_create_device_descriptor';
function usb_device_read_device_descriptor(device: PUSB_DEVICE; length: uint16_t): uint32_t; stdcall; public name 'usb_device_read_device_descriptor';
function usb_device_read_device_descriptor_ex(device: PUSB_DEVICE; length: uint16_t; allowshort: BOOL): uint32_t; stdcall; public name 'usb_device_read_device_descriptor_ex';

function usb_device_create_configurations(device: PUSB_DEVICE): uint32_t; stdcall; public name 'usb_device_create_configurations';
function usb_device_read_configurations(device: PUSB_DEVICE): uint32_t; stdcall; public name 'usb_device_read_configurations';

function usb_device_create_configuration(device: PUSB_DEVICE; index: uint8_t; size: uint16_t): uint32_t; stdcall; public name 'usb_device_create_configuration';
function usb_device_read_configuration(device: PUSB_DEVICE; index: uint8_t): uint32_t; stdcall; public name 'usb_device_read_configuration';

function usb_device_get_string_descriptor(device: PUSB_DEVICE; index: uint8_t; data: PVOID; length: uint16_t): uint32_t; stdcall; public name 'usb_device_get_string_descriptor';
function usb_device_get_string_descriptor_ex(device: PUSB_DEVICE; index: uint8_t; languageid: uint16_t; data: PVOID; length: uint16_t): uint32_t; stdcall; public name 'usb_device_get_string_descriptor_ex';

procedure usb_device_read_string_language_ids(device: PUSB_DEVICE; var languageids: TUSB_STRING_DESCRIPTOR_LANGIDS); stdcall; public name 'usb_device_read_string_language_ids';

function usb_device_read_string_descriptor(device: PUSB_DEVICE; index: uint8_t; value: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'usb_device_read_string_descriptor';
function usb_device_read_string_descriptor_ex(device: PUSB_DEVICE; index: uint8_t; languageid: uint16_t; value: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'usb_device_read_string_descriptor_ex';
function usb_device_read_string_descriptor_w(device: PUSB_DEVICE; index: uint8_t; value: PWIDECHAR; len: uint32_t): uint32_t; stdcall; public name 'usb_device_read_string_descriptor_w';
function usb_device_read_string_descriptor_ex_w(device: PUSB_DEVICE; index: uint8_t; languageid: uint16_t; value: PWIDECHAR; len: uint32_t): uint32_t; stdcall; public name 'usb_device_read_string_descriptor_ex_w';

function usb_device_get_configuration_descriptor(device: PUSB_DEVICE; index: uint8_t; data: PVOID; length: uint16_t): uint32_t; stdcall; public name 'usb_device_get_configuration_descriptor';

function usb_device_get_configuration(device: PUSB_DEVICE; var configurationvalue: uint8_t): uint32_t; stdcall; public name 'usb_device_get_configuration';
function usb_device_set_configuration(device: PUSB_DEVICE; configurationvalue: uint8_t): uint32_t; stdcall; public name 'usb_device_set_configuration';
function usb_device_find_configuration_by_value(device: PUSB_DEVICE; configurationvalue: uint8_t): PUSB_CONFIGURATION; stdcall; public name 'usb_device_find_configuration_by_value';

function usb_device_get_hub(device: PUSB_DEVICE): PUSB_HUB; stdcall; public name 'usb_device_get_hub';
function usb_device_get_port(device: PUSB_DEVICE): PUSB_PORT; stdcall; public name 'usb_device_get_port';

function usb_device_get_interface(device: PUSB_DEVICE; index: uint8_t; var alternatesetting: uint8_t): uint32_t; stdcall; public name 'usb_device_get_interface';
function usb_device_set_interface(device: PUSB_DEVICE; index, alternatesetting: uint8_t): uint32_t; stdcall; public name 'usb_device_set_interface';
function usb_device_find_interface_by_index(device: PUSB_DEVICE; index: uint8_t): PUSB_INTERFACE; stdcall; public name 'usb_device_find_interface_by_index';
function usb_device_find_interface_by_class_only(device: PUSB_DEVICE; interfaceclass: uint8_t): PUSB_INTERFACE; stdcall; public name 'usb_device_find_interface_by_class_only';
function usb_device_find_interface_by_class(device: PUSB_DEVICE; interfaceclass, interfacesubclass, interfaceprotocol: uint8_t): PUSB_INTERFACE; stdcall; public name 'usb_device_find_interface_by_class';

function usb_device_find_endpoint_by_index(device: PUSB_DEVICE; interrface: PUSB_INTERFACE; index: uint8_t): PUSB_ENDPOINT_DESCRIPTOR; stdcall; public name 'usb_device_find_endpoint_by_index';
function usb_device_find_endpoint_by_type(device: PUSB_DEVICE; interrface: PUSB_INTERFACE; direction, transfertype: uint8_t): PUSB_ENDPOINT_DESCRIPTOR; stdcall; public name 'usb_device_find_endpoint_by_type';
function usb_device_find_endpoint_by_type_ex(device: PUSB_DEVICE; interrface: PUSB_INTERFACE; direction, transfertype: uint8_t; var index: uint8_t): PUSB_ENDPOINT_DESCRIPTOR; stdcall; public name 'usb_device_find_endpoint_by_type_ex';

function usb_device_count_endpoints_by_type(device: PUSB_DEVICE; interrface: PUSB_INTERFACE; direction, transfertype: uint8_t): uint8_t; stdcall; public name 'usb_device_count_endpoints_by_type';

function usb_device_find_alternate_by_index(device: PUSB_DEVICE; interrface: PUSB_INTERFACE; index: uint8_t): PUSB_ALTERNATE; stdcall; public name 'usb_device_find_alternate_by_index';
function usb_device_find_alternate_by_setting(device: PUSB_DEVICE; interrface: PUSB_INTERFACE; alternatesetting: uint8_t): PUSB_ALTERNATE; stdcall; public name 'usb_device_find_alternate_by_setting';

function usb_device_find_alternate_endpoint_by_index(device: PUSB_DEVICE; interrface: PUSB_INTERFACE; alternate: PUSB_ALTERNATE; index: uint8_t): PUSB_ENDPOINT_DESCRIPTOR; stdcall; public name 'usb_device_find_alternate_endpoint_by_index';
function usb_device_find_alternate_endpoint_by_type(device: PUSB_DEVICE; interrface: PUSB_INTERFACE; alternate: PUSB_ALTERNATE; direction, transfertype: uint8_t): PUSB_ENDPOINT_DESCRIPTOR; stdcall; public name 'usb_device_find_alternate_endpoint_by_type';

function usb_device_set_feature(device: PUSB_DEVICE; endpoint: PUSB_ENDPOINT_DESCRIPTOR; feature, index: uint16_t): uint32_t; stdcall; public name 'usb_device_set_feature';
function usb_device_clear_feature(device: PUSB_DEVICE; endpoint: PUSB_ENDPOINT_DESCRIPTOR; feature: uint16_t): uint32_t; stdcall; public name 'usb_device_clear_feature';

function usb_device_set_state(device: PUSB_DEVICE; state: uint32_t): uint32_t; stdcall; public name 'usb_device_set_state';
function usb_device_set_status(device: PUSB_DEVICE; status: uint32_t): uint32_t; stdcall; public name 'usb_device_set_status';

function usb_device_bind(device: PUSB_DEVICE): uint32_t; stdcall; public name 'usb_device_bind';
function usb_device_unbind(device: PUSB_DEVICE; driver: PUSB_DRIVER): uint32_t; stdcall; public name 'usb_device_unbind';

function usb_device_attach(device: PUSB_DEVICE): uint32_t; stdcall; public name 'usb_device_attach';
function usb_device_detach(device: PUSB_DEVICE): uint32_t; stdcall; public name 'usb_device_detach';

function usb_device_allocate(host: PUSB_HOST; parent: PUSB_DEVICE): PUSB_DEVICE; stdcall; public name 'usb_device_allocate';
function usb_device_release(device: PUSB_DEVICE): uint32_t; stdcall; public name 'usb_device_release';

function usb_device_find(usbid: uint32_t): PUSB_DEVICE; stdcall; public name 'usb_device_find';
function usb_device_find_by_id(vendorid, productid: uint16_t): PUSB_DEVICE; stdcall; public name 'usb_device_find_by_id';
function usb_device_find_by_name(const name: PCHAR): PUSB_DEVICE; stdcall; public name 'usb_device_find_by_name';
function usb_device_find_by_description(const description: PCHAR): PUSB_DEVICE; stdcall; public name 'usb_device_find_by_description';
function usb_device_enumerate(callback: usb_device_enumerate_cb; data: PVOID): uint32_t; stdcall; public name 'usb_device_enumerate';

function usb_device_notification(device: PUSB_DEVICE; callback: usb_device_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall; public name 'usb_device_notification';

//Driver Methods
function usb_driver_create: PUSB_DRIVER; stdcall; public name 'usb_driver_create';
function usb_driver_create_ex(size: uint32_t): PUSB_DRIVER; stdcall; public name 'usb_driver_create_ex';
function usb_driver_destroy(driver: PUSB_DRIVER): uint32_t; stdcall; public name 'usb_driver_destroy';

function usb_driver_register(driver: PUSB_DRIVER): uint32_t; stdcall; public name 'usb_driver_register';
function usb_driver_deregister(driver: PUSB_DRIVER): uint32_t; stdcall; public name 'usb_driver_deregister';

function usb_driver_find(driverid: uint32_t): PUSB_DRIVER; stdcall; public name 'usb_driver_find';
function usb_driver_find_by_name(const name: PCHAR): PUSB_DRIVER; stdcall; public name 'usb_driver_find_by_name';
function usb_driver_enumerate(callback: usb_driver_enumerate_cb; data: PVOID): uint32_t; stdcall; public name 'usb_driver_enumerate';

//Host Methods
function usb_host_set_state(host: PUSB_HOST; state: uint32_t): uint32_t; stdcall; public name 'usb_host_set_state';

function usb_host_create: PUSB_HOST; stdcall; public name 'usb_host_create';
function usb_host_create_ex(size: uint32_t): PUSB_HOST; stdcall; public name 'usb_host_create_ex';
function usb_host_destroy(host: PUSB_HOST): uint32_t; stdcall; public name 'usb_host_destroy';

function usb_host_register(host: PUSB_HOST): uint32_t; stdcall; public name 'usb_host_register';
function usb_host_deregister(host: PUSB_HOST): uint32_t; stdcall; public name 'usb_host_deregister';

function usb_host_find(hostid: uint32_t): PUSB_HOST; stdcall; public name 'usb_host_find';
function usb_host_find_by_name(const name: PCHAR): PUSB_HOST; stdcall; public name 'usb_host_find_by_name';
function usb_host_find_by_description(const description: PCHAR): PUSB_HOST; stdcall; public name 'usb_host_find_by_description';
function usb_host_enumerate(callback: usb_host_enumerate_cb; data: PVOID): uint32_t; stdcall; public name 'usb_host_enumerate';

function usb_host_notification(host: PUSB_HOST; callback: usb_host_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall; public name 'usb_host_notification';

//Buffer Methods
function usb_buffer_allocate(device: PUSB_DEVICE; size: uint32_t): PVOID; stdcall; public name 'usb_buffer_allocate';
function usb_buffer_allocate_ex(device: PUSB_DEVICE; size: uint32_t; var flags: uint32_t): PVOID; stdcall; public name 'usb_buffer_allocate_ex';
function usb_buffer_validate(device: PUSB_DEVICE; buffer: PVOID; size: uint32_t; var flags: uint32_t): uint32_t; stdcall; public name 'usb_buffer_validate';
function usb_buffer_release(buffer: PVOID): uint32_t; stdcall; public name 'usb_buffer_release';

//Request Methods
function usb_request_allocate(device: PUSB_DEVICE; endpoint: PUSB_ENDPOINT_DESCRIPTOR; callback: usb_request_completed_cb; size: uint32_t; driverdata: PVOID): PUSB_REQUEST; stdcall; public name 'usb_request_allocate';
function usb_request_allocate_ex(device: PUSB_DEVICE; endpoint: PUSB_ENDPOINT_DESCRIPTOR; callback: usb_request_completed_cb; var data: PVOID; size: uint32_t; driverdata: PVOID): PUSB_REQUEST; stdcall; public name 'usb_request_allocate_ex';
function usb_request_release(request: PUSB_REQUEST): uint32_t; stdcall; public name 'usb_request_release';
function usb_request_initialize(request: PUSB_REQUEST; callback: usb_request_completed_cb; data: PVOID; size: uint32_t; driverdata: PVOID): uint32_t; stdcall; public name 'usb_request_initialize';

function usb_request_submit(request: PUSB_REQUEST): uint32_t; stdcall; public name 'usb_request_submit';
function usb_request_cancel(request: PUSB_REQUEST): uint32_t; stdcall; public name 'usb_request_cancel';

//Control Methods
function usb_control_request(device: PUSB_DEVICE; endpoint: PUSB_ENDPOINT_DESCRIPTOR; brequest, bmrequesttype: uint8_t; wvalue, windex: uint16_t; data: PVOID; wlength: uint16_t): uint32_t; stdcall; public name 'usb_control_request';
function usb_control_request_ex(device: PUSB_DEVICE; endpoint: PUSB_ENDPOINT_DESCRIPTOR; brequest, bmrequesttype: uint8_t; wvalue, windex: uint16_t; data: PVOID; wlength: uint16_t; timeout: uint32_t; allowshort: BOOL): uint32_t; stdcall; public name 'usb_control_request_ex';

//Synchronous Transfer Methods
function usb_control_transfer(device: PUSB_DEVICE; endpoint: PUSB_ENDPOINT_DESCRIPTOR; brequest, bmrequesttype: uint8_t; wvalue, windex: uint16_t; data: PVOID; wlength: uint16_t; var count: uint32_t; timeout: uint32_t): uint32_t; stdcall; public name 'usb_control_transfer';
function usb_bulk_transfer(device: PUSB_DEVICE; endpoint: PUSB_ENDPOINT_DESCRIPTOR; data: PVOID; size: uint32_t; var count: uint32_t; timeout: uint32_t): uint32_t; stdcall; public name 'usb_bulk_transfer';
function usb_interrupt_transfer(device: PUSB_DEVICE; endpoint: PUSB_ENDPOINT_DESCRIPTOR; data: PVOID; size: uint32_t; var count: uint32_t; timeout: uint32_t): uint32_t; stdcall; public name 'usb_interrupt_transfer';

{==============================================================================}
{USB Hub Functions}
//Hub Methods
function usb_hub_create_ports(hub: PUSB_HUB): uint32_t; stdcall; public name 'usb_hub_create_ports';
function usb_hub_power_on_ports(hub: PUSB_HUB): uint32_t; stdcall; public name 'usb_hub_power_on_ports';

function usb_hub_create_hub_descriptor(hub: PUSB_HUB): uint32_t; stdcall; public name 'usb_hub_create_hub_descriptor';
function usb_hub_read_hub_descriptor(hub: PUSB_HUB): uint32_t; stdcall; public name 'usb_hub_read_hub_descriptor';

function usb_hub_lock(hub: PUSB_HUB): uint32_t; stdcall; public name 'usb_hub_lock';
function usb_hub_unlock(hub: PUSB_HUB): uint32_t; stdcall; public name 'usb_hub_unlock';

function usb_hub_set_state(hub: PUSB_HUB; state: uint32_t): uint32_t; stdcall; public name 'usb_hub_set_state';

function usb_hub_allocate(device: PUSB_DEVICE): PUSB_HUB; stdcall; public name 'usb_hub_allocate';
function usb_hub_release(hub: PUSB_HUB): uint32_t; stdcall; public name 'usb_hub_release';

function usb_hub_find(hubid: uint32_t): PUSB_HUB; stdcall; public name 'usb_hub_find';
function usb_hub_find_by_name(const name: PCHAR): PUSB_HUB; stdcall; public name 'usb_hub_find_by_name';
function usb_hub_find_by_description(const description: PCHAR): PUSB_HUB; stdcall; public name 'usb_hub_find_by_description';
function usb_hub_enumerate(callback: usb_hub_enumerate_cb; data: PVOID): uint32_t; stdcall; public name 'usb_hub_enumerate';

function usb_hub_notification(hub: PUSB_HUB; callback: usb_hub_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall; public name 'usb_hub_notification';

procedure usb_hub_bind_devices(device: PUSB_DEVICE; callback: usb_device_bind_proc); stdcall; public name 'usb_hub_bind_devices';
procedure usb_hub_unbind_devices(device: PUSB_DEVICE; driver: PUSB_DRIVER; callback: usb_device_unbind_proc); stdcall; public name 'usb_hub_unbind_devices';
procedure usb_hub_enumerate_devices(device: PUSB_DEVICE; callback: usb_device_enumerate_cb; data: PVOID); stdcall; public name 'usb_hub_enumerate_devices';

//Hub Port Methods
function usb_hub_port_reset(port: PUSB_PORT; delay: uint32_t): uint32_t; stdcall; public name 'usb_hub_port_reset';

function usb_hub_port_disable(port: PUSB_PORT): uint32_t; stdcall; public name 'usb_hub_port_disable';

function usb_hub_port_power_on(port: PUSB_PORT): uint32_t; stdcall; public name 'usb_hub_port_power_on';
function usb_hub_port_power_off(port: PUSB_PORT): uint32_t; stdcall; public name 'usb_hub_port_power_off';

function usb_hub_port_get_status(port: PUSB_PORT): uint32_t; stdcall; public name 'usb_hub_port_get_status';

function usb_hub_port_set_feature(port: PUSB_PORT; feature: uint16_t): uint32_t; stdcall; public name 'usb_hub_port_set_feature';
function usb_hub_port_clear_feature(port: PUSB_PORT; feature: uint16_t): uint32_t; stdcall; public name 'usb_hub_port_clear_feature';
function usb_hub_port_change_feature(port: PUSB_PORT; feature: uint16_t; enable: BOOL): uint32_t; stdcall; public name 'usb_hub_port_change_feature';

function usb_hub_port_attach_device(port: PUSB_PORT): uint32_t; stdcall; public name 'usb_hub_port_attach_device';
function usb_hub_port_detach_device(port: PUSB_PORT): uint32_t; stdcall; public name 'usb_hub_port_detach_device';

function usb_hub_port_status_changed(port: PUSB_PORT): uint32_t; stdcall; public name 'usb_hub_port_status_changed';

{==============================================================================}
{USB Device, Driver and Host Helper Functions}
function usb_device_get_count: uint32_t; stdcall; public name 'usb_device_get_count';

function usb_device_check(device: PUSB_DEVICE): PUSB_DEVICE; stdcall; public name 'usb_device_check';

function usb_driver_get_count: uint32_t; stdcall; public name 'usb_driver_get_count';

function usb_driver_check(driver: PUSB_DRIVER): PUSB_DRIVER; stdcall; public name 'usb_driver_check';

function usb_host_get_count: uint32_t; stdcall; public name 'usb_host_get_count';

function usb_host_check(host: PUSB_HOST): PUSB_HOST; stdcall; public name 'usb_host_check';

function usb_is_hub(device: PUSB_DEVICE): BOOL; stdcall; public name 'usb_is_hub';
function usb_is_root_hub(device: PUSB_DEVICE): BOOL; stdcall; public name 'usb_is_root_hub';

function usb_is_control_request(request: PUSB_REQUEST): BOOL; stdcall; public name 'usb_is_control_request';
function usb_is_bulk_request(request: PUSB_REQUEST): BOOL; stdcall; public name 'usb_is_bulk_request';
function usb_is_interrupt_request(request: PUSB_REQUEST): BOOL; stdcall; public name 'usb_is_interrupt_request';
function usb_is_isochronous_request(request: PUSB_REQUEST): BOOL; stdcall; public name 'usb_is_isochronous_request';

function usb_is_in_endpoint(endpoint: PUSB_ENDPOINT_DESCRIPTOR): BOOL; stdcall; public name 'usb_is_in_endpoint';
function usb_is_out_endpoint(endpoint: PUSB_ENDPOINT_DESCRIPTOR): BOOL; stdcall; public name 'usb_is_out_endpoint';

function usb_is_bulk_endpoint(endpoint: PUSB_ENDPOINT_DESCRIPTOR): BOOL; stdcall; public name 'usb_is_bulk_endpoint';
function usb_is_interrupt_endpoint(endpoint: PUSB_ENDPOINT_DESCRIPTOR): BOOL; stdcall; public name 'usb_is_interrupt_endpoint';
function usb_is_isochronous_endpoint(endpoint: PUSB_ENDPOINT_DESCRIPTOR): BOOL; stdcall; public name 'usb_is_isochronous_endpoint';

function usb_status_to_string(status: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'usb_status_to_string';

function usb_device_type_to_string(usbtype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'usb_device_type_to_string';
function usb_device_state_to_string(usbstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'usb_device_state_to_string';
function usb_device_status_to_string(usbstatus: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'usb_device_status_to_string';

function usb_device_state_to_notification(state: uint32_t): uint32_t; stdcall; public name 'usb_device_state_to_notification';
function usb_device_status_to_notification(status: uint32_t): uint32_t; stdcall; public name 'usb_device_status_to_notification';

function usb_host_type_to_string(hosttype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'usb_host_type_to_string';
function usb_host_state_to_string(hoststate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'usb_host_state_to_string';

function usb_host_state_to_notification(state: uint32_t): uint32_t; stdcall; public name 'usb_host_state_to_notification';

procedure usb_log_device_configuration(device: PUSB_DEVICE; output: usb_log_output_proc; data: PVOID); stdcall; public name 'usb_log_device_configuration';
procedure usb_log_device_descriptor(device: PUSB_DEVICE; descriptor: PUSB_DEVICE_DESCRIPTOR; output: usb_log_output_proc; data: PVOID); stdcall; public name 'usb_log_device_descriptor';
procedure usb_log_configuration_descriptor(device: PUSB_DEVICE; descriptor: PUSB_CONFIGURATION_DESCRIPTOR; output: usb_log_output_proc; data: PVOID); stdcall; public name 'usb_log_configuration_descriptor';
procedure usb_log_interface_descriptor(device: PUSB_DEVICE; descriptor: PUSB_INTERFACE_DESCRIPTOR; output: usb_log_output_proc; data: PVOID); stdcall; public name 'usb_log_interface_descriptor';
procedure usb_log_endpoint_descriptor(device: PUSB_DEVICE; descriptor: PUSB_ENDPOINT_DESCRIPTOR; output: usb_log_output_proc; data: PVOID); stdcall; public name 'usb_log_endpoint_descriptor';

function usb_log_devices: uint32_t; stdcall; public name 'usb_log_devices';
function usb_log_devices_ex(device: PUSB_DEVICE; output: usb_log_output_proc; devicecallback, treecallback: usb_device_enumerate_cb; data: PVOID): uint32_t; stdcall; public name 'usb_log_devices_ex';

function usb_log_device_callback(device: PUSB_DEVICE; data: PVOID): uint32_t; stdcall; public name 'usb_log_device_callback';
function usb_log_tree_callback(device: PUSB_DEVICE; data: PVOID): uint32_t; stdcall; public name 'usb_log_tree_callback';

{==============================================================================}
{USB Hub Helper Functions}
function usb_hub_get_count: uint32_t; stdcall; public name 'usb_hub_get_count';

function usb_hub_check(hub: PUSB_HUB): PUSB_HUB; stdcall; public name 'usb_hub_check';

function usb_hub_is_multi_tt(hub: PUSB_HUB): BOOL; stdcall; public name 'usb_hub_is_multi_tt';
function usb_hub_is_compound(hub: PUSB_HUB): BOOL; stdcall; public name 'usb_hub_is_compound';

function usb_hub_has_port_indicator(hub: PUSB_HUB): BOOL; stdcall; public name 'usb_hub_has_port_indicator';
function usb_hub_has_port_power_switching(hub: PUSB_HUB): BOOL; stdcall; public name 'usb_hub_has_port_power_switching';
function usb_hub_has_port_current_protection(hub: PUSB_HUB): BOOL; stdcall; public name 'usb_hub_has_port_current_protection';

function usb_hub_get_tt_think_time(hub: PUSB_HUB): uint8_t; stdcall; public name 'usb_hub_get_tt_think_time';

function usb_hub_type_to_string(hubtype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'usb_hub_type_to_string';
function usb_hub_state_to_string(hubstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'usb_hub_state_to_string';

function usb_hub_state_to_notification(state: uint32_t): uint32_t; stdcall; public name 'usb_hub_state_to_notification';
{$ENDIF}
{==============================================================================}
{MMC Functions}
{$IFDEF API_EXPORT_MMC}
function mmc_start: uint32_t; stdcall; public name 'mmc_start';
function mmc_stop: uint32_t; stdcall; public name 'mmc_stop';

procedure mmc_async_start(sdhci: PSDHCI_HOST); stdcall; public name 'mmc_async_start';

{==============================================================================}
{MMC Functions}
function mmc_device_read_blocks(mmc: PMMC_DEVICE; const start, count: int64_t; buffer: PVOID): uint32_t; stdcall; public name 'mmc_device_read_blocks';
function mmc_device_write_blocks(mmc: PMMC_DEVICE; const start, count: int64_t; buffer: PVOID): uint32_t; stdcall; public name 'mmc_device_write_blocks';

function mmc_device_erase_blocks(mmc: PMMC_DEVICE; const start, count: int64_t): uint32_t; stdcall; public name 'mmc_device_erase_blocks';

function mmc_device_go_idle(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'mmc_device_go_idle';

function mmc_device_set_clock(mmc: PMMC_DEVICE; clock: uint32_t): uint32_t; stdcall; public name 'mmc_device_set_clock';
function mmc_device_set_timing(mmc: PMMC_DEVICE; timing: uint32_t): uint32_t; stdcall; public name 'mmc_device_set_timing';
function mmc_device_set_bus_width(mmc: PMMC_DEVICE; width: uint32_t): uint32_t; stdcall; public name 'mmc_device_set_bus_width';

function mmc_device_set_block_length(mmc: PMMC_DEVICE; length: uint32_t): uint32_t; stdcall; public name 'mmc_device_set_block_length';
function mmc_device_set_block_count(mmc: PMMC_DEVICE; count: uint32_t; relative: BOOL): uint32_t; stdcall; public name 'mmc_device_set_block_count';
function mmc_device_set_driver_stage(mmc: PMMC_DEVICE; driverstage: uint32_t): uint32_t; stdcall; public name 'mmc_device_set_driver_stage';

function mmc_device_stop_transmission(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'mmc_device_stop_transmission';

function mmc_device_select_card(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'mmc_device_select_card';
function mmc_device_deselect_card(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'mmc_device_deselect_card';

function mmc_device_switch(mmc: PMMC_DEVICE; setting, index, value: uint8_t; timeout: uint32_t): uint32_t; stdcall; public name 'mmc_device_switch';
function mmc_device_switch_ex(mmc: PMMC_DEVICE; setting, index, value: uint8_t; timeout, timing: uint32_t; sendstatus, retrycrcerror: BOOL): uint32_t; stdcall; public name 'mmc_device_switch_ex';

function mmc_device_poll_for_busy(mmc: PMMC_DEVICE; timeout, command: uint32_t): uint32_t; stdcall; public name 'mmc_device_poll_for_busy';
function mmc_device_poll_for_busy_ex(mmc: PMMC_DEVICE; timeout, command: uint32_t; sendstatus, retrycrcerror: BOOL): uint32_t; stdcall; public name 'mmc_device_poll_for_busy_ex';

function mmc_device_send_card_status(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'mmc_device_send_card_status';

function mmc_device_send_operation_condition(mmc: PMMC_DEVICE; probe: BOOL): uint32_t; stdcall; public name 'mmc_device_send_operation_condition';

function mmc_device_send_card_specific(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'mmc_device_send_card_specific';
function mmc_device_decode_card_specific(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'mmc_device_decode_card_specific';

function mmc_device_send_card_identification(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'mmc_device_send_card_identification';
function mmc_device_send_all_card_identification(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'mmc_device_send_all_card_identification';
function mmc_device_decode_card_identification(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'mmc_device_decode_card_identification';

function mmc_device_get_extended_card_specific(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'mmc_device_get_extended_card_specific';
function mmc_device_send_extended_card_specific(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'mmc_device_send_extended_card_specific';
function mmc_device_decode_extended_card_specific(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'mmc_device_decode_extended_card_specific';

function mmc_device_set_relative_address(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'mmc_device_set_relative_address';

function mmc_device_spi_set_crc(mmc: PMMC_DEVICE; enable: BOOL): uint32_t; stdcall; public name 'mmc_device_spi_set_crc';
function mmc_device_spi_read_operation_condition(mmc: PMMC_DEVICE; highcapacity: BOOL): uint32_t; stdcall; public name 'mmc_device_spi_read_operation_condition';

function mmc_device_insert(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'mmc_device_insert';
function mmc_device_remove(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'mmc_device_remove';

function mmc_device_initialize(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'mmc_device_initialize';
function mmc_device_deinitialize(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'mmc_device_deinitialize';

function mmc_device_get_card_detect(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'mmc_device_get_card_detect';
function mmc_device_get_write_protect(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'mmc_device_get_write_protect';
function mmc_device_send_command(mmc: PMMC_DEVICE; command: PMMC_COMMAND): uint32_t; stdcall; public name 'mmc_device_send_command';
function mmc_device_set_ios(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'mmc_device_set_ios';

function mmc_device_create: PMMC_DEVICE; stdcall; public name 'mmc_device_create';
function mmc_device_create_ex(size: uint32_t): PMMC_DEVICE; stdcall; public name 'mmc_device_create_ex';
function mmc_device_destroy(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'mmc_device_destroy';

function mmc_device_register(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'mmc_device_register';
function mmc_device_deregister(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'mmc_device_deregister';

function mmc_device_find(mmcid: uint32_t): PMMC_DEVICE; stdcall; public name 'mmc_device_find';
function mmc_device_find_by_device(device: PDEVICE): PMMC_DEVICE; stdcall; public name 'mmc_device_find_by_device';
function mmc_device_find_by_name(const name: PCHAR): PMMC_DEVICE; stdcall; public name 'mmc_device_find_by_name';
function mmc_device_find_by_description(const description: PCHAR): PMMC_DEVICE; stdcall; public name 'mmc_device_find_by_description';
function mmc_device_enumerate(callback: mmc_enumerate_cb; data: PVOID): uint32_t; stdcall; public name 'mmc_device_enumerate';

function mmc_device_notification(mmc: PMMC_DEVICE; callback: mmc_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall; public name 'mmc_device_notification';

{==============================================================================}
{SD Functions}
function sd_device_switch(mmc: PMMC_DEVICE; mode, group: int; value: uint8_t; buffer: PVOID): uint32_t; stdcall; public name 'sd_device_switch';

function sd_device_switch_highspeed(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'sd_device_switch_highspeed';

function sd_device_set_bus_width(mmc: PMMC_DEVICE; width: uint32_t): uint32_t; stdcall; public name 'sd_device_set_bus_width';

function sd_device_send_interface_condition(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'sd_device_send_interface_condition';

function sd_device_send_operation_condition(mmc: PMMC_DEVICE; probe: BOOL): uint32_t; stdcall; public name 'sd_device_send_operation_condition';

function sd_device_get_card_specific(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'sd_device_get_card_specific';
function sd_device_decode_card_specific(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'sd_device_decode_card_specific';

function sd_device_get_card_identification(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'sd_device_get_card_identification';
function sd_device_decode_card_identification(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'sd_device_decode_card_identification';

function sd_device_send_sd_status(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'sd_device_send_sd_status';
function sd_device_decode_sd_status(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'sd_device_decode_sd_status';

function sd_device_send_sd_switch(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'sd_device_send_sd_switch';
function sd_device_decode_sd_switch(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'sd_device_decode_sd_switch';

function sd_device_send_sd_configuration(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'sd_device_send_sd_configuration';
function sd_device_decode_sd_configuration(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'sd_device_decode_sd_configuration';

function sd_device_send_relative_address(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'sd_device_send_relative_address';

function sd_device_send_application_command(mmc: PMMC_DEVICE; command: PMMC_COMMAND): uint32_t; stdcall; public name 'sd_device_send_application_command';

{==============================================================================}
{SDIO Functions}
//Device Methods
function sdio_device_reset(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'sdio_device_reset';

function sdio_device_enable_wide_bus(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'sdio_device_enable_wide_bus';
function sdio_device_disable_wide_bus(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'sdio_device_disable_wide_bus';

function sdio_device_enable_highspeed(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'sdio_device_enable_highspeed';
function sdio_device_switch_highspeed(mmc: PMMC_DEVICE; enable: BOOL): uint32_t; stdcall; public name 'sdio_device_switch_highspeed';

function sdio_device_send_operation_condition(mmc: PMMC_DEVICE; probe: BOOL): uint32_t; stdcall; public name 'sdio_device_send_operation_condition';

function sdio_device_read_write_direct(mmc: PMMC_DEVICE; write: BOOL; operation, address: uint32_t; input: uint8_t; output: Puint8_t): uint32_t; stdcall; public name 'sdio_device_read_write_direct';
function sdio_device_read_write_extended(mmc: PMMC_DEVICE; write: BOOL; operation, address: uint32_t; increment: BOOL; buffer: PVOID; blockcount, blocksize: uint32_t): uint32_t; stdcall; public name 'sdio_device_read_write_extended';

function sdio_device_read_byte(mmc: PMMC_DEVICE; address: uint32_t; output: Puint8_t): uint32_t; stdcall; public name 'sdio_device_read_byte';
function sdio_device_write_byte(mmc: PMMC_DEVICE; address: uint32_t; input: uint8_t): uint32_t; stdcall; public name 'sdio_device_write_byte';

function sdio_device_read_cccr(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'sdio_device_read_cccr';

function sdio_device_read_fbr(func: PSDIO_FUNCTION): uint32_t; stdcall; public name 'sdio_device_read_fbr';

function sdio_device_read_cis(mmc: PMMC_DEVICE; func: PSDIO_FUNCTION): uint32_t; stdcall; public name 'sdio_device_read_cis';

function sdio_device_read_common_cis(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'sdio_device_read_common_cis';
function sdio_device_read_function_cis(func: PSDIO_FUNCTION): uint32_t; stdcall; public name 'sdio_device_read_function_cis';

function sdio_device_process_interrupts(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'sdio_device_process_interrupts';
function sdio_device_register_interrupt(mmc: PMMC_DEVICE; func: PSDIO_FUNCTION; handler: sdio_interrupt_handler): uint32_t; stdcall; public name 'sdio_device_register_interrupt';
function sdio_device_deregister_interrupt(mmc: PMMC_DEVICE; func: PSDIO_FUNCTION): uint32_t; stdcall; public name 'sdio_device_deregister_interrupt';

function sdio_device_bind_functions(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'sdio_device_bind_functions';
function sdio_device_unbind_functions(mmc: PMMC_DEVICE; driver: PSDIO_DRIVER): uint32_t; stdcall; public name 'sdio_device_unbind_functions';

//Function Methods
function sdio_function_allocate(mmc: PMMC_DEVICE; number: uint32_t): PSDIO_FUNCTION; stdcall; public name 'sdio_function_allocate';
function sdio_function_release(func: PSDIO_FUNCTION): uint32_t; stdcall; public name 'sdio_function_release';

function sdio_function_find(mmc: PMMC_DEVICE; number: uint32_t): PSDIO_FUNCTION; stdcall; public name 'sdio_function_find';
function sdio_function_find_by_id(mmc: PMMC_DEVICE; vendorid, deviceid: uint16_t): PSDIO_FUNCTION; stdcall; public name 'sdio_function_find_by_id';
function sdio_function_enumerate(mmc: PMMC_DEVICE; callback: sdio_function_enumerate_cb; data: PVOID): uint32_t; stdcall; public name 'sdio_function_enumerate';

function sdio_function_bind(func: PSDIO_FUNCTION; driver: PSDIO_DRIVER): uint32_t; stdcall; public name 'sdio_function_bind';
function sdio_function_unbind(func: PSDIO_FUNCTION; driver: PSDIO_DRIVER): uint32_t; stdcall; public name 'sdio_function_unbind';

function sdio_function_enable(func: PSDIO_FUNCTION): uint32_t; stdcall; public name 'sdio_function_enable';
function sdio_function_disable(func: PSDIO_FUNCTION): uint32_t; stdcall; public name 'sdio_function_disable';

function sdio_function_set_block_size(func: PSDIO_FUNCTION; blocksize: uint32_t): uint32_t; stdcall; public name 'sdio_function_set_block_size';

function sdio_function_read_write_extended(func: PSDIO_FUNCTION; write: BOOL; address: uint32_t; increment: BOOL; buffer: PVOID; size: uint32_t): uint32_t; stdcall; public name 'sdio_function_read_write_extended';

function sdio_function_read(func: PSDIO_FUNCTION; address: uint32_t; buffer: PVOID; size: uint32_t): uint32_t; stdcall; public name 'sdio_function_read';
function sdio_function_write(func: PSDIO_FUNCTION; address: uint32_t; buffer: PVOID; size: uint32_t): uint32_t; stdcall; public name 'sdio_function_write';

function sdio_function_read_byte(func: PSDIO_FUNCTION; address: uint32_t; output: Puint8_t): uint32_t; stdcall; public name 'sdio_function_read_byte';
function sdio_function_write_byte(func: PSDIO_FUNCTION; address: uint32_t; input: uint8_t): uint32_t; stdcall; public name 'sdio_function_write_byte';
function sdio_function_write_read_byte(func: PSDIO_FUNCTION; address: uint32_t; input: uint8_t; output: Puint8_t): uint32_t; stdcall; public name 'sdio_function_write_read_byte';

function sdio_function_read_word(func: PSDIO_FUNCTION; address: uint32_t; output: Puint16_t): uint32_t; stdcall; public name 'sdio_function_read_word';
function sdio_function_write_word(func: PSDIO_FUNCTION; address: uint32_t; input: uint16_t): uint32_t; stdcall; public name 'sdio_function_write_word';

function sdio_function_read_long(func: PSDIO_FUNCTION; address: uint32_t; output: Puint32_t): uint32_t; stdcall; public name 'sdio_function_read_long';
function sdio_function_write_long(func: PSDIO_FUNCTION; address: uint32_t; input: uint32_t): uint32_t; stdcall; public name 'sdio_function_write_long';

function sdio_function_register_interrupt(func: PSDIO_FUNCTION; handler: sdio_interrupt_handler): uint32_t; stdcall; public name 'sdio_function_register_interrupt';
function sdio_function_deregister_interrupt(func: PSDIO_FUNCTION): uint32_t; stdcall; public name 'sdio_function_deregister_interrupt';

//Host Methods
function sdio_host_dispatch_interrupt(sdhci: PSDHCI_HOST; irq, fiq: BOOL): uint32_t; stdcall; public name 'sdio_host_dispatch_interrupt';

//Driver Methods
function sdio_driver_create: PSDIO_DRIVER; stdcall; public name 'sdio_driver_create';
function sdio_driver_create_ex(size: uint32_t): PSDIO_DRIVER; stdcall; public name 'sdio_driver_create_ex';
function sdio_driver_destroy(driver: PSDIO_DRIVER): uint32_t; stdcall; public name 'sdio_driver_destroy';

function sdio_driver_register(driver: PSDIO_DRIVER): uint32_t; stdcall; public name 'sdio_driver_register';
function sdio_driver_deregister(driver: PSDIO_DRIVER): uint32_t; stdcall; public name 'sdio_driver_deregister';

function sdio_driver_find(driverid: uint32_t): PSDIO_DRIVER; stdcall; public name 'sdio_driver_find';
function sdio_driver_find_by_name(const name: PCHAR): PSDIO_DRIVER; stdcall; public name 'sdio_driver_find_by_name';
function sdio_driver_enumerate(callback: sdio_driver_enumerate_cb; data: PVOID): uint32_t; stdcall; public name 'sdio_driver_enumerate';

{==============================================================================}
{SDHCI Functions}
function sdhci_host_reset(sdhci: PSDHCI_HOST; mask: uint8_t): uint32_t; stdcall; public name 'sdhci_host_reset';
function sdhci_host_hardware_reset(sdhci: PSDHCI_HOST): uint32_t; stdcall; public name 'sdhci_host_hardware_reset';

function sdhci_host_set_power(sdhci: PSDHCI_HOST; power: uint16_t): uint32_t; stdcall; public name 'sdhci_host_set_power';
function sdhci_host_set_clock(sdhci: PSDHCI_HOST; clock: uint32_t): uint32_t; stdcall; public name 'sdhci_host_set_clock';
function sdhci_host_set_timing(sdhci: PSDHCI_HOST; timing: uint32_t): uint32_t; stdcall; public name 'sdhci_host_set_timing';
function sdhci_host_set_bus_width(sdhci: PSDHCI_HOST; buswidth: uint32_t): uint32_t; stdcall; public name 'sdhci_host_set_bus_width';

function sdhci_host_prepare_dma(sdhci: PSDHCI_HOST; command: PMMC_COMMAND): uint32_t; stdcall; public name 'sdhci_host_prepare_dma';
function sdhci_host_start_dma(sdhci: PSDHCI_HOST; command: PMMC_COMMAND): uint32_t; stdcall; public name 'sdhci_host_start_dma';
function sdhci_host_stop_dma(sdhci: PSDHCI_HOST; command: PMMC_COMMAND): uint32_t; stdcall; public name 'sdhci_host_stop_dma';
procedure sdhci_host_complete_dma(request: PDMA_REQUEST); stdcall; public name 'sdhci_host_complete_dma'; // $IFDEF i386

function sdhci_host_setup_card_irq(sdhci: PSDHCI_HOST; enable: LONGBOOL): uint32_t; stdcall; public name 'sdhci_host_setup_card_irq';
function sdhci_host_complete_card_irq(sdhci: PSDHCI_HOST): uint32_t; stdcall; public name 'sdhci_host_complete_card_irq';

function sdhci_host_transfer_pio(sdhci: PSDHCI_HOST): uint32_t; stdcall; public name 'sdhci_host_transfer_pio';
function sdhci_host_transfer_dma(sdhci: PSDHCI_HOST): uint32_t; stdcall; public name 'sdhci_host_transfer_dma';

function sdhci_host_finish_command(sdhci: PSDHCI_HOST): uint32_t; stdcall; public name 'sdhci_host_finish_command';
function sdhci_host_finish_data(sdhci: PSDHCI_HOST): uint32_t; stdcall; public name 'sdhci_host_finish_data';

function sdhci_host_command_interrupt(sdhci: PSDHCI_HOST; interruptmask: uint32_t; var returnmask: uint32_t): uint32_t; stdcall; public name 'sdhci_host_command_interrupt';
function sdhci_host_data_interrupt(sdhci: PSDHCI_HOST; interruptmask: uint32_t): uint32_t; stdcall; public name 'sdhci_host_data_interrupt';

function sdhci_host_start(sdhci: PSDHCI_HOST): uint32_t; stdcall; public name 'sdhci_host_start';
function sdhci_host_stop(sdhci: PSDHCI_HOST): uint32_t; stdcall; public name 'sdhci_host_stop';

function sdhci_host_lock(sdhci: PSDHCI_HOST): uint32_t; stdcall; public name 'sdhci_host_lock';
function sdhci_host_unlock(sdhci: PSDHCI_HOST): uint32_t; stdcall; public name 'sdhci_host_unlock';

function sdhci_host_signal(sdhci: PSDHCI_HOST; semaphore: SEMAPHORE_HANDLE): uint32_t; stdcall; public name 'sdhci_host_signal';

function sdhci_host_read_byte(sdhci: PSDHCI_HOST; reg: uint32_t): uint8_t; stdcall; public name 'sdhci_host_read_byte';
function sdhci_host_read_word(sdhci: PSDHCI_HOST; reg: uint32_t): uint16_t; stdcall; public name 'sdhci_host_read_word';
function sdhci_host_read_long(sdhci: PSDHCI_HOST; reg: uint32_t): uint32_t; stdcall; public name 'sdhci_host_read_long';
procedure sdhci_host_write_byte(sdhci: PSDHCI_HOST; reg: uint32_t; value: uint8_t); stdcall; public name 'sdhci_host_write_byte';
procedure sdhci_host_write_word(sdhci: PSDHCI_HOST; reg: uint32_t; value: uint16_t); stdcall; public name 'sdhci_host_write_word';
procedure sdhci_host_write_long(sdhci: PSDHCI_HOST; reg: uint32_t; value: uint32_t); stdcall; public name 'sdhci_host_write_long';

function sdhci_host_set_clock_divider(sdhci: PSDHCI_HOST; index: int; divider: uint32_t): uint32_t; stdcall; public name 'sdhci_host_set_clock_divider';
function sdhci_host_set_control_register(sdhci: PSDHCI_HOST): uint32_t; stdcall; public name 'sdhci_host_set_control_register';

function sdhci_host_get_adma_address(sdhci: PSDHCI_HOST): SIZE_T; stdcall; public name 'sdhci_host_get_adma_address';
procedure sdhci_host_set_adma_address(sdhci: PSDHCI_HOST; address: SIZE_T); stdcall; public name 'sdhci_host_set_adma_address';
function sdhci_host_get_sdma_address(sdhci: PSDHCI_HOST; command: PMMC_COMMAND): SIZE_T; stdcall; public name 'sdhci_host_get_sdma_address';
procedure sdhci_host_set_sdma_address(sdhci: PSDHCI_HOST; address: SIZE_T); stdcall; public name 'sdhci_host_set_sdma_address';

procedure sdhci_host_write_adma_descriptor(sdhci: PSDHCI_HOST; var descriptor: PVOID; command, len: uint16_t; address: SIZE_T); stdcall; public name 'sdhci_host_write_adma_descriptor';

function sdhci_host_create: PSDHCI_HOST; stdcall; public name 'sdhci_host_create';
function sdhci_host_create_ex(size: uint32_t): PSDHCI_HOST; stdcall; public name 'sdhci_host_create_ex';
function sdhci_host_destroy(sdhci: PSDHCI_HOST): uint32_t; stdcall; public name 'sdhci_host_destroy';

function sdhci_host_register(sdhci: PSDHCI_HOST): uint32_t; stdcall; public name 'sdhci_host_register';
function sdhci_host_deregister(sdhci: PSDHCI_HOST): uint32_t; stdcall; public name 'sdhci_host_deregister';

function sdhci_host_find(sdhciid: uint32_t): PSDHCI_HOST; stdcall; public name 'sdhci_host_find';
function sdhci_host_enumerate(callback: sdhci_enumerate_cb; data: PVOID): uint32_t; stdcall; public name 'sdhci_host_enumerate';

function sdhci_host_notification(sdhci: PSDHCI_HOST; callback: sdhci_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall; public name 'sdhci_host_notification';

{==============================================================================}
{MMC Helper Functions}
function mmc_get_count: uint32_t; stdcall; public name 'mmc_get_count';

function mmc_device_check(mmc: PMMC_DEVICE): PMMC_DEVICE; stdcall; public name 'mmc_device_check';

function mmc_is_sd(mmc: PMMC_DEVICE): BOOL; stdcall; public name 'mmc_is_sd';
function mmc_is_sdio(mmc: PMMC_DEVICE): BOOL; stdcall; public name 'mmc_is_sdio';

function mmc_get_sdhci(mmc: PMMC_DEVICE): PSDHCI_HOST; stdcall; public name 'mmc_get_sdhci';

function mmc_get_cid_value(mmc: PMMC_DEVICE; version, value: uint32_t): uint32_t; stdcall; public name 'mmc_get_cid_value';
function mmc_get_csd_value(mmc: PMMC_DEVICE; value: uint32_t): uint32_t; stdcall; public name 'mmc_get_csd_value';

function mmc_extract_bits(buffer: PVOID; start, size: uint32_t): uint32_t; stdcall; public name 'mmc_extract_bits';
function mmc_extract_bits_ex(buffer: PVOID; length, start, size: uint32_t): uint32_t; stdcall; public name 'mmc_extract_bits_ex';

function mmc_is_multi_command(command: uint16_t): BOOL; stdcall; public name 'mmc_is_multi_command';

function mmc_is_non_removable(mmc: PMMC_DEVICE): BOOL; stdcall; public name 'mmc_is_non_removable';
function mmc_has_extended_csd(mmc: PMMC_DEVICE): BOOL; stdcall; public name 'mmc_has_extended_csd';
function mmc_has_set_block_count(mmc: PMMC_DEVICE): BOOL; stdcall; public name 'mmc_has_set_block_count';
function mmc_has_auto_block_count(mmc: PMMC_DEVICE): BOOL; stdcall; public name 'mmc_has_auto_block_count';
function mmc_has_auto_command_stop(mmc: PMMC_DEVICE): BOOL; stdcall; public name 'mmc_has_auto_command_stop';

function mmc_status_to_string(status: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'mmc_status_to_string';

function mmc_version_to_string(version: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'mmc_version_to_string';
function mmc_timing_to_string(timing: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'mmc_timing_to_string';
function mmc_bus_width_to_string(buswidth: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'mmc_bus_width_to_string';
function mmc_driver_type_to_string(drivertype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'mmc_driver_type_to_string';
function mmc_signal_voltage_to_string(signalvoltage: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'mmc_signal_voltage_to_string';

function mmc_device_type_to_string(mmctype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'mmc_device_type_to_string';
function mmc_device_state_to_string(mmcstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'mmc_device_state_to_string';

function mmc_device_state_to_notification(state: uint32_t): uint32_t; stdcall; public name 'mmc_device_state_to_notification';

{==============================================================================}
{SD Helper Functions}
function sd_get_max_clock(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'sd_get_max_clock';

function sd_get_cid_value(mmc: PMMC_DEVICE; value: uint32_t): uint32_t; stdcall; public name 'sd_get_cid_value';
function sd_get_csd_value(mmc: PMMC_DEVICE; version, value: uint32_t): uint32_t; stdcall; public name 'sd_get_csd_value';
function sd_get_scr_value(mmc: PMMC_DEVICE; value: uint32_t): uint32_t; stdcall; public name 'sd_get_scr_value';
function sd_get_ssr_value(mmc: PMMC_DEVICE; value: uint32_t): uint32_t; stdcall; public name 'sd_get_ssr_value';
function sd_get_switch_value(mmc: PMMC_DEVICE; value: uint32_t): uint32_t; stdcall; public name 'sd_get_switch_value';

function sd_version_to_string(version: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'sd_version_to_string';
function sd_bus_width_to_string(buswidth: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'sd_bus_width_to_string';

{==============================================================================}
{SDIO Helper Functions}
function sdio_driver_get_count: uint32_t; stdcall; public name 'sdio_driver_get_count';

function sdio_driver_check(driver: PSDIO_DRIVER): PSDIO_DRIVER; stdcall; public name 'sdio_driver_check';

function sdio_device_get_max_clock(mmc: PMMC_DEVICE): uint32_t; stdcall; public name 'sdio_device_get_max_clock';

function sdio_function_get_mmc(func: PSDIO_FUNCTION): PMMC_DEVICE; stdcall; public name 'sdio_function_get_mmc';
function sdio_function_get_sdhci(func: PSDIO_FUNCTION): PSDHCI_HOST; stdcall; public name 'sdio_function_get_sdhci';

function sdio_version_to_string(version: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'sdio_version_to_string';

function sdio_function_state_to_string(sdiostate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'sdio_function_state_to_string';
function sdio_function_status_to_string(sdiostatus: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'sdio_function_status_to_string';

function sdio_function_state_to_notification(state: uint32_t): uint32_t; stdcall; public name 'sdio_function_state_to_notification';
function sdio_function_status_to_notification(status: uint32_t): uint32_t; stdcall; public name 'sdio_function_status_to_notification';

{==============================================================================}
{SDHCI Helper Functions}
function sdhci_get_count: uint32_t; stdcall; public name 'sdhci_get_count';

function sdhci_host_check(sdhci: PSDHCI_HOST): PSDHCI_HOST; stdcall; public name 'sdhci_host_check';

function sdhci_is_spi(sdhci: PSDHCI_HOST): BOOL; stdcall; public name 'sdhci_is_spi';
function sdhci_has_dma(sdhci: PSDHCI_HOST): BOOL; stdcall; public name 'sdhci_has_dma';
function sdhci_has_cmd23(sdhci: PSDHCI_HOST): BOOL; stdcall; public name 'sdhci_has_cmd23';
function sdhci_auto_cmd12(sdhci: PSDHCI_HOST): BOOL; stdcall; public name 'sdhci_auto_cmd12';
function sdhci_auto_cmd23(sdhci: PSDHCI_HOST): BOOL; stdcall; public name 'sdhci_auto_cmd23';

function sdhci_get_version(sdhci: PSDHCI_HOST): uint16_t; stdcall; public name 'sdhci_get_version';

function sdhci_get_command(command: uint16_t): uint16_t; stdcall; public name 'sdhci_get_command';
function sdhci_make_command(command, flags: uint16_t): uint16_t; stdcall; public name 'sdhci_make_command';
function sdhci_make_block_size(dma, blocksize: uint16_t): uint16_t; stdcall; public name 'sdhci_make_block_size';

function sdhci_version_to_string(version: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'sdhci_version_to_string';
function sdhci_power_to_string(power: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'sdhci_power_to_string';

function sdhci_device_type_to_string(sdhcitype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'sdhci_device_type_to_string';
function sdhci_host_type_to_string(sdhcitype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'sdhci_host_type_to_string';
function sdhci_device_state_to_string(sdhcistate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'sdhci_device_state_to_string';
function sdhci_host_state_to_string(sdhcistate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'sdhci_host_state_to_string';

function sdhci_host_state_to_notification(state: uint32_t): uint32_t; stdcall; public name 'sdhci_host_state_to_notification';
{$ENDIF}
{==============================================================================}
{SPI Functions}
{$IFDEF API_EXPORT_SPI}
function spi_device_start(spi: PSPI_DEVICE; mode, clockrate, clockphase, clockpolarity: uint32_t): uint32_t; stdcall; public name 'spi_device_start';
function spi_device_stop(spi: PSPI_DEVICE): uint32_t; stdcall; public name 'spi_device_stop';

function spi_device_read(spi: PSPI_DEVICE; chipselect: uint16_t; dest: PVOID; size, flags: uint32_t; var count: uint32_t): uint32_t; stdcall; public name 'spi_device_read';
function spi_device_write(spi: PSPI_DEVICE; chipselect: uint16_t; source: PVOID; size, flags: uint32_t; var count: uint32_t): uint32_t; stdcall; public name 'spi_device_write';
function spi_device_write_read(spi: PSPI_DEVICE; chipselect: uint16_t; source, dest: PVOID; size, flags: uint32_t; var count: uint32_t): uint32_t; stdcall; public name 'spi_device_write_read';

function spi_device_get_mode(spi: PSPI_DEVICE): uint32_t; stdcall; public name 'spi_device_get_mode';
function spi_device_set_mode(spi: PSPI_DEVICE; mode: uint32_t): uint32_t; stdcall; public name 'spi_device_set_mode';

function spi_device_get_clock_rate(spi: PSPI_DEVICE; chipselect: uint16_t): uint32_t; stdcall; public name 'spi_device_get_clock_rate';
function spi_device_set_clock_rate(spi: PSPI_DEVICE; chipselect: uint16_t; clockrate: uint32_t): uint32_t; stdcall; public name 'spi_device_set_clock_rate';

function spi_device_get_clock_phase(spi: PSPI_DEVICE): uint32_t; stdcall; public name 'spi_device_get_clock_phase';
function spi_device_set_clock_phase(spi: PSPI_DEVICE; clockphase: uint32_t): uint32_t; stdcall; public name 'spi_device_set_clock_phase';

function spi_device_get_clock_polarity(spi: PSPI_DEVICE): uint32_t; stdcall; public name 'spi_device_get_clock_polarity';
function spi_device_set_clock_polarity(spi: PSPI_DEVICE; clockpolarity: uint32_t): uint32_t; stdcall; public name 'spi_device_set_clock_polarity';

function spi_device_get_select_polarity(spi: PSPI_DEVICE; chipselect: uint16_t): uint32_t; stdcall; public name 'spi_device_get_select_polarity';
function spi_device_set_select_polarity(spi: PSPI_DEVICE; chipselect: uint16_t; selectpolarity: uint32_t): uint32_t; stdcall; public name 'spi_device_set_select_polarity';

function spi_device_get_byte_delay(spi: PSPI_DEVICE): uint32_t; stdcall; public name 'spi_device_get_byte_delay';
function spi_device_set_byte_delay(spi: PSPI_DEVICE; delay: uint32_t): uint32_t; stdcall; public name 'spi_device_set_byte_delay';

function spi_device_properties(spi: PSPI_DEVICE; properties: PSPI_PROPERTIES): uint32_t; stdcall; public name 'spi_device_properties';
function spi_device_get_properties(spi: PSPI_DEVICE; properties: PSPI_PROPERTIES): uint32_t; stdcall; public name 'spi_device_get_properties';

function spi_device_create: PSPI_DEVICE; stdcall; public name 'spi_device_create';
function spi_device_create_ex(size: uint32_t): PSPI_DEVICE; stdcall; public name 'spi_device_create_ex';
function spi_device_destroy(spi: PSPI_DEVICE): uint32_t; stdcall; public name 'spi_device_destroy';

function spi_device_register(spi: PSPI_DEVICE): uint32_t; stdcall; public name 'spi_device_register';
function spi_device_deregister(spi: PSPI_DEVICE): uint32_t; stdcall; public name 'spi_device_deregister';

function spi_device_find(spiid: uint32_t): PSPI_DEVICE; stdcall; public name 'spi_device_find';
function spi_device_find_by_name(const name: PCHAR): PSPI_DEVICE; stdcall; public name 'spi_device_find_by_name';
function spi_device_find_by_description(const description: PCHAR): PSPI_DEVICE; stdcall; public name 'spi_device_find_by_description';
function spi_device_enumerate(callback: spi_enumerate_cb; data: PVOID): uint32_t; stdcall; public name 'spi_device_enumerate';

function spi_device_notification(spi: PSPI_DEVICE; callback: spi_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall; public name 'spi_device_notification';

{==============================================================================}
{SPI Helper Functions}
function spi_get_count: uint32_t; stdcall; public name 'spi_get_count';
function spi_device_get_default: PSPI_DEVICE; stdcall; public name 'spi_device_get_default';
function spi_device_set_default(spi: PSPI_DEVICE): uint32_t; stdcall; public name 'spi_device_set_default';

function spi_device_check(spi: PSPI_DEVICE): PSPI_DEVICE; stdcall; public name 'spi_device_check';

function spi_type_to_string(spitype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'spi_type_to_string';
function spi_state_to_string(spistate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'spi_state_to_string';

function spi_chip_select_to_string(chipselect: uint16_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'spi_chip_select_to_string';
function spi_mode_to_string(mode: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'spi_mode_to_string';
function spi_clock_phase_to_string(phase: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'spi_clock_phase_to_string';
function spi_clock_polarity_to_string(polarity: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'spi_clock_polarity_to_string';
function spi_select_polarity_to_string(polarity: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'spi_select_polarity_to_string';
{$ENDIF}
{==============================================================================}
{I2C Functions}
{$IFDEF API_EXPORT_I2C}
function i2c_device_start(i2c: PI2C_DEVICE; rate: uint32_t): uint32_t; stdcall; public name 'i2c_device_start';
function i2c_device_stop(i2c: PI2C_DEVICE): uint32_t; stdcall; public name 'i2c_device_stop';

function i2c_device_read(i2c: PI2C_DEVICE; address: uint16_t; buffer: PVOID; size: uint32_t; var count: uint32_t): uint32_t; stdcall; public name 'i2c_device_read';
function i2c_device_write(i2c: PI2C_DEVICE; address: uint16_t; buffer: PVOID; size: uint32_t; var count: uint32_t): uint32_t; stdcall; public name 'i2c_device_write';
function i2c_device_write_read(i2c: PI2C_DEVICE; address: uint16_t; initial: PVOID; len: uint32_t; data: PVOID; size: uint32_t; var count: uint32_t): uint32_t; stdcall; public name 'i2c_device_write_read';
function i2c_device_write_write(i2c: PI2C_DEVICE; address: uint16_t; initial: PVOID; len: uint32_t; data: PVOID; size: uint32_t; var count: uint32_t): uint32_t; stdcall; public name 'i2c_device_write_write';

function i2c_device_get_rate(i2c: PI2C_DEVICE): uint32_t; stdcall; public name 'i2c_device_get_rate';
function i2c_device_set_rate(i2c: PI2C_DEVICE; rate: uint32_t): uint32_t; stdcall; public name 'i2c_device_set_rate';

function i2c_device_get_address(i2c: PI2C_DEVICE): uint16_t; stdcall; public name 'i2c_device_get_address';
function i2c_device_set_address(i2c: PI2C_DEVICE; address: uint16_t): uint32_t; stdcall; public name 'i2c_device_set_address';

function i2c_device_properties(i2c: PI2C_DEVICE; properties: PI2C_PROPERTIES): uint32_t; stdcall; public name 'i2c_device_properties';
function i2c_device_get_properties(i2c: PI2C_DEVICE; properties: PI2C_PROPERTIES): uint32_t; stdcall; public name 'i2c_device_get_properties';

function i2c_device_create: PI2C_DEVICE; stdcall; public name 'i2c_device_create';
function i2c_device_create_ex(size: uint32_t): PI2C_DEVICE; stdcall; public name 'i2c_device_create_ex';
function i2c_device_destroy(i2c: PI2C_DEVICE): uint32_t; stdcall; public name 'i2c_device_destroy';

function i2c_device_register(i2c: PI2C_DEVICE): uint32_t; stdcall; public name 'i2c_device_register';
function i2c_device_deregister(i2c: PI2C_DEVICE): uint32_t; stdcall; public name 'i2c_device_deregister';

function i2c_device_find(i2cid: uint32_t): PI2C_DEVICE; stdcall; public name 'i2c_device_find';
function i2c_device_find_by_name(const name: PCHAR): PI2C_DEVICE; stdcall; public name 'i2c_device_find_by_name';
function i2c_device_find_by_description(const description: PCHAR): PI2C_DEVICE; stdcall; public name 'i2c_device_find_by_description';
function i2c_device_enumerate(callback: i2c_enumerate_cb; data: PVOID): uint32_t; stdcall; public name 'i2c_device_enumerate';

function i2c_device_notification(i2c: PI2C_DEVICE; callback: i2c_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall; public name 'i2c_device_notification';

{==============================================================================}
{I2C Slave Functions}
function i2c_slave_start(i2c: PI2C_DEVICE): uint32_t; stdcall; public name 'i2c_slave_start';
function i2c_slave_stop(i2c: PI2C_DEVICE): uint32_t; stdcall; public name 'i2c_slave_stop';

function i2c_slave_read(i2c: PI2C_DEVICE; buffer: PVOID; size: uint32_t; var count: uint32_t): uint32_t; stdcall; public name 'i2c_slave_read';
function i2c_slave_write(i2c: PI2C_DEVICE; buffer: PVOID; size: uint32_t; var count: uint32_t): uint32_t; stdcall; public name 'i2c_slave_write';

function i2c_slave_get_address(i2c: PI2C_DEVICE): uint16_t; stdcall; public name 'i2c_slave_get_address';
function i2c_slave_set_address(i2c: PI2C_DEVICE; address: uint16_t): uint32_t; stdcall; public name 'i2c_slave_set_address';

function i2c_slave_get_properties(i2c: PI2C_DEVICE; properties: PI2C_PROPERTIES): uint32_t; stdcall; public name 'i2c_slave_get_properties';

function i2c_slave_create: PI2C_DEVICE; stdcall; public name 'i2c_slave_create';
function i2c_slave_create_ex(size: uint32_t): PI2C_DEVICE; stdcall; public name 'i2c_slave_create_ex';
function i2c_slave_destroy(i2c: PI2C_DEVICE): uint32_t; stdcall; public name 'i2c_slave_destroy';

function i2c_slave_register(i2c: PI2C_DEVICE): uint32_t; stdcall; public name 'i2c_slave_register';
function i2c_slave_deregister(i2c: PI2C_DEVICE): uint32_t; stdcall; public name 'i2c_slave_deregister';

function i2c_slave_find(i2cid: uint32_t): PI2C_DEVICE; stdcall; public name 'i2c_slave_find';
function i2c_slave_find_by_name(const name: PCHAR): PI2C_DEVICE; stdcall; public name 'i2c_slave_find_by_name';
function i2c_slave_find_by_description(const description: PCHAR): PI2C_DEVICE; stdcall; public name 'i2c_slave_find_by_description';

{==============================================================================}
{I2C Helper Functions}
function i2c_get_count: uint32_t; stdcall; public name 'i2c_get_count';
function i2c_device_get_default: PI2C_DEVICE; stdcall; public name 'i2c_device_get_default';
function i2c_device_set_default(i2c: PI2C_DEVICE): uint32_t; stdcall; public name 'i2c_device_set_default';

function i2c_device_check(i2c: PI2C_DEVICE): PI2C_DEVICE; stdcall; public name 'i2c_device_check';

function i2c_device_is_slave(i2c: PI2C_DEVICE): BOOL; stdcall; public name 'i2c_device_is_slave';

function i2c_type_to_string(i2ctype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'i2c_type_to_string';
function i2c_state_to_string(i2cstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'i2c_state_to_string';

function i2c_is7bit_address(address: uint16_t): BOOL; stdcall; public name 'i2c_is7bit_address';
function i2c_is10bit_address(address: uint16_t): BOOL; stdcall; public name 'i2c_is10bit_address';
{$ENDIF}
{==============================================================================}
{PWM Functions}
{$IFDEF API_EXPORT_PWM}
function pwm_device_start(pwm: PPWM_DEVICE): uint32_t; stdcall; public name 'pwm_device_start';
function pwm_device_stop(pwm: PPWM_DEVICE): uint32_t; stdcall; public name 'pwm_device_stop';

function pwm_device_write(pwm: PPWM_DEVICE; value: uint32_t): uint32_t; stdcall; public name 'pwm_device_write';

function pwm_device_get_gpio(pwm: PPWM_DEVICE): uint32_t; stdcall; public name 'pwm_device_get_gpio';
function pwm_device_set_gpio(pwm: PPWM_DEVICE; gpio: uint32_t): uint32_t; stdcall; public name 'pwm_device_set_gpio';
function pwm_device_get_mode(pwm: PPWM_DEVICE): uint32_t; stdcall; public name 'pwm_device_get_mode';
function pwm_device_set_mode(pwm: PPWM_DEVICE; mode: uint32_t): uint32_t; stdcall; public name 'pwm_device_set_mode';
function pwm_device_get_range(pwm: PPWM_DEVICE): uint32_t; stdcall; public name 'pwm_device_get_range';
function pwm_device_set_range(pwm: PPWM_DEVICE; range: uint32_t): uint32_t; stdcall; public name 'pwm_device_set_range';
function pwm_device_get_frequency(pwm: PPWM_DEVICE): uint32_t; stdcall; public name 'pwm_device_get_frequency';
function pwm_device_set_frequency(pwm: PPWM_DEVICE; frequency: uint32_t): uint32_t; stdcall; public name 'pwm_device_set_frequency';
function pwm_device_get_polarity(pwm: PPWM_DEVICE): uint32_t; stdcall; public name 'pwm_device_get_polarity';
function pwm_device_set_polarity(pwm: PPWM_DEVICE; polarity: uint32_t): uint32_t; stdcall; public name 'pwm_device_set_polarity';

function pwm_device_configure(pwm: PPWM_DEVICE; dutyns, periodns: uint32_t): uint32_t; stdcall; public name 'pwm_device_configure';

function pwm_device_properties(pwm: PPWM_DEVICE; properties: PPWM_PROPERTIES): uint32_t; stdcall; public name 'pwm_device_properties';
function pwm_device_get_properties(pwm: PPWM_DEVICE; properties: PPWM_PROPERTIES): uint32_t; stdcall; public name 'pwm_device_get_properties';

function pwm_device_create: PPWM_DEVICE; stdcall; public name 'pwm_device_create';
function pwm_device_create_ex(size: uint32_t): PPWM_DEVICE; stdcall; public name 'pwm_device_create_ex';
function pwm_device_destroy(pwm: PPWM_DEVICE): uint32_t; stdcall; public name 'pwm_device_destroy';

function pwm_device_register(pwm: PPWM_DEVICE): uint32_t; stdcall; public name 'pwm_device_register';
function pwm_device_deregister(pwm: PPWM_DEVICE): uint32_t; stdcall; public name 'pwm_device_deregister';

function pwm_device_find(pwmid: uint32_t): PPWM_DEVICE; stdcall; public name 'pwm_device_find';
function pwm_device_find_by_name(const name: PCHAR): PPWM_DEVICE; stdcall; public name 'pwm_device_find_by_name';
function pwm_device_find_by_description(const description: PCHAR): PPWM_DEVICE; stdcall; public name 'pwm_device_find_by_description';
function pwm_device_enumerate(callback: pwm_enumerate_cb; data: PVOID): uint32_t; stdcall; public name 'pwm_device_enumerate';

function pwm_device_notification(pwm: PPWM_DEVICE; callback: pwm_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall; public name 'pwm_device_notification';

{==============================================================================}
{PWM Helper Functions}
function pwm_get_count: uint32_t; stdcall; public name 'pwm_get_count';
function pwm_device_get_default: PPWM_DEVICE; stdcall; public name 'pwm_device_get_default';
function pwm_device_set_default(pwm: PPWM_DEVICE): uint32_t; stdcall; public name 'pwm_device_set_default';

function pwm_device_check(pwm: PPWM_DEVICE): PPWM_DEVICE; stdcall; public name 'pwm_device_check';

function pwm_type_to_string(pwmtype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'pwm_type_to_string';
function pwm_state_to_string(pwmstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'pwm_state_to_string';
function pwm_mode_to_string(pwmmode: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'pwm_mode_to_string';
function pwm_polarity_to_string(pwmpolarity: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'pwm_polarity_to_string';
{$ENDIF}
{==============================================================================}
{PCM (I2S) Functions}
{$IFDEF API_EXPORT_PCM}
//To Do
{==============================================================================}
{PCM (I2S) Helper Functions}
//To Do
{$ENDIF}
{==============================================================================}
{GPIO Functions}
{$IFDEF API_EXPORT_GPIO}
function gpio_device_start(gpio: PGPIO_DEVICE): uint32_t; stdcall; public name 'gpio_device_start';
function gpio_device_stop(gpio: PGPIO_DEVICE): uint32_t; stdcall; public name 'gpio_device_stop';

function gpio_device_read(gpio: PGPIO_DEVICE; reg: uint32_t): uint32_t; stdcall; public name 'gpio_device_read';
procedure gpio_device_write(gpio: PGPIO_DEVICE; reg, value: uint32_t); stdcall; public name 'gpio_device_write';

function gpio_device_input_get(gpio: PGPIO_DEVICE; pin: uint32_t): uint32_t; stdcall; public name 'gpio_device_input_get';
function gpio_device_input_wait(gpio: PGPIO_DEVICE; pin, trigger, timeout: uint32_t): uint32_t; stdcall; public name 'gpio_device_input_wait';
function gpio_device_input_event(gpio: PGPIO_DEVICE; pin, trigger, flags, timeout: uint32_t; callback: gpio_event_cb; data: PVOID): uint32_t; stdcall; public name 'gpio_device_input_event';
function gpio_device_input_cancel(gpio: PGPIO_DEVICE; pin: uint32_t): uint32_t; stdcall; public name 'gpio_device_input_cancel';

function gpio_device_output_set(gpio: PGPIO_DEVICE; pin, level: uint32_t): uint32_t; stdcall; public name 'gpio_device_output_set';

function gpio_device_level_get(gpio: PGPIO_DEVICE; pin: uint32_t): uint32_t; stdcall; public name 'gpio_device_level_get';
function gpio_device_level_set(gpio: PGPIO_DEVICE; pin, level: uint32_t): uint32_t; stdcall; public name 'gpio_device_level_set';

function gpio_device_pull_get(gpio: PGPIO_DEVICE; pin: uint32_t): uint32_t; stdcall; public name 'gpio_device_pull_get';
function gpio_device_pull_select(gpio: PGPIO_DEVICE; pin, mode: uint32_t): uint32_t; stdcall; public name 'gpio_device_pull_select';

function gpio_device_function_get(gpio: PGPIO_DEVICE; pin: uint32_t): uint32_t; stdcall; public name 'gpio_device_function_get';
function gpio_device_function_select(gpio: PGPIO_DEVICE; pin, mode: uint32_t): uint32_t; stdcall; public name 'gpio_device_function_select';

function gpio_device_properties(gpio: PGPIO_DEVICE; properties: PGPIO_PROPERTIES): uint32_t; stdcall; public name 'gpio_device_properties';
function gpio_device_get_properties(gpio: PGPIO_DEVICE; properties: PGPIO_PROPERTIES): uint32_t; stdcall; public name 'gpio_device_get_properties';

function gpio_device_create: PGPIO_DEVICE; stdcall; public name 'gpio_device_create';
function gpio_device_create_ex(size: uint32_t): PGPIO_DEVICE; stdcall; public name 'gpio_device_create_ex';
function gpio_device_destroy(gpio: PGPIO_DEVICE): uint32_t; stdcall; public name 'gpio_device_destroy';

function gpio_device_register(gpio: PGPIO_DEVICE): uint32_t; stdcall; public name 'gpio_device_register';
function gpio_device_deregister(gpio: PGPIO_DEVICE): uint32_t; stdcall; public name 'gpio_device_deregister';

function gpio_device_find(gpioid: uint32_t): PGPIO_DEVICE; stdcall; public name 'gpio_device_find';
function gpio_device_find_by_name(const name: PCHAR): PGPIO_DEVICE; stdcall; public name 'gpio_device_find_by_name';
function gpio_device_find_by_description(const description: PCHAR): PGPIO_DEVICE; stdcall; public name 'gpio_device_find_by_description';
function gpio_device_enumerate(callback: gpio_enumerate_cb; data: PVOID): uint32_t; stdcall; public name 'gpio_device_enumerate';

function gpio_device_notification(gpio: PGPIO_DEVICE; callback: gpio_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall; public name 'gpio_device_notification';

{==============================================================================}
{GPIO Helper Functions}
function gpio_get_count: uint32_t; stdcall; public name 'gpio_get_count';
function gpio_device_get_default: PGPIO_DEVICE; stdcall; public name 'gpio_device_get_default';
function gpio_device_set_default(gpio: PGPIO_DEVICE): uint32_t; stdcall; public name 'gpio_device_set_default';

function gpio_device_check(gpio: PGPIO_DEVICE): PGPIO_DEVICE; stdcall; public name 'gpio_device_check';

function gpio_type_to_string(gpiotype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'gpio_type_to_string';
function gpio_state_to_string(gpiostate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'gpio_state_to_string';

function gpio_device_create_event(gpio: PGPIO_DEVICE; pin: PGPIO_PIN; callback: gpio_event_cb; data: PVOID; timeout: uint32_t): PGPIO_EVENT; stdcall; public name 'gpio_device_create_event';
function gpio_device_destroy_event(gpio: PGPIO_DEVICE; event: PGPIO_EVENT): uint32_t; stdcall; public name 'gpio_device_destroy_event';

function gpio_device_register_event(gpio: PGPIO_DEVICE; pin: PGPIO_PIN; event: PGPIO_EVENT): uint32_t; stdcall; public name 'gpio_device_register_event';
function gpio_device_deregister_event(gpio: PGPIO_DEVICE; pin: PGPIO_PIN; event: PGPIO_EVENT): uint32_t; stdcall; public name 'gpio_device_deregister_event';

function gpio_pin_to_string(pin: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'gpio_pin_to_string';
function gpio_level_to_string(level: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'gpio_level_to_string';
function gpio_trigger_to_string(trigger: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'gpio_trigger_to_string';

function gpio_pull_to_string(value: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'gpio_pull_to_string';
function gpio_function_to_string(value: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'gpio_function_to_string';
{$ENDIF}
{==============================================================================}
{UART Functions}
{$IFDEF API_EXPORT_UART}
function uart_device_open(uart: PUART_DEVICE; baudrate, databits, stopbits, parity, flowcontrol: uint32_t): uint32_t; stdcall; public name 'uart_device_open';
function uart_device_close(uart: PUART_DEVICE): uint32_t; stdcall; public name 'uart_device_close';

function uart_device_read(uart: PUART_DEVICE; buffer: PVOID; size, flags: uint32_t; var count: uint32_t): uint32_t; stdcall; public name 'uart_device_read';
function uart_device_write(uart: PUART_DEVICE; buffer: PVOID; size, flags: uint32_t; var count: uint32_t): uint32_t; stdcall; public name 'uart_device_write';

function uart_device_wait(uart: PUART_DEVICE; direction, timeout: uint32_t): uint32_t; stdcall; public name 'uart_device_wait';

function uart_device_status(uart: PUART_DEVICE): uint32_t; stdcall; public name 'uart_device_status';
function uart_device_get_status(uart: PUART_DEVICE): uint32_t; stdcall; public name 'uart_device_get_status';
function uart_device_set_status(uart: PUART_DEVICE; status: uint32_t): uint32_t; stdcall; public name 'uart_device_set_status';

function uart_device_properties(uart: PUART_DEVICE; properties: PUART_PROPERTIES): uint32_t; stdcall; public name 'uart_device_properties';
function uart_device_get_properties(uart: PUART_DEVICE; properties: PUART_PROPERTIES): uint32_t; stdcall; public name 'uart_device_get_properties';
function uart_device_set_properties(uart: PUART_DEVICE; properties: PUART_PROPERTIES): uint32_t; stdcall; public name 'uart_device_set_properties';

function uart_device_create: PUART_DEVICE; stdcall; public name 'uart_device_create';
function uart_device_create_ex(size: uint32_t): PUART_DEVICE; stdcall; public name 'uart_device_create_ex';
function uart_device_destroy(uart: PUART_DEVICE): uint32_t; stdcall; public name 'uart_device_destroy';

function uart_device_register(uart: PUART_DEVICE): uint32_t; stdcall; public name 'uart_device_register';
function uart_device_deregister(uart: PUART_DEVICE): uint32_t; stdcall; public name 'uart_device_deregister';

function uart_device_find(uartid: uint32_t): PUART_DEVICE; stdcall; public name 'uart_device_find';
function uart_device_find_by_name(const name: PCHAR): PUART_DEVICE; stdcall; public name 'uart_device_find_by_name';
function uart_device_find_by_description(const description: PCHAR): PUART_DEVICE; stdcall; public name 'uart_device_find_by_description';
function uart_device_enumerate(callback: uart_enumerate_cb; data: PVOID): uint32_t; stdcall; public name 'uart_device_enumerate';

function uart_device_notification(uart: PUART_DEVICE; callback: uart_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall; public name 'uart_device_notification';

{==============================================================================}
{UART Helper Functions}
function uart_get_count: uint32_t; stdcall; public name 'uart_get_count';
function uart_device_get_default: PUART_DEVICE; stdcall; public name 'uart_device_get_default';
function uart_device_set_default(uart: PUART_DEVICE): uint32_t; stdcall; public name 'uart_device_set_default';

function uart_device_check(uart: PUART_DEVICE): PUART_DEVICE; stdcall; public name 'uart_device_check';

function uart_type_to_string(uarttype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'uart_type_to_string';
function uart_mode_to_string(uartmode: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'uart_mode_to_string';
function uart_state_to_string(uartstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'uart_state_to_string';

{==============================================================================}
{UART Serial Helper Functions}
function uart_serial_device_receive(uart: PUART_DEVICE): uint32_t; stdcall; public name 'uart_serial_device_receive';
function uart_serial_device_transmit(uart: PUART_DEVICE): uint32_t; stdcall; public name 'uart_serial_device_transmit';
{$ENDIF}
{==============================================================================}
{Serial Functions}
{$IFDEF API_EXPORT_SERIAL}
function serial_device_open(serial: PSERIAL_DEVICE; baudrate, databits, stopbits, parity, flowcontrol, receivedepth, transmitdepth: uint32_t): uint32_t; stdcall; public name 'serial_device_open';
function serial_device_close(serial: PSERIAL_DEVICE): uint32_t; stdcall; public name 'serial_device_close';

function serial_device_read(serial: PSERIAL_DEVICE; buffer: PVOID; size, flags: uint32_t; var count: uint32_t): uint32_t; stdcall; public name 'serial_device_read';
function serial_device_write(serial: PSERIAL_DEVICE; buffer: PVOID; size, flags: uint32_t; var count: uint32_t): uint32_t; stdcall; public name 'serial_device_write';

function serial_device_wait(serial: PSERIAL_DEVICE; direction, timeout: uint32_t; var count: uint32_t): uint32_t; stdcall; public name 'serial_device_wait';
function serial_device_flush(serial: PSERIAL_DEVICE; flags: uint32_t): uint32_t; stdcall; public name 'serial_device_flush';

function serial_device_status(serial: PSERIAL_DEVICE): uint32_t; stdcall; public name 'serial_device_status';
function serial_device_get_status(serial: PSERIAL_DEVICE): uint32_t; stdcall; public name 'serial_device_get_status';
function serial_device_set_status(serial: PSERIAL_DEVICE; status: uint32_t): uint32_t; stdcall; public name 'serial_device_set_status';

function serial_device_properties(serial: PSERIAL_DEVICE; properties: PSERIAL_PROPERTIES): uint32_t; stdcall; public name 'serial_device_properties';
function serial_device_get_properties(serial: PSERIAL_DEVICE; properties: PSERIAL_PROPERTIES): uint32_t; stdcall; public name 'serial_device_get_properties';
function serial_device_set_properties(serial: PSERIAL_DEVICE; properties: PSERIAL_PROPERTIES): uint32_t; stdcall; public name 'serial_device_set_properties';

function serial_device_create: PSERIAL_DEVICE; stdcall; public name 'serial_device_create';
function serial_device_create_ex(size: uint32_t): PSERIAL_DEVICE; stdcall; public name 'serial_device_create_ex';
function serial_device_destroy(serial: PSERIAL_DEVICE): uint32_t; stdcall; public name 'serial_device_destroy';

function serial_device_register(serial: PSERIAL_DEVICE): uint32_t; stdcall; public name 'serial_device_register';
function serial_device_deregister(serial: PSERIAL_DEVICE): uint32_t; stdcall; public name 'serial_device_deregister';

function serial_device_find(serialid: uint32_t): PSERIAL_DEVICE; stdcall; public name 'serial_device_find';
function serial_device_find_by_name(const name: PCHAR): PSERIAL_DEVICE; stdcall; public name 'serial_device_find_by_name';
function serial_device_find_by_description(const description: PCHAR): PSERIAL_DEVICE; stdcall; public name 'serial_device_find_by_description';
function serial_device_enumerate(callback: serial_enumerate_cb; data: PVOID): uint32_t; stdcall; public name 'serial_device_enumerate';

function serial_device_notification(serial: PSERIAL_DEVICE; callback: serial_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall; public name 'serial_device_notification';

{==============================================================================}
{Serial Helper Functions}
function serial_get_count: uint32_t; stdcall; public name 'serial_get_count';

function serial_device_get_default: PSERIAL_DEVICE; stdcall; public name 'serial_device_get_default';
function serial_device_set_default(serial: PSERIAL_DEVICE): uint32_t; stdcall; public name 'serial_device_set_default';

function serial_device_check(serial: PSERIAL_DEVICE): PSERIAL_DEVICE; stdcall; public name 'serial_device_check';

function serial_type_to_string(serialtype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'serial_type_to_string';
function serial_state_to_string(serialstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'serial_state_to_string';

function serial_device_redirect_input(serial: PSERIAL_DEVICE): BOOL; stdcall; public name 'serial_device_redirect_input';
function serial_device_redirect_output(serial: PSERIAL_DEVICE): BOOL; stdcall; public name 'serial_device_redirect_output';

function serial_buffer_read_start(buffer: PSERIAL_BUFFER; var available: uint32_t): PVOID; stdcall; public name 'serial_buffer_read_start';
function serial_buffer_read_complete(buffer: PSERIAL_BUFFER; removed: uint32_t): BOOL; stdcall; public name 'serial_buffer_read_complete';

function serial_buffer_write_start(buffer: PSERIAL_BUFFER; var available: uint32_t): PVOID; stdcall; public name 'serial_buffer_write_start';
function serial_buffer_write_complete(buffer: PSERIAL_BUFFER; added: uint32_t): BOOL; stdcall; public name 'serial_buffer_write_complete';

function serial_data_bits_to_string(bits: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'serial_data_bits_to_string';
function serial_stop_bits_to_string(bits: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'serial_stop_bits_to_string';
function serial_parity_to_string(parity: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'serial_parity_to_string';
function serial_flow_control_to_string(flow: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'serial_flow_control_to_string';

{==============================================================================}
{Serial Logging Helper Functions}
function serial_logging_device_add(serial: PSERIAL_DEVICE): uint32_t; stdcall; public name 'serial_logging_device_add';
function serial_logging_device_remove(serial: PSERIAL_DEVICE): uint32_t; stdcall; public name 'serial_logging_device_remove';
function serial_logging_device_parameters(serial: PSERIAL_DEVICE; const parameters: PCHAR; var baudrate, parity, databits, stopbits: uint32_t): uint32_t; stdcall; public name 'serial_logging_device_parameters';
{$ENDIF}
{==============================================================================}
{RTC Functions}
{$IFDEF API_EXPORT_RTC}
function rtc_device_start(rtc: PRTC_DEVICE): uint32_t; stdcall; public name 'rtc_device_start';
function rtc_device_stop(rtc: PRTC_DEVICE): uint32_t; stdcall; public name 'rtc_device_stop';

function rtc_device_get_time(rtc: PRTC_DEVICE): int64_t; stdcall; public name 'rtc_device_get_time';
function rtc_device_set_time(rtc: PRTC_DEVICE; const time: int64_t): int64_t; stdcall; public name 'rtc_device_set_time';

function rtc_device_properties(rtc: PRTC_DEVICE; properties: PRTC_PROPERTIES): uint32_t; stdcall; public name 'rtc_device_properties';
function rtc_device_get_properties(rtc: PRTC_DEVICE; properties: PRTC_PROPERTIES): uint32_t; stdcall; public name 'rtc_device_get_properties';

function rtc_device_create: PRTC_DEVICE; stdcall; public name 'rtc_device_create';
function rtc_device_create_ex(size: uint32_t): PRTC_DEVICE; stdcall; public name 'rtc_device_create_ex';
function rtc_device_destroy(rtc: PRTC_DEVICE): uint32_t; stdcall; public name 'rtc_device_destroy';

function rtc_device_register(rtc: PRTC_DEVICE): uint32_t; stdcall; public name 'rtc_device_register';
function rtc_device_deregister(rtc: PRTC_DEVICE): uint32_t; stdcall; public name 'rtc_device_deregister';

function rtc_device_find(rtcid: uint32_t): PRTC_DEVICE; stdcall; public name 'rtc_device_find';
function rtc_device_find_by_name(const name: PCHAR): PRTC_DEVICE; stdcall; public name 'rtc_device_find_by_name';
function rtc_device_find_by_description(const description: PCHAR): PRTC_DEVICE; stdcall; public name 'rtc_device_find_by_description';
function rtc_device_enumerate(callback: rtc_enumerate_cb; data: PVOID): uint32_t; stdcall; public name 'rtc_device_enumerate';

function rtc_device_notification(rtc: PRTC_DEVICE; callback: rtc_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall; public name 'rtc_device_notification';

{==============================================================================}
{RTC Helper Functions}
function rtc_get_count: uint32_t; stdcall; public name 'rtc_get_count';
function rtc_device_get_default: PRTC_DEVICE; stdcall; public name 'rtc_device_get_default';
function rtc_device_set_default(rtc: PRTC_DEVICE): uint32_t; stdcall; public name 'rtc_device_set_default';

function rtc_device_check(rtc: PRTC_DEVICE): PRTC_DEVICE; stdcall; public name 'rtc_device_check';

function rtc_device_type_to_string(rtctype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'rtc_device_type_to_string';
function rtc_device_state_to_string(rtcstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'rtc_device_state_to_string';

function rtc_time_is_valid(const time: SYSTEMTIME): BOOL; stdcall; public name 'rtc_time_is_valid';

function rtc_systemtime_to_filetime(const systemtime: SYSTEMTIME; var filetime: int64_t): BOOL; stdcall; public name 'rtc_systemtime_to_filetime';
function rtc_filetime_to_systemtime(const filetime: int64_t; var systemtime: SYSTEMTIME): BOOL; stdcall; public name 'rtc_filetime_to_systemtime';
{$ENDIF}
{==============================================================================}
{Font Functions}
{$IFDEF API_EXPORT_FONT}
function font_load(header: PFONT_HEADER; data: PFONT_DATA; size: uint32_t): FONT_HANDLE; stdcall; public name 'font_load';
function font_load_ex(header: PFONT_HEADER; data: PFONT_DATA; unicode: PFONT_UNICODE; size: uint32_t; properties: PFONT_PROPERTIES): FONT_HANDLE; stdcall; public name 'font_load_ex';
function font_unload(handle: FONT_HANDLE): uint32_t; stdcall; public name 'font_unload';

function font_get_name(handle: FONT_HANDLE; name: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'font_get_name';
function font_get_description(handle: FONT_HANDLE; description: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'font_get_description';

function font_get_width(handle: FONT_HANDLE): uint32_t; stdcall; public name 'font_get_width';
function font_get_height(handle: FONT_HANDLE): uint32_t; stdcall; public name 'font_get_height';

function font_get_properties(handle: FONT_HANDLE; properties: PFONT_PROPERTIES): uint32_t; stdcall; public name 'font_get_properties';

function font_char_width(handle: FONT_HANDLE; character: uint16_t): uint32_t; stdcall; public name 'font_char_width';
function font_char_height(handle: FONT_HANDLE; character: uint16_t): uint32_t; stdcall; public name 'font_char_height';

function font_text_width(handle: FONT_HANDLE; const text: PCHAR): uint32_t; stdcall; public name 'font_text_width';
function font_text_height(handle: FONT_HANDLE; const text: PCHAR): uint32_t; stdcall; public name 'font_text_height';

function font_find_by_name(const name: PCHAR): FONT_HANDLE; stdcall; public name 'font_find_by_name';
function font_find_by_description(const description: PCHAR): FONT_HANDLE; stdcall; public name 'font_find_by_description';
function font_enumerate(callback: font_enumerate_cb; data: PVOID): uint32_t; stdcall; public name 'font_enumerate';

{==============================================================================}
{PSF Font Functions}
function psf_font_load(const filename: PCHAR): FONT_HANDLE; stdcall; public name 'psf_font_load';
function psf_font_load_ex(data: PVOID; size: uint32_t): FONT_HANDLE; stdcall; public name 'psf_font_load_ex';

{==============================================================================}
{Font Helper Functions}
function font_get_count: uint32_t; stdcall; public name 'font_get_count';
function font_get_default: FONT_HANDLE; stdcall; public name 'font_get_default';
function font_set_default(handle: FONT_HANDLE): uint32_t; stdcall; public name 'font_set_default';

function font_check(font: PFONT_ENTRY): PFONT_ENTRY; stdcall; public name 'font_check';
{$ENDIF}
{==============================================================================}
{Framebuffer Functions}
{$IFDEF API_EXPORT_FRAMEBUFFER}
function framebuffer_device_allocate(framebuffer: PFRAMEBUFFER_DEVICE; properties: PFRAMEBUFFER_PROPERTIES): uint32_t; stdcall; public name 'framebuffer_device_allocate';
function framebuffer_device_release(framebuffer: PFRAMEBUFFER_DEVICE): uint32_t; stdcall; public name 'framebuffer_device_release';

function framebuffer_device_blank(framebuffer: PFRAMEBUFFER_DEVICE; blank: BOOL): uint32_t; stdcall; public name 'framebuffer_device_blank';

function framebuffer_device_read(framebuffer: PFRAMEBUFFER_DEVICE; x, y: uint32_t; buffer: PVOID; len, flags: uint32_t): uint32_t; stdcall; public name 'framebuffer_device_read';
function framebuffer_device_write(framebuffer: PFRAMEBUFFER_DEVICE; x, y: uint32_t; buffer: PVOID; len, flags: uint32_t): uint32_t; stdcall; public name 'framebuffer_device_write';

function framebuffer_device_mark(framebuffer: PFRAMEBUFFER_DEVICE; x, y, width, height, flags: uint32_t): uint32_t; stdcall; public name 'framebuffer_device_mark';
function framebuffer_device_commit(framebuffer: PFRAMEBUFFER_DEVICE; address: SIZE_T; size, flags: uint32_t): uint32_t; stdcall; public name 'framebuffer_device_commit';

function framebuffer_device_get_rect(framebuffer: PFRAMEBUFFER_DEVICE; x, y: uint32_t; buffer: PVOID; width, height, skip, flags: uint32_t): uint32_t; stdcall; public name 'framebuffer_device_get_rect';
function framebuffer_device_put_rect(framebuffer: PFRAMEBUFFER_DEVICE; x, y: uint32_t; buffer: PVOID; width, height, skip, flags: uint32_t): uint32_t; stdcall; public name 'framebuffer_device_put_rect';
function framebuffer_device_copy_rect(framebuffer: PFRAMEBUFFER_DEVICE; x1, y1, x2, y2, width, height, flags: uint32_t): uint32_t; stdcall; public name 'framebuffer_device_copy_rect';
function framebuffer_device_fill_rect(framebuffer: PFRAMEBUFFER_DEVICE; x, y, width, height, color, flags: uint32_t): uint32_t; stdcall; public name 'framebuffer_device_fill_rect';

function framebuffer_device_get_line(framebuffer: PFRAMEBUFFER_DEVICE; y: uint32_t): PVOID; stdcall; public name 'framebuffer_device_get_line';
function framebuffer_device_get_point(framebuffer: PFRAMEBUFFER_DEVICE; x, y: uint32_t): PVOID; stdcall; public name 'framebuffer_device_get_point';

function framebuffer_device_wait_sync(framebuffer: PFRAMEBUFFER_DEVICE): uint32_t; stdcall; public name 'framebuffer_device_wait_sync';

function framebuffer_device_get_offset(framebuffer: PFRAMEBUFFER_DEVICE; var x, y: uint32_t): uint32_t; stdcall; public name 'framebuffer_device_get_offset';
function framebuffer_device_set_offset(framebuffer: PFRAMEBUFFER_DEVICE; x, y: uint32_t; pan: BOOL): uint32_t; stdcall; public name 'framebuffer_device_set_offset';
function framebuffer_device_set_offset_ex(framebuffer: PFRAMEBUFFER_DEVICE; x, y: uint32_t; pan, switch: BOOL): uint32_t; stdcall; public name 'framebuffer_device_set_offset_ex';

function framebuffer_device_get_palette(framebuffer: PFRAMEBUFFER_DEVICE; palette: PFRAMEBUFFER_PALETTE): uint32_t; stdcall; public name 'framebuffer_device_get_palette';
function framebuffer_device_set_palette(framebuffer: PFRAMEBUFFER_DEVICE; palette: PFRAMEBUFFER_PALETTE): uint32_t; stdcall; public name 'framebuffer_device_set_palette';

function framebuffer_device_set_backlight(framebuffer: PFRAMEBUFFER_DEVICE; brightness: uint32_t): uint32_t; stdcall; public name 'framebuffer_device_set_backlight';

function framebuffer_device_set_cursor(framebuffer: PFRAMEBUFFER_DEVICE; width, height, hotspotx, hotspoty: uint32_t; image: PVOID; len: uint32_t): uint32_t; stdcall; public name 'framebuffer_device_set_cursor';
function framebuffer_device_update_cursor(framebuffer: PFRAMEBUFFER_DEVICE; enabled: BOOL; x, y: int32_t; relative: BOOL): uint32_t; stdcall; public name 'framebuffer_device_update_cursor';

function framebuffer_device_get_properties(framebuffer: PFRAMEBUFFER_DEVICE; properties: PFRAMEBUFFER_PROPERTIES): uint32_t; stdcall; public name 'framebuffer_device_get_properties';
function framebuffer_device_set_properties(framebuffer: PFRAMEBUFFER_DEVICE; properties: PFRAMEBUFFER_PROPERTIES): uint32_t; stdcall; public name 'framebuffer_device_set_properties';

function framebuffer_device_check_flag(framebuffer: PFRAMEBUFFER_DEVICE; flag: uint32_t): BOOL; stdcall; public name 'framebuffer_device_check_flag';

function framebuffer_device_get_format(framebuffer: PFRAMEBUFFER_DEVICE): uint32_t; stdcall; public name 'framebuffer_device_get_format';

function framebuffer_device_create: PFRAMEBUFFER_DEVICE; stdcall; public name 'framebuffer_device_create';
function framebuffer_device_create_ex(size: uint32_t): PFRAMEBUFFER_DEVICE; stdcall; public name 'framebuffer_device_create_ex';
function framebuffer_device_destroy(framebuffer: PFRAMEBUFFER_DEVICE): uint32_t; stdcall; public name 'framebuffer_device_destroy';

function framebuffer_device_register(framebuffer: PFRAMEBUFFER_DEVICE): uint32_t; stdcall; public name 'framebuffer_device_register';
function framebuffer_device_deregister(framebuffer: PFRAMEBUFFER_DEVICE): uint32_t; stdcall; public name 'framebuffer_device_deregister';

function framebuffer_device_find(framebufferid: uint32_t): PFRAMEBUFFER_DEVICE; stdcall; public name 'framebuffer_device_find';
function framebuffer_device_find_by_name(const name: PCHAR): PFRAMEBUFFER_DEVICE; stdcall; public name 'framebuffer_device_find_by_name';
function framebuffer_device_find_by_description(const description: PCHAR): PFRAMEBUFFER_DEVICE; stdcall; public name 'framebuffer_device_find_by_description';
function framebuffer_device_enumerate(callback: framebuffer_enumerate_cb; data: PVOID): uint32_t; stdcall; public name 'framebuffer_device_enumerate';

function framebuffer_device_notification(framebuffer: PFRAMEBUFFER_DEVICE; callback: framebuffer_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall; public name 'framebuffer_device_notification';

{==============================================================================}
{Framebuffer Helper Functions}
function framebuffer_device_get_count: uint32_t; stdcall; public name 'framebuffer_device_get_count';
function framebuffer_device_get_default: PFRAMEBUFFER_DEVICE; stdcall; public name 'framebuffer_device_get_default';
function framebuffer_device_set_default(framebuffer: PFRAMEBUFFER_DEVICE): uint32_t; stdcall; public name 'framebuffer_device_set_default';

function framebuffer_device_check(framebuffer: PFRAMEBUFFER_DEVICE): PFRAMEBUFFER_DEVICE; stdcall; public name 'framebuffer_device_check';

function framebuffer_device_swap(value: uint32_t): uint32_t; stdcall; public name 'framebuffer_device_swap';

function framebuffer_type_to_string(framebuffertype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'framebuffer_type_to_string';
function framebuffer_state_to_string(framebufferstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'framebuffer_state_to_string';

procedure framebuffer_device_hide_cursor(framebuffer: PFRAMEBUFFER_DEVICE); stdcall; public name 'framebuffer_device_hide_cursor';
procedure framebuffer_device_show_cursor(framebuffer: PFRAMEBUFFER_DEVICE); stdcall; public name 'framebuffer_device_show_cursor';

function framebuffer_cursor_to_string(state: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'framebuffer_cursor_to_string';

function framebuffer_depth_to_string(depth: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'framebuffer_depth_to_string';
function framebuffer_order_to_string(order: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'framebuffer_order_to_string';
function framebuffer_mode_to_string(mode: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'framebuffer_mode_to_string';
function framebuffer_rotation_to_string(rotation: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'framebuffer_rotation_to_string';
{$ENDIF}
{==============================================================================}
{Graphics Console Functions}
{$IFDEF API_EXPORT_GRAPHICSCONSOLE}
function graphics_window_create(console: PCONSOLE_DEVICE; position: uint32_t): WINDOW_HANDLE; stdcall; public name 'graphics_window_create';
function graphics_window_create_ex(console: PCONSOLE_DEVICE; font: FONT_HANDLE; size, state, mode, position: uint32_t): WINDOW_HANDLE; stdcall; public name 'graphics_window_create_ex';
function graphics_window_destroy(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'graphics_window_destroy';

function graphics_window_show(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'graphics_window_show';
function graphics_window_hide(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'graphics_window_hide';

function graphics_window_activate(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'graphics_window_activate';
function graphics_window_deactivate(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'graphics_window_deactivate';

function graphics_window_next(console: PCONSOLE_DEVICE; visible: BOOL): WINDOW_HANDLE; stdcall; public name 'graphics_window_next';
function graphics_window_previous(console: PCONSOLE_DEVICE; visible: BOOL): WINDOW_HANDLE; stdcall; public name 'graphics_window_previous';

function graphics_window_at(console: PCONSOLE_DEVICE; x, y: uint32_t; visible: BOOL): WINDOW_HANDLE; stdcall; public name 'graphics_window_at';
function graphics_window_find(console: PCONSOLE_DEVICE; position: uint32_t): WINDOW_HANDLE; stdcall; public name 'graphics_window_find';
function graphics_window_enumerate(console: PCONSOLE_DEVICE; callback: graphics_window_enumerate_cb; data: PVOID): uint32_t; stdcall; public name 'graphics_window_enumerate';

function graphics_window_check_flag(handle: WINDOW_HANDLE; flag: uint32_t): BOOL; stdcall; public name 'graphics_window_check_flag';
function graphics_window_update_flag(handle: WINDOW_HANDLE; flag: uint32_t; clear: BOOL): uint32_t; stdcall; public name 'graphics_window_update_flag';

function graphics_window_get_mode(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'graphics_window_get_mode';
function graphics_window_get_state(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'graphics_window_get_state';

function graphics_window_get_position(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'graphics_window_get_position';
function graphics_window_set_position(handle: WINDOW_HANDLE; position: uint32_t): uint32_t; stdcall; public name 'graphics_window_set_position';

function graphics_window_get_properties(handle: WINDOW_HANDLE; properties: PWINDOW_PROPERTIES): uint32_t; stdcall; public name 'graphics_window_get_properties';

function graphics_window_get_min_x(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'graphics_window_get_min_x';
function graphics_window_get_min_y(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'graphics_window_get_min_y';
function graphics_window_get_max_x(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'graphics_window_get_max_x';
function graphics_window_get_max_y(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'graphics_window_get_max_y';

function graphics_window_get_rect(handle: WINDOW_HANDLE): TCONSOLE_RECT; stdcall; public name 'graphics_window_get_rect';
function graphics_window_set_rect(handle: WINDOW_HANDLE; const rect: TCONSOLE_RECT): uint32_t; stdcall; public name 'graphics_window_set_rect';
function graphics_window_reset_rect(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'graphics_window_reset_rect';

function graphics_window_get_viewport(handle: WINDOW_HANDLE; var x1, y1, x2, y2: uint32_t): uint32_t; stdcall; public name 'graphics_window_get_viewport';
function graphics_window_set_viewport(handle: WINDOW_HANDLE; x1, y1, x2, y2: uint32_t): uint32_t; stdcall; public name 'graphics_window_set_viewport';
function graphics_window_reset_viewport(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'graphics_window_reset_viewport';

function graphics_window_get_cols(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'graphics_window_get_cols';
function graphics_window_get_rows(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'graphics_window_get_rows';

function graphics_window_get_width(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'graphics_window_get_width';
function graphics_window_get_height(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'graphics_window_get_height';
function graphics_window_get_format(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'graphics_window_get_format';

function graphics_window_get_forecolor(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'graphics_window_get_forecolor';
function graphics_window_set_forecolor(handle: WINDOW_HANDLE; color: uint32_t): uint32_t; stdcall; public name 'graphics_window_set_forecolor';
function graphics_window_get_backcolor(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'graphics_window_get_backcolor';
function graphics_window_set_backcolor(handle: WINDOW_HANDLE; color: uint32_t): uint32_t; stdcall; public name 'graphics_window_set_backcolor';

function graphics_window_get_font(handle: WINDOW_HANDLE): FONT_HANDLE; stdcall; public name 'graphics_window_get_font';
function graphics_window_set_font(handle: WINDOW_HANDLE; font: FONT_HANDLE): uint32_t; stdcall; public name 'graphics_window_set_font';

function graphics_window_get_cursor_xy(handle: WINDOW_HANDLE; var x, y: uint32_t): uint32_t; stdcall; public name 'graphics_window_get_cursor_xy';
function graphics_window_set_cursor_xy(handle: WINDOW_HANDLE; x, y: uint32_t): uint32_t; stdcall; public name 'graphics_window_set_cursor_xy';
function graphics_window_get_cursor_mode(handle: WINDOW_HANDLE): CURSOR_MODE; stdcall; public name 'graphics_window_get_cursor_mode';
function graphics_window_set_cursor_mode(handle: WINDOW_HANDLE; cursormode: CURSOR_MODE): uint32_t; stdcall; public name 'graphics_window_set_cursor_mode';
function graphics_window_get_cursor_blink(handle: WINDOW_HANDLE): BOOL; stdcall; public name 'graphics_window_get_cursor_blink';
function graphics_window_set_cursor_blink(handle: WINDOW_HANDLE; cursorblink: BOOL): uint32_t; stdcall; public name 'graphics_window_set_cursor_blink';
function graphics_window_get_cursor_state(handle: WINDOW_HANDLE): CURSOR_STATE; stdcall; public name 'graphics_window_get_cursor_state';
function graphics_window_set_cursor_state(handle: WINDOW_HANDLE; cursorstate: CURSOR_STATE): uint32_t; stdcall; public name 'graphics_window_set_cursor_state';
function graphics_window_get_cursor_shape(handle: WINDOW_HANDLE): CURSOR_SHAPE; stdcall; public name 'graphics_window_get_cursor_shape';
function graphics_window_set_cursor_shape(handle: WINDOW_HANDLE; cursorshape: CURSOR_SHAPE): uint32_t; stdcall; public name 'graphics_window_set_cursor_shape';

function graphics_window_cursor_on(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'graphics_window_cursor_on';
function graphics_window_cursor_off(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'graphics_window_cursor_off';
function graphics_window_cursor_line(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'graphics_window_cursor_line';
function graphics_window_cursor_bar(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'graphics_window_cursor_bar';
function graphics_window_cursor_block(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'graphics_window_cursor_block';
function graphics_window_cursor_move(handle: WINDOW_HANDLE; x, y: uint32_t): uint32_t; stdcall; public name 'graphics_window_cursor_move';
function graphics_window_cursor_blink(handle: WINDOW_HANDLE; enabled: BOOL): uint32_t; stdcall; public name 'graphics_window_cursor_blink';

function graphics_window_clear(handle: WINDOW_HANDLE): uint32_t; stdcall; public name 'graphics_window_clear';
function graphics_window_clear_ex(handle: WINDOW_HANDLE; x1, y1, x2, y2, color: uint32_t): uint32_t; stdcall; public name 'graphics_window_clear_ex';

function graphics_window_draw_box(handle: WINDOW_HANDLE; x1, y1, x2, y2, color, width: uint32_t): uint32_t; stdcall; public name 'graphics_window_draw_box';
function graphics_window_draw_line(handle: WINDOW_HANDLE; x1, y1, x2, y2, color, width: uint32_t): uint32_t; stdcall; public name 'graphics_window_draw_line';
function graphics_window_draw_block(handle: WINDOW_HANDLE; x1, y1, x2, y2, color: uint32_t): uint32_t; stdcall; public name 'graphics_window_draw_block';
function graphics_window_draw_circle(handle: WINDOW_HANDLE; x, y, color, width, radius: uint32_t): uint32_t; stdcall; public name 'graphics_window_draw_circle';

function graphics_window_draw_char(handle: WINDOW_HANDLE; ch: CHAR; x, y: uint32_t): uint32_t; stdcall; public name 'graphics_window_draw_char';
function graphics_window_draw_char_ex(handle: WINDOW_HANDLE; font: FONT_HANDLE; ch: CHAR; x, y, forecolor, backcolor: uint32_t): uint32_t; stdcall; public name 'graphics_window_draw_char_ex';

function graphics_window_draw_text(handle: WINDOW_HANDLE; const text: PCHAR; x, y: uint32_t): uint32_t; stdcall; public name 'graphics_window_draw_text';
function graphics_window_draw_text_ex(handle: WINDOW_HANDLE; font: FONT_HANDLE; const text: PCHAR; x, y, forecolor, backcolor: uint32_t): uint32_t; stdcall; public name 'graphics_window_draw_text_ex';

function graphics_window_draw_pixel(handle: WINDOW_HANDLE; x, y, color: uint32_t): uint32_t; stdcall; public name 'graphics_window_draw_pixel';
function graphics_window_draw_image(handle: WINDOW_HANDLE; x, y: uint32_t; image: PVOID; width, height, format: uint32_t): uint32_t; stdcall; public name 'graphics_window_draw_image';

function graphics_window_get_pixel(handle: WINDOW_HANDLE; x, y: uint32_t): uint32_t; stdcall; public name 'graphics_window_get_pixel';
function graphics_window_get_image(handle: WINDOW_HANDLE; x, y: uint32_t; image: PVOID; width, height, format: uint32_t): uint32_t; stdcall; public name 'graphics_window_get_image';

function graphics_window_copy_image(handle: WINDOW_HANDLE; const source, dest: TCONSOLE_POINT; width, height: uint32_t): uint32_t; stdcall; public name 'graphics_window_copy_image';
function graphics_window_move_image(handle: WINDOW_HANDLE; const source, dest: TCONSOLE_POINT; width, height, fillcolor: uint32_t): uint32_t; stdcall; public name 'graphics_window_move_image';

function graphics_window_image_size(handle: WINDOW_HANDLE; width, height, format, stride: uint32_t): uint32_t; stdcall; public name 'graphics_window_image_size';

{==============================================================================}
{Graphics Console Helper Functions}
function graphics_window_get_count(console: PCONSOLE_DEVICE): uint32_t; stdcall; public name 'graphics_window_get_count';
function graphics_window_get_active(console: PCONSOLE_DEVICE): WINDOW_HANDLE; stdcall; public name 'graphics_window_get_active';

function graphics_window_check(console: PCONSOLE_DEVICE; window: PGRAPHICS_WINDOW): PGRAPHICS_WINDOW; stdcall; public name 'graphics_window_check';
{$ENDIF}
{==============================================================================}
{HID Functions}
{$IFDEF API_EXPORT_HID}
function hid_parser_parse_collections(device: PHID_DEVICE; var collections: PHID_COLLECTIONS; var count: uint32_t): uint32_t; stdcall; public name 'hid_parser_parse_collections';
function hid_parser_free_collections(collections: PHID_COLLECTIONS; count: uint32_t): uint32_t; stdcall; public name 'hid_parser_free_collections';

function hid_parser_count_collections(device: PHID_DEVICE; parent: PHID_COLLECTION): uint32_t; stdcall; public name 'hid_parser_count_collections';
function hid_parser_count_reports(device: PHID_DEVICE; collection: PHID_COLLECTION): uint32_t; stdcall; public name 'hid_parser_count_reports';
function hid_parser_count_usages(device: PHID_DEVICE; report: PHID_REPORT): uint32_t; stdcall; public name 'hid_parser_count_usages';

function hid_parser_allocate_collection(device: PHID_DEVICE; parent: PHID_COLLECTION; state: PHID_STATE; flags, start: uint32_t): PHID_COLLECTION; stdcall; public name 'hid_parser_allocate_collection';
function hid_parser_allocate_report(device: PHID_DEVICE; collection: PHID_COLLECTION; state: PHID_STATE; kind: uint8_t; flags, index, sequence: uint32_t): PHID_REPORT; stdcall; public name 'hid_parser_allocate_report';
function hid_parser_allocate_usage(device: PHID_DEVICE; report: PHID_REPORT; state: PHID_STATE; index: uint32_t): PHID_USAGE; stdcall; public name 'hid_parser_allocate_usage';
function hid_parser_update_usage(device: PHID_DEVICE; report: PHID_REPORT; state: PHID_STATE; usage: PHID_USAGE): BOOL; stdcall; public name 'hid_parser_update_usage';
function hid_parser_free_usage(device: PHID_DEVICE; usage: PHID_USAGE): BOOL; stdcall; public name 'hid_parser_free_usage';

function hid_parser_pop_stack(var stack: PHID_STACK; var state: PHID_STATE): uint32_t; stdcall; public name 'hid_parser_pop_stack';
function hid_parser_push_stack(stack: PHID_STACK): uint32_t; stdcall; public name 'hid_parser_push_stack';
function hid_parser_free_stack(stack: PHID_STACK): uint32_t; stdcall; public name 'hid_parser_free_stack';

function hid_parser_reset_state(state: PHID_STATE): uint32_t; stdcall; public name 'hid_parser_reset_state';
function hid_parser_clean_state(state: PHID_STATE): uint32_t; stdcall; public name 'hid_parser_clean_state';

function hid_find_collection(device: PHID_DEVICE; page, usage: uint16_t): PHID_COLLECTION; stdcall; public name 'hid_find_collection';

function hid_find_report_ids(device: PHID_DEVICE; collection: PHID_COLLECTION; var minid, maxid: uint8_t): uint32_t; stdcall; public name 'hid_find_report_ids';
function hid_find_report_sizes(device: PHID_DEVICE; collection: PHID_COLLECTION; kind: uint8_t; var minsize, maxsize: uint32_t): uint32_t; stdcall; public name 'hid_find_report_sizes';

function hid_count_reports(device: PHID_DEVICE; collection: PHID_COLLECTION; kind, id: uint8_t; var count: uint32_t): uint32_t; stdcall; public name 'hid_count_reports';
function hid_find_reports(device: PHID_DEVICE; collection: PHID_COLLECTION; kind, id: uint8_t; reports: PHID_REPORTS; count: uint32_t): uint32_t; stdcall; public name 'hid_find_reports';

function hid_allocate_definition(device: PHID_DEVICE; collection: PHID_COLLECTION; kind, id: uint8_t): PHID_DEFINITION; stdcall; public name 'hid_allocate_definition';
function hid_free_definition(definition: PHID_DEFINITION): uint32_t; stdcall; public name 'hid_free_definition';

function hid_insert_bit_field(field: PHID_FIELD; buffer: PVOID; size: uint32_t; value: BOOL): uint32_t; stdcall; public name 'hid_insert_bit_field';
function hid_insert_signed_field(field: PHID_FIELD; buffer: PVOID; size: uint32_t; value: int32_t): uint32_t; stdcall; public name 'hid_insert_signed_field';
function hid_insert_unsigned_field(field: PHID_FIELD; buffer: PVOID; size, value: uint32_t): uint32_t; stdcall; public name 'hid_insert_unsigned_field';

function hid_extract_bit_field(field: PHID_FIELD; buffer: PVOID; size: uint32_t; var value: BOOL): uint32_t; stdcall; public name 'hid_extract_bit_field';
function hid_extract_signed_field(field: PHID_FIELD; buffer: PVOID; size: uint32_t; var value: int32_t): uint32_t; stdcall; public name 'hid_extract_signed_field';
function hid_extract_unsigned_field(field: PHID_FIELD; buffer: PVOID; size: uint32_t; var value: uint32_t): uint32_t; stdcall; public name 'hid_extract_unsigned_field';

{==============================================================================}
{HID Device Functions}
function hid_device_set_state(device: PHID_DEVICE; state: uint32_t): uint32_t; stdcall; public name 'hid_device_set_state';

function hid_device_get_idle(device: PHID_DEVICE; var duration: uint16_t; reportid: uint8_t): uint32_t; stdcall; public name 'hid_device_get_idle';
function hid_device_set_idle(device: PHID_DEVICE; duration: uint16_t; reportid: uint8_t): uint32_t; stdcall; public name 'hid_device_set_idle';

function hid_device_get_report(device: PHID_DEVICE; reporttype, reportid: uint8_t; reportdata: PVOID; reportsize: uint32_t): uint32_t; stdcall; public name 'hid_device_get_report';
function hid_device_set_report(device: PHID_DEVICE; reporttype, reportid: uint8_t; reportdata: PVOID; reportsize: uint32_t): uint32_t; stdcall; public name 'hid_device_set_report';

function hid_device_allocate_report(device: PHID_DEVICE; collection: PHID_COLLECTION; reportid: uint8_t; reportsize: uint32_t): uint32_t; stdcall; public name 'hid_device_allocate_report';
function hid_device_release_report(device: PHID_DEVICE; reportid: uint8_t): uint32_t; stdcall; public name 'hid_device_release_report';

function hid_device_submit_report(device: PHID_DEVICE; reportid: uint8_t): uint32_t; stdcall; public name 'hid_device_submit_report';
function hid_device_cancel_report(device: PHID_DEVICE; reportid: uint8_t): uint32_t; stdcall; public name 'hid_device_cancel_report';

function hid_device_get_protocol(device: PHID_DEVICE; var protocol: uint8_t): uint32_t; stdcall; public name 'hid_device_get_protocol';
function hid_device_set_protocol(device: PHID_DEVICE; protocol: uint8_t): uint32_t; stdcall; public name 'hid_device_set_protocol';

function hid_device_get_interval(device: PHID_DEVICE; var interval: uint32_t): uint32_t; stdcall; public name 'hid_device_get_interval';
function hid_device_set_interval(device: PHID_DEVICE; interval: uint32_t): uint32_t; stdcall; public name 'hid_device_set_interval';

function hid_device_get_report_descriptor(device: PHID_DEVICE; descriptor: PHID_REPORT_DESCRIPTOR; size: uint32_t): uint32_t; stdcall; public name 'hid_device_get_report_descriptor';
function hid_device_get_physical_descriptor_set0(device: PHID_DEVICE; descriptor: PHID_PHYSICAL_DESCRIPTOR_SET0): uint32_t; stdcall; public name 'hid_device_get_physical_descriptor_set0';
function hid_device_get_physical_descriptor_set(device: PHID_DEVICE; descriptor: PHID_PHYSICAL_DESCRIPTOR_SET; index: uint8_t; size: uint32_t): uint32_t; stdcall; public name 'hid_device_get_physical_descriptor_set';

function hid_device_bind_device(device: PHID_DEVICE): uint32_t; stdcall; public name 'hid_device_bind_device';
function hid_device_unbind_device(device: PHID_DEVICE; consumer: PHID_CONSUMER): uint32_t; stdcall; public name 'hid_device_unbind_device';

function hid_device_bind_collections(device: PHID_DEVICE): uint32_t; stdcall; public name 'hid_device_bind_collections';
function hid_device_unbind_collections(device: PHID_DEVICE; consumer: PHID_CONSUMER): uint32_t; stdcall; public name 'hid_device_unbind_collections';

function hid_device_create: PHID_DEVICE; stdcall; public name 'hid_device_create';
function hid_device_create_ex(size: uint32_t): PHID_DEVICE; stdcall; public name 'hid_device_create_ex';
function hid_device_destroy(device: PHID_DEVICE): uint32_t; stdcall; public name 'hid_device_destroy';

function hid_device_register(device: PHID_DEVICE): uint32_t; stdcall; public name 'hid_device_register';
function hid_device_deregister(device: PHID_DEVICE): uint32_t; stdcall; public name 'hid_device_deregister';

function hid_device_find(hidid: uint32_t): PHID_DEVICE; stdcall; public name 'hid_device_find';
function hid_device_find_by_name(const name: PCHAR): PHID_DEVICE; stdcall; public name 'hid_device_find_by_name';
function hid_device_find_by_description(const description: PCHAR): PHID_DEVICE; stdcall; public name 'hid_device_find_by_description';
function hid_device_enumerate(callback: hid_device_enumerate_cb; data: PVOID): uint32_t; stdcall; public name 'hid_device_enumerate';

function hid_device_notification(device: PHID_DEVICE; callback: hid_device_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall; public name 'hid_device_notification';

{==============================================================================}
{HID Consumer Functions}
function hid_consumer_create: PHID_CONSUMER; stdcall; public name 'hid_consumer_create';
function hid_consumer_create_ex(size: uint32_t): PHID_CONSUMER; stdcall; public name 'hid_consumer_create_ex';
function hid_consumer_destroy(consumer: PHID_CONSUMER): uint32_t; stdcall; public name 'hid_consumer_destroy';

function hid_consumer_register(consumer: PHID_CONSUMER): uint32_t; stdcall; public name 'hid_consumer_register';
function hid_consumer_deregister(consumer: PHID_CONSUMER): uint32_t; stdcall; public name 'hid_consumer_deregister';

function hid_consumer_find(consumerid: uint32_t): PHID_CONSUMER; stdcall; public name 'hid_consumer_find';
function hid_consumer_find_by_name(const name: PCHAR): PHID_CONSUMER; stdcall; public name 'hid_consumer_find_by_name';
function hid_consumer_enumerate(callback: hid_consumer_enumerate_cb; data: PVOID): uint32_t; stdcall; public name 'hid_consumer_enumerate';

{==============================================================================}
{HID Helper Functions}
function hid_is_bit_field(field: PHID_FIELD): BOOL; stdcall; public name 'hid_is_bit_field';
function hid_is_byte_field(field: PHID_FIELD): BOOL; stdcall; public name 'hid_is_byte_field';
function hid_is_word_field(field: PHID_FIELD): BOOL; stdcall; public name 'hid_is_word_field';
function hid_is_long_field(field: PHID_FIELD): BOOL; stdcall; public name 'hid_is_long_field';
function hid_is_signed_field(field: PHID_FIELD): BOOL; stdcall; public name 'hid_is_signed_field';

function hid_page_to_string(page: uint16_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'hid_page_to_string';
function hid_usage_to_string(page, usage, count: uint16_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'hid_usage_to_string';

function hid_unit_type_to_string(unittype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'hid_unit_type_to_string';

function hid_report_kind_to_string(kind: uint8_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'hid_report_kind_to_string';
function hid_report_flags_to_string(flags: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'hid_report_flags_to_string';

function hid_collection_flags_to_string(flags: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'hid_collection_flags_to_string';

{==============================================================================}
{HID Device Helper Functions}
function hid_device_get_count: uint32_t; stdcall; public name 'hid_device_get_count';

function hid_device_check(device: PHID_DEVICE): PHID_DEVICE; stdcall; public name 'hid_device_check';

function hid_device_type_to_string(hidtype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'hid_device_type_to_string';
function hid_device_state_to_string(hidstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'hid_device_state_to_string';

function hid_device_state_to_notification(state: uint32_t): uint32_t; stdcall; public name 'hid_device_state_to_notification';

{==============================================================================}
{HID Consumer Helper Functions}
function hid_consumer_get_count: uint32_t; stdcall; public name 'hid_consumer_get_count';

function hid_consumer_check(consumer: PHID_CONSUMER): PHID_CONSUMER; stdcall; public name 'hid_consumer_check';
{$ENDIF}
{==============================================================================}
{Keymap Functions}
{$IFDEF API_EXPORT_KEYMAP}
function keymap_load(header: PKEYMAP_HEADER; data: PKEYMAP_DATA; size: uint32_t): KEYMAP_HANDLE; stdcall; public name 'keymap_load';
function keymap_load_ex(header: PKEYMAP_HEADER; data: PKEYMAP_DATA; capskeys: PKEYMAP_CAPSKEYS; deadkeys: PKEYMAP_DEADKEYS; size: uint32_t; properties: PKEYMAP_PROPERTIES): KEYMAP_HANDLE; stdcall; public name 'keymap_load_ex';
function keymap_unload(handle: KEYMAP_HANDLE): uint32_t; stdcall; public name 'keymap_unload';

function keymap_get_name(handle: KEYMAP_HANDLE; name: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'keymap_get_name';
function keymap_get_description(handle: KEYMAP_HANDLE; description: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'keymap_get_description';

function keymap_check_flag(handle: KEYMAP_HANDLE; flag: uint32_t): BOOL; stdcall; public name 'keymap_check_flag';

function keymap_get_key_code(handle: KEYMAP_HANDLE; scancode: uint16_t; index: uint8_t): uint16_t; stdcall; public name 'keymap_get_key_code';

function keymap_get_char_code(handle: KEYMAP_HANDLE; keycode: uint16_t): CHAR; stdcall; public name 'keymap_get_char_code';
function keymap_get_char_unicode(handle: KEYMAP_HANDLE; keycode: uint16_t): WCHAR; stdcall; public name 'keymap_get_char_unicode';

function keymap_check_capskey(handle: KEYMAP_HANDLE; scancode: uint16_t): BOOL; stdcall; public name 'keymap_check_capskey';

function keymap_check_deadkey(handle: KEYMAP_HANDLE; scancode: uint16_t; index: uint8_t): BOOL; stdcall; public name 'keymap_check_deadkey';
function keymap_resolve_deadkey(handle: KEYMAP_HANDLE; deadcode, scancode: uint16_t; deadindex, scanindex: uint8_t; var keycode: uint16_t): BOOL; stdcall; public name 'keymap_resolve_deadkey';

function keymap_get_properties(handle: KEYMAP_HANDLE; properties: PKEYMAP_PROPERTIES): uint32_t; stdcall; public name 'keymap_get_properties';

function keymap_find_by_name(const name: PCHAR): KEYMAP_HANDLE; stdcall; public name 'keymap_find_by_name';
function keymap_find_by_description(const description: PCHAR): KEYMAP_HANDLE; stdcall; public name 'keymap_find_by_description';
function keymap_enumerate(callback: keymap_enumerate_cb; data: PVOID): uint32_t; stdcall; public name 'keymap_enumerate';

{==============================================================================}
{Keymap Helper Functions}
function keymap_get_count: uint32_t; stdcall; public name 'keymap_get_count';
function keymap_get_default: KEYMAP_HANDLE; stdcall; public name 'keymap_get_default';
function keymap_set_default(handle: KEYMAP_HANDLE): uint32_t; stdcall; public name 'keymap_set_default';

function keymap_check(keymap: PKEYMAP_ENTRY): PKEYMAP_ENTRY; stdcall; public name 'keymap_check';
{$ENDIF}
{==============================================================================}
{Keyboard Functions}
{$IFDEF API_EXPORT_KEYBOARD}
function keyboard_get(var keycode: uint16_t): uint32_t; stdcall; public name 'keyboard_get';
function keyboard_peek: uint32_t; stdcall; public name 'keyboard_peek';
function keyboard_read(buffer: PVOID; size: uint32_t; var count: uint32_t): uint32_t; stdcall; public name 'keyboard_read';
function keyboard_read_ex(buffer: PVOID; size, flags: uint32_t; var count: uint32_t): uint32_t; stdcall; public name 'keyboard_read_ex';

function keyboard_put(scancode, keycode: uint16_t; modifiers: uint32_t): uint32_t; stdcall; public name 'keyboard_put';
function keyboard_write(buffer: PVOID; size, count: uint32_t): uint32_t; stdcall; public name 'keyboard_write';

function keyboard_flush: uint32_t; stdcall; public name 'keyboard_flush';

function keyboard_device_get(keyboard: PKEYBOARD_DEVICE; var keycode: uint16_t): uint32_t; stdcall; public name 'keyboard_device_get';
function keyboard_device_read(keyboard: PKEYBOARD_DEVICE; buffer: PVOID; size: uint32_t; var count: uint32_t): uint32_t; stdcall; public name 'keyboard_device_read';
function keyboard_device_control(keyboard: PKEYBOARD_DEVICE; request: int; argument1: SIZE_T; var argument2: SIZE_T): uint32_t; stdcall; public name 'keyboard_device_control';

function keyboard_device_set_state(keyboard: PKEYBOARD_DEVICE; state: uint32_t): uint32_t; stdcall; public name 'keyboard_device_set_state';

function keyboard_device_create: PKEYBOARD_DEVICE; stdcall; public name 'keyboard_device_create';
function keyboard_device_create_ex(size: uint32_t): PKEYBOARD_DEVICE; stdcall; public name 'keyboard_device_create_ex';
function keyboard_device_destroy(keyboard: PKEYBOARD_DEVICE): uint32_t; stdcall; public name 'keyboard_device_destroy';

function keyboard_device_register(keyboard: PKEYBOARD_DEVICE): uint32_t; stdcall; public name 'keyboard_device_register';
function keyboard_device_deregister(keyboard: PKEYBOARD_DEVICE): uint32_t; stdcall; public name 'keyboard_device_deregister';

function keyboard_device_find(keyboardid: uint32_t): PKEYBOARD_DEVICE; stdcall; public name 'keyboard_device_find';
function keyboard_device_find_by_name(const name: PCHAR): PKEYBOARD_DEVICE; stdcall; public name 'keyboard_device_find_by_name';
function keyboard_device_find_by_description(const description: PCHAR): PKEYBOARD_DEVICE; stdcall; public name 'keyboard_device_find_by_description';
function keyboard_device_enumerate(callback: keyboard_enumerate_cb; data: PVOID): uint32_t; stdcall; public name 'keyboard_device_enumerate';

function keyboard_device_notification(keyboard: PKEYBOARD_DEVICE; callback: keyboard_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall; public name 'keyboard_device_notification';

{==============================================================================}
{Keyboard Helper Functions}
function keyboard_get_count: uint32_t; stdcall; public name 'keyboard_get_count';

function keyboard_device_check(keyboard: PKEYBOARD_DEVICE): PKEYBOARD_DEVICE; stdcall; public name 'keyboard_device_check';

function keyboard_device_type_to_string(keyboardtype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'keyboard_device_type_to_string';
function keyboard_device_state_to_string(keyboardstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'keyboard_device_state_to_string';

function keyboard_device_state_to_notification(state: uint32_t): uint32_t; stdcall; public name 'keyboard_device_state_to_notification';

function keyboard_remap_ctrl_code(keycode, charcode: uint16_t): uint16_t; stdcall; public name 'keyboard_remap_ctrl_code';
function keyboard_remap_key_code(scancode, keycode: uint16_t; var charcode: uint8_t; modifiers: uint32_t): BOOL; stdcall; public name 'keyboard_remap_key_code';
function keyboard_remap_scan_code(scancode, keycode: uint16_t; var charcode: uint8_t; modifiers: uint32_t): BOOL; stdcall; public name 'keyboard_remap_scan_code';

function keyboard_insert_data(keyboard: PKEYBOARD_DEVICE; data: PKEYBOARD_DATA; signal: BOOL): uint32_t; stdcall; public name 'keyboard_insert_data';
{$ENDIF}
{==============================================================================}
{Mouse Functions}
{$IFDEF API_EXPORT_MOUSE}
function mouse_peek: uint32_t; stdcall; public name 'mouse_peek';
function mouse_read(buffer: PVOID; size: uint32_t; var count: uint32_t): uint32_t; stdcall; public name 'mouse_read';
function mouse_read_ex(buffer: PVOID; size, flags: uint32_t; var count: uint32_t): uint32_t; stdcall; public name 'mouse_read_ex';

function mouse_write(buffer: PVOID; size, count: uint32_t): uint32_t; stdcall; public name 'mouse_write';

function mouse_flush: uint32_t; stdcall; public name 'mouse_flush';

function mouse_device_read(mouse: PMOUSE_DEVICE; buffer: PVOID; size: uint32_t; var count: uint32_t): uint32_t; stdcall; public name 'mouse_device_read';
function mouse_device_update(mouse: PMOUSE_DEVICE): uint32_t; stdcall; public name 'mouse_device_update';
function mouse_device_control(mouse: PMOUSE_DEVICE; request: int; argument1: SIZE_T; var argument2: SIZE_T): uint32_t; stdcall; public name 'mouse_device_control';

function mouse_device_get_properties(mouse: PMOUSE_DEVICE; properties: PMOUSE_PROPERTIES): uint32_t; stdcall; public name 'mouse_device_get_properties';

function mouse_device_set_state(mouse: PMOUSE_DEVICE; state: uint32_t): uint32_t; stdcall; public name 'mouse_device_set_state';

function mouse_device_create: PMOUSE_DEVICE; stdcall; public name 'mouse_device_create';
function mouse_device_create_ex(size: uint32_t): PMOUSE_DEVICE; stdcall; public name 'mouse_device_create_ex';
function mouse_device_destroy(mouse: PMOUSE_DEVICE): uint32_t; stdcall; public name 'mouse_device_destroy';

function mouse_device_register(mouse: PMOUSE_DEVICE): uint32_t; stdcall; public name 'mouse_device_register';
function mouse_device_deregister(mouse: PMOUSE_DEVICE): uint32_t; stdcall; public name 'mouse_device_deregister';

function mouse_device_find(mouseid: uint32_t): PMOUSE_DEVICE; stdcall; public name 'mouse_device_find';
function mouse_device_find_by_name(const name: PCHAR): PMOUSE_DEVICE; stdcall; public name 'mouse_device_find_by_name';
function mouse_device_find_by_description(const description: PCHAR): PMOUSE_DEVICE; stdcall; public name 'mouse_device_find_by_description';
function mouse_device_enumerate(callback: mouse_enumerate_cb; data: PVOID): uint32_t; stdcall; public name 'mouse_device_enumerate';

function mouse_device_notification(mouse: PMOUSE_DEVICE; callback: mouse_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall; public name 'mouse_device_notification';

{==============================================================================}
{Mouse Helper Functions}
function mouse_get_count: uint32_t; stdcall; public name 'mouse_get_count';

function mouse_device_check(mouse: PMOUSE_DEVICE): PMOUSE_DEVICE; stdcall; public name 'mouse_device_check';

function mouse_device_type_to_string(mousetype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'mouse_device_type_to_string';
function mouse_device_state_to_string(mousestate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'mouse_device_state_to_string';

function mouse_device_rotation_to_string(rotation: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'mouse_device_rotation_to_string';

function mouse_device_state_to_notification(state: uint32_t): uint32_t; stdcall; public name 'mouse_device_state_to_notification';

function mouse_device_resolve_rotation(rotation: uint32_t): uint32_t; stdcall; public name 'mouse_device_resolve_rotation';

function mouse_insert_data(mouse: PMOUSE_DEVICE; data: PMOUSE_DATA; signal: BOOL): uint32_t; stdcall; public name 'mouse_insert_data';
{$ENDIF}
{==============================================================================}
{Touch Functions}
{$IFDEF API_EXPORT_TOUCH}
function touch_device_start(touch: PTOUCH_DEVICE): uint32_t; stdcall; public name 'touch_device_start';
function touch_device_stop(touch: PTOUCH_DEVICE): uint32_t; stdcall; public name 'touch_device_stop';

function touch_device_peek(touch: PTOUCH_DEVICE): uint32_t; stdcall; public name 'touch_device_peek';

function touch_device_read(touch: PTOUCH_DEVICE; buffer: PVOID; size, flags: uint32_t; var count: uint32_t): uint32_t; stdcall; public name 'touch_device_read';
function touch_device_write(touch: PTOUCH_DEVICE; buffer: PVOID; size, count: uint32_t): uint32_t; stdcall; public name 'touch_device_write';

function touch_device_flush(touch: PTOUCH_DEVICE): uint32_t; stdcall; public name 'touch_device_flush';
function touch_device_update(touch: PTOUCH_DEVICE): uint32_t; stdcall; public name 'touch_device_update';

function touch_device_control(touch: PTOUCH_DEVICE; request: int; argument1: SIZE_T; var argument2: SIZE_T): uint32_t; stdcall; public name 'touch_device_control';

function touch_device_properties(touch: PTOUCH_DEVICE; properties: PTOUCH_PROPERTIES): uint32_t; stdcall; public name 'touch_device_properties';
function touch_device_get_properties(touch: PTOUCH_DEVICE; properties: PTOUCH_PROPERTIES): uint32_t; stdcall; public name 'touch_device_get_properties';

function touch_device_create: PTOUCH_DEVICE; stdcall; public name 'touch_device_create';
function touch_device_create_ex(size: uint32_t): PTOUCH_DEVICE; stdcall; public name 'touch_device_create_ex';
function touch_device_destroy(touch: PTOUCH_DEVICE): uint32_t; stdcall; public name 'touch_device_destroy';

function touch_device_register(touch: PTOUCH_DEVICE): uint32_t; stdcall; public name 'touch_device_register';
function touch_device_deregister(touch: PTOUCH_DEVICE): uint32_t; stdcall; public name 'touch_device_deregister';

function touch_device_find(touchid: uint32_t): PTOUCH_DEVICE; stdcall; public name 'touch_device_find';
function touch_device_find_by_name(const name: PCHAR): PTOUCH_DEVICE; stdcall; public name 'touch_device_find_by_name';
function touch_device_find_by_description(const description: PCHAR): PTOUCH_DEVICE; stdcall; public name 'touch_device_find_by_description';
function touch_device_enumerate(callback: touch_enumerate_cb; data: PVOID): uint32_t; stdcall; public name 'touch_device_enumerate';

function touch_device_notification(touch: PTOUCH_DEVICE; callback: touch_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall; public name 'touch_device_notification';

{==============================================================================}
{Touch Helper Functions}
function touch_get_count: uint32_t; stdcall; public name 'touch_get_count';
function touch_device_get_default: PTOUCH_DEVICE; stdcall; public name 'touch_device_get_default';
function touch_device_set_default(touch: PTOUCH_DEVICE): uint32_t; stdcall; public name 'touch_device_set_default';

function touch_device_check(touch: PTOUCH_DEVICE): PTOUCH_DEVICE; stdcall; public name 'touch_device_check';

function touch_device_type_to_string(touchtype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'touch_device_type_to_string';
function touch_device_state_to_string(touchstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'touch_device_state_to_string';

function touch_device_rotation_to_string(rotation: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'touch_device_rotation_to_string';

function touch_device_resolve_rotation(rotation: uint32_t): uint32_t; stdcall; public name 'touch_device_resolve_rotation';

function touch_device_set_callback(touch: PTOUCH_DEVICE; event: touch_event_cb; parameter: PVOID): uint32_t; stdcall; public name 'touch_device_set_callback';

function touch_insert_data(touch: PTOUCH_DEVICE; data: PTOUCH_DATA; signal: BOOL): uint32_t; stdcall; public name 'touch_insert_data';
{$ENDIF}
{==============================================================================}
{Joystick Functions}
{$IFDEF API_EXPORT_JOYSTICK}
function joystick_device_start(joystick: PJOYSTICK_DEVICE): uint32_t; stdcall; public name 'joystick_device_start';
function joystick_device_stop(joystick: PJOYSTICK_DEVICE): uint32_t; stdcall; public name 'joystick_device_stop';

function joystick_device_peek(joystick: PJOYSTICK_DEVICE): uint32_t; stdcall; public name 'joystick_device_peek';

function joystick_device_read(joystick: PJOYSTICK_DEVICE; buffer: PVOID; size, flags: uint32_t; var count: uint32_t): uint32_t; stdcall; public name 'joystick_device_read';
function joystick_device_write(joystick: PJOYSTICK_DEVICE; buffer: PVOID; size, count: uint32_t): uint32_t; stdcall; public name 'joystick_device_write';

function joystick_device_flush(joystick: PJOYSTICK_DEVICE): uint32_t; stdcall; public name 'joystick_device_flush';
function joystick_device_update(joystick: PJOYSTICK_DEVICE): uint32_t; stdcall; public name 'joystick_device_update';

function joystick_device_control(joystick: PJOYSTICK_DEVICE; request: int; argument1: SIZE_T; var argument2: SIZE_T): uint32_t; stdcall; public name 'joystick_device_control';

function joystick_device_get_properties(joystick: PJOYSTICK_DEVICE; properties: PJOYSTICK_PROPERTIES): uint32_t; stdcall; public name 'joystick_device_get_properties';

function joystick_device_set_state(joystick: PJOYSTICK_DEVICE; state: uint32_t): uint32_t; stdcall; public name 'joystick_device_set_state';

function joystick_device_create: PJOYSTICK_DEVICE; stdcall; public name 'joystick_device_create';
function joystick_device_create_ex(size: uint32_t): PJOYSTICK_DEVICE; stdcall; public name 'joystick_device_create_ex';
function joystick_device_destroy(joystick: PJOYSTICK_DEVICE): uint32_t; stdcall; public name 'joystick_device_destroy';

function joystick_device_register(joystick: PJOYSTICK_DEVICE): uint32_t; stdcall; public name 'joystick_device_register';
function joystick_device_deregister(joystick: PJOYSTICK_DEVICE): uint32_t; stdcall; public name 'joystick_device_deregister';

function joystick_device_find(joystickid: uint32_t): PJOYSTICK_DEVICE; stdcall; public name 'joystick_device_find';
function joystick_device_find_by_name(const name: PCHAR): PJOYSTICK_DEVICE; stdcall; public name 'joystick_device_find_by_name';
function joystick_device_find_by_description(const description: PCHAR): PJOYSTICK_DEVICE; stdcall; public name 'joystick_device_find_by_description';
function joystick_device_enumerate(callback: joystick_enumerate_cb; data: PVOID): uint32_t; stdcall; public name 'joystick_device_enumerate';

function joystick_device_notification(joystick: PJOYSTICK_DEVICE; callback: joystick_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall; public name 'joystick_device_notification';

{==============================================================================}
{Joystick Helper Functions}
function joystick_get_count: uint32_t; stdcall; public name 'joystick_get_count';
function joystick_device_get_default: PJOYSTICK_DEVICE; stdcall; public name 'joystick_device_get_default';
function joystick_device_set_default(joystick: PJOYSTICK_DEVICE): uint32_t; stdcall; public name 'joystick_device_set_default';

function joystick_device_check(joystick: PJOYSTICK_DEVICE): PJOYSTICK_DEVICE; stdcall; public name 'joystick_device_check';

function joystick_device_axis_to_string(name: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'joystick_device_axis_to_string';
function joystick_device_hat_to_string(name: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'joystick_device_hat_to_string';
function joystick_device_button_to_string(name: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'joystick_device_button_to_string';

function joystick_device_type_to_string(joysticktype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'joystick_device_type_to_string';
function joystick_device_state_to_string(joystickstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'joystick_device_state_to_string';

function joystick_device_state_to_notification(state: uint32_t): uint32_t; stdcall; public name 'joystick_device_state_to_notification';

function joystick_device_get_axis(joystick: PJOYSTICK_DEVICE; index: uint32_t): uint32_t; stdcall; public name 'joystick_device_get_axis';
function joystick_device_set_axis(joystick: PJOYSTICK_DEVICE; index, name: uint32_t): uint32_t; stdcall; public name 'joystick_device_set_axis';

function joystick_device_get_hat(joystick: PJOYSTICK_DEVICE; index: uint32_t): uint32_t; stdcall; public name 'joystick_device_get_hat';
function joystick_device_set_hat(joystick: PJOYSTICK_DEVICE; index, name: uint32_t): uint32_t; stdcall; public name 'joystick_device_set_hat';

function joystick_device_get_button(joystick: PJOYSTICK_DEVICE; index: uint32_t): uint32_t; stdcall; public name 'joystick_device_get_button';
function joystick_device_set_button(joystick: PJOYSTICK_DEVICE; index, name: uint32_t): uint32_t; stdcall; public name 'joystick_device_set_button';

function joystick_device_set_callback(joystick: PJOYSTICK_DEVICE; event: joystick_event_cb; parameter: PVOID): uint32_t; stdcall; public name 'joystick_device_set_callback';

function joystick_insert_data(joystick: PJOYSTICK_DEVICE; data: PJOYSTICK_DATA; signal: BOOL): uint32_t; stdcall; public name 'joystick_insert_data';
{$ENDIF}
{==============================================================================}
{Storage Functions}
{$IFDEF API_EXPORT_STORAGE}
function storage_device_read(storage: PSTORAGE_DEVICE; const start, count: int64_t; buffer: PVOID): uint32_t; stdcall; public name 'storage_device_read';
function storage_device_write(storage: PSTORAGE_DEVICE; const start, count: int64_t; buffer: PVOID): uint32_t; stdcall; public name 'storage_device_write';
function storage_device_erase(storage: PSTORAGE_DEVICE; const start, count: int64_t): uint32_t; stdcall; public name 'storage_device_erase';
function storage_device_control(storage: PSTORAGE_DEVICE; request: int; argument1: SIZE_T; var argument2: SIZE_T): uint32_t; stdcall; public name 'storage_device_control';

function storage_device_set_state(storage: PSTORAGE_DEVICE; state: uint32_t): uint32_t; stdcall; public name 'storage_device_set_state';

function storage_device_start_status(storage: PSTORAGE_DEVICE; interval: uint32_t): uint32_t; stdcall; public name 'storage_device_start_status';
function storage_device_stop_status(storage: PSTORAGE_DEVICE): uint32_t; stdcall; public name 'storage_device_stop_status';

function storage_device_create: PSTORAGE_DEVICE; stdcall; public name 'storage_device_create';
function storage_device_create_ex(size: uint32_t): PSTORAGE_DEVICE; stdcall; public name 'storage_device_create_ex';
function storage_device_destroy(storage: PSTORAGE_DEVICE): uint32_t; stdcall; public name 'storage_device_destroy';

function storage_device_register(storage: PSTORAGE_DEVICE): uint32_t; stdcall; public name 'storage_device_register';
function storage_device_deregister(storage: PSTORAGE_DEVICE): uint32_t; stdcall; public name 'storage_device_deregister';

function storage_device_find(storageid: uint32_t): PSTORAGE_DEVICE; stdcall; public name 'storage_device_find';
function storage_device_find_by_device(device: PDEVICE): PSTORAGE_DEVICE; stdcall; public name 'storage_device_find_by_device';
function storage_device_find_by_name(const name: PCHAR): PSTORAGE_DEVICE; stdcall; public name 'storage_device_find_by_name';
function storage_device_find_by_description(const description: PCHAR): PSTORAGE_DEVICE; stdcall; public name 'storage_device_find_by_description';
function storage_device_enumerate(callback: storage_enumerate_cb; data: PVOID): uint32_t; stdcall; public name 'storage_device_enumerate';

function storage_device_notification(storage: PSTORAGE_DEVICE; callback: storage_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall; public name 'storage_device_notification';

{==============================================================================}
{Storage Helper Functions}
function storage_get_count: uint32_t; stdcall; public name 'storage_get_count';

function storage_device_check(storage: PSTORAGE_DEVICE): PSTORAGE_DEVICE; stdcall; public name 'storage_device_check';

function storage_device_type_to_string(storagetype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'storage_device_type_to_string';
function storage_device_state_to_string(storagestate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'storage_device_state_to_string';

function storage_device_state_to_notification(state: uint32_t): uint32_t; stdcall; public name 'storage_device_state_to_notification';
{$ENDIF}
{==============================================================================}
{Network Functions}
{$IFDEF API_EXPORT_NETWORK}
function network_start: uint32_t; stdcall; public name 'network_start';
function network_stop: uint32_t; stdcall; public name 'network_stop';

function network_start_completed: BOOL; stdcall; public name 'network_start_completed';

function network_device_open(network: PNETWORK_DEVICE): uint32_t; stdcall; public name 'network_device_open';
function network_device_close(network: PNETWORK_DEVICE): uint32_t; stdcall; public name 'network_device_close';
function network_device_read(network: PNETWORK_DEVICE; buffer: PVOID; size: uint32_t; var length: uint32_t): uint32_t; stdcall; public name 'network_device_read';
function network_device_write(network: PNETWORK_DEVICE; buffer: PVOID; size: uint32_t; var length: uint32_t): uint32_t; stdcall; public name 'network_device_write';
function network_device_control(network: PNETWORK_DEVICE; request: int; argument1: SIZE_T; var argument2: SIZE_T): uint32_t; stdcall; public name 'network_device_control';

function network_buffer_allocate(network: PNETWORK_DEVICE; var entry: PNETWORK_ENTRY): uint32_t; stdcall; public name 'network_buffer_allocate';
function network_buffer_release(network: PNETWORK_DEVICE; entry: PNETWORK_ENTRY): uint32_t; stdcall; public name 'network_buffer_release';
function network_buffer_receive(network: PNETWORK_DEVICE; var entry: PNETWORK_ENTRY): uint32_t; stdcall; public name 'network_buffer_receive';
function network_buffer_transmit(network: PNETWORK_DEVICE; entry: PNETWORK_ENTRY): uint32_t; stdcall; public name 'network_buffer_transmit';

function network_device_set_state(network: PNETWORK_DEVICE; state: uint32_t): uint32_t; stdcall; public name 'network_device_set_state';
function network_device_set_status(network: PNETWORK_DEVICE; status: uint32_t): uint32_t; stdcall; public name 'network_device_set_status';

function network_device_create: PNETWORK_DEVICE; stdcall; public name 'network_device_create';
function network_device_create_ex(size: uint32_t): PNETWORK_DEVICE; stdcall; public name 'network_device_create_ex';
function network_device_destroy(network: PNETWORK_DEVICE): uint32_t; stdcall; public name 'network_device_destroy';

function network_device_register(network: PNETWORK_DEVICE): uint32_t; stdcall; public name 'network_device_register';
function network_device_deregister(network: PNETWORK_DEVICE): uint32_t; stdcall; public name 'network_device_deregister';

function network_device_find(networkid: uint32_t): PNETWORK_DEVICE; stdcall; public name 'network_device_find';
function network_device_find_by_name(const name: PCHAR): PNETWORK_DEVICE; stdcall; public name 'network_device_find_by_name';
function network_device_find_by_description(const description: PCHAR): PNETWORK_DEVICE; stdcall; public name 'network_device_find_by_description';
function network_device_enumerate(callback: network_enumerate_cb; data: PVOID): uint32_t; stdcall; public name 'network_device_enumerate';

function network_device_notification(network: PNETWORK_DEVICE; callback: network_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall; public name 'network_device_notification';

function network_event_allocate(callback: network_event_callback_cb; data: PVOID; event: uint32_t): PNETWORK_EVENT; stdcall; public name 'network_event_allocate';
function network_event_release(event: PNETWORK_EVENT): uint32_t; stdcall; public name 'network_event_release';

function network_event_register(callback: network_event_callback_cb; data: PVOID; event: uint32_t): THANDLE; stdcall; public name 'network_event_register';
function network_event_deregister(handle: THANDLE): uint32_t; stdcall; public name 'network_event_deregister';

function network_event_notify(event: uint32_t): uint32_t; stdcall; public name 'network_event_notify';

{==============================================================================}
{Network Helper Functions}
function network_get_last_error: int32_t; stdcall; public name 'network_get_last_error';
procedure network_set_last_error(error: int32_t); stdcall; public name 'network_set_last_error';

function network_get_count: uint32_t; stdcall; public name 'network_get_count';

function network_device_check(network: PNETWORK_DEVICE): PNETWORK_DEVICE; stdcall; public name 'network_device_check';

function network_device_type_to_string(networktype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'network_device_type_to_string';
function network_device_state_to_string(networkstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'network_device_state_to_string';
function network_device_status_to_string(networkstatus: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'network_device_status_to_string';

function network_device_state_to_notification(state: uint32_t): uint32_t; stdcall; public name 'network_device_state_to_notification';
function network_device_status_to_notification(status: uint32_t): uint32_t; stdcall; public name 'network_device_status_to_notification';

function network_event_check(event: PNETWORK_EVENT): PNETWORK_EVENT; stdcall; public name 'network_event_check';

function hardware_address_to_string(const address: THARDWARE_ADDRESS; separator: PCHAR; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'hardware_address_to_string';
procedure string_to_hardware_address(_string: PCHAR; var address: THARDWARE_ADDRESS); stdcall; public name 'string_to_hardware_address';

function valid_hardware_address(const address: THARDWARE_ADDRESS): BOOL; stdcall; public name 'valid_hardware_address';
procedure random_hardware_addres(var addresss: THARDWARE_ADDRESS); stdcall; public name 'random_hardware_address';

function compare_hardware_address(const address1, address2: THARDWARE_ADDRESS): BOOL; stdcall; public name 'compare_hardware_address';
function compare_hardware_default(const address: THARDWARE_ADDRESS): BOOL; stdcall; public name 'compare_hardware_default';
function compare_hardware_broadcast(const address: THARDWARE_ADDRESS): BOOL; stdcall; public name 'compare_hardware_broadcast';
function compare_hardware_multicast(const address: THARDWARE_ADDRESS): BOOL; stdcall; public name 'compare_hardware_multicast';

function adapter_type_to_string(_type: uint16_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'adapter_type_to_string';
function adapter_mode_to_string(mode: uint16_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'adapter_mode_to_string';
function adapter_config_to_string(config: uint16_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'adapter_config_to_string';
function adapter_state_to_string(state: int; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'adapter_state_to_string';
function adapter_status_to_string(status: int; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'adapter_status_to_string';

function frame_type_to_string(_type: uint16_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'frame_type_to_string';
function network_media_type_to_string(_type: uint16_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'network_media_type_to_string';
function packet_type_to_string(_type: uint16_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'packet_type_to_string';

function config_type_to_string(_type: uint16_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'config_type_to_string';
function config_command_to_string(command: uint16_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'config_command_to_string';

function auth_type_to_string(_type: uint16_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'auth_type_to_string';
function auth_command_to_string(command: uint16_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'auth_command_to_string';

function phy_interface_mode_to_string(mode: uint16_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'phy_interface_mode_to_string';
function phy_link_speed_to_string(speed: uint16_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'phy_link_speed_to_string';
function phy_duplex_mode_to_string(mode: uint16_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'phy_duplex_mode_to_string';

function match_string_to_phy_interface_mode(mode: PCHAR): uint16_t; stdcall; public name 'match_string_to_phy_interface_mode';
{$ENDIF}
{==============================================================================}
{Timezone Functions}
{$IFDEF API_EXPORT_TIMEZONE}
function timezone_add(data: PTIMEZONE_DATA; default: BOOL): uint32_t; stdcall; public name 'timezone_add';
function timezone_delete(timezone: PTIMEZONE_ENTRY): uint32_t; stdcall; public name 'timezone_delete';

function timezone_get_name(timezone: PTIMEZONE_ENTRY; name: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'timezone_get_name';
function timezone_get_description(timezone: PTIMEZONE_ENTRY; description: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'timezone_get_description';

function timezone_get_bias(timezone: PTIMEZONE_ENTRY): int32_t; stdcall; public name 'timezone_get_bias';
function timezone_get_state(timezone: PTIMEZONE_ENTRY): uint32_t; stdcall; public name 'timezone_get_state';
function timezone_get_state_ex(timezone: PTIMEZONE_ENTRY; const datetime: double_t): uint32_t; stdcall; public name 'timezone_get_state_ex';
function timezone_get_active_bias(timezone: PTIMEZONE_ENTRY): int32_t; stdcall; public name 'timezone_get_active_bias';
function timezone_get_active_bias_ex(timezone: PTIMEZONE_ENTRY; const datetime: double_t): int32_t; stdcall; public name 'timezone_get_active_bias_ex';

function timezone_get_standard_name(timezone: PTIMEZONE_ENTRY; name: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'timezone_get_standard_name';
function timezone_get_standard_bias(timezone: PTIMEZONE_ENTRY): int32_t; stdcall; public name 'timezone_get_standard_bias';
function timezone_get_standard_date(timezone: PTIMEZONE_ENTRY; next: BOOL): double_t; stdcall; public name 'timezone_get_standard_date';
function timezone_get_standard_start(timezone: PTIMEZONE_ENTRY): SYSTEMTIME; stdcall; public name 'timezone_get_standard_start';

function timezone_get_daylight_name(timezone: PTIMEZONE_ENTRY; name: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'timezone_get_daylight_name';
function timezone_get_daylight_bias(timezone: PTIMEZONE_ENTRY): int32_t; stdcall; public name 'timezone_get_daylight_bias';
function timezone_get_daylight_date(timezone: PTIMEZONE_ENTRY; next: BOOL): double_t; stdcall; public name 'timezone_get_daylight_date';
function timezone_get_daylight_start(timezone: PTIMEZONE_ENTRY): SYSTEMTIME; stdcall; public name 'timezone_get_daylight_start';

function timezone_find(const name: PCHAR): PTIMEZONE_ENTRY; stdcall; public name 'timezone_find';
function timezone_find_by_standard(const standardname: PCHAR): PTIMEZONE_ENTRY; stdcall; public name 'timezone_find_by_standard';
function timezone_find_by_daylight(const daylightname: PCHAR): PTIMEZONE_ENTRY; stdcall; public name 'timezone_find_by_daylight';

function timezone_enumerate(callback: timezone_enumerate_cb; data: PVOID): uint32_t; stdcall; public name 'timezone_enumerate';

{==============================================================================}
{Timezone Helper Functions}
function timezone_get_count: uint32_t; stdcall; public name 'timezone_get_count';
function timezone_get_default: PTIMEZONE_ENTRY; stdcall; public name 'timezone_get_default';
function timezone_set_default(timezone: PTIMEZONE_ENTRY): uint32_t; stdcall; public name 'timezone_set_default';

function timezone_check(timezone: PTIMEZONE_ENTRY): PTIMEZONE_ENTRY; stdcall; public name 'timezone_check';

function timezone_update_offset: uint32_t; stdcall; public name 'timezone_update_offset';

function timezone_start_to_date_time(const start: SYSTEMTIME; year: uint16_t): double_t; stdcall; public name 'timezone_start_to_date_time';
function timezone_start_to_description(const start: SYSTEMTIME; description: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'timezone_start_to_description';
{$ENDIF}
{==============================================================================}
{Locale Functions}
{$IFDEF API_EXPORT_LOCALE}
function IsValidCodePage(codepage: UINT): BOOL; stdcall; public name 'IsValidCodePage';

function GetACP: UINT; stdcall; public name 'GetACP';
function GetOEMCP: UINT; stdcall; public name 'GetOEMCP';

function SetACP(codepage: UINT): BOOL; stdcall; public name 'SetACP';
function SetOEMCP(codepage: UINT): BOOL; stdcall; public name 'SetOEMCP';

function GetConsoleCP: UINT; stdcall; public name 'GetConsoleCP';
function SetConsoleCP(wcodepageid: UINT): BOOL; stdcall; public name 'SetConsoleCP';

function GetConsoleOutputCP: UINT; stdcall; public name 'GetConsoleOutputCP';
function SetConsoleOutputCP(wcodepageid: UINT): BOOL; stdcall; public name 'SetConsoleOutputCP';

function GetCPInfo(codepage: UINT; var lpcpinfo: CPINFO): BOOL; stdcall; public name 'GetCPInfo';

function GetCPInfoEx(codepage: UINT; dwflags: uint32_t; var lpcpinfoex: CPINFOEXA): BOOL; stdcall; public name 'GetCPInfoEx';
function GetCPInfoExA(codepage: UINT; dwflags: uint32_t; var lpcpinfoex: CPINFOEXA): BOOL; stdcall; public name 'GetCPInfoExA';
function GetCPInfoExW(codepage: UINT; dwflags: uint32_t; var lpcpinfoex: CPINFOEXW): BOOL; stdcall; public name 'GetCPInfoExW';

function IsValidLocale(_locale: LCID; dwflags: uint32_t): BOOL; stdcall; public name 'IsValidLocale';

function GetSystemDefaultLCID: LCID; stdcall; public name 'GetSystemDefaultLCID';
function GetUserDefaultLCID: LCID; stdcall; public name 'GetUserDefaultLCID';

function SetSystemDefaultLCID(_locale: LCID): BOOL; stdcall; public name 'SetSystemDefaultLCID';

function GetSystemDefaultLangID: LANGID; stdcall; public name 'GetSystemDefaultLangID';
function GetUserDefaultLangID: LANGID; stdcall; public name 'GetUserDefaultLangID';

{==============================================================================}
{Locale Helper Functions}
function map_page(codepage: UINT): uint16_t; stdcall; public name 'map_page';
function get_page(pageid: uint16_t): PCODE_PAGE; stdcall; public name 'get_page';
function check_page(page: PCODE_PAGE): BOOL; stdcall; public name 'check_page';

function link_page(page: PCODE_PAGE): BOOL; stdcall; public name 'link_page';
function unlink_page(page: PCODE_PAGE): BOOL; stdcall; public name 'unlink_page';

function load_page(pageid: uint16_t; table: PCODE_TABLE; lower: PLOWER_TABLE; upper: PUPPER_TABLE): BOOL; stdcall; public name 'load_page';
function unload_page(pageid: uint16_t; page: PCODE_PAGE): BOOL; stdcall; public name 'unload_page';

function default_trans(pageid, transid: uint16_t): BOOL; stdcall; public name 'default_trans';
function install_trans(pageid: uint16_t; table: PTRANS_TABLE): BOOL; stdcall; public name 'install_trans';
{$ENDIF}
{==============================================================================}
{Unicode Functions}
{$IFDEF API_EXPORT_UNICODE}
function MultiByteToWideChar(codepage: UINT; dwflags: uint32_t; lpmultibytestr: LPCSTR; cbmultibyte: int; lpwidecharstr: LPWSTR; cchwidechar: int): int; stdcall; public name 'MultiByteToWideChar';
function WideCharToMultiByte(codepage: UINT; dwflags: uint32_t; lpwidecharstr: LPCWSTR; cchwidechar: int; lpmultibytestr: LPSTR; cbmultibyte: int; lpdefaultchar: LPCSTR; lpuseddefaultchar: LPBOOL): int; stdcall; public name 'WideCharToMultiByte';

function CompareString(locale: LCID; dwcmpflags: uint32_t; lpstring1: LPCSTR; cchcount1: int; lpstring2: LPCSTR; cchcount2: int): int; stdcall; public name 'CompareString';
function CompareStringA(locale: LCID; dwcmpflags: uint32_t; lpstring1: LPCSTR; cchcount1: int; lpstring2: LPCSTR; cchcount2: int): int; stdcall; public name 'CompareStringA';
function CompareStringW(locale: LCID; dwcmpflags: uint32_t; lpstring1: LPCWSTR; cchcount1: int; lpstring2: LPCWSTR; cchcount2: int): int; stdcall; public name 'CompareStringW';

function CharUpper(lpsz: LPSTR): LPSTR; stdcall; public name 'CharUpper';
function CharUpperA(lpsz: LPSTR): LPSTR; stdcall; public name 'CharUpperA';
function CharUpperW(lpsz: LPWSTR): LPWSTR; stdcall; public name 'CharUpperW';

function CharUpperBuff(lpsz: LPSTR; cchlength: uint32_t): uint32_t; stdcall; public name 'CharUpperBuff';
function CharUpperBuffA(lpsz: LPSTR; cchlength: uint32_t): uint32_t; stdcall; public name 'CharUpperBuffA';
function CharUpperBuffW(lpsz: LPWSTR; cchlength: uint32_t): uint32_t; stdcall; public name 'CharUpperBuffW';

function CharLower(lpsz: LPSTR): LPSTR; stdcall; public name 'CharLower';
function CharLowerA(lpsz: LPSTR): LPSTR; stdcall; public name 'CharLowerA';
function CharLowerW(lpsz: LPWSTR): LPWSTR; stdcall; public name 'CharLowerW';

function CharLowerBuff(lpsz: LPSTR; cchlength: uint32_t): uint32_t; stdcall; public name 'CharLowerBuff';
function CharLowerBuffA(lpsz: LPSTR; cchlength: uint32_t): uint32_t; stdcall; public name 'CharLowerBuffA';
function CharLowerBuffW(lpsz: LPWSTR; cchlength: uint32_t): uint32_t; stdcall; public name 'CharLowerBuffW';

function AnsiToOem(lpszsrc: LPCSTR; lpszdst: LPSTR): BOOL; stdcall; public name 'AnsiToOem';
function AnsiToOemBuff(lpszsrc: LPCSTR; lpszdst: LPSTR; cchdstlength: uint32_t): BOOL; stdcall; public name 'AnsiToOemBuff';
function OemToAnsi(lpszsrc: LPCSTR; lpszdst: LPSTR): BOOL; stdcall; public name 'OemToAnsi';
function OemToAnsiBuff(lpszsrc: LPCSTR; lpszdst: LPSTR; cchdstlength: uint32_t): BOOL; stdcall; public name 'OemToAnsiBuff';

function CharToOem(lpszsrc: LPCSTR; lpszdst: LPSTR): BOOL; stdcall; public name 'CharToOem';
function CharToOemA(lpszsrc: LPCSTR; lpszdst: LPSTR): BOOL; stdcall; public name 'CharToOemA';
function CharToOemW(lpszsrc: LPCWSTR; lpszdst: LPSTR): BOOL; stdcall; public name 'CharToOemW';

function OemToChar(lpszsrc: LPCSTR; lpszdst: LPSTR): BOOL; stdcall; public name 'OemToChar';
function OemToCharA(lpszsrc: LPCSTR; lpszdst: LPSTR): BOOL; stdcall; public name 'OemToCharA';
function OemToCharW(lpszsrc: LPCSTR; lpszdst: LPWSTR): BOOL; stdcall; public name 'OemToCharW';

function CharToOemBuff(lpszsrc: LPCSTR; lpszdst: LPSTR; cchdstlength: uint32_t): BOOL; stdcall; public name 'CharToOemBuff';
function CharToOemBuffA(lpszsrc: LPCSTR; lpszdst: LPSTR; cchdstlength: uint32_t): BOOL; stdcall; public name 'CharToOemBuffA';
function CharToOemBuffW(lpszsrc: LPCWSTR; lpszdst: LPSTR; cchdstlength: uint32_t): BOOL; stdcall; public name 'CharToOemBuffW';

function OemToCharBuff(lpszsrc: LPCSTR; lpszdst: LPSTR; cchdstlength: uint32_t): BOOL; stdcall; public name 'OemToCharBuff';
function OemToCharBuffA(lpszsrc: LPCSTR; lpszdst: LPSTR; cchdstlength: uint32_t): BOOL; stdcall; public name 'OemToCharBuffA';
function OemToCharBuffW(lpszsrc: LPCSTR; lpszdst: LPWSTR; cchdstlength: uint32_t): BOOL; stdcall; public name 'OemToCharBuffW';
{$ENDIF}
{==============================================================================}
{TFTFramebuffer Functions}
{$IFDEF API_EXPORT_TFTFRAMEBUFFER}
function tft_framebuffer_allocate(framebuffer: PFRAMEBUFFER_DEVICE; properties: PFRAMEBUFFER_PROPERTIES): uint32_t; stdcall; public name 'tft_framebuffer_allocate';
function tft_framebuffer_release(framebuffer: PFRAMEBUFFER_DEVICE): uint32_t; stdcall; public name 'tft_framebuffer_release';

function tft_framebuffer_mark(framebuffer: PFRAMEBUFFER_DEVICE; x, y, width, height, flags: uint32_t): uint32_t; stdcall; public name 'tft_framebuffer_mark';
function tft_framebuffer_commit(framebuffer: PFRAMEBUFFER_DEVICE; address: SIZE_T; size, flags: uint32_t): uint32_t; stdcall; public name 'tft_framebuffer_commit';

procedure tft_framebuffer_update_display(framebuffer: PTFT_FRAMEBUFFER); stdcall; public name 'tft_framebuffer_update_display';
{$ENDIF}
{==============================================================================}
{FileSystem Functions (Ultibo)}
{$IFDEF API_EXPORT_FILESYSTEM}
function file_sys_start: uint32_t; stdcall; public name 'file_sys_start';
function file_sys_stop: uint32_t; stdcall; public name 'file_sys_stop';

function file_sys_start_completed: BOOL; stdcall; public name 'file_sys_start_completed';

procedure file_sys_async_start(data: PVOID); stdcall; public name 'file_sys_async_start';

{Drive Functions}
{function GetPathDrive(const path: PCHAR): uint8_t; stdcall; public name 'GetPathDrive';} {Exported in Ultibo}
{function GetDriveType(drive: uint8_t): TDRIVE_TYPE; stdcall; public name 'GetDriveType';} {Exported in Ultibo}
{procedure GetDriveData(drive: uint8_t; var data: TDRIVE_DATA); stdcall; public name 'GetDriveData';} {Exported in Ultibo}
{function GetDriveAttr(drive: uint8_t): uint32_t; stdcall; public name 'GetDriveAttr';} {Exported in Ultibo}
{function GetDriveLabel(drive: uint8_t; _label: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'GetDriveLabel';} {Exported in Ultibo}
{function SetDriveLabel(drive: uint8_t; const _label: PCHAR): BOOL; stdcall; public name 'SetDriveLabel';} {Exported in Ultibo}
{function GetDriveSerial(drive: uint8_t): uint32_t; stdcall; public name 'GetDriveSerial';} {Exported in Ultibo}
{function SetDriveSerial(drive: uint8_t; serial: uint32_t): BOOL; stdcall; public name 'SetDriveSerial';} {Exported in Ultibo}
{function IsDriveValid(drive: uint8_t): BOOL; stdcall; public name 'IsDriveValid';} {Exported in Ultibo}
{function GetValidDrives: uint32_t; stdcall; public name 'GetValidDrives';} {Exported in Ultibo}
{function GetValidDriveNames(names: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'GetValidDriveNames';} {Exported in Ultibo}
{function GetDriveFreeSpace(drive: uint8_t): uint32_t; stdcall; public name 'GetDriveFreeSpace';} {Exported in Ultibo}
{function GetDriveFreeSpaceEx(drive: uint8_t): int64_t; stdcall; public name 'GetDriveFreeSpaceEx';} {Exported in Ultibo}
{function GetDriveTotalSpace(drive: uint8_t): uint32_t; stdcall; public name 'GetDriveTotalSpace';} {Exported in Ultibo}
{function GetDriveTotalSpaceEx(drive: uint8_t): int64_t; stdcall; public name 'GetDriveTotalSpaceEx';} {Exported in Ultibo}

{function GetDriveInformation(const path: PCHAR; var clustersize: uint32_t; var totalclustercount, freeclustercount: int64_t): BOOL; stdcall; public name 'GetDriveInformation';} {Exported in Ultibo}

{function GetCurrentDrive: uint8_t; stdcall; public name 'GetCurrentDrive';} {Exported in Ultibo}
{function SetCurrentDrive(const drive: PCHAR): BOOL; stdcall; public name 'SetCurrentDrive';} {Exported in Ultibo}

{File Functions}
function FileOpen(const filename: PCHAR; mode: int): THANDLE; stdcall; public name 'FileOpen';
function FileCreate(const filename: PCHAR): THANDLE; stdcall; public name 'FileCreate';
{function DeleteFile(const filename: PCHAR): BOOL; stdcall; public name 'DeleteFile';} {Exported in Ultibo}
procedure FileClose(handle: THANDLE); stdcall; public name 'FileClose';
function RenameFile(const oldname, newname: PCHAR): BOOL; stdcall; public name 'RenameFile';
function FileSeek(handle: THANDLE; offset, origin: int32_t): int32_t; stdcall; public name 'FileSeek';
function FileFlush(handle: THANDLE): BOOL; stdcall; public name 'FileFlush';
function FileTruncate(handle: THANDLE): BOOL; stdcall; public name 'FileTruncate';
{function SetEndOfFile(handle: THANDLE): BOOL; stdcall; public name 'SetEndOfFile';} {Exported in Ultibo}

function EndOfFile(handle: THANDLE): BOOL; stdcall; public name 'EndOfFile';
function FilePos(handle: THANDLE): int32_t; stdcall; public name 'FilePos';
function FileSize(handle: THANDLE): int32_t; stdcall; public name 'FileSize';

function FileAge(const filename: PCHAR): int; stdcall; public name 'FileAge';
function FileExists(const filename: PCHAR): BOOL; stdcall; public name 'FileExists';
function FileGetAttr(const filename: PCHAR): int; stdcall; public name 'FileGetAttr';
function FileGetDate(handle: THANDLE): int; stdcall; public name 'FileGetDate';
function FileSetAttr(const filename: PCHAR; attr: int): int; stdcall; public name 'FileSetAttr';
function FileSetDate(handle: THANDLE; age: int): int; stdcall; public name 'FileSetDate';

function FileRead(handle: THANDLE; buffer: PVOID; count: int32_t): int32_t; stdcall; public name 'FileRead';
function FileWrite(handle: THANDLE; buffer: PVOID; count: int32_t): int32_t; stdcall; public name 'FileWrite';

{Directory Functions}
function CreateDir(const dirname: PCHAR): BOOL; stdcall; public name 'CreateDir';
function RemoveDir(const dirname: PCHAR): BOOL; stdcall; public name 'RemoveDir';
function RenameDir(const oldname, newname: PCHAR): BOOL; stdcall; public name 'RenameDir';
function GetCurrentDir(dirname: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'GetCurrentDir';
function SetCurrentDir(const dirname: PCHAR): BOOL; stdcall; public name 'SetCurrentDir';
function DirectoryExists(const dirname: PCHAR): BOOL; stdcall; public name 'DirectoryExists';
procedure ForceDirectories(dirname: PCHAR); stdcall; public name 'ForceDirectories';
procedure DeleteTree(const dirname: PCHAR); stdcall; public name 'DeleteTree';

{Search Functions}

{Additional Functions}
function FileCopy(const sourcefile, destfile: PCHAR; failifexists: BOOL): BOOL; stdcall; public name 'FileCopy';
function FileCopyEx(const sourcefile, destfile: PCHAR; failifexists: BOOL; usesourcedate: BOOL; destdate: int; usesourceattr: BOOL; destattr: int): BOOL; stdcall; public name 'FileCopyEx';

function GetShortName(const filename: PCHAR; shortname: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'GetShortName';
function GetLongName(const filename: PCHAR; longname: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'GetLongName';
function GetTrueName(const filename: PCHAR; truename: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'GetTrueName';

{Extended Functions}
function FileSeekEx(handle: THANDLE; const offset: int64_t; origin: int32_t): int64_t; stdcall; public name 'FileSeekEx';

function EndOfFileEx(handle: THANDLE): BOOL; stdcall; public name 'EndOfFileEx';
function FilePosEx(handle: THANDLE): int64_t; stdcall; public name 'FilePosEx';
function FileSizeEx(handle: THANDLE): int64_t; stdcall; public name 'FileSizeEx';

function FileAgeEx(const filename: PCHAR): FILETIME; stdcall; public name 'FileAgeEx';

function FileGetAttrEx(handle: THANDLE): int; stdcall; public name 'FileGetAttrEx';

function FileGetDateEx(handle: THANDLE): FILETIME; stdcall; public name 'FileGetDateEx';
function FileSetDateEx(handle: THANDLE; age: FILETIME): int; stdcall; public name 'FileSetDateEx';

{function GetFileTime(handle: THANDLE; createtime, accesstime, writetime: PFILETIME): BOOL; stdcall; public name 'GetFileTime';} {Exported in Ultibo}
{function SetFileTime(handle: THANDLE; createtime, accesstime, writetime: PFILETIME): BOOL; stdcall; public name 'SetFileTime';} {Exported in Ultibo}

function FindFirstEx(const path: PCHAR; var searchrec: TFILE_SEARCH_REC): int; stdcall; public name 'FindFirstEx';
function FindNextEx(var searchrec: TFILE_SEARCH_REC): int; stdcall; public name 'FindNextEx';
procedure FindCloseEx(var searchrec: TFILE_SEARCH_REC); stdcall; public name 'FindCloseEx';

{==============================================================================}
{FileSystem Functions (Win32 Compatibility)}
{Drive Functions}
{function DefineDosDevice(dwflags: uint32_t; const lpdevicename, lptargetpath: LPCSTR): BOOL; stdcall; public name 'DefineDosDevice';} {Exported in Ultibo}
{function GetDiskType(const lprootpathname: LPCSTR): UINT; stdcall; public name 'GetDiskType'; // GetDriveType - Already defined above} {Exported in Ultibo}
{function GetDiskFreeSpace(const lprootpathname: LPCSTR; var lpsectorspercluster, lpbytespersector, lpnumberoffreeclusters, lptotalnumberofclusters: uint32_t): BOOL; stdcall; public name 'GetDiskFreeSpace';} {Exported in Ultibo}
{function GetDiskFreeSpaceEx(const lpdirectoryname: LPCSTR; var lpfreebytesavailabletocaller, lptotalnumberofbytes: ULARGE_INTEGER; lptotalnumberoffreebytes: PULARGE_INTEGER): BOOL; stdcall; public name 'GetDiskFreeSpaceEx';} {Exported in Ultibo}
{function GetLogicalDrives: uint32_t; stdcall; public name 'GetLogicalDrives';} {Exported in Ultibo}
{function GetLogicalDriveStrings(nbufferlength: uint32_t; lpbuffer: LPSTR): uint32_t; stdcall; public name 'GetLogicalDriveStrings';} {Exported in Ultibo}
{function GetVolumeInformation(const lprootpathname: LPCSTR; lpvolumenamebuffer: LPSTR; nvolumenamesize: uint32_t; lpvolumeserialnumber: LPDWORD; var lpmaximumcomponentlength, lpfilesystemflags: uint32_t; lpfilesystemnamebuffer: LPSTR; nfilesystemnamesize: uint32_t): BOOL; stdcall; public name 'GetVolumeInformation';} {Exported in Ultibo}
{function QueryDosDevice(const lpdevicename: LPCSTR; lptargetpath: LPSTR; ucchmax: uint32_t): uint32_t; stdcall; public name 'QueryDosDevice';} {Exported in Ultibo}
{function SetVolumeLabel(const lprootpathname, lpvolumename: LPCSTR): BOOL; stdcall; public name 'SetVolumeLabel';} {Exported in Ultibo}

{File Functions}
{function AreFileApisANSI: BOOL; stdcall; public name 'AreFileApisANSI';} {Exported in Ultibo}
{function CloseHandle(hobject: HANDLE): BOOL; stdcall; public name 'CloseHandle';} {Exported in Ultibo}
{function CopyFile(const lpexistingfilename, lpnewfilename: LPCSTR; bfailifexists: BOOL): BOOL; stdcall; public name 'CopyFile';} {Exported in Ultibo}
{function CreateFile(const lpfilename: LPCSTR; dwdesiredaccess, dwsharemode: uint32_t; lpsecurityattributes: LPSECURITY_ATTRIBUTES; dwcreationdisposition: uint32_t; dwflagsandattributes: uint32_t; htemplatefile: HANDLE): HANDLE; stdcall; public name 'CreateFile';} {Exported in Ultibo}
{function FindCloseFile(hfindfile: HANDLE): BOOL; stdcall; public name 'FindCloseFile';} {Exported in Ultibo}
{function FindFirstFile(const lpfilename: LPCSTR; var lpfindfiledata: WIN32_FIND_DATAA): HANDLE; stdcall; public name 'FindFirstFile';} {Exported in Ultibo}
{function FindNextFile(hfindfile: HANDLE; var lpfindfiledata: WIN32_FIND_DATAA): BOOL; stdcall; public name 'FindNextFile';} {Exported in Ultibo}
{function FlushFileBuffers(hfile: HANDLE): BOOL; stdcall; public name 'FlushFileBuffers';} {Exported in Ultibo}
{function GetFileAttributes(const lpfilename: LPCSTR): uint32_t; stdcall; public name 'GetFileAttributes';} {Exported in Ultibo}
{function GetFileInformationByHandle(hfile: HANDLE; var lpfileinformation: BY_HANDLE_FILE_INFORMATION): BOOL; stdcall; public name 'GetFileInformationByHandle';} {Exported in Ultibo}
{function GetFileSize(hfile: HANDLE; lpfilesizehigh: LPDWORD): uint32_t; stdcall; public name 'GetFileSize';} {Exported in Ultibo}
{function GetFullPathName(const lpfilename: LPCSTR; nbufferlength: uint32_t; lpbuffer: LPSTR; var lpfilepart: LPSTR): uint32_t; stdcall; public name 'GetFullPathName';} {Exported in Ultibo}
{function GetShortPathName(const lpszlongpath: LPCSTR; lpszshortpath: LPSTR; cchbuffer: uint32_t): uint32_t; stdcall; public name 'GetShortPathName';} {Exported in Ultibo}
{function MoveFile(const lpexistingfilename, lpnewfilename: LPCSTR): BOOL; stdcall; public name 'MoveFile';} {Exported in Ultibo}
{function ReadFile(hfile: HANDLE; lpbuffer: LPVOID; nnumberofbytestoread: uint32_t; lpnumberofbytesread: LPDWORD; lpoverlapped: LPOVERLAPPED): BOOL; stdcall; public name 'ReadFile';} {Exported in Ultibo}
{procedure SetFileApisToANSI; stdcall; public name 'SetFileApisToANSI';} {Exported in Ultibo}
{procedure SetFileApisToOEM; stdcall; public name 'SetFileApisToOEM';} {Exported in Ultibo}
{function SetFileAttributes(const lpfilename: LPCSTR; dwfileattributes: uint32_t): BOOL; stdcall; public name 'SetFileAttributes';} {Exported in Ultibo}
{function SetFilePointer(hfile: HANDLE; ldistancetomove: LONG; lpdistancetomovehigh: PLONG; dwmovemethod: uint32_t): uint32_t; stdcall; public name 'SetFilePointer';} {Exported in Ultibo}
{function SetFilePointerEx(hfile: HANDLE; lidistancetomove: LARGE_INTEGER; lpnewfilepointer: PLARGE_INTEGER; dwmovemethod: uint32_t): BOOL; stdcall; public name 'SetFilePointerEx';} {Exported in Ultibo}
{function WriteFile(hfile: HANDLE; lpbuffer: LPCVOID; nnumberofbytestowrite: uint32_t; lpnumberofbyteswritten: LPDWORD; lpoverlapped: LPOVERLAPPED): BOOL; stdcall; public name 'WriteFile';} {Exported in Ultibo}
{function GetLongPathName(const lpszshortpath: LPCSTR; lpszlongpath: LPSTR; cchbuffer: uint32_t): uint32_t; stdcall; public name 'GetLongPathName';} {Exported in Ultibo}
{function GetFinalPathNameByHandle(hfile: HANDLE; lpszfilepath: LPSTR; cchfilepath, dwflags: uint32_t): uint32_t; stdcall; public name 'GetFinalPathNameByHandle';} {Exported in Ultibo}

{function SetFileShortName(hfile: HANDLE; const lpshortname: LPCSTR): BOOL; stdcall; public name 'SetFileShortName';} {Exported in Ultibo}
{function CreateHardLink(const lpfilename, lpexistingfilename: LPCSTR; lpsecurityattributes: LPSECURITY_ATTRIBUTES): BOOL; stdcall; public name 'CreateHardLink';} {Exported in Ultibo}
{function CreateSymbolicLink(const lpsymlinkfilename, lptargetfilename: LPCSTR; dwflags: uint32_t): BOOL; stdcall; public name 'CreateSymbolicLink';} {Exported in Ultibo}

{Directory Functions}
{function CreateDirectory(const lppathname: LPCSTR; lpsecurityattributes: LPSECURITY_ATTRIBUTES): BOOL; stdcall; public name 'CreateDirectory';} {Exported in Ultibo}
{function GetCurrentDirectory(nbufferlength: uint32_t; lpbuffer: LPSTR): uint32_t; stdcall; public name 'GetCurrentDirectory';} {Exported in Ultibo}
{function RemoveDirectory(const lppathname: LPCSTR): BOOL; stdcall; public name 'RemoveDirectory';} {Exported in Ultibo}
{function SetCurrentDirectory(const lppathname: LPCSTR): BOOL; stdcall; public name 'SetCurrentDirectory';} {Exported in Ultibo}

{==============================================================================}
{FileSystem Helper Functions}
function file_sys_redirect_input(handle: THANDLE): BOOL; stdcall; public name 'file_sys_redirect_input';
function file_sys_redirect_output(handle: THANDLE): BOOL; stdcall; public name 'file_sys_redirect_output';

function compare_partitions(partition1, partition2: PVOID): int; stdcall; public name 'compare_partitions';

function disk_media_type_to_string(_type: TMEDIA_TYPE; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'disk_media_type_to_string';
function floppy_type_to_string(_type: TFLOPPY_TYPE; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'floppy_type_to_string';
function image_type_to_string(_type: TIMAGE_TYPE; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'image_type_to_string';

function drive_type_to_string(_type: TDRIVE_TYPE; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'drive_type_to_string';

function file_sys_type_to_string(_type: TFILE_SYS_TYPE; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'file_sys_type_to_string';
function string_to_file_sys_type(filesystype: PCHAR): TFILE_SYS_TYPE; stdcall; public name 'string_to_file_sys_type';

function partition_id_to_string(id: uint8_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'partition_id_to_string';
function string_to_partition_id(partitionid: PCHAR): uint8_t; stdcall; public name 'string_to_partition_id';

function cache_mode_to_string(cachemode: TCACHE_MODE; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'cache_mode_to_string';
function cache_state_to_string(cachestate: TCACHE_STATE; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'cache_state_to_string';
{$ENDIF}
{==============================================================================}
{Winsock Functions}
{$IFDEF API_EXPORT_WINSOCK}
function WSStart: BOOL; stdcall; public name 'WSStart';
function WSStop: BOOL; stdcall; public name 'WSStop';

procedure WSAsyncStart(data: PVOID); stdcall; public name 'WSAsyncStart';

function accept(s: TSOCKET; addr: PSockAddr; addrlen: ptOS_INT): TSOCKET; stdcall; public name 'accept';
function bind(s: TSOCKET; addr: PSockaddr; namelen: tOS_INT): tOS_INT; stdcall; public name 'bind';
function closesocket(s: TSOCKET): tOS_INT; stdcall; public name 'closesocket';
function connect(s: TSOCKET; name: PSockAddr; namelen: tOS_INT): tOS_INT; stdcall; public name 'connect';
function ioctlsocket(s: TSOCKET; cmd: int32_t; arg: pu_long): tOS_INT; stdcall; public name 'ioctlsocket';
function getpeername(s: TSOCKET; name: PSockaddr; namelen: ptOS_INT): tOS_INT; stdcall; public name 'getpeername';
function getsockname(s: TSOCKET; name: PSockaddr; namelen: ptOS_INT): tOS_INT; stdcall; public name 'getsockname';
function getsockopt(s: TSOCKET; level: tOS_INT; optname: tOS_INT; optval: PCHAR; optlen: ptOS_INT): tOS_INT; stdcall; public name 'getsockopt';
function htonl(hostlong: u_long): u_long; stdcall; public name 'htonl';
function htons(hostshort: u_short): u_short; stdcall; public name 'htons';
function inet_addr(const cp: PCHAR): u_long; stdcall; public name 'inet_addr';
function inet_ntoa(inaddr: TInAddr): PCHAR; stdcall; public name 'inet_ntoa';
function listen(s: TSOCKET; backlog: tOS_INT): tOS_INT; stdcall; public name 'listen';
function ntohl(netlong: u_long): u_long; stdcall; public name 'ntohl';
function ntohs(netshort: u_short): u_short; stdcall; public name 'ntohs';
function recv(s: TSOCKET; buf: PCHAR; len: tOS_INT; flags: tOS_INT): tOS_INT; stdcall; public name 'recv';
function recvfrom(s: TSOCKET; buf: PCHAR; len: tOS_INT; flags: tOS_INT; from: PSockAddr; fromlen: ptOS_INT): tOS_INT; stdcall; public name 'recvfrom';
function select(nfds: tOS_INT; readfds, writefds, exceptfds: PFDSet; timeout: PTimeVal): tOS_INT; stdcall; public name 'select';
function send(s: TSOCKET; const buf: PCHAR; len: tOS_INT; flags: tOS_INT): tOS_INT; stdcall; public name 'send';
function sendto(s: TSOCKET; const buf: PCHAR; len: tOS_INT; flags: tOS_INT; toaddr: PSockAddr; tolen: tOS_INT): tOS_INT; stdcall; public name 'sendto';
function setsockopt(s: TSOCKET; level: tOS_INT; optname: tOS_INT; const optval: PCHAR; optlen: tOS_INT): tOS_INT; stdcall; public name 'setsockopt';
function shutdown(s: TSOCKET; how: tOS_INT): tOS_INT; stdcall; public name 'shutdown';
function socket(af: tOS_INT; struct: tOS_INT; protocol: tOS_INT): TSOCKET; stdcall; public name 'socket';

function gethostbyaddr(const addr: PCHAR; len: tOS_INT; family: tOS_INT): PHostEnt; stdcall; public name 'gethostbyaddr';
function gethostbyname(const name: PCHAR): PHostEnt; stdcall; public name 'gethostbyname';
function gethostname(name: PCHAR; namelen: tOS_INT): tOS_INT; stdcall; public name 'gethostname';
function getservbyport(port: tOS_INT; const proto: PCHAR): PServEnt; stdcall; public name 'getservbyport';
function getservbyname(const name, proto: PCHAR): PServEnt; stdcall; public name 'getservbyname';
function getprotobynumber(proto: tOS_INT): PProtoEnt; stdcall; public name 'getprotobynumber';
function getprotobyname(const name: PCHAR): PProtoEnt; stdcall; public name 'getprotobyname';

function WSAStartup(wversionrequired: uint16_t; var wsadata: TWSADATA): tOS_INT; stdcall; public name 'WSAStartup';
function WSACleanup: tOS_INT; stdcall; public name 'WSACleanup';
procedure WSASetLastError(ierror: tOS_INT); stdcall; public name 'WSASetLastError';
function WSAGetLastError: tOS_INT; stdcall; public name 'WSAGetLastError';
function WSAIsBlocking: BOOL; stdcall; public name 'WSAIsBlocking';
function WSAUnhookBlockingHook: tOS_INT; stdcall; public name 'WSAUnhookBlockingHook';
function WSASetBlockingHook(lpblockfunc: TFarProc): TFarProc; stdcall; public name 'WSASetBlockingHook';
function WSACancelBlockingCall: tOS_INT; stdcall; public name 'WSACancelBlockingCall';
function WSAAsyncGetServByName(hwnd: HWND; wmsg: u_int; const name: PCHAR; const proto: PCHAR; buf: PCHAR; buflen: tOS_INT): THANDLE; stdcall; public name 'WSAAsyncGetServByName';
function WSAAsyncGetServByPort(hwnd: HWND; wmsg: u_int; port: tOS_INT; proto: PCHAR; buf: PCHAR; buflen: tOS_INT): THANDLE; stdcall; public name 'WSAAsyncGetServByPort';
function WSAAsyncGetProtoByName(hwnd: HWND; wmsg: u_int; const name: PCHAR; buf: PCHAR; buflen: tOS_INT): THANDLE; stdcall; public name 'WSAAsyncGetProtoByName';
function WSAAsyncGetProtoByNumber(hwnd: HWND; wmsg: u_int; number: tOS_INT; buf: PCHAR; buflen: tOS_INT): THANDLE; stdcall; public name 'WSAAsyncGetProtoByNumber';
function WSAAsyncGetHostByName(hwnd: HWND; wmsg: u_int; const name: PCHAR; buf: PCHAR; buflen: tOS_INT): THANDLE; stdcall; public name 'WSAAsyncGetHostByName';
function WSAAsyncGetHostByAddr(hwnd: HWND; wmsg: u_int; const addr: PCHAR; len: tOS_INT; family: tOS_INT; buf: PCHAR; buflen: tOS_INT): THANDLE; stdcall; public name 'WSAAsyncGetHostByAddr';
function WSACancelAsyncRequest(hasynctaskhandle: THANDLE): tOS_INT; stdcall; public name 'WSACancelAsyncRequest';
function WSAAsyncSelect(s: TSOCKET; hwnd: HWND; wmsg: u_int; levent: int32_t): tOS_INT; stdcall; public name 'WSAAsyncSelect'; //  really a c-long
function WSARecvEx(s: TSOCKET; buf: PVOID; len: tOS_INT; flags: ptOS_INT): tOS_INT; stdcall; public name 'WSARecvEx';
function __WSAFDIsSet(s: TSOCKET; var fdset: TFDSet): BOOL; stdcall; public name '__WSAFDIsSet';
function __WSAFDIsSet_(s: TSOCKET; var fdset: TFDSet): tOS_INT; stdcall; public name '__WSAFDIsSet_';

function TransmitFile(hsocket: TSOCKET; hfile: THANDLE; nnumberofbytestowrite: uint32_t; nnumberofbytespersend: uint32_t; lpoverlapped: POverlapped; lptransmitbuffers: PTransmitFileBuffers; dwreserved: uint32_t): BOOL; stdcall; public name 'TransmitFile';

function AcceptEx(slistensocket, sacceptsocket: TSOCKET; lpoutputbuffer: PVOID; dwreceivedatalength, dwlocaladdresslength, dwremoteaddresslength: uint32_t; var lpdwbytesreceived: uint32_t; lpoverlapped: POverlapped): BOOL; stdcall; public name 'AcceptEx';

procedure GetAcceptExSockaddrs(lpoutputbuffer: PVOID; dwreceivedatalength, dwlocaladdresslength, dwremoteaddresslength: uint32_t; var localsockaddr: PSockAddr; var localsockaddrlength: int; var remotesockaddr: PSockAddr; var remotesockaddrlength: int); stdcall; public name 'GetAcceptExSockaddrs';

function WSAMakeSyncReply(buflen, error: uint16_t): uint32_t; stdcall; public name 'WSAMakeSyncReply';
function WSAMakeSelectReply(event, error: uint16_t): uint32_t; stdcall; public name 'WSAMakeSelectReply';
function WSAGetAsyncBuflen(param: uint32_t): uint16_t; stdcall; public name 'WSAGetAsyncBuflen';
function WSAGetAsyncError(param: uint32_t): uint16_t; stdcall; public name 'WSAGetAsyncError';
function WSAGetSelectEvent(param: uint32_t): uint16_t; stdcall; public name 'WSAGetSelectEvent';
function WSAGetSelectError(param: uint32_t): uint16_t; stdcall; public name 'WSAGetSelectError';

procedure FD_CLR(socket: TSOCKET; var fdset: TFDSet); stdcall; public name 'FD_CLR';
function FD_ISSET(socket: TSOCKET; var fdset: TFDSet): BOOL; stdcall; public name 'FD_ISSET';
procedure FD_SET(socket: TSOCKET; var fdset: TFDSet); stdcall; public name 'FD_SET';
procedure FD_ZERO(var fdset: TFDSet); stdcall; public name 'FD_ZERO';

{==============================================================================}
{Winsock Undocumented Functions}
function WsControl(proto: uint32_t; action: uint32_t; prequestinfo: PVOID; var pcbrequestinfolen: uint32_t; presponseinfo: PVOID; var pcbresponseinfolen: uint32_t): int; stdcall; public name 'WsControl';

function getnetbyaddr(addr: PVOID; len, struct: int): PNetEnt; stdcall; public name 'getnetbyaddr';
function getnetbyname(const name: PCHAR): PNetEnt; stdcall; public name 'getnetbyname';

{==============================================================================}
{Winsock Enhanced Functions}
function WsControlEx(proto: uint32_t; action: uint32_t; prequestinfo: PVOID; var pcbrequestinfolen: uint32_t; presponseinfo: PVOID; var pcbresponseinfolen: uint32_t): int; stdcall; public name 'WsControlEx';

{==============================================================================}
{Winsock Helper Functions}
function WinsockRedirectInput(s: TSOCKET): BOOL; stdcall; public name 'WinsockRedirectInput';
function WinsockRedirectOutput(s: TSOCKET): BOOL; stdcall; public name 'WinsockRedirectOutput';

function WinsockErrorToString(error: int32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'WinsockErrorToString';
{$ENDIF}
{==============================================================================}
{Winsock2 Functions}
{$IFDEF API_EXPORT_WINSOCK2}
function WS2Start: BOOL; stdcall; public name 'WS2Start';
function WS2Stop: BOOL; stdcall; public name 'WS2Stop';

procedure WS2AsyncStart(data: PVOID); stdcall; public name 'WS2AsyncStart';

function accept(s: TSOCKET; addr: PSockAddr; addrlen: Pint32_t): TSOCKET; stdcall; public name 'accept';
function bind(s: TSOCKET; addr: PSockAddr; namelen: int32_t): int32_t; stdcall; public name 'bind';
function closesocket(s: TSOCKET): int32_t; stdcall; public name 'closesocket';
function connect(s: TSOCKET; name: PSockAddr; namelen: int32_t): int32_t; stdcall; public name 'connect';
function ioctlsocket(s: TSOCKET; cmd: int32_t; arg: pu_long): int32_t; stdcall; public name 'ioctlsocket';
function getpeername(s: TSOCKET; name: PSockAddr; namelen: Pint32_t): int32_t; stdcall; public name 'getpeername';
function getsockname(s: TSOCKET; name: PSockAddr; namelen: Pint32_t): int32_t; stdcall; public name 'getsockname';
function getsockopt(s: TSOCKET; level, optname: int32_t; optval: PCHAR; optlen: Pint32_t): int32_t; stdcall; public name 'getsockopt';
function htonl(hostlong: u_long): u_long; stdcall; public name 'htonl';
function htons(hostshort: u_short): u_short; stdcall; public name 'htons';
function inet_addr(const cp: PCHAR): u_long; stdcall; public name 'inet_addr';
function inet_ntoa(inaddr: TInAddr): PCHAR; stdcall; public name 'inet_ntoa';
function listen(s: TSOCKET; backlog: int32_t): int32_t; stdcall; public name 'listen';
function ntohl(netlong: u_long): u_long; stdcall; public name 'ntohl';
function ntohs(netshort: u_short): u_short; stdcall; public name 'ntohs';
function recv(s: TSOCKET; buf: PCHAR; len, flags: int32_t): int32_t; stdcall; public name 'recv';
function recvfrom(s: TSOCKET; buf: PCHAR; len, flags: int32_t; from: PSockAddr; fromlen: Pint32_t): int32_t; stdcall; public name 'recvfrom';
function select(nfds: int32_t; readfds, writefds, exceptfds: PFDSet; timeout: PTimeVal): int32_t; stdcall; public name 'select';
function send(s: TSOCKET; const buf: PCHAR; len, flags: int32_t): int32_t; stdcall; public name 'send';
function sendto(s: TSOCKET; const buf: PCHAR; len, flags: int32_t; addrto: PSockAddr; tolen: int32_t): int32_t; stdcall; public name 'sendto';
function setsockopt(s: TSOCKET; level, optname: int32_t; const optval: PCHAR; optlen: int32_t): int32_t; stdcall; public name 'setsockopt';
function shutdown(s: TSOCKET; how: int32_t): int32_t; stdcall; public name 'shutdown';
function socket(af, struct, protocol: int32_t): TSOCKET; stdcall; public name 'socket';

function gethostbyaddr(addr: PVOID; len, family: int32_t): PHostEnt; stdcall; public name 'gethostbyaddr';
function gethostbyname(const name: PCHAR): PHostEnt; stdcall; public name 'gethostbyname';
function gethostname(name: PCHAR; len: int32_t): int32_t; stdcall; public name 'gethostname';
function getservbyport(port: int32_t; const proto: PCHAR): PServEnt; stdcall; public name 'getservbyport';
function getservbyname(const name, proto: PCHAR): PServEnt; stdcall; public name 'getservbyname';
function getprotobynumber(proto: int32_t): PProtoEnt; stdcall; public name 'getprotobynumber';
function getprotobyname(const name: PCHAR): PProtoEnt; stdcall; public name 'getprotobyname';

function getaddrinfo(pnodename, pservicename: PCHAR; phints: PAddrInfo; var ppresult: PAddrInfo): int32_t; stdcall; public name 'getaddrinfo';
procedure freeaddrinfo(ai: PAddrInfo); stdcall; public name 'freeaddrinfo';
function getnameinfo(sa: PSockAddr; salen: int; host: PCHAR; hostlen: uint32_t; serv: PCHAR; servlen: uint32_t; flags: int): int; stdcall; public name 'getnameinfo';

function WSAStartup(wversionrequired: uint16_t; var wsdata: TWSAData): int32_t; stdcall; public name 'WSAStartup';
function WSACleanup: int32_t; stdcall; public name 'WSACleanup';
procedure WSASetLastError(ierror: int32_t); stdcall; public name 'WSASetLastError';
function WSAGetLastError: int32_t; stdcall; public name 'WSAGetLastError';
function WSAIsBlocking: BOOL; stdcall; public name 'WSAIsBlocking';
function WSAUnhookBlockingHook: int32_t; stdcall; public name 'WSAUnhookBlockingHook';
function WSASetBlockingHook(lpblockfunc: TFarProc): TFarProc; stdcall; public name 'WSASetBlockingHook';
function WSACancelBlockingCall: int32_t; stdcall; public name 'WSACancelBlockingCall';
function WSAAsyncGetServByName(hwindow: HWND; wmsg: u_int; const name, proto: PCHAR; buf: PCHAR; buflen: int32_t): THANDLE; stdcall; public name 'WSAAsyncGetServByName';
function WSAAsyncGetServByPort(hwindow: HWND; wmsg, port: u_int; proto, buf: PCHAR; buflen: int32_t): THANDLE; stdcall; public name 'WSAAsyncGetServByPort';
function WSAAsyncGetProtoByName(hwindow: HWND; wmsg: u_int; const name: PCHAR; buf: PCHAR; buflen: int32_t): THANDLE; stdcall; public name 'WSAAsyncGetProtoByName';
function WSAAsyncGetProtoByNumber(hwindow: HWND; wmsg: u_int; number: int32_t; buf: PCHAR; buflen: int32_t): THANDLE; stdcall; public name 'WSAAsyncGetProtoByNumber';
function WSAAsyncGetHostByName(hwindow: HWND; wmsg: u_int; const name: PCHAR; buf: PCHAR; buflen: int32_t): THANDLE; stdcall; public name 'WSAAsyncGetHostByName';
function WSAAsyncGetHostByAddr(hwindow: HWND; wmsg: u_int; const addr: PCHAR; len, family: int32_t; buf: PCHAR; buflen: int32_t): THANDLE; stdcall; public name 'WSAAsyncGetHostByAddr';
function WSACancelAsyncRequest(hasynctaskhandle: THANDLE): int32_t; stdcall; public name 'WSACancelAsyncRequest';
function WSAAsyncSelect(s: TSOCKET; hwindow: HWND; wmsg: u_int; levent: int32_t): int32_t; stdcall; public name 'WSAAsyncSelect';
function __WSAFDIsSet(s: TSOCKET; var fdset: TFDSet): BOOL; stdcall; public name '__WSAFDIsSet';

{ WinSock 2 API new function prototypes }
function inet_pton(family: int32_t; pszaddrstring: PCHAR; paddrbuf: PVOID): int32_t; stdcall; public name 'inet_pton';
function InetPtonA(family: int32_t; pszaddrstring: PCHAR; paddrbuf: PVOID): int32_t; stdcall; public name 'InetPtonA';
function InetPtonW(family: int32_t; pszaddrstring: PWCHAR; paddrbuf: PVOID): int32_t; stdcall; public name 'InetPtonW';

function inet_ntop(family: int32_t; paddr: PVOID; pstringbuf: PCHAR; stringbufsize: int32_t): PCHAR; stdcall; public name 'inet_ntop';
function InetNtopA(family: int32_t; paddr: PVOID; pstringbuf: PCHAR; stringbufsize: int32_t): PCHAR; stdcall; public name 'InetNtopA';
function InetNtopW(family: int32_t; paddr: PVOID; pstringbuf: PWCHAR; stringbufsize: int32_t): PWCHAR; stdcall; public name 'InetNtopW';

function WSAAccept(s: TSOCKET; addr: TSockAddr; addrlen: Pint32_t; lpfncondition: LPCONDITIONPROC; dwcallbackdata: uint32_t): TSOCKET; stdcall; public name 'WSAAccept';
function WSACloseEvent(hevent: WSAEVENT): WordBool; stdcall; public name 'WSACloseEvent';
function WSAConnect(s: TSOCKET; name: PSockAddr; namelen: int32_t; lpcallerdata, lpcalleedata: LPWSABUF; lpsqos, lpgqos: LPQOS): int32_t; stdcall; public name 'WSAConnect';
function WSACreateEvent: WSAEVENT; stdcall; public name 'WSACreateEvent';
function WSADuplicateSocketA(s: TSOCKET; dwprocessid: uint32_t; lpprotocolinfo: LPWSAProtocol_InfoA): int32_t; stdcall; public name 'WSADuplicateSocketA';
function WSADuplicateSocketW(s: TSOCKET; dwprocessid: uint32_t; lpprotocolinfo: LPWSAProtocol_InfoW): int32_t; stdcall; public name 'WSADuplicateSocketW';
function WSAEnumNetworkEvents(s: TSOCKET; heventobject: WSAEVENT; lpnetworkevents: LPWSANETWORKEVENTS): int32_t; stdcall; public name 'WSAEnumNetworkEvents';
function WSAEnumProtocolsA(lpiprotocols: Pint32_t; lpprotocolbuffer: LPWSAProtocol_InfoA; var lpdwbufferlength: uint32_t): int32_t; stdcall; public name 'WSAEnumProtocolsA';
function WSAEnumProtocolsW(lpiprotocols: Pint32_t; lpprotocolbuffer: LPWSAProtocol_InfoW; var lpdwbufferlength: uint32_t): int32_t; stdcall; public name 'WSAEnumProtocolsW';
function WSAEventSelect(s: TSOCKET; heventobject: WSAEVENT; lnetworkevents: int32_t): int32_t; stdcall; public name 'WSAEventSelect';
function WSAGetOverlappedResult(s: TSOCKET; lpoverlapped: LPWSAOVERLAPPED; lpcbtransfer: LPDWORD; fwait: BOOL; var lpdwflags: uint32_t): WordBool; stdcall; public name 'WSAGetOverlappedResult';
function WSAGetQosByName(s: TSOCKET; lpqosname: LPWSABUF; lpqos: LPQOS): WordBool; stdcall; public name 'WSAGetQosByName';
function WSAhtonl(s: TSOCKET; hostlong: u_long; var lpnetlong: uint32_t): int32_t; stdcall; public name 'WSAhtonl';
function WSAhtons(s: TSOCKET; hostshort: u_short; var lpnetshort: uint16_t): int32_t; stdcall; public name 'WSAhtons';
function WSAIoctl(s: TSOCKET; dwiocontrolcode: uint32_t; lpvinbuffer: PVOID; cbinbuffer: uint32_t; lpvoutbuffer: PVOID; cboutbuffer: uint32_t; lpcbbytesreturned: LPDWORD; lpoverlapped: LPWSAOVERLAPPED; lpcompletionroutine: LPWSAOVERLAPPED_COMPLETION_ROUTINE): int32_t; stdcall; public name 'WSAIoctl';
function WSAJoinLeaf(s: TSOCKET; name: PSockAddr; namelen: int32_t; lpcallerdata, lpcalleedata: LPWSABUF; lpsqos, lpgqos: LPQOS; dwflags: uint32_t): TSOCKET; stdcall; public name 'WSAJoinLeaf';
function WSANtohl(s: TSOCKET; netlong: u_long; var lphostlong: uint32_t): int32_t; stdcall; public name 'WSANtohl';
function WSANtohs(s: TSOCKET; netshort: u_short; var lphostshort: uint16_t): int32_t; stdcall; public name 'WSANtohs';
function WSARecv(s: TSOCKET; lpbuffers: LPWSABUF; dwbuffercount: uint32_t; var lpnumberofbytesrecvd: uint32_t; var lpflags: uint32_t; lpoverlapped: LPWSAOVERLAPPED; lpcompletionroutine: LPWSAOVERLAPPED_COMPLETION_ROUTINE): int32_t; stdcall; public name 'WSARecv';
function WSARecvDisconnect(s: TSOCKET; lpinbounddisconnectdata: LPWSABUF): int32_t; stdcall; public name 'WSARecvDisconnect';
function WSARecvFrom(s: TSOCKET; lpbuffers: LPWSABUF; dwbuffercount: uint32_t; var lpnumberofbytesrecvd: uint32_t; var lpflags: uint32_t; lpfrom: PSockAddr; lpfromlen: Pint32_t; lpoverlapped: LPWSAOVERLAPPED; lpcompletionroutine: LPWSAOVERLAPPED_COMPLETION_ROUTINE): int32_t; stdcall; public name 'WSARecvFrom';
function WSARecvMsg(s: TSOCKET; lpmsg: LPWSAMSG; lpdwnumberofbytesrecvd: uint32_t; lpoverlapped: LPWSAOVERLAPPED; lpcompletionroutine: LPWSAOVERLAPPED_COMPLETION_ROUTINE): int32_t; stdcall; public name 'WSARecvMsg';
function WSAResetEvent(hevent: WSAEVENT): WordBool; stdcall; public name 'WSAResetEvent';
function WSASend(s: TSOCKET; lpbuffers: LPWSABUF; dwbuffercount: uint32_t; var lpnumberofbytessent: uint32_t; dwflags: uint32_t; lpoverlapped: LPWSAOVERLAPPED; lpcompletionroutine: LPWSAOVERLAPPED_COMPLETION_ROUTINE): int32_t; stdcall; public name 'WSASend';
function WSASendDisconnect(s: TSOCKET; lpoutbounddisconnectdata: LPWSABUF): int32_t; stdcall; public name 'WSASendDisconnect';
function WSASendTo(s: TSOCKET; lpbuffers: LPWSABUF; dwbuffercount: uint32_t; var lpnumberofbytessent: uint32_t; dwflags: uint32_t; lpto: PSockAddr; itolen: int32_t; lpoverlapped: LPWSAOVERLAPPED; lpcompletionroutine: LPWSAOVERLAPPED_COMPLETION_ROUTINE): int32_t; stdcall; public name 'WSASendTo';
function WSASendMsg(s: TSOCKET; lpmsg: LPWSAMSG; dwflags: uint32_t; lpnumberofbytessent: uint32_t; lpoverlapped: LPWSAOVERLAPPED; lpcompletionroutine: LPWSAOVERLAPPED_COMPLETION_ROUTINE): int32_t; stdcall; public name 'WSASendMsg';
function WSASetEvent(hevent: WSAEVENT): WordBool; stdcall; public name 'WSASetEvent';
function WSASocketA(af, itype, protocol: int32_t; lpprotocolinfo: LPWSAProtocol_InfoA; g: GROUP; dwflags: uint32_t): TSOCKET; stdcall; public name 'WSASocketA';
function WSASocketW(af, itype, protocol: int32_t; lpprotocolinfo: LPWSAProtocol_InfoW; g: GROUP; dwflags: uint32_t): TSOCKET; stdcall; public name 'WSASocketW';

function WSAWaitForMultipleEvents(cevents: uint32_t; lphevents: PWSAEVENT; fwaitall: LONGBOOL; dwtimeout: uint32_t; falertable: LONGBOOL): uint32_t; stdcall; public name 'WSAWaitForMultipleEvents';
function WSAAddressToStringA(var lpsaaddress: TSockAddr; const dwaddresslength: uint32_t; const lpprotocolinfo: LPWSAProtocol_InfoA; const lpszaddressstring: PCHAR; var lpdwaddressstringlength: uint32_t): int32_t; stdcall; public name 'WSAAddressToStringA';
function WSAAddressToStringW(var lpsaaddress: TSockAddr; const dwaddresslength: uint32_t; const lpprotocolinfo: LPWSAProtocol_InfoW; const lpszaddressstring: PWCHAR; var lpdwaddressstringlength: uint32_t): int32_t; stdcall; public name 'WSAAddressToStringW';

function WSAStringToAddressA(const addressstring: PCHAR; const addressfamily: int32_t; const lpprotocolinfo: LPWSAProtocol_InfoA; var lpaddress: TSockAddr; var lpaddresslength: int32_t): int32_t; stdcall; public name 'WSAStringToAddressA';
function WSAStringToAddressW(const addressstring: PWCHAR; const addressfamily: int32_t; const lpprotocolinfo: LPWSAProtocol_InfoA; var lpaddress: TSockAddr; var lpaddresslength: int32_t): int32_t; stdcall; public name 'WSAStringToAddressW';

{ Registration and Name Resolution API functions }
function WSALookupServiceBeginA(const lpqsrestrictions: LPWSAQuerySetA; const dwcontrolflags: uint32_t; lphlookup: PHANDLE): int32_t; stdcall; public name 'WSALookupServiceBeginA';
function WSALookupServiceBeginW(const lpqsrestrictions: LPWSAQuerySetW; const dwcontrolflags: uint32_t; lphlookup: PHANDLE): int32_t; stdcall; public name 'WSALookupServiceBeginW';

function WSALookupServiceNextA(const hlookup: THANDLE; const dwcontrolflags: uint32_t; var lpdwbufferlength: uint32_t; lpqsresults: LPWSAQuerySetA): int32_t; stdcall; public name 'WSALookupServiceNextA';
function WSALookupServiceNextW(const hlookup: THANDLE; const dwcontrolflags: uint32_t; var lpdwbufferlength: uint32_t; lpqsresults: LPWSAQuerySetW): int32_t; stdcall; public name 'WSALookupServiceNextW';
function WSALookupServiceEnd(const hlookup: THANDLE): int32_t; stdcall; public name 'WSALookupServiceEnd';
function WSAInstallServiceClassA(const lpserviceclassinfo: LPWSAServiceClassInfoA): int32_t; stdcall; public name 'WSAInstallServiceClassA';
function WSAInstallServiceClassW(const lpserviceclassinfo: LPWSAServiceClassInfoW): int32_t; stdcall; public name 'WSAInstallServiceClassW';
function WSARemoveServiceClass(const lpserviceclassid: PGUID): int32_t; stdcall; public name 'WSARemoveServiceClass';
function WSAGetServiceClassInfoA(const lpproviderid: PGUID; const lpserviceclassid: PGUID; var lpdwbufsize: uint32_t; lpserviceclassinfo: LPWSAServiceClassInfoA): int32_t; stdcall; public name 'WSAGetServiceClassInfoA';
function WSAGetServiceClassInfoW(const lpproviderid: PGUID; const lpserviceclassid: PGUID; var lpdwbufsize: uint32_t; lpserviceclassinfo: LPWSAServiceClassInfoW): int32_t; stdcall; public name 'WSAGetServiceClassInfoW';

function WSAEnumNameSpaceProvidersA(var lpdwbufferlength: uint32_t; const lpnspbuffer: LPWSANameSpace_InfoA): int32_t; stdcall; public name 'WSAEnumNameSpaceProvidersA';
function WSAEnumNameSpaceProvidersW(var lpdwbufferlength: uint32_t; const lpnspbuffer: LPWSANameSpace_InfoW): int32_t; stdcall; public name 'WSAEnumNameSpaceProvidersW';

function WSAGetServiceClassNameByClassIdA(const lpserviceclassid: PGUID; lpszserviceclassname: PCHAR; var lpdwbufferlength: uint32_t): int32_t; stdcall; public name 'WSAGetServiceClassNameByClassIdA';
function WSAGetServiceClassNameByClassIdW(const lpserviceclassid: PGUID; lpszserviceclassname: PWCHAR; var lpdwbufferlength: uint32_t): int32_t; stdcall; public name 'WSAGetServiceClassNameByClassIdW';
function WSASetServiceA(const lpqsreginfo: LPWSAQuerySetA; const essoperation: TWSAeSetServiceOp; const dwcontrolflags: uint32_t): int32_t; stdcall; public name 'WSASetServiceA';
function WSASetServiceW(const lpqsreginfo: LPWSAQuerySetW; const essoperation: TWSAeSetServiceOp; const dwcontrolflags: uint32_t): int32_t; stdcall; public name 'WSASetServiceW';

function WSAMakeSyncReply(buflen, error: uint16_t): int32_t; stdcall; public name 'WSAMakeSyncReply';
function WSAMakeSelectReply(event, error: uint16_t): int32_t; stdcall; public name 'WSAMakeSelectReply';
function WSAGetAsyncBuflen(param: int32_t): uint16_t; stdcall; public name 'WSAGetAsyncBuflen';
function WSAGetAsyncError(param: int32_t): uint16_t; stdcall; public name 'WSAGetAsyncError';
function WSAGetSelectEvent(param: int32_t): uint16_t; stdcall; public name 'WSAGetSelectEvent';
function WSAGetSelectError(param: int32_t): uint16_t; stdcall; public name 'WSAGetSelectError';

procedure FD_CLR(socket: TSOCKET; var fdset: TFDSet); stdcall; public name 'FD_CLR';
function FD_ISSET(socket: TSOCKET; var fdset: TFDSet): BOOL; stdcall; public name 'FD_ISSET';
procedure FD_SET(socket: TSOCKET; var fdset: TFDSet); stdcall; public name 'FD_SET';
procedure FD_ZERO(var fdset: TFDSet); stdcall; public name 'FD_ZERO';

{==============================================================================}
{Winsock2 Undocumented Functions}
function WsControl(proto: uint32_t; action: uint32_t; prequestinfo: PVOID; var pcbrequestinfolen: uint32_t; presponseinfo: PVOID; var pcbresponseinfolen: uint32_t): int; stdcall; public name 'WsControl';

function getnetbyaddr(addr: PVOID; len, struct: int): PNetEnt; stdcall; public name 'getnetbyaddr';
function getnetbyname(const name: PCHAR): PNetEnt; stdcall; public name 'getnetbyname';

{==============================================================================}
{Winsock2 Enhanced Functions}
function WsControlEx(proto: uint32_t; action: uint32_t; prequestinfo: PVOID; var pcbrequestinfolen: uint32_t; presponseinfo: PVOID; var pcbresponseinfolen: uint32_t): int; stdcall; public name 'WsControlEx';

{==============================================================================}
{Winsock2 Helper Functions}
function Winsock2RedirectInput(s: TSOCKET): BOOL; stdcall; public name 'Winsock2RedirectInput';
function Winsock2RedirectOutput(s: TSOCKET): BOOL; stdcall; public name 'Winsock2RedirectOutput';

function Winsock2ErrorToString(error: int32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'Winsock2ErrorToString';
{$ENDIF}
{==============================================================================}
{Iphlpapi Functions}
{$IFDEF API_EXPORT_IPHLPAPI}
function GetNumberOfInterfaces(var pdwnumif: uint32_t): uint32_t; stdcall; public name 'GetNumberOfInterfaces';
function GetIfEntry(pifrow: PMIB_IFROW): uint32_t; stdcall; public name 'GetIfEntry';
function GetIfTable(piftable: PMIB_IFTABLE; var pdwsize: uint32_t; border: BOOL): uint32_t; stdcall; public name 'GetIfTable';
function GetIpAddrTable(pipaddrtable: PMIB_IPADDRTABLE; var pdwsize: uint32_t; border: BOOL): uint32_t; stdcall; public name 'GetIpAddrTable';
function GetIpNetTable(pipnettable: PMIB_IPNETTABLE; var pdwsize: uint32_t; border: BOOL): uint32_t; stdcall; public name 'GetIpNetTable';
function GetIpForwardTable(pipforwardtable: PMIB_IPFORWARDTABLE; var pdwsize: uint32_t; border: BOOL): uint32_t; stdcall; public name 'GetIpForwardTable';
function GetTcpTable(ptcptable: PMIB_TCPTABLE; var pdwsize: uint32_t; border: BOOL): uint32_t; stdcall; public name 'GetTcpTable';
function GetUdpTable(pudptable: PMIB_UDPTABLE; var pdwsize: uint32_t; border: BOOL): uint32_t; stdcall; public name 'GetUdpTable';

function GetIpStatistics(var pstats: MIB_IPSTATS): uint32_t; stdcall; public name 'GetIpStatistics';
function GetIcmpStatistics(var pstats: MIB_ICMP): uint32_t; stdcall; public name 'GetIcmpStatistics';
function GetTcpStatistics(var pstats: MIB_TCPSTATS): uint32_t; stdcall; public name 'GetTcpStatistics';
function GetUdpStatistics(var pstats: MIB_UDPSTATS): uint32_t; stdcall; public name 'GetUdpStatistics';

function SetIfEntry(const pifrow: MIB_IFROW): uint32_t; stdcall; public name 'SetIfEntry';
function CreateIpForwardEntry(const proute: MIB_IPFORWARDROW): uint32_t; stdcall; public name 'CreateIpForwardEntry';
function SetIpForwardEntry(const proute: MIB_IPFORWARDROW): uint32_t; stdcall; public name 'SetIpForwardEntry';
function DeleteIpForwardEntry(const proute: MIB_IPFORWARDROW): uint32_t; stdcall; public name 'DeleteIpForwardEntry';

function SetIpStatistics(const pipstats: MIB_IPSTATS): uint32_t; stdcall; public name 'SetIpStatistics';
function SetIpTTL(nttl: UINT): uint32_t; stdcall; public name 'SetIpTTL';

function CreateIpNetEntry(const parpentry: MIB_IPNETROW): uint32_t; stdcall; public name 'CreateIpNetEntry';
function SetIpNetEntry(const parpentry: MIB_IPNETROW): uint32_t; stdcall; public name 'SetIpNetEntry';
function DeleteIpNetEntry(const parpentry: MIB_IPNETROW): uint32_t; stdcall; public name 'DeleteIpNetEntry';
function FlushIpNetTable(dwifindex: uint32_t): uint32_t; stdcall; public name 'FlushIpNetTable';

function CreateProxyArpEntry(dwaddress, dwmask, dwifindex: uint32_t): uint32_t; stdcall; public name 'CreateProxyArpEntry';
function DeleteProxyArpEntry(dwaddress, dwmask, dwifindex: uint32_t): uint32_t; stdcall; public name 'DeleteProxyArpEntry';

function SetTcpEntry(const ptcprow: MIB_TCPROW): uint32_t; stdcall; public name 'SetTcpEntry';
function GetInterfaceInfo(piftable: PIP_INTERFACE_INFO; var dwoutbuflen: uint32_t): uint32_t; stdcall; public name 'GetInterfaceInfo';
function GetUniDirectionalAdapterInfo(pipifinfo: PIP_UNIDIRECTIONAL_ADAPTER_ADDRESS; var dwoutbuflen: uint32_t): uint32_t; stdcall; public name 'GetUniDirectionalAdapterInfo';

function GetBestInterface(dwdestaddr: IPAddr; var pdwbestifindex: uint32_t): uint32_t; stdcall; public name 'GetBestInterface';
function GetBestRoute(dwdestaddr, dwsourceaddr: uint32_t; pbestroute: PMIB_IPFORWARDROW): uint32_t; stdcall; public name 'GetBestRoute';
function NotifyAddrChange(var handle: THANDLE; overlapped: POVERLAPPED): uint32_t; stdcall; public name 'NotifyAddrChange';
function NotifyRouteChange(var handle: THANDLE; overlapped: POVERLAPPED): uint32_t; stdcall; public name 'NotifyRouteChange';
function GetAdapterIndex(adaptername: LPWSTR; var ifindex: uint32_t): uint32_t; stdcall; public name 'GetAdapterIndex';
function AddIPAddress(address: IPAddr; ipmask: IPMask; ifindex: uint32_t; var ntecontext, nteinstance: uint32_t): uint32_t; stdcall; public name 'AddIPAddress';
function DeleteIPAddress(ntecontext: uint32_t): uint32_t; stdcall; public name 'DeleteIPAddress';
function GetNetworkParams(pfixedinfo: PFIXED_INFO; var poutbuflen: uint32_t): uint32_t; stdcall; public name 'GetNetworkParams';
function GetAdaptersInfo(padapterinfo: PIP_ADAPTER_INFO; var poutbuflen: uint32_t): uint32_t; stdcall; public name 'GetAdaptersInfo';
function GetPerAdapterInfo(ifindex: uint32_t; pperadapterinfo: PIP_PER_ADAPTER_INFO; var poutbuflen: uint32_t): uint32_t; stdcall; public name 'GetPerAdapterInfo';
function IpReleaseAddress(const adapterinfo: IP_ADAPTER_INDEX_MAP): uint32_t; stdcall; public name 'IpReleaseAddress';
function IpRenewAddress(const adapterinfo: IP_ADAPTER_INDEX_MAP): uint32_t; stdcall; public name 'IpRenewAddress';
function SendARP(const destip, srcip: IPAddr; pmacaddr: PDWORD; var phyaddrlen: uint32_t): uint32_t; stdcall; public name 'SendARP';
function GetRTTAndHopCount(destipaddress: IPAddr; var hopcount: uint32_t; maxhops: uint32_t; var rtt: uint32_t): BOOL; stdcall; public name 'GetRTTAndHopCount';
function GetFriendlyIfIndex(ifindex: uint32_t): uint32_t; stdcall; public name 'GetFriendlyIfIndex';
function EnableRouter(var phandle: THANDLE; poverlapped: POVERLAPPED): uint32_t; stdcall; public name 'EnableRouter';
function UnenableRouter(poverlapped: POVERLAPPED; lpdwenablecount: LPDWORD): uint32_t; stdcall; public name 'UnenableRouter';

{==============================================================================}
{IP Helper Helper Functions}
function MIBIFOperStatusToString(value: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'MIBIFOperStatusToString';
function MIBIFTypeToString(value: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'MIBIFTypeToString';
function MIBIFAdminStatusToString(value: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'MIBIFAdminStatusToString';

function MIBTCPRTOToString(value: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'MIBTCPRTOToString';
function MIBTCPStateToString(value: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'MIBTCPStateToString';

function MIBIPForwardingToString(value: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'MIBIPForwardingToString';
function MIBIPRouteTypeToString(value: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'MIBIPRouteTypeToString';
function MIBIPProtoToString(value: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'MIBIPProtoToString';
function MIBIPNetTypeToString(value: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'MIBIPNetTypeToString';
{$ENDIF}
{==============================================================================}
{Ultibo Functions}
{$IFDEF API_EXPORT_ULTIBO}
{General Functions (Compatibility)}
function GetVersion: uint32_t; stdcall; public name 'GetVersion';

function GetVersionEx(lpversioninformation: LPOSVERSIONINFOA): BOOL; stdcall; public name 'GetVersionEx';
function GetVersionExA(lpversioninformation: LPOSVERSIONINFOA): BOOL; stdcall; public name 'GetVersionExA';
function GetVersionExW(lpversioninformation: LPOSVERSIONINFOW): BOOL; stdcall; public name 'GetVersionExW';

procedure GetSystemInfo(var lpsysteminfo: SYSTEM_INFO); stdcall; public name 'GetSystemInfo';
procedure GetNativeSystemInfo(lpsysteminfo: LPSYSTEM_INFO); stdcall; public name 'GetNativeSystemInfo';
function GetLargePageMinimum: SIZE_T; stdcall; public name 'GetLargePageMinimum';

function GetComputerName(lpbuffer: LPSTR; var nsize: uint32_t): BOOL; stdcall; public name 'GetComputerName';
function GetComputerNameA(lpbuffer: LPSTR; var nsize: uint32_t): BOOL; stdcall; public name 'GetComputerNameA';
function GetComputerNameW(lpbuffer: LPWSTR; var nsize: uint32_t): BOOL; stdcall; public name 'GetComputerNameW';

function SetComputerName(const lpcomputername: LPCSTR): BOOL; stdcall; public name 'SetComputerName';
function SetComputerNameA(const lpcomputername: LPCSTR): BOOL; stdcall; public name 'SetComputerNameA';
function SetComputerNameW(const lpcomputername: LPCWSTR): BOOL; stdcall; public name 'SetComputerNameW';

function GetComputerNameEx(nametype: COMPUTER_NAME_FORMAT; lpbuffer: LPSTR; var nsize: uint32_t): BOOL; stdcall; public name 'GetComputerNameEx';
function GetComputerNameExA(nametype: COMPUTER_NAME_FORMAT; lpbuffer: LPSTR; var nsize: uint32_t): BOOL; stdcall; public name 'GetComputerNameExA';
function GetComputerNameExW(nametype: COMPUTER_NAME_FORMAT; lpbuffer: LPWSTR; var nsize: uint32_t): BOOL; stdcall; public name 'GetComputerNameExW';

function SetComputerNameEx(nametype: COMPUTER_NAME_FORMAT; const lpbuffer: LPCSTR): BOOL; stdcall; public name 'SetComputerNameEx';
function SetComputerNameExA(nametype: COMPUTER_NAME_FORMAT; const lpbuffer: LPCSTR): BOOL; stdcall; public name 'SetComputerNameExA';
function SetComputerNameExW(nametype: COMPUTER_NAME_FORMAT; const lpbuffer: LPCWSTR): BOOL; stdcall; public name 'SetComputerNameExW';

function ExitUltibo(dwreserved: uint32_t; ureserved: UINT): BOOL; stdcall; public name 'ExitUltibo';
function ExitUltiboEx(uflags: UINT; dwreserved: uint32_t): BOOL; stdcall; public name 'ExitUltiboEx';

{==============================================================================}
{General Functions (Ultibo)}
function RestartComputer(delay: uint32_t): BOOL; stdcall; public name 'RestartComputer';
function ShutdownComputer(delay: uint32_t): BOOL; stdcall; public name 'ShutdownComputer';

function Uptime: FILETIME; stdcall; public name 'Uptime';

{==============================================================================}
{Time Functions (Compatibility)}
function GetTickCount: uint32_t; stdcall; public name 'GetTickCount';
function GetTickCount64: ULONGLONG; stdcall; public name 'GetTickCount64';

procedure GetSystemTime(var lpsystemtime: SYSTEMTIME); stdcall; public name 'GetSystemTime';
procedure GetSystemTimeAsFileTime(var lpsystemtimeasfiletime: FILETIME); stdcall; public name 'GetSystemTimeAsFileTime';
function SetSystemTime(var lpsystemtime: SYSTEMTIME): BOOL; stdcall; public name 'SetSystemTime';

procedure GetLocalTime(var lpsystemtime: SYSTEMTIME); stdcall; public name 'GetLocalTime';
function SetLocalTime(var lpsystemtime: SYSTEMTIME): BOOL; stdcall; public name 'SetLocalTime';

function SystemTimeToTzSpecificLocalTime(lptimezoneinformation: LPTIME_ZONE_INFORMATION; var lpuniversaltime, lplocaltime: SYSTEMTIME): BOOL; stdcall; public name 'SystemTimeToTzSpecificLocalTime';
function TzSpecificLocalTimeToSystemTime(lptimezoneinformation: LPTIME_ZONE_INFORMATION; const lplocaltime: SYSTEMTIME; var lpuniversaltime: SYSTEMTIME): BOOL; stdcall; public name 'TzSpecificLocalTimeToSystemTime';

function GetTimeZoneInformation(var lptimezoneinformation: TIME_ZONE_INFORMATION): uint32_t; stdcall; public name 'GetTimeZoneInformation';
function SetTimeZoneInformation(const lptimezoneinformation: TIME_ZONE_INFORMATION): BOOL; stdcall; public name 'SetTimeZoneInformation';

function SystemTimeToFileTime(const lpsystemtime: SYSTEMTIME; var lpfiletime: FILETIME): BOOL; stdcall; public name 'SystemTimeToFileTime';
function FileTimeToSystemTime(const lpfiletime: FILETIME; var lpsystemtime: SYSTEMTIME): BOOL; stdcall; public name 'FileTimeToSystemTime';

function FileTimeToLocalFileTime(const lpfiletime: FILETIME; var lplocalfiletime: FILETIME): BOOL; stdcall; public name 'FileTimeToLocalFileTime';
function LocalFileTimeToFileTime(const lplocalfiletime: FILETIME; var lpfiletime: FILETIME): BOOL; stdcall; public name 'LocalFileTimeToFileTime';

function CompareFileTime(const lpfiletime1, lpfiletime2: FILETIME): LONG; stdcall; public name 'CompareFileTime';

function FileTimeToDosDateTime(const lpfiletime: FILETIME; var lpfatdate, lpfattime: uint16_t): BOOL; stdcall; public name 'FileTimeToDosDateTime';
function DosDateTimeToFileTime(wfatdate, wfattime: uint16_t; var lpfiletime: FILETIME): BOOL; stdcall; public name 'DosDateTimeToFileTime';

function QueryPerformanceCounter(var lpPerformanceCount: LARGE_INTEGER): BOOL; stdcall; public name 'QueryPerformanceCounter';
function QueryPerformanceFrequency(var lpFrequency: LARGE_INTEGER): BOOL; stdcall; public name 'QueryPerformanceFrequency';

{==============================================================================}
{Time Functions (Ultibo)}
function GetCurrentTime: FILETIME; stdcall; public name 'GetCurrentTime';
procedure SetCurrentTime(const time: FILETIME); stdcall; public name 'SetCurrentTime';

function GetTimeAdjust: int32_t; stdcall; public name 'GetTimeAdjust';
procedure SetTimeAdjust(adjust: int32_t); stdcall; public name 'SetTimeAdjust';

function GetCurrentTimezone(name: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'GetCurrentTimezone';
function SetCurrentTimezone(const name: PCHAR): BOOL; stdcall; public name 'SetCurrentTimezone';

function GetTimezoneActiveOffset: int32_t; stdcall; public name 'GetTimezoneActiveOffset';
function GetTimezoneStandardOffset: int32_t; stdcall; public name 'GetTimezoneStandardOffset';
procedure SetTimezoneStandardOffset(offset: int32_t); stdcall; public name 'SetTimezoneStandardOffset';
function GetTimezoneDaylightOffset: int32_t; stdcall; public name 'GetTimezoneDaylightOffset';
procedure SetTimezoneDaylightOffset(offset: int32_t); stdcall; public name 'SetTimezoneDaylightOffset';

function GetTimezoneStandardStart(description: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'GetTimezoneStandardStart';
function GetTimezoneDaylightStart(description: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'GetTimezoneDaylightStart';

function GetTimezoneStandardDate: double_t; stdcall; public name 'GetTimezoneStandardDate';
function GetTimezoneDaylightDate: double_t; stdcall; public name 'GetTimezoneDaylightDate';

function FileTimeToDateTime(const filetime: FILETIME): double_t; stdcall; public name 'FileTimeToDateTime';
function DateTimeToFileTime(datetime: double_t): FILETIME; stdcall; public name 'DateTimeToFileTime';

function LocalFileTimeToDateTime(const filetime: FILETIME): double_t; stdcall; public name 'LocalFileTimeToDateTime';
function DateTimeToLocalFileTime(datetime: double_t): FILETIME; stdcall; public name 'DateTimeToLocalFileTime';

function SystemFileTimeToDateTime(const filetime: FILETIME): double_t; stdcall; public name 'SystemFileTimeToDateTime';
function DateTimeToSystemFileTime(datetime: double_t): FILETIME; stdcall; public name 'DateTimeToSystemFileTime';

function FileTimeToUnixTime(const filetime: FILETIME): time_t; stdcall; public name 'FileTimeToUnixTime';
function UnixTimeToFileTime(unixtime: time_t): FILETIME; stdcall; public name 'UnixTimeToFileTime';

function UnixTimeToDateTime(unixtime: time_t): double_t; stdcall; public name 'UnixTimeToDateTime';
function DateTimeToUnixTime(datetime: double_t): time_t; stdcall; public name 'DateTimeToUnixTime';

function FileTimeToFileDate(const filetime: FILETIME): int; stdcall; public name 'FileTimeToFileDate';
function FileDateToFileTime(filedate: int): FILETIME; stdcall; public name 'FileDateToFileTime';

function FileTimeToAdjustedTime(const filetime: FILETIME): FILETIME; stdcall; public name 'FileTimeToAdjustedTime';
function AdjustedTimeToFileTime(const filetime: FILETIME): FILETIME; stdcall; public name 'AdjustedTimeToFileTime';

function RoundFileTime(const filetime: FILETIME): FILETIME; stdcall; public name 'RoundFileTime';

function ConvertFileTime(const filetime: FILETIME; offset: int; local: BOOL): FILETIME; stdcall; public name 'ConvertFileTime';
function ConvertDateTime(datetime: double_t; offset: int; local: BOOL): double_t; stdcall; public name 'ConvertDateTime';

{==============================================================================}
{Drive Functions (Compatibility)}
function GetDiskType(const lprootpathname: LPCSTR): UINT; stdcall; public name 'GetDiskType'; // GetDriveType - Already defined below
function GetDriveTypeA(const lprootpathname: LPCSTR): UINT; stdcall; public name 'GetDriveTypeA';
function GetDriveTypeW(const lprootpathname: LPCWSTR): UINT; stdcall; public name 'GetDriveTypeW';

function GetLogicalDrives: uint32_t; stdcall; public name 'GetLogicalDrives';

function GetLogicalDriveStrings(nbufferlength: uint32_t; lpbuffer: LPSTR): uint32_t; stdcall; public name 'GetLogicalDriveStrings';
function GetLogicalDriveStringsA(nbufferlength: uint32_t; lpbuffer: LPSTR): uint32_t; stdcall; public name 'GetLogicalDriveStringsA';
function GetLogicalDriveStringsW(nbufferlength: uint32_t; lpbuffer: LPWSTR): uint32_t; stdcall; public name 'GetLogicalDriveStringsW';

function DefineDosDevice(dwflags: uint32_t; const lpdevicename, lptargetpath: LPCSTR): BOOL; stdcall; public name 'DefineDosDevice';
function DefineDosDeviceA(dwflags: uint32_t; const lpdevicename, lptargetpath: LPCSTR): BOOL; stdcall; public name 'DefineDosDeviceA';
function DefineDosDeviceW(dwflags: uint32_t; const lpdevicename, lptargetpath: LPCWSTR): BOOL; stdcall; public name 'DefineDosDeviceW';

function QueryDosDevice(const lpdevicename: LPCSTR; lptargetpath: LPSTR; ucchmax: uint32_t): uint32_t; stdcall; public name 'QueryDosDevice';
function QueryDosDeviceA(const lpdevicename: LPCSTR; lptargetpath: LPSTR; ucchmax: uint32_t): uint32_t; stdcall; public name 'QueryDosDeviceA';
function QueryDosDeviceW(const lpdevicename: LPCWSTR; lptargetpath: LPWSTR; ucchmax: uint32_t): uint32_t; stdcall; public name 'QueryDosDeviceW';

function SetVolumeLabel(const lprootpathname, lpvolumename: LPCSTR): BOOL; stdcall; public name 'SetVolumeLabel';
function SetVolumeLabelA(const lprootpathname, lpvolumename: LPCSTR): BOOL; stdcall; public name 'SetVolumeLabelA';
function SetVolumeLabelW(const lprootpathname, lpvolumename: LPCWSTR): BOOL; stdcall; public name 'SetVolumeLabelW';

function GetVolumeInformation(const lprootpathname: LPCSTR; lpvolumenamebuffer: LPSTR; nvolumenamesize: uint32_t; lpvolumeserialnumber: LPDWORD; var lpmaximumcomponentlength, lpfilesystemflags: uint32_t; lpfilesystemnamebuffer: LPSTR; nfilesystemnamesize: uint32_t): BOOL; stdcall; public name 'GetVolumeInformation';
function GetVolumeInformationA(const lprootpathname: LPCSTR; lpvolumenamebuffer: LPSTR; nvolumenamesize: uint32_t; lpvolumeserialnumber: LPDWORD; var lpmaximumcomponentlength, lpfilesystemflags: uint32_t; lpfilesystemnamebuffer: LPSTR; nfilesystemnamesize: uint32_t): BOOL; stdcall; public name 'GetVolumeInformationA';
function GetVolumeInformationW(const lprootpathname: LPCWSTR; lpvolumenamebuffer: LPWSTR; nvolumenamesize: uint32_t; lpvolumeserialnumber: LPDWORD; var lpmaximumcomponentlength, lpfilesystemflags: uint32_t; lpfilesystemnamebuffer: LPWSTR; nfilesystemnamesize: uint32_t): BOOL; stdcall; public name 'GetVolumeInformationW';

function GetDiskFreeSpace(const lprootpathname: LPCSTR; var lpsectorspercluster, lpbytespersector, lpnumberoffreeclusters, lptotalnumberofclusters: uint32_t): BOOL; stdcall; public name 'GetDiskFreeSpace';
function GetDiskFreeSpaceA(const lprootpathname: LPCSTR; var lpsectorspercluster, lpbytespersector, lpnumberoffreeclusters, lptotalnumberofclusters: uint32_t): BOOL; stdcall; public name 'GetDiskFreeSpaceA';
function GetDiskFreeSpaceW(const lprootpathname: LPCWSTR; var lpsectorspercluster, lpbytespersector, lpnumberoffreeclusters, lptotalnumberofclusters: uint32_t): BOOL; stdcall; public name 'GetDiskFreeSpaceW';

function GetDiskFreeSpaceEx(const lpdirectoryname: LPCSTR; var lpfreebytesavailabletocaller, lptotalnumberofbytes: ULARGE_INTEGER; lptotalnumberoffreebytes: PULARGE_INTEGER): BOOL; stdcall; public name 'GetDiskFreeSpaceEx';
function GetDiskFreeSpaceExA(const lpdirectoryname: LPCSTR; var lpfreebytesavailabletocaller, lptotalnumberofbytes: ULARGE_INTEGER; lptotalnumberoffreebytes: PULARGE_INTEGER): BOOL; stdcall; public name 'GetDiskFreeSpaceExA';
function GetDiskFreeSpaceExW(const lpdirectoryname: LPCWSTR; var lpfreebytesavailabletocaller, lptotalnumberofbytes: ULARGE_INTEGER; lptotalnumberoffreebytes: PULARGE_INTEGER): BOOL; stdcall; public name 'GetDiskFreeSpaceExW';

{==============================================================================}
{Drive Functions (Ultibo)}
function GetPathDrive(const path: PCHAR): uint8_t; stdcall; public name 'GetPathDrive';
function GetDriveType(drive: uint8_t): TDRIVE_TYPE; stdcall; public name 'GetDriveType';
procedure GetDriveData(drive: uint8_t; var data: TDRIVE_DATA); stdcall; public name 'GetDriveData';
function GetDriveAttr(drive: uint8_t): uint32_t; stdcall; public name 'GetDriveAttr';
function GetDriveLabel(drive: uint8_t; _label: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'GetDriveLabel';
function SetDriveLabel(drive: uint8_t; const _label: PCHAR): BOOL; stdcall; public name 'SetDriveLabel';
function GetDriveSerial(drive: uint8_t): uint32_t; stdcall; public name 'GetDriveSerial';
function SetDriveSerial(drive: uint8_t; serial: uint32_t): BOOL; stdcall; public name 'SetDriveSerial';
function IsDriveValid(drive: uint8_t): BOOL; stdcall; public name 'IsDriveValid';
function GetValidDrives: uint32_t; stdcall; public name 'GetValidDrives';
function GetValidDriveNames(names: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'GetValidDriveNames';
function GetDriveFreeSpace(drive: uint8_t): uint32_t; stdcall; public name 'GetDriveFreeSpace';
function GetDriveFreeSpaceEx(drive: uint8_t): int64_t; stdcall; public name 'GetDriveFreeSpaceEx';
function GetDriveTotalSpace(drive: uint8_t): uint32_t; stdcall; public name 'GetDriveTotalSpace';
function GetDriveTotalSpaceEx(drive: uint8_t): int64_t; stdcall; public name 'GetDriveTotalSpaceEx';

function GetDriveInformation(const path: PCHAR; var clustersize: uint32_t; var totalclustercount, freeclustercount: int64_t): BOOL; stdcall; public name 'GetDriveInformation';

function GetCurrentDrive: uint8_t; stdcall; public name 'GetCurrentDrive';
function SetCurrentDrive(const drive: PCHAR): BOOL; stdcall; public name 'SetCurrentDrive';

{==============================================================================}
{File Functions (Compatibility)}
function AreFileApisANSI: BOOL; stdcall; public name 'AreFileApisANSI';
procedure SetFileApisToOEM; stdcall; public name 'SetFileApisToOEM';
procedure SetFileApisToANSI; stdcall; public name 'SetFileApisToANSI';

function CreateFile(const lpfilename: LPCSTR; dwdesiredaccess, dwsharemode: uint32_t; lpsecurityattributes: LPSECURITY_ATTRIBUTES; dwcreationdisposition: uint32_t; dwflagsandattributes: uint32_t; htemplatefile: HANDLE): HANDLE; stdcall; public name 'CreateFile';
function CreateFileA(const lpfilename: LPCSTR; dwdesiredaccess, dwsharemode: uint32_t; lpsecurityattributes: LPSECURITY_ATTRIBUTES; dwcreationdisposition: uint32_t; dwflagsandattributes: uint32_t; htemplatefile: HANDLE): HANDLE; stdcall; public name 'CreateFileA';
function CreateFileW(const lpfilename: LPCWSTR; dwdesiredaccess, dwsharemode: uint32_t; lpsecurityattributes: LPSECURITY_ATTRIBUTES; dwcreationdisposition: uint32_t; dwflagsandattributes: uint32_t; htemplatefile: HANDLE): HANDLE; stdcall; public name 'CreateFileW';

function SetFileAttributes(const lpfilename: LPCSTR; dwfileattributes: uint32_t): BOOL; stdcall; public name 'SetFileAttributes';
function SetFileAttributesA(const lpfilename: LPCSTR; dwfileattributes: uint32_t): BOOL; stdcall; public name 'SetFileAttributesA';
function SetFileAttributesW(const lpfilename: LPCWSTR; dwfileattributes: uint32_t): BOOL; stdcall; public name 'SetFileAttributesW';

function GetFileAttributes(const lpfilename: LPCSTR): uint32_t; stdcall; public name 'GetFileAttributes';
function GetFileAttributesA(const lpfilename: LPCSTR): uint32_t; stdcall; public name 'GetFileAttributesA';
function GetFileAttributesW(const lpfilename: LPCWSTR): uint32_t; stdcall; public name 'GetFileAttributesW';

function DeleteFile(const lpfilename: LPCSTR): BOOL; stdcall; public name 'DeleteFile';
function DeleteFileA(const lpfilename: LPCSTR): BOOL; stdcall; public name 'DeleteFileA';
function DeleteFileW(const lpfilename: LPCWSTR): BOOL; stdcall; public name 'DeleteFileW';

function MoveFile(const lpexistingfilename, lpnewfilename: LPCSTR): BOOL; stdcall; public name 'MoveFile';
function MoveFileA(const lpexistingfilename, lpnewfilename: LPCSTR): BOOL; stdcall; public name 'MoveFileA';
function MoveFileW(const lpexistingfilename, lpnewfilename: LPCWSTR): BOOL; stdcall; public name 'MoveFileW';

function FindFirstFile(const lpfilename: LPCSTR; var lpfindfiledata: WIN32_FIND_DATAA): HANDLE; stdcall; public name 'FindFirstFile';
function FindFirstFileA(const lpfilename: LPCSTR; var lpfindfiledata: WIN32_FIND_DATAA): HANDLE; stdcall; public name 'FindFirstFileA';
function FindFirstFileW(const lpfilename: LPCWSTR; var lpfindfiledata: WIN32_FIND_DATAW): HANDLE; stdcall; public name 'FindFirstFileW';

function FindNextFile(hfindfile: HANDLE; var lpfindfiledata: WIN32_FIND_DATAA): BOOL; stdcall; public name 'FindNextFile';
function FindNextFileA(hfindfile: HANDLE; var lpfindfiledata: WIN32_FIND_DATAA): BOOL; stdcall; public name 'FindNextFileA';
function FindNextFileW(hfindfile: HANDLE; var lpfindfiledata: WIN32_FIND_DATAW): BOOL; stdcall; public name 'FindNextFileW';

function FindCloseFile(hfindfile: HANDLE): BOOL; stdcall; public name 'FindCloseFile';

function GetFileSize(hfile: HANDLE; lpfilesizehigh: LPDWORD): uint32_t; stdcall; public name 'GetFileSize';
function GetFileSizeEx(hfile: HANDLE; var lpfilesize: LARGE_INTEGER): BOOL; stdcall; public name 'GetFileSizeEx';

function GetFileTime(hfile: HANDLE; lpcreationtime, lplastaccesstime, lplastwritetime: PFILETIME): BOOL; stdcall; public name 'GetFileTime';
function SetFileTime(hfile: HANDLE; lpcreationtime, lplastaccesstime, lplastwritetime: PFILETIME): BOOL; stdcall; public name 'SetFileTime';

function ReadFile(hfile: HANDLE; lpbuffer: LPVOID; nnumberofbytestoread: uint32_t; lpnumberofbytesread: LPDWORD; lpoverlapped: LPOVERLAPPED): BOOL; stdcall; public name 'ReadFile';
function WriteFile(hfile: HANDLE; lpbuffer: LPCVOID; nnumberofbytestowrite: uint32_t; lpnumberofbyteswritten: LPDWORD; lpoverlapped: LPOVERLAPPED): BOOL; stdcall; public name 'WriteFile';

function SetEndOfFile(hfile: HANDLE): BOOL; stdcall; public name 'SetEndOfFile';

function SetFilePointer(hfile: HANDLE; ldistancetomove: LONG; lpdistancetomovehigh: PLONG; dwmovemethod: uint32_t): uint32_t; stdcall; public name 'SetFilePointer';
function SetFilePointerEx(hfile: HANDLE; lidistancetomove: LARGE_INTEGER; lpnewfilepointer: PLARGE_INTEGER; dwmovemethod: uint32_t): BOOL; stdcall; public name 'SetFilePointerEx';

function FlushFileBuffers(hfile: HANDLE): BOOL; stdcall; public name 'FlushFileBuffers';

function CopyFile(const lpexistingfilename, lpnewfilename: LPCSTR; bfailifexists: BOOL): BOOL; stdcall; public name 'CopyFile';
function CopyFileA(const lpexistingfilename, lpnewfilename: LPCSTR; bfailifexists: BOOL): BOOL; stdcall; public name 'CopyFileA';
function CopyFileW(const lpexistingfilename, lpnewfilename: LPCWSTR; bfailifexists: BOOL): BOOL; stdcall; public name 'CopyFileW';

function SetFileShortName(hfile: HANDLE; const lpshortname: LPCSTR): BOOL; stdcall; public name 'SetFileShortName';
function SetFileShortNameA(hfile: HANDLE; const lpshortname: LPCSTR): BOOL; stdcall; public name 'SetFileShortNameA';
function SetFileShortNameW(hfile: HANDLE; const lpshortname: LPCWSTR): BOOL; stdcall; public name 'SetFileShortNameW';

function CreateHardLink(const lpfilename, lpexistingfilename: LPCSTR; lpsecurityattributes: LPSECURITY_ATTRIBUTES): BOOL; stdcall; public name 'CreateHardLink';
function CreateHardLinkA(const lpfilename, lpexistingfilename: LPCSTR; lpsecurityattributes: LPSECURITY_ATTRIBUTES): BOOL; stdcall; public name 'CreateHardLinkA';
function CreateHardLinkW(const lpfilename, lpexistingfilename: LPCWSTR; lpsecurityattributes: LPSECURITY_ATTRIBUTES): BOOL; stdcall; public name 'CreateHardLinkW';

function CreateSymbolicLink(const lpsymlinkfilename, lptargetfilename: LPCSTR; dwflags: uint32_t): BOOL; stdcall; public name 'CreateSymbolicLink';
function CreateSymbolicLinkA(const lpsymlinkfilename, lptargetfilename: LPCSTR; dwflags: uint32_t): BOOL; stdcall; public name 'CreateSymbolicLinkA';
function CreateSymbolicLinkW(const lpsymlinkfilename, lptargetfilename: LPCWSTR; dwflags: uint32_t): BOOL; stdcall; public name 'CreateSymbolicLinkW';

function GetFileInformationByHandle(hfile: HANDLE; var lpfileinformation: BY_HANDLE_FILE_INFORMATION): BOOL; stdcall; public name 'GetFileInformationByHandle';

function GetFinalPathNameByHandle(hfile: HANDLE; lpszfilepath: LPSTR; cchfilepath, dwflags: uint32_t): uint32_t; stdcall; public name 'GetFinalPathNameByHandle';
function GetFinalPathNameByHandleA(hfile: HANDLE; lpszfilepath: LPSTR; cchfilepath, dwflags: uint32_t): uint32_t; stdcall; public name 'GetFinalPathNameByHandleA';
function GetFinalPathNameByHandleW(hfile: HANDLE; lpszfilepath: LPWSTR; cchfilepath, dwflags: uint32_t): uint32_t; stdcall; public name 'GetFinalPathNameByHandleW';

{==============================================================================}
{File Functions (Ultibo)}

{==============================================================================}
{Directory Functions (Compatibility)}
function CreateDirectory(const lppathname: LPCSTR; lpsecurityattributes: LPSECURITY_ATTRIBUTES): BOOL; stdcall; public name 'CreateDirectory';
function CreateDirectoryA(const lppathname: LPCSTR; lpsecurityattributes: LPSECURITY_ATTRIBUTES): BOOL; stdcall; public name 'CreateDirectoryA';
function CreateDirectoryW(const lppathname: LPCWSTR; lpsecurityattributes: LPSECURITY_ATTRIBUTES): BOOL; stdcall; public name 'CreateDirectoryW';

function RemoveDirectory(const lppathname: LPCSTR): BOOL; stdcall; public name 'RemoveDirectory';
function RemoveDirectoryA(const lppathname: LPCSTR): BOOL; stdcall; public name 'RemoveDirectoryA';
function RemoveDirectoryW(const lppathname: LPCWSTR): BOOL; stdcall; public name 'RemoveDirectoryW';

function SetCurrentDirectory(const lppathname: LPCSTR): BOOL; stdcall; public name 'SetCurrentDirectory';
function SetCurrentDirectoryA(const lppathname: LPCSTR): BOOL; stdcall; public name 'SetCurrentDirectoryA';
function SetCurrentDirectoryW(const lppathname: LPCWSTR): BOOL; stdcall; public name 'SetCurrentDirectoryW';

function GetCurrentDirectory(nbufferlength: uint32_t; lpbuffer: LPSTR): uint32_t; stdcall; public name 'GetCurrentDirectory';
function GetCurrentDirectoryA(nbufferlength: uint32_t; lpbuffer: LPSTR): uint32_t; stdcall; public name 'GetCurrentDirectoryA';
function GetCurrentDirectoryW(nbufferlength: uint32_t; lpbuffer: LPWSTR): uint32_t; stdcall; public name 'GetCurrentDirectoryW';

function GetLongPathName(const lpszshortpath: LPCSTR; lpszlongpath: LPSTR; cchbuffer: uint32_t): uint32_t; stdcall; public name 'GetLongPathName';
function GetLongPathNameA(const lpszshortpath: LPCSTR; lpszlongpath: LPSTR; cchbuffer: uint32_t): uint32_t; stdcall; public name 'GetLongPathNameA';
function GetLongPathNameW(const lpszshortpath: LPCWSTR; lpszlongpath: LPWSTR; cchbuffer: uint32_t): uint32_t; stdcall; public name 'GetLongPathNameW';

function GetShortPathName(const lpszlongpath: LPCSTR; lpszshortpath: LPSTR; cchbuffer: uint32_t): uint32_t; stdcall; public name 'GetShortPathName';
function GetShortPathNameA(const lpszlongpath: LPCSTR; lpszshortpath: LPSTR; cchbuffer: uint32_t): uint32_t; stdcall; public name 'GetShortPathNameA';
function GetShortPathNameW(const lpszlongpath: LPCWSTR; lpszshortpath: LPWSTR; cchbuffer: uint32_t): uint32_t; stdcall; public name 'GetShortPathNameW';

function GetFullPathName(const lpfilename: LPCSTR; nbufferlength: uint32_t; lpbuffer: LPSTR; var lpfilepart: LPSTR): uint32_t; stdcall; public name 'GetFullPathName';
function GetFullPathNameA(const lpfilename: LPCSTR; nbufferlength: uint32_t; lpbuffer: LPSTR; var lpfilepart: LPSTR): uint32_t; stdcall; public name 'GetFullPathNameA';
function GetFullPathNameW(const lpfilename: LPCWSTR; nbufferlength: uint32_t; lpbuffer: LPWSTR; var lpfilepart: LPWSTR): uint32_t; stdcall; public name 'GetFullPathNameW';

{==============================================================================}
{Directory Functions (Ultibo)}

{==============================================================================}
{Command Line Functions (Compatibility)}
function GetCommandLine: LPSTR; stdcall; public name 'GetCommandLine';
function GetCommandLineA: LPSTR; stdcall; public name 'GetCommandLineA';
function GetCommandLineW: LPWSTR; stdcall; public name 'GetCommandLineW';

{==============================================================================}
{Command Line Functions (Ultibo)}
function IsParamPresent(const param: PCHAR): BOOL; stdcall; public name 'IsParamPresent';
function GetParamIndex(const param: PCHAR): int; stdcall; public name 'GetParamIndex';
function GetParamValue(const param: PCHAR; value: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'GetParamValue';

{==============================================================================}
{Environment Functions (Compatibility)}
function GetEnvironmentStrings: LPSTR; stdcall; public name 'GetEnvironmentStrings';
function GetEnvironmentStringsA: LPSTR; stdcall; public name 'GetEnvironmentStringsA';
function GetEnvironmentStringsW: LPWSTR; stdcall; public name 'GetEnvironmentStringsW';

function FreeEnvironmentStrings(pstr: LPSTR): BOOL; stdcall; public name 'FreeEnvironmentStrings';
function FreeEnvironmentStringsA(pstr: LPSTR): BOOL; stdcall; public name 'FreeEnvironmentStringsA';
function FreeEnvironmentStringsW(pstr: LPWSTR): BOOL; stdcall; public name 'FreeEnvironmentStringsW';

function GetEnvironmentVariable(const lpname: LPCSTR; lpbuffer: LPSTR; nsize: uint32_t): uint32_t; stdcall; public name 'GetEnvironmentVariable';
function GetEnvironmentVariableA(const lpname: LPCSTR; lpbuffer: LPSTR; nsize: uint32_t): uint32_t; stdcall; public name 'GetEnvironmentVariableA';
function GetEnvironmentVariableW(const lpname: LPCWSTR; lpbuffer: LPWSTR; nsize: uint32_t): uint32_t; stdcall; public name 'GetEnvironmentVariableW';

function SetEnvironmentVariable(const lpname, lpvalue: LPCSTR): BOOL; stdcall; public name 'SetEnvironmentVariable';
function SetEnvironmentVariableA(const lpname, lpvalue: LPCSTR): BOOL; stdcall; public name 'SetEnvironmentVariableA';
function SetEnvironmentVariableW(const lpname, lpvalue: LPCWSTR): BOOL; stdcall; public name 'SetEnvironmentVariableW';

function ExpandEnvironmentStrings(const lpsrc: LPCSTR; lpdst: LPSTR; nsize: uint32_t): uint32_t; stdcall; public name 'ExpandEnvironmentStrings';
function ExpandEnvironmentStringsA(const lpsrc: LPCSTR; lpdst: LPSTR; nsize: uint32_t): uint32_t; stdcall; public name 'ExpandEnvironmentStringsA';
function ExpandEnvironmentStringsW(const lpsrc: LPCWSTR; lpdst: LPWSTR; nsize: uint32_t): uint32_t; stdcall; public name 'ExpandEnvironmentStringsW';

{==============================================================================}
{Error Functions (Compatibility)}
function GetLastError: uint32_t; stdcall; public name 'GetLastError';
procedure SetLastError(dwerrcode: uint32_t); stdcall; public name 'SetLastError';

{==============================================================================}
{String Functions (Ultibo)}

{==============================================================================}
{GUID Functions (Ultibo)}
function CreateGUID: TGUID; stdcall; public name 'CreateGUID';
function GUIDToString(const value: TGUID; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'GUIDToString';
function StringToGUID(const value: PCHAR): TGUID; stdcall; public name 'StringToGUID';
function NullGUID(const guid: TGUID): BOOL; stdcall; public name 'NullGUID';
function CompareGUID(const guid1, guid2: TGUID): BOOL; stdcall; public name 'CompareGUID';

{==============================================================================}
{SID Functions (Ultibo)}
function SIDToString(sid: PSID; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'SIDToString';
function StringToSID(value: PCHAR): PSID; stdcall; public name 'StringToSID';

{==============================================================================}
{Date Functions (Ultibo)}

{==============================================================================}
{Numeric Functions (Ultibo)}
function Min(a, b: int): int; stdcall; public name 'Min';
function Max(a, b: int): int; stdcall; public name 'Max';

function MinEx(a, b: uint32_t): uint32_t; stdcall; public name 'MinEx';
function MaxEx(a, b: uint32_t): uint32_t; stdcall; public name 'MaxEx';

function Min64(const a, b: int64_t): int64_t; stdcall; public name 'Min64';
function Max64(const a, b: int64_t): int64_t; stdcall; public name 'Max64';

function Or64(const value1, value2: int64_t): int64_t; stdcall; public name 'Or64';
function And64(const value1, value2: int64_t): int64_t; stdcall; public name 'And64';
function Xor64(const value1, value2: int64_t): int64_t; stdcall; public name 'Xor64';
function Not64(const value: int64_t): int64_t; stdcall; public name 'Not64';

function Rol32(value: uint32_t; count: uint8_t): uint32_t; stdcall; public name 'Rol32';
function Ror32(value: uint32_t; count: uint8_t): uint32_t; stdcall; public name 'Ror32';

function WordSwap(value: uint16_t): uint16_t; stdcall; public name 'WordSwap';
function LongSwap(value: uint32_t): uint32_t; stdcall; public name 'LongSwap';
function Int64Swap(const value: int64_t): int64_t; stdcall; public name 'Int64Swap';
function BufferSwap(buffer: PVOID; size: uint32_t): BOOL; stdcall; public name 'BufferSwap';

{==============================================================================}
{Hash Functions (Ultibo)}
function GenerateNameHash(const name: PCHAR; size: int): uint32_t; stdcall; public name 'GenerateNameHash';
function GenerateStringHash(const value: PCHAR; casesensitive: BOOL): uint32_t; stdcall; public name 'GenerateStringHash';

{==============================================================================}
{Locale Functions (Compatibility)}
{function IsValidLocale(localeid: LCID; dwflags: uint32_t): BOOL; stdcall; public name 'IsValidLocale';} {Exported in Locale}

{function GetSystemDefaultLCID: LCID; stdcall; public name 'GetSystemDefaultLCID';} {Exported in Locale}
{function GetUserDefaultLCID: LCID; stdcall; public name 'GetUserDefaultLCID';} {Exported in Locale}

function GetThreadLocale: LCID; stdcall; public name 'GetThreadLocale';
function SetThreadLocale(localeid: LCID): BOOL; stdcall; public name 'SetThreadLocale';

{==============================================================================}
{Locale Functions (Ultibo)}
{function SetSystemDefaultLCID(localeid: LCID): BOOL; stdcall; public name 'SetSystemDefaultLCID';} {Exported in Locale}

function WideCharToString(const buffer: PWCHAR; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'WideCharToString';
function WideCharLenToString(const buffer: PWCHAR; _length: int; _string: PCHAR; len: uint32_t): uint32_t; stdcall; public name 'WideCharLenToString';
function StringToWideChar(const _string: PCHAR; buffer: PWCHAR; size: int): BOOL; stdcall; public name 'StringToWideChar';

{==============================================================================}
{Code Page Functions (Compatibility)}
{function IsValidCodePage(codepage: UINT): BOOL; stdcall; public name 'IsValidCodePage';} {Exported in Locale}

{function GetACP: UINT; stdcall; public name 'GetACP';} {Exported in Locale}
{function GetOEMCP: UINT; stdcall; public name 'GetOEMCP';} {Exported in Locale}

{function GetConsoleCP: UINT; stdcall; public name 'GetConsoleCP';} {Exported in Locale}
{function SetConsoleCP(wcodepageid: UINT): BOOL; stdcall; public name 'SetConsoleCP';} {Exported in Locale}

{function GetConsoleOutputCP: UINT; stdcall; public name 'GetConsoleOutputCP';} {Exported in Locale}
{function SetConsoleOutputCP(wcodepageid: UINT): BOOL; stdcall; public name 'SetConsoleOutputCP';} {Exported in Locale}

{function GetCPInfo(codepage: UINT; var lpcpinfo: CPINFO): BOOL; stdcall; public name 'GetCPInfo';} {Exported in Locale}

{function GetCPInfoEx(codepage: UINT; dwflags: uint32_t; var lpcpinfoex: CPINFOEXA): BOOL; stdcall; public name 'GetCPInfoEx';} {Exported in Locale}
{function GetCPInfoExA(codepage: UINT; dwflags: uint32_t; var lpcpinfoex: CPINFOEXA): BOOL; stdcall; public name 'GetCPInfoExA';} {Exported in Locale}
{function GetCPInfoExW(codepage: UINT; dwflags: uint32_t; var lpcpinfoex: CPINFOEXW): BOOL; stdcall; public name 'GetCPInfoExW';} {Exported in Locale}

{==============================================================================}
{Code Page Functions (Ultibo)}
{function SetACP(codepage: UINT): BOOL; stdcall; public name 'SetACP';} {Exported in Locale}
{function SetOEMCP(codepage: UINT): BOOL; stdcall; public name 'SetOEMCP';} {Exported in Locale}

{==============================================================================}
{Translation Functions (Compatibility)}
{function MultiByteToWideChar(codepage: UINT; dwflags: uint32_t; lpmultibytestr: LPCSTR; cbmultibyte: int; lpwidecharstr: LPWSTR; cchwidechar: int): int; stdcall; public name 'MultiByteToWideChar';} {Exported in Unicode}
{function WideCharToMultiByte(codepage: UINT; dwflags: uint32_t; lpwidecharstr: LPCWSTR; cchwidechar: int; lpmultibytestr: LPSTR; cbmultibyte: int; lpdefaultchar: LPCSTR; lpuseddefaultchar: LPBOOL): int; stdcall; public name 'WideCharToMultiByte';} {Exported in Unicode}

{function CompareString(locale: LCID; dwcmpflags: uint32_t; lpstring1: LPCSTR; cchcount1: int; lpstring2: LPCSTR; cchcount2: int): int; stdcall; public name 'CompareString';} {Exported in Unicode}
{function CompareStringA(locale: LCID; dwcmpflags: uint32_t; lpstring1: LPCSTR; cchcount1: int; lpstring2: LPCSTR; cchcount2: int): int; stdcall; public name 'CompareStringA';} {Exported in Unicode}
{function CompareStringW(locale: LCID; dwcmpflags: uint32_t; lpstring1: LPCWSTR; cchcount1: int; lpstring2: LPCWSTR; cchcount2: int): int; stdcall; public name 'CompareStringW';} {Exported in Unicode}

{function CharUpper(lpsz: LPSTR): LPSTR; stdcall; public name 'CharUpper';} {Exported in Unicode}
{function CharUpperA(lpsz: LPSTR): LPSTR; stdcall; public name 'CharUpperA';} {Exported in Unicode}
{function CharUpperW(lpsz: LPWSTR): LPWSTR; stdcall; public name 'CharUpperW';} {Exported in Unicode}

{function CharUpperBuff(lpsz: LPSTR; cchlength: uint32_t): uint32_t; stdcall; public name 'CharUpperBuff';} {Exported in Unicode}
{function CharUpperBuffA(lpsz: LPSTR; cchlength: uint32_t): uint32_t; stdcall; public name 'CharUpperBuffA';} {Exported in Unicode}
{function CharUpperBuffW(lpsz: LPWSTR; cchlength: uint32_t): uint32_t; stdcall; public name 'CharUpperBuffW';} {Exported in Unicode}

{function CharLower(lpsz: LPSTR): LPSTR; stdcall; public name 'CharLower';} {Exported in Unicode}
{function CharLowerA(lpsz: LPSTR): LPSTR; stdcall; public name 'CharLowerA';} {Exported in Unicode}
{function CharLowerW(lpsz: LPWSTR): LPWSTR; stdcall; public name 'CharLowerW';} {Exported in Unicode}

{function CharLowerBuff(lpsz: LPSTR; cchlength: uint32_t): uint32_t; stdcall; public name 'CharLowerBuff';} {Exported in Unicode}
{function CharLowerBuffA(lpsz: LPSTR; cchlength: uint32_t): uint32_t; stdcall; public name 'CharLowerBuffA';} {Exported in Unicode}
{function CharLowerBuffW(lpsz: LPWSTR; cchlength: uint32_t): uint32_t; stdcall; public name 'CharLowerBuffW';} {Exported in Unicode}

{function AnsiToOem(lpszsrc: LPCSTR; lpszdst: LPSTR): BOOL; stdcall; public name 'AnsiToOem';} {Exported in Unicode}
{function AnsiToOemBuff(lpszsrc: LPCSTR; lpszdst: LPSTR; cchdstlength: uint32_t): BOOL; stdcall; public name 'AnsiToOemBuff';} {Exported in Unicode}
{function OemToAnsi(lpszsrc: LPCSTR; lpszdst: LPSTR): BOOL; stdcall; public name 'OemToAnsi';} {Exported in Unicode}
{function OemToAnsiBuff(lpszsrc: LPCSTR; lpszdst: LPSTR; cchdstlength: uint32_t): BOOL; stdcall; public name 'OemToAnsiBuff';} {Exported in Unicode}

{function CharToOem(lpszsrc: LPCSTR; lpszdst: LPSTR): BOOL; stdcall; public name 'CharToOem';} {Exported in Unicode}
{function CharToOemA(lpszsrc: LPCSTR; lpszdst: LPSTR): BOOL; stdcall; public name 'CharToOemA';} {Exported in Unicode}
{function CharToOemW(lpszsrc: LPCWSTR; lpszdst: LPSTR): BOOL; stdcall; public name 'CharToOemW';} {Exported in Unicode}

{function OemToChar(lpszsrc: LPCSTR; lpszdst: LPSTR): BOOL; stdcall; public name 'OemToChar';} {Exported in Unicode}
{function OemToCharA(lpszsrc: LPCSTR; lpszdst: LPSTR): BOOL; stdcall; public name 'OemToCharA';} {Exported in Unicode}
{function OemToCharW(lpszsrc: LPCSTR; lpszdst: LPWSTR): BOOL; stdcall; public name 'OemToCharW';} {Exported in Unicode}

{function CharToOemBuff(lpszsrc: LPCSTR; lpszdst: LPSTR; cchdstlength: uint32_t): BOOL; stdcall; public name 'CharToOemBuff';} {Exported in Unicode}
{function CharToOemBuffA(lpszsrc: LPCSTR; lpszdst: LPSTR; cchdstlength: uint32_t): BOOL; stdcall; public name 'CharToOemBuffA';} {Exported in Unicode}
{function CharToOemBuffW(lpszsrc: LPCWSTR; lpszdst: LPSTR; cchdstlength: uint32_t): BOOL; stdcall; public name 'CharToOemBuffW';} {Exported in Unicode}

{function OemToCharBuff(lpszsrc: LPCSTR; lpszdst: LPSTR; cchdstlength: uint32_t): BOOL; stdcall; public name 'OemToCharBuff';} {Exported in Unicode}
{function OemToCharBuffA(lpszsrc: LPCSTR; lpszdst: LPSTR; cchdstlength: uint32_t): BOOL; stdcall; public name 'OemToCharBuffA';} {Exported in Unicode}
{function OemToCharBuffW(lpszsrc: LPCSTR; lpszdst: LPWSTR; cchdstlength: uint32_t): BOOL; stdcall; public name 'OemToCharBuffW';} {Exported in Unicode}

{==============================================================================}
{Handle Functions (Compatibility)}
function CloseHandle(hobject: HANDLE): BOOL; stdcall; public name 'CloseHandle';
function DuplicateHandle(hsourceprocesshandle: HANDLE; hsourcehandle: HANDLE; htargetprocesshandle: HANDLE; lptargethandle: LPHANDLE; dwdesiredaccess: uint32_t; binherithandle: BOOL; dwoptions: uint32_t): BOOL; stdcall; public name 'DuplicateHandle';

function GetHandleInformation(hobject: HANDLE; var lpdwflags: uint32_t): BOOL; stdcall; public name 'GetHandleInformation';
function SetHandleInformation(hobject: HANDLE; dwmask: uint32_t; dwflags: uint32_t): BOOL; stdcall; public name 'SetHandleInformation';

{==============================================================================}
{Memory Functions (Compatibility)}
procedure MoveMemory(destination, source: PVOID; length: SIZE_T); stdcall; public name 'MoveMemory';
procedure CopyMemory(destination, source: PVOID; length: SIZE_T); stdcall; public name 'CopyMemory';
procedure FillMemory(destination: PVOID; length: SIZE_T; fill: uint8_t); stdcall; public name 'FillMemory';
procedure ZeroMemory(destination: PVOID; length: SIZE_T); stdcall; public name 'ZeroMemory';

function GlobalAlloc(uflags: UINT; dwbytes: SIZE_T): HGLOBAL; stdcall; public name 'GlobalAlloc';
function GlobalReAlloc(hmem: HGLOBAL; dwbytes: SIZE_T; uflags: UINT): HGLOBAL; stdcall; public name 'GlobalReAlloc';
function GlobalFree(hmem: HGLOBAL): HGLOBAL; stdcall; public name 'GlobalFree';

function GlobalSize(hmem: HGLOBAL): SIZE_T; stdcall; public name 'GlobalSize';
function GlobalFlags(hmem: HGLOBAL): UINT; stdcall; public name 'GlobalFlags';

function GlobalLock(hmem: HGLOBAL): LPVOID; stdcall; public name 'GlobalLock';
function GlobalUnlock(hmem: HGLOBAL): BOOL; stdcall; public name 'GlobalUnlock';

function GlobalHandle(pmem: LPCVOID): HGLOBAL; stdcall; public name 'GlobalHandle';

procedure GlobalMemoryStatus(var lpbuffer: MEMORYSTATUS); stdcall; public name 'GlobalMemoryStatus';
function GlobalMemoryStatusEx(var lpbuffer: MEMORYSTATUSEX): BOOL; stdcall; public name 'GlobalMemoryStatusEx';

function LocalAlloc(uflags: UINT; ubytes: SIZE_T): HLOCAL; stdcall; public name 'LocalAlloc';
function LocalReAlloc(hmem: HLOCAL; ubytes: SIZE_T; uflags: UINT): HLOCAL; stdcall; public name 'LocalReAlloc';
function LocalFree(hmem: HLOCAL): HLOCAL; stdcall; public name 'LocalFree';

function LocalSize(hmem: HLOCAL): SIZE_T; stdcall; public name 'LocalSize';
function LocalFlags(hmem: HLOCAL): UINT; stdcall; public name 'LocalFlags';

function LocalLock(hmem: HLOCAL): LPVOID; stdcall; public name 'LocalLock';
function LocalUnlock(hmem: HLOCAL): BOOL; stdcall; public name 'LocalUnlock';

function LocalHandle(pmem: LPCVOID): HLOCAL; stdcall; public name 'LocalHandle';

function VirtualAlloc(lpaddress: LPVOID; dwsize: SIZE_T; flallocationtype: uint32_t; flprotect: uint32_t): LPVOID; stdcall; public name 'VirtualAlloc';
function VirtualFree(lpaddress: LPVOID; dwsize: SIZE_T; dwfreetype: uint32_t): BOOL; stdcall; public name 'VirtualFree';

function VirtualQuery(lpaddress: LPCVOID; var lpbuffer: MEMORY_BASIC_INFORMATION; dwlength: uint32_t): uint32_t; stdcall; public name 'VirtualQuery';

function VirtualLock(lpaddress: LPVOID; dwsize: SIZE_T): BOOL; stdcall; public name 'VirtualLock';
function VirtualUnlock(lpaddress: LPVOID; dwsize: SIZE_T): BOOL; stdcall; public name 'VirtualUnlock';

function FlushInstructionCache(hprocess: HANDLE; lpbaseaddress: LPCVOID; dwsize: uint32_t): BOOL; stdcall; public name 'FlushInstructionCache';

function GetNumaHighestNodeNumber(var highestnodenumber: ULONG): BOOL; stdcall; public name 'GetNumaHighestNodeNumber';
function GetNumaProcessorNode(const processor: uint8_t; var nodenumber: uint8_t): BOOL; stdcall; public name 'GetNumaProcessorNode';

{==============================================================================}
{Tls Functions (Compatibility)}
function TlsAlloc: uint32_t; stdcall; public name 'TlsAlloc';
function TlsAllocEx(bfree: BOOL): uint32_t; stdcall; public name 'TlsAllocEx';
function TlsGetValue(dwtlsindex: uint32_t): LPVOID; stdcall; public name 'TlsGetValue';
function TlsSetValue(dwtlsindex: uint32_t; lptlsvalue: LPVOID): BOOL; stdcall; public name 'TlsSetValue';
function TlsFree(dwtlsindex: uint32_t): BOOL; stdcall; public name 'TlsFree';

{==============================================================================}
{Thread Functions (Compatibility)}
function SwitchToThread: BOOL; stdcall; public name 'SwitchToThread';

procedure Sleep(dwmilliseconds: uint32_t); stdcall; public name 'Sleep';
function SleepEx(dwmilliseconds: uint32_t; balertable: BOOL): uint32_t; stdcall; public name 'SleepEx';

function GetCurrentThread: HANDLE; stdcall; public name 'GetCurrentThread';
function GetCurrentThreadId: uint32_t; stdcall; public name 'GetCurrentThreadId';

function GetThreadPriority(hthread: HANDLE): int; stdcall; public name 'GetThreadPriority';
function SetThreadPriority(hthread: HANDLE; npriority: int): BOOL; stdcall; public name 'SetThreadPriority';

function GetExitCodeThread(hthread: HANDLE; var lpexitcode: uint32_t): BOOL; stdcall; public name 'GetExitCodeThread';

function GetThreadAffinityMask(hthread: HANDLE): DWORD_PTR; stdcall; public name 'GetThreadAffinityMask';
function SetThreadAffinityMask(hthread: HANDLE; dwthreadaffinitymask: DWORD_PTR): DWORD_PTR; stdcall; public name 'SetThreadAffinityMask';

function GetThreadTimes(hthread: HANDLE; var lpcreationtime, lpexittime, lpkerneltime, lpusertime: FILETIME): BOOL; stdcall; public name 'GetThreadTimes';

function CreateThread(lpthreadattributes: LPSECURITY_ATTRIBUTES; dwstacksize: uint32_t; lpstartaddress: LPTHREAD_START_ROUTINE; lpparameter: LPVOID; dwcreationflags: uint32_t; lpthreadid: LPDWORD): HANDLE; stdcall; public name 'CreateThread';
function OpenThread(dwdesiredaccess: uint32_t; binherithandle: BOOL; dwthreadid: uint32_t): HANDLE; stdcall; public name 'OpenThread';

function SuspendThread(hthread: HANDLE): uint32_t; stdcall; public name 'SuspendThread';
function ResumeThread(hthread: HANDLE): uint32_t; stdcall; public name 'ResumeThread';

function TerminateThread(hthread: HANDLE; dwexitcode: uint32_t): BOOL; stdcall; public name 'TerminateThread';

procedure ExitThread(dwexitcode: uint32_t); stdcall; public name 'ExitThread';

function WaitForSingleObject(hhandle: HANDLE; dwmilliseconds: uint32_t): uint32_t; stdcall; public name 'WaitForSingleObject';
function WaitForMultipleObjects(ncount: uint32_t; lphandles: PHANDLE; bwaitall: BOOL; dwmilliseconds: uint32_t): uint32_t; stdcall; public name 'WaitForMultipleObjects';

function WaitForSingleObjectEx(hhandle: HANDLE; dwmilliseconds: uint32_t; balertable: BOOL): uint32_t; stdcall; public name 'WaitForSingleObjectEx';
function WaitForMultipleObjectsEx(ncount: uint32_t; lphandles: PHANDLE; bwaitall: BOOL; dwmilliseconds: uint32_t; balertable: BOOL): uint32_t; stdcall; public name 'WaitForMultipleObjectsEx';

{==============================================================================}
{Thread Functions (Ultibo)}
function BeginThreadEx(threadfunction: thread_func; parameter: PVOID; var threadid: TTHREAD_ID; const stacksize: SIZE_T; priority, affinity, cpu: uint32_t; const name: PCHAR): TTHREAD_ID; stdcall; public name 'BeginThreadEx';

{==============================================================================}
{Message Functions (Compatibility)}
function WaitMessage: BOOL; stdcall; public name 'WaitMessage';

function GetMessage(lpmsg: LPMSG; hthread: HANDLE; wmsgfiltermin, wmsgfiltermax: UINT): BOOL; stdcall; public name 'GetMessage';
function PeekMessage(var lpmsg: MSG; hthread: HANDLE; wmsgfiltermin, wmsgfiltermax, wremovemsg: UINT): BOOL; stdcall; public name 'PeekMessage';

function PostMessage(hthread: HANDLE; msg: UINT; wparam: WPARAM; lparam: LPARAM): BOOL; stdcall; public name 'PostMessage';
function SendMessage(hthread: HANDLE; msg: UINT; wparam: WPARAM; lparam: LPARAM): LRESULT; stdcall; public name 'SendMessage';
function SendMessageTimeout(hthread: HANDLE; msg: UINT; wparam: WPARAM; lparam: LPARAM; fuflags, utimeout: UINT; var lpdwresult: DWORD_PTR): LRESULT; stdcall; public name 'SendMessageTimeout';

{==============================================================================}
{Notification Functions (Compatibility)}

{==============================================================================}
{Interlocked Functions (Compatibility)}
function InterlockedIncrement(var lpaddend: LONG): LONG; stdcall; public name 'InterlockedIncrement';
function InterlockedDecrement(var lpaddend: LONG): LONG; stdcall; public name 'InterlockedDecrement';

function InterlockedExchange(var target: LONG; value: LONG): LONG; stdcall; public name 'InterlockedExchange';
function InterlockedExchangePointer(var target: PVOID; value: PVOID): PVOID; stdcall; public name 'InterlockedExchangePointer';

function InterlockedExchangeAdd(var addend: LONG; value: LONG): LONG; stdcall; public name 'InterlockedExchangeAdd';
function InterlockedCompareExchange(var destination: LONG; exchange: LONG; comperand: LONG): LONG; stdcall; public name 'InterlockedCompareExchange';
function InterlockedCompareExchangePointer(var destination: PVOID; exchange, comperand: PVOID): PVOID; stdcall; public name 'InterlockedCompareExchangePointer';

{==============================================================================}
{Mutex Functions (Compatibility)}
function CreateMutex(lpmutexattributes: LPSECURITY_ATTRIBUTES; binitialowner: BOOL; const lpname: LPCSTR): HANDLE; stdcall; public name 'CreateMutex';
function CreateMutexA(lpmutexattributes: LPSECURITY_ATTRIBUTES; binitialowner: BOOL; const lpname: LPCSTR): HANDLE; stdcall; public name 'CreateMutexA';
function CreateMutexW(lpmutexattributes: LPSECURITY_ATTRIBUTES; binitialowner: BOOL; const lpname: LPCWSTR): HANDLE; stdcall; public name 'CreateMutexW';

function OpenMutex(dwdesiredaccess: uint32_t; binherithandle: BOOL; const lpname: LPCSTR): HANDLE; stdcall; public name 'OpenMutex';
function OpenMutexA(dwdesiredaccess: uint32_t; binherithandle: BOOL; const lpname: LPCSTR): HANDLE; stdcall; public name 'OpenMutexA';
function OpenMutexW(dwdesiredaccess: uint32_t; binherithandle: BOOL; const lpname: LPCWSTR): HANDLE; stdcall; public name 'OpenMutexW';

function ReleaseMutex(hmutex: HANDLE): BOOL; stdcall; public name 'ReleaseMutex';

{==============================================================================}
{Semaphore Functions (Compatibility)}
function CreateSemaphore(lpsemaphoreattributes: LPSECURITY_ATTRIBUTES; linitialcount, lmaximumcount: LONG; const lpname: LPCSTR): HANDLE; stdcall; public name 'CreateSemaphore';
function CreateSemaphoreA(lpsemaphoreattributes: LPSECURITY_ATTRIBUTES; linitialcount, lmaximumcount: LONG; const lpname: LPCSTR): HANDLE; stdcall; public name 'CreateSemaphoreA';
function CreateSemaphoreW(lpsemaphoreattributes: LPSECURITY_ATTRIBUTES; linitialcount, lmaximumcount: LONG; const lpname: LPCWSTR): HANDLE; stdcall; public name 'CreateSemaphoreW';

function OpenSemaphore(dwdesiredaccess: uint32_t; binherithandle: BOOL; const lpname: LPCSTR): HANDLE; stdcall; public name 'OpenSemaphore';
function OpenSemaphoreA(dwdesiredaccess: uint32_t; binherithandle: BOOL; const lpname: LPCSTR): HANDLE; stdcall; public name 'OpenSemaphoreA';
function OpenSemaphoreW(dwdesiredaccess: uint32_t; binherithandle: BOOL; const lpname: LPCWSTR): HANDLE; stdcall; public name 'OpenSemaphoreW';

function ReleaseSemaphore(hsemaphore: HANDLE; lreleasecount: LONG; lppreviouscount: LPLONG): BOOL; stdcall; public name 'ReleaseSemaphore';

{==============================================================================}
{Critical Section Functions (Compatibility)}
procedure InitializeCriticalSection(var lpcriticalsection: CRITICAL_SECTION); stdcall; public name 'InitializeCriticalSection';
procedure EnterCriticalSection(var lpcriticalsection: CRITICAL_SECTION); stdcall; public name 'EnterCriticalSection';
procedure LeaveCriticalSection(var lpcriticalsection: CRITICAL_SECTION); stdcall; public name 'LeaveCriticalSection';
function TryEnterCriticalSection(var lpcriticalsection: CRITICAL_SECTION): BOOL; stdcall; public name 'TryEnterCriticalSection';

function InitializeCriticalSectionAndSpinCount(var lpcriticalsection: CRITICAL_SECTION; dwspincount: uint32_t): BOOL; stdcall; public name 'InitializeCriticalSectionAndSpinCount';
function SetCriticalSectionSpinCount(var lpcriticalsection: CRITICAL_SECTION; dwspincount: uint32_t): uint32_t; stdcall; public name 'SetCriticalSectionSpinCount';

procedure DeleteCriticalSection(var lpcriticalsection: CRITICAL_SECTION); stdcall; public name 'DeleteCriticalSection';

{==============================================================================}
{Condition Variable Functions (Compatibility)}
procedure InitializeConditionVariable(var conditionvariable: CONDITION_VARIABLE); stdcall; public name 'InitializeConditionVariable';

procedure WakeConditionVariable(var conditionvariable: CONDITION_VARIABLE); stdcall; public name 'WakeConditionVariable';
procedure WakeAllConditionVariable(var conditionvariable: CONDITION_VARIABLE); stdcall; public name 'WakeAllConditionVariable';

function SleepConditionVariableCS(var conditionvariable: CONDITION_VARIABLE; var criticalsection: CRITICAL_SECTION; dwmilliseconds: uint32_t): BOOL; stdcall; public name 'SleepConditionVariableCS';

procedure DeleteConditionVariable(var conditionvariable: CONDITION_VARIABLE); stdcall; public name 'DeleteConditionVariable';

{==============================================================================}
{Event Functions (Compatibility)}
function CreateEvent(lpeventattributes: LPSECURITY_ATTRIBUTES; bmanualreset, binitialstate: BOOL; const lpname: LPCSTR): HANDLE; stdcall; public name 'CreateEvent';
function CreateEventA(lpeventattributes: LPSECURITY_ATTRIBUTES; bmanualreset, binitialstate: BOOL; const lpname: LPCSTR): HANDLE; stdcall; public name 'CreateEventA';
function CreateEventW(lpeventattributes: LPSECURITY_ATTRIBUTES; bmanualreset, binitialstate: BOOL; const lpname: LPCWSTR): HANDLE; stdcall; public name 'CreateEventW';

function OpenEvent(dwdesiredaccess: uint32_t; binherithandle: BOOL; const lpname: LPCSTR): HANDLE; stdcall; public name 'OpenEvent';
function OpenEventA(dwdesiredaccess: uint32_t; binherithandle: BOOL; const lpname: LPCSTR): HANDLE; stdcall; public name 'OpenEventA';
function OpenEventW(dwdesiredaccess: uint32_t; binherithandle: BOOL; const lpname: LPCWSTR): HANDLE; stdcall; public name 'OpenEventW';

function SetEvent(hevent: HANDLE): BOOL; stdcall; public name 'SetEvent';
function ResetEvent(hevent: HANDLE): BOOL; stdcall; public name 'ResetEvent';
function PulseEvent(hevent: HANDLE): BOOL; stdcall; public name 'PulseEvent';

{==============================================================================}
{Process Functions (Compatibility)}
function GetProcessAffinityMask(hprocess: HANDLE; var lpprocessaffinitymask, lpsystemaffinitymask: DWORD_PTR): BOOL; stdcall; public name 'GetProcessAffinityMask';
function SetProcessAffinityMask(hprocess: HANDLE; dwprocessaffinitymask: DWORD_PTR): BOOL; stdcall; public name 'SetProcessAffinityMask';

function GetProcessTimes(hprocess: HANDLE; var lpcreationtime, lpexittime, lpkerneltime, lpusertime: FILETIME): BOOL; stdcall; public name 'GetProcessTimes';
function GetProcessIoCounters(hprocess: HANDLE; var lpiocounters: IO_COUNTERS): BOOL; stdcall; public name 'GetProcessIoCounters';

function GetCurrentProcess: HANDLE; stdcall; public name 'GetCurrentProcess';
function GetCurrentProcessId: uint32_t; stdcall; public name 'GetCurrentProcessId';

procedure ExitProcess(uexitcode: UINT); stdcall; public name 'ExitProcess';
procedure FatalExit(exitcode: int); stdcall; public name 'FatalExit';

function TerminateProcess(hprocess: HANDLE; uexitcode: UINT): BOOL; stdcall; public name 'TerminateProcess';

{==============================================================================}
{Debug Functions (Compatibility)}
procedure OutputDebugString(const lpoutputstring: LPCSTR); stdcall; public name 'OutputDebugString';
procedure OutputDebugStringA(const lpoutputstring: LPCSTR); stdcall; public name 'OutputDebugStringA';
procedure OutputDebugStringW(const lpoutputstring: LPCWSTR); stdcall; public name 'OutputDebugStringW';

{==============================================================================}
{Library Functions (Compatibility)}
function lstrcmp(lpstring1, lpstring2: LPCSTR): int; stdcall; public name 'lstrcmp';
function lstrcmpA(lpstring1, lpstring2: LPCSTR): int; stdcall; public name 'lstrcmpA';
function lstrcmpW(lpstring1, lpstring2: LPCWSTR): int; stdcall; public name 'lstrcmpW';

function lstrcmpi(lpstring1, lpstring2: LPCSTR): int; stdcall; public name 'lstrcmpi';
function lstrcmpiA(lpstring1, lpstring2: LPCSTR): int; stdcall; public name 'lstrcmpiA';
function lstrcmpiW(lpstring1, lpstring2: LPCWSTR): int; stdcall; public name 'lstrcmpiW';

function lstrcpy(lpstring1: LPSTR; lpstring2: LPCSTR): LPSTR; stdcall; public name 'lstrcpy';
function lstrcpyA(lpstring1: LPSTR; lpstring2: LPCSTR): LPSTR; stdcall; public name 'lstrcpyA';
function lstrcpyW(lpstring1: LPWSTR; lpstring2: LPCWSTR): LPWSTR; stdcall; public name 'lstrcpyW';

function lstrcpyn(lpstring1: LPSTR; lpstring2: LPCSTR; imaxlength: int): LPSTR; stdcall; public name 'lstrcpyn';
function lstrcpynA(lpstring1: LPSTR; lpstring2: LPCSTR; imaxlength: int): LPSTR; stdcall; public name 'lstrcpynA';
function lstrcpynW(lpstring1: LPWSTR; lpstring2: LPCWSTR; imaxlength: int): LPWSTR; stdcall; public name 'lstrcpynW';

function lstrcat(lpstring1: LPSTR; lpstring2: LPCSTR): LPSTR; stdcall; public name 'lstrcat';
function lstrcatA(lpstring1: LPSTR; lpstring2: LPCSTR): LPSTR; stdcall; public name 'lstrcatA';
function lstrcatW(lpstring1: LPWSTR; lpstring2: LPCWSTR): LPWSTR; stdcall; public name 'lstrcatW';

function lstrlen(lpstring: LPCSTR): int; stdcall; public name 'lstrlen';
function lstrlenA(lpstring: LPCSTR): int; stdcall; public name 'lstrlenA';
function lstrlenW(lpstring: LPCWSTR): int; stdcall; public name 'lstrlenW';
{$ENDIF}
{==============================================================================}
{==============================================================================}
{API Libraries}
{$if defined(API_EXPORT_PLATFORM) or defined(API_EXPORT_CONSOLE) or defined(API_EXPORT_LOGGING) or defined(API_EXPORT_SERIAL)}
{$linklib ultiboapi}
{$ENDIF}

{==============================================================================}
{==============================================================================}

implementation

{$NOTES OFF}

{==============================================================================}
{==============================================================================}
var
 {API specific variables}
 APIInitialized: BOOL;

{==============================================================================}
{==============================================================================}
{Initialization Functions}
procedure APIInit;
begin
 {}
 {Check Initialized}
 if APIInitialized then Exit;

 APIInitialized:=True;
end;

{==============================================================================}
{==============================================================================}
{API Functions}
function APIStringToPCharAlloc(const Value:String):PChar;
{Allocates and returns a buffer large enough to hold a copy of the supplied}
{ string plus a null terminator and copies the string to the buffer}
{Note: The caller must free the returned buffer}
begin
 {}
 {Allocate Result}
 Result:=GetMem((Length(Value) + 1) * SizeOf(Char));

 {Copy Value}
 if Length(Value) > 0 then StrLCopy(Result,PChar(Value),Length(Value));

 {Add Null Terminator}
 Result[Length(Value)]:=#0;
end;

{==============================================================================}

function APIStringToPCharBuffer(const Value:String;Buffer:PChar;Len:LongWord):LongWord;
{Copies the supplied string to the supplied buffer and returns the number of}
{characters copied to the buffer, not including the null terminator}

{The caller must supply a preallocated Buffer, the value of Len indicates the}
{number of characters the buffer can hold including the null terminator}

{If the buffer is too small the return value is the size in characters needed}
{to store the supplied string and the null terminator}

{If an error occurs the return value is zero}
begin
 {}
 Result:=0;

 {Check Buffer}
 if Buffer = nil then Exit;

 {Check Length}
 if Len < (Length(Value) + 1) then
  begin
   {Return Length Needed}
   Result:=(Length(Value) + 1);
  end
 else
  begin
   {Copy Value}
   if Length(Value) > 0 then StrLCopy(Buffer,PChar(Value),Length(Value));

   {Add Null Terminator}
   Buffer[Length(Value)]:=#0;

   {Return Length Copied}
   Result:=Length(Value);
  end;
end;

{==============================================================================}

procedure APIStringToPCharBufferLen(const Value:String;Buffer:PChar;var Len:LongWord);
{Copies the supplied string to the supplied buffer and updates Len with the number of}
{characters copied to the buffer, not including the null terminator}

{The caller must supply a preallocated Buffer, the value of Len indicates the}
{number of characters the buffer can hold including the null terminator}

{If the buffer is too small the value returned in Len is the number of characters}
{copied, not including the null terminator, which will be less than the string}
begin
 {}
 {Check Buffer and Length}
 if (Buffer = nil) or (Len < 1) then
  begin
   {Return Empty}
   Len:=0;
  end
 else
  begin
   {Return Length Copied}
   Len:=Min(Length(Value),Len - 1);

   {Copy Value}
   if Length(Value) > 0 then StrLCopy(Buffer,PChar(Value),Len);

   {Add Null Terminator}
   Buffer[Length(Value)]:=#0;
  end;
end;

{==============================================================================}

function APIUnicodeStringToPWideCharBuffer(const Value:UnicodeString;Buffer:PWideChar;Len:LongWord):LongWord;
{Copies the supplied string to the supplied buffer and returns the number of}
{characters copied to the buffer, not including the null terminator}

{The caller must supply a preallocated Buffer, the value of Len indicates the}
{number of characters the buffer can hold including the null terminator}

{If the buffer is too small the return value is the size in characters needed}
{to store the supplied string and the null terminator}

{If an error occurs the return value is zero}
begin
 {}
 Result:=0;

 {Check Buffer}
 if Buffer = nil then Exit;

 {Check Length}
 if Len < (Length(Value) + 1) then
  begin
   {Return Length Needed}
   Result:=(Length(Value) + 1);
  end
 else
  begin
   {Copy Value}
   if Length(Value) > 0 then StrLCopy(Buffer,PWideChar(Value),Length(Value));

   {Add Null Terminator}
   Buffer[Length(Value)]:=#0;

   {Return Length Copied}
   Result:=Length(Value);
  end;
end;

{==============================================================================}
{==============================================================================}
{Platform Functions}
{$IFDEF API_EXPORT_PLATFORM}
{Device Tree Functions}
function device_tree_valid: BOOL; stdcall;
{Check if valid Device Tree information was provided by the firmware/bootloader}
begin
 {}
 if Assigned(DeviceTreeValidHandler) then
  begin
   Result:=DeviceTreeValidHandler;
  end
 else
  begin
   Result:=DEVICE_TREE_VALID;
  end;
end;

{==============================================================================}

function device_tree_get_base: SIZE_T; stdcall;
{Get the base address of the Device Tree Blob (Where Applicable)}
begin
 {}
 if Assigned(DeviceTreeGetBaseHandler) then
  begin
   Result:=DeviceTreeGetBaseHandler;
  end
 else
  begin
   Result:=DEVICE_TREE_BASE;
  end;
end;

{==============================================================================}

function device_tree_get_size: uint32_t; stdcall;
{Get the total size of the Device Tree Blob (Where Applicable)}
begin
 {}
 if Assigned(DeviceTreeGetSizeHandler) then
  begin
   Result:=DeviceTreeGetSizeHandler;
  end
 else
  begin
   Result:=DEVICE_TREE_SIZE;
  end;
end;

{==============================================================================}

function device_tree_read(const path, name: PCHAR; buffer: PVOID; var size: uint32_t): uint32_t; stdcall;
{Read the raw value of a Device Tree property (Where Applicable)}
{Path: The path of the requested property}
{Name: The name of the requested property}
{Buffer: A pointer to a buffer to receive the raw value}
{Size: The size in byte of the buffer, updated on return with the actual size of the value}
{Return: ERROR_SUCCESS if the property value was read or another error code on failure}
begin
 {}
 if Assigned(DeviceTreeReadHandler) then
  begin
   Result:=DeviceTreeReadHandler(String(path),String(name),buffer,size);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function device_tree_read32(const path, name: PCHAR; var value: uint32_t): uint32_t; stdcall;
{Read a 32-bit value from a Device Tree property (Where Applicable)}
{Path: The path of the requested property}
{Name: The name of the requested property}
{Value: The returned value of the property}
{Return: ERROR_SUCCESS if the property value was read or another error code on failure}
begin
 {}
 if Assigned(DeviceTreeRead32Handler) then
  begin
   Result:=DeviceTreeRead32Handler(String(path),String(name),value);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function device_tree_read64(const path, name: PCHAR; var value: uint64_t): uint32_t; stdcall;
{Read a 64-bit value from a Device Tree property (Where Applicable)}
{Path: The path of the requested property}
{Name: The name of the requested property}
{Value: The returned value of the property}
{Return: ERROR_SUCCESS if the property value was read or another error code on failure}
begin
 {}
 if Assigned(DeviceTreeRead64Handler) then
  begin
   Result:=DeviceTreeRead64Handler(String(path),String(name),value);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function device_tree_read_string(const path, name: PCHAR; value: PCHAR; len: uint32_t): uint32_t; stdcall;
{Read a string value from a Device Tree property (Where Applicable)}
{Path: The path of the requested property}
{Name: The name of the requested property}
{Value: The returned value of the property}
{Return: ERROR_SUCCESS if the property value was read or another error code on failure}
var
 Buffer:String;
begin
 {}
 if Assigned(DeviceTreeReadStringHandler) then
  begin
   Result:=DeviceTreeReadStringHandler(String(path),String(name),Buffer);
   if Result = ERROR_SUCCESS then APIStringToPCharBuffer(Buffer,value,len);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}
{Boot Functions}
procedure boot_blink; stdcall;
{Blink the Activity LED (Where Applicable)}
{Note: Intended for startup diagnostics when bootstrapping a new board}
begin
 {}
 if Assigned(BootBlinkHandler) then
  begin
   BootBlinkHandler;
  end;
end;

{==============================================================================}

procedure boot_output(value: uint32_t); stdcall;
{Output boot time information (Where Applicable)}
{Note: Intended for startup diagnostics when bootstrapping a new board}
begin
 {}
 if Assigned(BootOutputHandler) then
  begin
   BootOutputHandler(Value);
  end;
end;

{==============================================================================}

procedure boot_console_start; stdcall;
{Start the boot time console display (Where Applicable)}
{Note: Intended for startup diagnostics when bootstrapping a new board}
begin
 {}
 if Assigned(BootConsoleStartHandler) then
  begin
   BootConsoleStartHandler;
  end;
end;

{==============================================================================}

procedure boot_console_write(const value: PCHAR); stdcall;
{Output text to the boot time console display (Where Applicable)}
{Note: Intended for startup diagnostics when bootstrapping a new board}
begin
 {}
 if Assigned(BootConsoleWriteHandler) then
  begin
   BootConsoleWriteHandler(String(Value));
  end;
end;

{==============================================================================}

procedure boot_console_write_ex(const value: PCHAR; x, y: uint32_t); stdcall;
{Output text to the boot time console display at the specified X and Y position (Where Applicable)}
{Note: Intended for startup diagnostics when bootstrapping a new board}
begin
 {}
 if Assigned(BootConsoleWriteExHandler) then
  begin
   BootConsoleWriteExHandler(String(Value),X,Y);
  end;
end;

{==============================================================================}

function boot_console_get_x: uint32_t; stdcall;
{Get the current X position of the boot time console display (Where Applicable)}
{Note: Intended for startup diagnostics when bootstrapping a new board}
begin
 {}
 if Assigned(BootConsoleGetXHandler) then
  begin
   Result:=BootConsoleGetXHandler;
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function boot_console_get_y: uint32_t; stdcall;
{Get the current Y position of the boot time console display (Where Applicable)}
{Note: Intended for startup diagnostics when bootstrapping a new board}
begin
 {}
 if Assigned(BootConsoleGetYHandler) then
  begin
   Result:=BootConsoleGetYHandler;
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}
{LED Functions}
procedure power_led_enable; stdcall;
{Enable the Power LED (Where Applicable)}
begin
 {}
 if Assigned(PowerLEDEnableHandler) then
  begin
   PowerLEDEnableHandler;
  end;
end;

{==============================================================================}

procedure power_led_on; stdcall;
{Turn On the Power LED (Where Applicable)}
begin
 {}
 if Assigned(PowerLEDOnHandler) then
  begin
   PowerLEDOnHandler;
  end;
end;

{==============================================================================}

procedure power_led_off; stdcall;
{Turn Off the Power LED (Where Applicable)}
begin
 {}
 if Assigned(PowerLEDOffHandler) then
  begin
   PowerLEDOffHandler;
  end;
end;

{==============================================================================}

procedure activity_led_enable; stdcall;
{Enable the Activity LED (Where Applicable)}
begin
 {}
 if Assigned(ActivityLEDEnableHandler) then
  begin
   ActivityLEDEnableHandler;
  end;
end;

{==============================================================================}

procedure activity_led_on; stdcall;
{Turn On the Activity LED (Where Applicable)}
begin
 {}
 if Assigned(ActivityLEDOnHandler) then
  begin
   ActivityLEDOnHandler;
  end;
end;

{==============================================================================}

procedure activity_led_off; stdcall;
{Turn Off the Activity LED (Where Applicable)}
begin
 {}
 if Assigned(ActivityLEDOffHandler) then
  begin
   ActivityLEDOffHandler;
  end;
end;

{==============================================================================}
{Counter Functions (Timer device)}
function counter_available: BOOL; stdcall;
{Check if a counter is currently available}
begin
 {}
 if Assigned(CounterAvailableHandler) then
  begin
   Result:=CounterAvailableHandler;
  end
 else
  begin
   Result:=False;
  end;
end;

{==============================================================================}

function counter_read: uint32_t; stdcall;
{Read the current value of the default counter}
begin
 {}
 if Assigned(CounterReadHandler) then
  begin
   Result:=CounterReadHandler;
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function counter_read64: int64_t; stdcall;
{Read the current value of the default counter}
begin
 {}
 if Assigned(CounterRead64Handler) then
  begin
   Result:=CounterRead64Handler;
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function counter_wait: uint32_t; stdcall;
{_wait for the current interval to expire on the default counter}
begin
 {}
 if Assigned(CounterWaitHandler) then
  begin
   Result:=CounterWaitHandler;
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function counter_event(callback: counter_event_cb; data: PVOID): uint32_t; stdcall;
begin
 {}
 if Assigned(CounterEventHandler) then
  begin
   Result:=CounterEventHandler(callback,data);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function counter_cancel: uint32_t; stdcall;
{Cancel a previously scheduled event callback function on the default counter}
begin
 {}
 if Assigned(CounterCancelHandler) then
  begin
   Result:=CounterCancelHandler;
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function counter_get_rate: uint32_t; stdcall;
{Get the current clock rate in Hz of the default counter}
begin
 {}
 if Assigned(CounterGetRateHandler) then
  begin
   Result:=CounterGetRateHandler;
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function counter_set_rate(rate: uint32_t): uint32_t; stdcall;
{Set the current clock rate in Hz of the default counter}
begin
 {}
 if Assigned(CounterSetRateHandler) then
  begin
   Result:=CounterSetRateHandler(rate);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function counter_get_interval: uint32_t; stdcall;
{Get the current interval in ticks of the default counter}
begin
 {}
 if Assigned(CounterGetIntervalHandler) then
  begin
   Result:=CounterGetIntervalHandler;
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function counter_set_interval(interval: uint32_t): uint32_t; stdcall;
{Set the current interval in ticks of the default counter}
begin
 {}
 if Assigned(CounterSetIntervalHandler) then
  begin
   Result:=CounterSetIntervalHandler(Interval);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}
{Mailbox Functions}
function mailbox_receive(mailbox, channel: uint32_t): uint32_t; stdcall;
{Receive from specified mailbox on specified channel}
begin
 {}
 if Assigned(MailboxReceiveHandler) then
  begin
   Result:=MailboxReceiveHandler(mailbox,channel);
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

procedure mailbox_send(mailbox, channel, data: uint32_t); stdcall;
{Send to specified mailbox on specified channel}
begin
 {}
 if Assigned(MailboxSendHandler) then
  begin
   MailboxSendHandler(mailbox,channel,data);
  end;
end;

{==============================================================================}

function mailbox_call(mailbox, channel, data: uint32_t; var response: uint32_t): uint32_t; stdcall;
{Perform a transaction (Send/Receive) to specified mailbox on specified channel}
begin
 {}
 if Assigned(MailboxCallHandler) then
  begin
   Result:=MailboxCallHandler(mailbox,channel,data,response);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function mailbox_call_ex(mailbox, channel, data: uint32_t; var response: uint32_t; timeout: uint32_t): uint32_t; stdcall;
{Perform a transaction (Send/Receive) to specified mailbox on specified channel}
begin
 {}
 if Assigned(MailboxCallExHandler) then
  begin
   Result:=MailboxCallExHandler(mailbox,channel,data,response,timeout);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function mailbox_property_call(mailbox, channel: uint32_t; data: PVOID; var response: uint32_t): uint32_t; stdcall;
{Perform a property tag transaction (Send/Receive) to specified mailbox on specified channel}
begin
 {}
 if Assigned(MailboxPropertyCallHandler) then
  begin
   Result:=MailboxPropertyCallHandler(mailbox,channel,data,response);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function mailbox_property_call_ex(mailbox, channel: uint32_t; data: PVOID; var response: uint32_t; timeout: uint32_t): uint32_t; stdcall;
{Perform a property tag transaction (Send/Receive) to specified mailbox on specified channel}
begin
 {}
 if Assigned(MailboxPropertyCallExHandler) then
  begin
   Result:=MailboxPropertyCallExHandler(mailbox,channel,data,response,timeout);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function mailbox_property_tag(tag: uint32_t; data: PVOID; size: uint32_t): uint32_t; stdcall;
{Request a property tag (Get/Set) from the mailbox property channel}
begin
 {}
 if Assigned(MailboxPropertyTagHandler) then
  begin
   Result:=MailboxPropertyTagHandler(tag,data,size);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}
{Random Number Functions}
function random_available: BOOL; stdcall;
{Check if a hardware random number generator is currently available}
{The software random number generator from the RTL is always available}
begin
 {}
 if Assigned(RandomAvailableHandler) then
  begin
   Result:=RandomAvailableHandler;
  end
 else
  begin
   Result:=False;
  end;
end;

{==============================================================================}

procedure random_seed(seed: uint32_t); stdcall;
begin
 {}
 if Assigned(RandomSeedHandler) then
  begin
   RandomSeedHandler(seed);
  end;
end;

{==============================================================================}

function random_read_longint(limit: int32_t): int32_t; stdcall;
begin
 {}
 if Assigned(RandomReadLongIntHandler) then
  begin
   Result:=RandomReadLongIntHandler(limit);
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function random_read_int64(limit: int64_t): int64_t; stdcall;
begin
 {}
 if Assigned(RandomReadInt64Handler) then
  begin
   Result:=RandomReadInt64Handler(limit);
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function random_read_double: double_t; stdcall;
begin
 {}
 if Assigned(RandomReadDoubleHandler) then
  begin
   Result:=RandomReadDoubleHandler;
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function random_read_extended: double_t; stdcall;
{Note: Replaced by RandomReadDouble}
begin
 {}
 Result:=RandomReadExtended;
end;

{==============================================================================}
{Watchdog Functions}
function watchdog_available: BOOL; stdcall;
{Check if a watchdog timer is currently available}
begin
 {}
 if Assigned(WatchdogAvailableHandler) then
  begin
   Result:=WatchdogAvailableHandler;
  end
 else
  begin
   Result:=False;
  end;
end;

{==============================================================================}

function watchdog_start(milliseconds: uint32_t): uint32_t; stdcall;
begin
 {}
 if Assigned(WatchdogStartHandler) then
  begin
   Result:=WatchdogStartHandler(milliseconds);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function watchdog_stop: uint32_t; stdcall;
begin
 {}
 if Assigned(WatchdogStopHandler) then
  begin
   Result:=WatchdogStopHandler;
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function watchdog_refresh(milliseconds: uint32_t): uint32_t; stdcall;
begin
 {}
 if Assigned(WatchdogRefreshHandler) then
  begin
   Result:=WatchdogRefreshHandler(milliseconds);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}
{Interrupt Request (IRQ) Functions}
function request_irq(cpuid, number: uint32_t; handler: interrupt_handler; parameter: PVOID): uint32_t; stdcall;
{Request registration of the supplied handler to the specified IRQ number}
{Note: If the IRQ number is already registered then the request will fail}
begin
 {}
 if Assigned(RequestIRQHandler) then
  begin
   Result:=RequestIRQHandler(cpuid,number,handler,parameter);
  end
 else
  begin
   Result:=RequestExIRQ(cpuid,number,handler,nil,parameter);
  end;
end;

{==============================================================================}

function release_irq(cpuid, number: uint32_t; handler: interrupt_handler; parameter: PVOID): uint32_t; stdcall;
{Request deregistration of the supplied handler from the specified IRQ number}
{Note: If the IRQ number is not currently registered then the request will fail}
begin
 {}
 if Assigned(ReleaseIRQHandler) then
  begin
   Result:=ReleaseIRQHandler(cpuid,number,handler,parameter);
  end
 else
  begin
   Result:=ReleaseExIRQ(cpuid,number,handler,nil,parameter);
  end;
end;

{==============================================================================}

function request_ex_irq(cpuid, number: uint32_t; handler: interrupt_handler; handler_ex: interrupt_ex_handler; parameter: PVOID): uint32_t; stdcall;
{Request registration of the supplied extended handler to the specified IRQ number}
{Note: If the IRQ number is already registered then the request will fail}
begin
 {}
 if Assigned(RequestExIRQHandler) then
  begin
   Result:=RequestExIRQHandler(cpuid,number,handler,handler_ex,parameter);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function release_ex_irq(cpuid, number: uint32_t; handler: interrupt_handler; handler_ex: interrupt_ex_handler; parameter: PVOID): uint32_t; stdcall;
{Request deregistration of the supplied extended handler from the specified IRQ number}
{Note: If the IRQ number is not currently registered then the request will fail}
begin
 {}
 if Assigned(ReleaseExIRQHandler) then
  begin
   Result:=ReleaseExIRQHandler(cpuid,number,handler,handler_ex,parameter);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}
{Fast Interrupt Request (FIQ) Functions}
function request_fiq(cpuid, number: uint32_t; handler: interrupt_handler; parameter: PVOID): uint32_t; stdcall;
{Request registration of the supplied handler to the specified FIQ number (Where Applicable)}
{Note: If the FIQ number is already registered then the request will fail}
begin
 {}
 if Assigned(RequestFIQHandler) then
  begin
   Result:=RequestFIQHandler(cpuid,number,handler,parameter);
  end
 else
  begin
   Result:=RequestExFIQ(cpuid,number,handler,nil,parameter);
  end;
end;

{==============================================================================}

function release_fiq(cpuid, number: uint32_t; handler: interrupt_handler; parameter: PVOID): uint32_t; stdcall;
{Request deregistration of the supplied handler from the specified FIQ number (Where Applicable)}
{Note: If the FIQ number is not currently registered then the request will fail}
begin
 {}
 if Assigned(ReleaseFIQHandler) then
  begin
   Result:=ReleaseFIQHandler(cpuid,number,handler,parameter);
  end
 else
  begin
   Result:=ReleaseExFIQ(cpuid,number,handler,nil,parameter);
  end;
end;

{==============================================================================}

function request_ex_fiq(cpuid, number: uint32_t; handler: interrupt_handler; handler_ex: interrupt_ex_handler; parameter: PVOID): uint32_t; stdcall;
{Request registration of the supplied extended handler to the specified FIQ number (Where Applicable)}
{Note: If the FIQ number is already registered then the request will fail}
begin
 {}
 if Assigned(RequestExFIQHandler) then
  begin
   Result:=RequestExFIQHandler(cpuid,number,handler,handler_ex,parameter);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function release_ex_fiq(cpuid, number: uint32_t; handler: interrupt_handler; handler_ex: interrupt_ex_handler; parameter: PVOID): uint32_t; stdcall;
{Request deregistration of the supplied extended handler from the specified FIQ number (Where Applicable)}
{Note: If the FIQ number is not currently registered then the request will fail}
begin
 {}
 if Assigned(ReleaseExFIQHandler) then
  begin
   Result:=ReleaseExFIQHandler(cpuid,number,handler,handler_ex,parameter);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}
{Inter Processor Interrupt (IPI) Functions}
function request_ipi(cpuid, number: uint32_t; handler: ipi_handler; parameter: PVOID): uint32_t; stdcall;
{Request registration of the supplied handler to the specified IPI number (Where Applicable)}
{Note: If the IPI number is already registered then the request will fail}
begin
 {}
 Result:=RequestIPI(cpuid,number,handler,parameter);
end;

{==============================================================================}

function release_ipi(cpuid, number: uint32_t; handler: ipi_handler; parameter: PVOID): uint32_t; stdcall;
{Request deregistration of the supplied handler from the specified IPI number (Where Applicable)}
{Note: If the IPI number is not currently registered then the request will fail}
begin
 {}
 Result:=ReleaseIPI(cpuid,number,handler,parameter);
end;

{==============================================================================}
{Interrupt Register/Deregister Functions}
function register_interrupt(number, mask, priority, flags: uint32_t; handler: shared_interrupt_handler; parameter: PVOID): uint32_t; stdcall;
{Request registration of the supplied handler to the specified interrupt number (Where Applicable)}
{Number: The interrupt number to register the hanlder for}
{Mask: The mask of CPUs to register the handler for (eg CPU_MASK_0, CPU_MASK_1) (Where Applicable)}
{Priority: The priority level of the interrupt to be registered (eg INTERRUPT_PRIORITY_MAXIMUM) (Where Applicable)}
{Flags: The flags to control the registration of the interrupt (eg INTERRUPT_FLAG_SHARED) (Where Applicable)}
{Handler: The shared interrupt handler to be called when the interrupt occurs}
{Parameter: A pointer to be passed to the handler when the interrupt occurs (Optional)}
{Return: ERROR_SUCCESS if the callback was scheduled successfully or another error code on failure}
begin
 {}
 Result:=RegisterInterrupt(number,mask,priority,flags,handler,parameter);
end;

{==============================================================================}

function deregister_interrupt(number, mask, priority, flags: uint32_t; handler: shared_interrupt_handler; parameter: PVOID): uint32_t; stdcall;
{Request deregistration of the supplied handler from the specified interrupt number (Where Applicable)}
{Number: The interrupt number to deregister the hanlder for}
{Mask: The mask of CPUs to deregister the handler for (eg CPU_MASK_0, CPU_MASK_1) (Where Applicable)}
{Priority: The priority level of the interrupt to be deregistered (eg INTERRUPT_PRIORITY_MAXIMUM) (Where Applicable)}
{Flags: The flags to control the deregistration of the interrupt (eg INTERRUPT_FLAG_SHARED, INTERRUPT_FLAG_LOCAL, INTERRUPT_FLAG_FIQ) (Where Applicable)}
{Handler: The shared interrupt handler to be called when the interrupt occurs}
{Parameter: A pointer to be passed to the handler when the interrupt occurs (Optional)}
{Return: ERROR_SUCCESS if the callback was scheduled successfully or another error code on failure}
begin
 {}
 Result:=DeregisterInterrupt(number,mask,priority,flags,handler,parameter);
end;

{==============================================================================}
{System Call (Software Interrupt or SWI) Functions}
procedure system_call(number: uint32_t; param1, param2, param3: SIZE_T); stdcall;
{Perform a System Call function with the supplied parameters (Where Applicable)}
{Number: The System Call number to be called}
{Param1: The first parameter to pass to the function (Optional / Function defined)}
{Param2: The second parameter to pass to the function (Optional / Function defined)}
{Param3: The third parameter to pass to the function (Optional / Function defined)}
begin
 {}
 if Assigned(SystemCallHandler) then
  begin
   SystemCallHandler(number,param1,param2,param3);
  end;
end;

{==============================================================================}

function register_system_call(number: uint32_t; handler: system_call_handler): uint32_t; stdcall;
{Request registration of the supplied handler to the specified System Call number (Where Applicable)}
{Number: The System Call number to be registered}
{Handler: The handler function to be registered}
{Note: If the System Call number is already registered then the request will fail}
begin
 {}
 if Assigned(RegisterSystemCallHandler) then
  begin
   Result:=RegisterSystemCallHandler(number,handler);
  end
 else
  begin
   Result:=RegisterSystemCallEx(CPU_ID_ALL,number,handler,nil);
  end;
end;

{==============================================================================}

function deregister_system_call(number: uint32_t; handler: system_call_handler): uint32_t; stdcall;
{Request deregistration of the supplied handler from the specified System Call number (Where Applicable)}
{Number: The System Call number to be deregistered}
{Handler: The handler function to be deregistered}
{Note: If the System Call number is not currently registered then the request will fail}
begin
 {}
 if Assigned(DeregisterSystemCallHandler) then
  begin
   Result:=DeregisterSystemCallHandler(number,handler);
  end
 else
  begin
   Result:=DeregisterSystemCallEx(CPU_ID_ALL,number,handler,nil);
  end;
end;

{==============================================================================}

function register_system_call_ex(cpuid, number: uint32_t; handler: system_call_handler; handler_ex: system_call_ex_handler): uint32_t; stdcall;
{Request registration of the supplied extended handler to the specified System Call number (Where Applicable)}
{CPUID: The CPU ID to register the System Call against (or CPU_ID_ALL)}
{Number: The System Call number to be registered}
{Handler: The handler function to be registered (Optional) (Handler or HandlerEx must be specified, not both)}
{HandlerEx: The extended handler function to be registered (Optional) (Handler or HandlerEx must be specified, not both)}
{Note: If the System Call number is already registered then the request will fail}
begin
 {}
 if Assigned(RegisterSystemCallExHandler) then
  begin
   Result:=RegisterSystemCallExHandler(cpuid,number,handler,handler_ex);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function deregister_system_call_ex(cpuid, number: uint32_t; handler: system_call_handler; handler_ex: system_call_ex_handler): uint32_t; stdcall;
{Request deregistration of the supplied extended handler from the specified System Call number (Where Applicable)}
{CPUID: The CPU ID to deregister the System Call from (or CPU_ID_ALL)}
{Number: The System Call number to be deregistered}
{Handler: The handler function to be deregistered (Optional) (Handler or HandlerEx must be specified, not both)}
{HandlerEx: The extended handler function to be deregistered (Optional) (Handler or HandlerEx must be specified, not both)}
{Note: If the System Call number is not currently registered then the request will fail}
begin
 {}
 if Assigned(DeregisterSystemCallExHandler) then
  begin
   Result:=DeregisterSystemCallExHandler(cpuid,number,handler,handler_ex);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}
{Interrupt Entry Functions}
function get_interrupt_count: uint32_t; stdcall;
{Get the number of interrupt entries for the current platform}
begin
 {}
 if Assigned(GetInterruptCountHandler) then
  begin
   Result:=GetInterruptCountHandler;
  end
 else
  begin
   Result:=IRQ_COUNT;
  end;
end;

{==============================================================================}

function get_interrupt_start: uint32_t; stdcall;
{Get the starting number of interrupt entries for the current platform}
begin
 {}
 if Assigned(GetInterruptStartHandler) then
  begin
   Result:=GetInterruptStartHandler;
  end
 else
  begin
   Result:=IRQ_START;
  end;
end;

{==============================================================================}

function get_interrupt_entry(number, instance: uint32_t; var interrupt: TINTERRUPT_ENTRY): uint32_t; stdcall;
{Get the interrupt entry for the specified interrupt number and instance}
begin
 {}
 if Assigned(GetInterruptEntryHandler) then
  begin
   Result:=GetInterruptEntryHandler(number,instance,interrupt);
  end
 else
  begin
   FillChar(Result,SizeOf(TINTERRUPT_ENTRY),0);

   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}
{Local Interrupt Entry Functions}
function get_local_interrupt_count: uint32_t; stdcall;
{Get the number of local interrupt entries for the current platform (Where Applicable)}
begin
 {}
 if Assigned(GetLocalInterruptCountHandler) then
  begin
   Result:=GetLocalInterruptCountHandler;
  end
 else
  begin
   Result:=IRQ_LOCAL_COUNT;
  end;
end;

{==============================================================================}

function get_local_interrupt_start: uint32_t; stdcall;
{Get the starting number of local interrupt entries for the current platform (Where Applicable)}
begin
 {}
 if Assigned(GetLocalInterruptStartHandler) then
  begin
   Result:=GetLocalInterruptStartHandler;
  end
 else
  begin
   Result:=IRQ_LOCAL_START;
  end;
end;

{==============================================================================}

function get_local_interrupt_entry(cpuid, number, instance: uint32_t; var interrupt: TINTERRUPT_ENTRY): uint32_t; stdcall;
{Get the local interrupt entry for the specified interrupt number and instance (Where Applicable)}
begin
 {}
 if Assigned(GetLocalInterruptEntryHandler) then
  begin
   Result:=GetLocalInterruptEntryHandler(cpuid,number,instance,interrupt);
  end
 else
  begin
   FillChar(Result,SizeOf(TINTERRUPT_ENTRY),0);

   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}
{Software Interrupt Entry (SWI) Functions}
function get_software_interrupt_count: uint32_t; stdcall;
{Get the number of software interrupt entries for the current platform (Where Applicable)}
begin
 {}
 if Assigned(GetSoftwareInterruptCountHandler) then
  begin
   Result:=GetSoftwareInterruptCountHandler;
  end
 else
  begin
   Result:=IRQ_SOFTWARE_COUNT;
  end;
end;

{==============================================================================}

function get_software_interrupt_start: uint32_t; stdcall;
{Get the starting number of software interrupt entries for the current platform (Where Applicable)}
begin
 {}
 if Assigned(GetSoftwareInterruptStartHandler) then
  begin
   Result:=GetSoftwareInterruptStartHandler;
  end
 else
  begin
   Result:=IRQ_SOFTWARE_START;
  end;
end;

{==============================================================================}

function get_software_interrupt_entry(cpuid, number, instance: uint32_t; var interrupt: TINTERRUPT_ENTRY): uint32_t; stdcall;
{Get the software interrupt entry for the specified interrupt number and instance (Where Applicable)}
begin
 {}
 if Assigned(GetSoftwareInterruptEntryHandler) then
  begin
   Result:=GetSoftwareInterruptEntryHandler(cpuid,number,instance,interrupt);
  end
 else
  begin
   FillChar(Result,SizeOf(TINTERRUPT_ENTRY),0);

   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}
{System Call Entry Functions}
function get_system_call_count: uint32_t; stdcall;
{Get the number of system call entries for the current platform (Where Applicable)}
begin
 {}
 if Assigned(GetSystemCallCountHandler) then
  begin
   Result:=GetSystemCallCountHandler;
  end
 else
  begin
   Result:=SWI_COUNT;
  end;
end;

{==============================================================================}

function get_system_call_entry(number: uint32_t): TSYSTEM_CALL_ENTRY; stdcall;
{Get the system call entry for the specified system call number (Where Applicable)}
begin
 {}
 if Assigned(GetSystemCallEntryHandler) then
  begin
   Result:=GetSystemCallEntryHandler(number);
  end
 else
  begin
   FillChar(Result,SizeOf(TSYSTEM_CALL_ENTRY),0);
  end;
end;

{==============================================================================}
{System Functions}
function system_restart(delay: uint32_t): uint32_t; stdcall;
{Restart the system}
{Delay: How long to delay before commencing the restart (Milliseconds)}
{Return: ERROR_SUCCESS if the restart was successfully initiated or another error code on failure}
begin
 {}
 Result:=SystemRestart(delay);
end;

{==============================================================================}

function system_shutdown(delay: uint32_t): uint32_t; stdcall;
{Shutdown the system}
{Delay: How long to delay before commencing the shutdown (Milliseconds)}
{Return: ERROR_SUCCESS if the shutdown was successfully initiated or another error code on failure}
begin
 {}
 Result:=SystemShutdown(delay);
end;

{==============================================================================}

function system_register_shutdown(callback: TShutdownCallback; parameter: PVOID; timeout: uint32_t): uint32_t; stdcall;
{Register a procedure to be called during system shutdown or restart}
{Callback: The procedure to be called on shutdown or restart}
{Parameter: A pointer to be passed to the callback procedure}
{Timeout: Time the shutdown process should wait for this callback to complete (0 for the default timeout) (Milliseconds)}
{Return: ERROR_SUCCESS if the callback was successfully registered or another error code on failure}
begin
 {}
 Result:=SystemRegisterShutdown(callback,parameter,timeout);
end;

{==============================================================================}

function system_deregister_shutdown(callback: TShutdownCallback; parameter: PVOID): uint32_t; stdcall;
{Deregister a procedure from being called during system shutdown or restart}
{Callback: The procedure previously registered for shutdown or restart}
{Parameter: The pointer previously registered for the callback procedure}
{Return: ERROR_SUCCESS if the callback was successfully deregistered or another error code on failure}
begin
 {}
 Result:=SystemDeregisterShutdown(callback,parameter);
end;

{==============================================================================}

function system_get_uptime: int64_t; stdcall;
{Get the current system up time in 100 nanosecond ticks since 1/1/1601}
{Return: The current system up time}
{Note: This is the same time format as Windows FILE_TIME and is intended to allow
 compatibility with file system functions etc.}
begin
 {}
 if Assigned(SystemGetUptimeHandler) then
  begin
   Result:=SystemGetUptimeHandler;
  end
 else
  begin
   Result:=SystemGetUptime;
  end;
end;

{==============================================================================}

function system_get_command_line(commandline: PCHAR; len: uint32_t): uint32_t; stdcall;
{Get the current command line}
var
 Buffer:String;
begin
 {}
 if Assigned(SystemGetCommandLineHandler) then
  begin
   Buffer:=SystemGetCommandLineHandler;
  end
 else
  begin
   if cmdline = nil then Buffer:='' else Buffer:=String(cmdline);
  end;

 Result:=APIStringToPCharBuffer(Buffer,commandline,len);
end;

{==============================================================================}

function system_get_environment: PVOID; stdcall;
{Get the current environment}
begin
 {}
 if Assigned(SystemGetEnvironmentHandler) then
  begin
   Result:=SystemGetEnvironmentHandler;
  end
 else
  begin
   Result:=envp;
  end;
end;

{==============================================================================}

function system_date_to_string(date: double_t; value: PCHAR; len: uint32_t): uint32_t; stdcall;
{Return the supplied date value as a string in the system defined format}
{Date: The date in Pascal TDateTime format}
{Return: The date formatted according to the system date format}
{Note: Applications should use FormatDateTime or DateTimeToString directly}
{      This function is intended to provide a uniform and generic date and}
{      time output from system functions such as logging and debug output}
begin
 {}
 Result:=APIStringToPCharBuffer(SystemDateToString(date),value,len);
end;

{==============================================================================}

function system_time_to_string(time: double_t; value: PCHAR; len: uint32_t): uint32_t; stdcall;
{Return the supplied time value as a string in the system defined format}
{Time: The time in Pascal TDateTime format}
{Return: The time formatted according to the system time format}
{Note: Applications should use FormatDateTime or DateTimeToString directly}
{      This function is intended to provide a uniform and generic date and}
{      time output from system functions such as logging and debug output}
begin
 {}
 Result:=APIStringToPCharBuffer(SystemTimeToString(time),value,len);
end;

{==============================================================================}

function system_date_time_to_string(datetime: double_t; value: PCHAR; len: uint32_t): uint32_t; stdcall;
{Return the supplied date and time value as a string in the system defined format}
{DateTime: The date and time in Pascal TDateTime format}
{Return: The date and time formatted according to the system date and time format}
{Note: Applications should use FormatDateTime or DateTimeToString directly}
{      This function is intended to provide a uniform and generic date and}
{      time output from system functions such as logging and debug output}
begin
 {}
 Result:=APIStringToPCharBuffer(SystemDateTimeToString(datetime),value,len);
end;

{==============================================================================}

function system_interval_to_string(interval: double_t; value: PCHAR; len: uint32_t): uint32_t; stdcall;
{Return the supplied time interval as a string in the system defined format}
{Interval: The time interval in Pascal TDateTime format}
{Return: The time interval formatted according to the system time format}
begin
 {}
 Result:=APIStringToPCharBuffer(SystemIntervalToString(interval),value,len);
end;

{==============================================================================}
{CPU Functions}
function cpu_get_arch: uint32_t; stdcall;
{Get the CPU architecture for this board}
begin
 {}
 if Assigned(CPUGetArchHandler) then
  begin
   Result:=CPUGetArchHandler;
  end
 else
  begin
   Result:=CPU_ARCH;
  end;
end;

{==============================================================================}

function cpu_get_type: uint32_t; stdcall;
{Get the CPU type for this board}
begin
 {}
 if Assigned(CPUGetTypeHandler) then
  begin
   Result:=CPUGetTypeHandler;
  end
 else
  begin
   Result:=CPU_TYPE;
  end;
end;

{==============================================================================}

function cpu_get_boot: uint32_t; stdcall;
{Get the boot CPU for this board}
begin
 {}
 if Assigned(CPUGetBootHandler) then
  begin
   Result:=CPUGetBootHandler;
  end
 else
  begin
   Result:=CPU_BOOT;
  end;
end;

{==============================================================================}

function cpu_get_mask: uint32_t; stdcall;
{Get the CPU mask for this board}
begin
 {}
 if Assigned(CPUGetMaskHandler) then
  begin
   Result:=CPUGetMaskHandler;
  end
 else
  begin
   Result:=CPU_MASK;
  end;
end;

{==============================================================================}

function cpu_get_count: uint32_t; stdcall;
{Get the CPU count for this board}
begin
 {}
 if Assigned(CPUGetCountHandler) then
  begin
   Result:=CPUGetCountHandler;
  end
 else
  begin
   Result:=CPU_COUNT;
  end;
end;

{==============================================================================}

function cpu_get_mode: uint32_t; stdcall;
{Get the current CPU mode}
{Note: The return value is specific to the CPU type}
begin
 {}
 if Assigned(CPUGetModeHandler) then
  begin
   Result:=CPUGetModeHandler;
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function cpu_get_state: uint32_t; stdcall;
{Get the current CPU state}
begin
 {}
 if Assigned(CPUGetStateHandler) then
  begin
   Result:=CPUGetStateHandler;
  end
 else
  begin
   Result:=CPU_STATE_NONE;
  end;
end;

{==============================================================================}

function cpu_get_group: uint32_t; stdcall;
{Get the current CPU group}
begin
 {}
 if Assigned(CPUGetGroupHandler) then
  begin
   Result:=CPUGetGroupHandler;
  end
 else
  begin
   Result:=CPU_GROUP_0;
  end;
end;

{==============================================================================}

function cpu_get_current: uint32_t; stdcall;
{Get the current CPU ID}
begin
 {}
 if Assigned(CPUGetCurrentHandler) then
  begin
   Result:=CPUGetCurrentHandler;
  end
 else
  begin
   Result:=CPU_ID_0;
  end;
end;

{==============================================================================}

function cpu_get_memory(var address: SIZE_T; var length: uint64_t): uint32_t; stdcall;
{Get the memory start and size available to the CPU}
begin
 {}
 if Assigned(CPUGetMemoryHandler) then
  begin
   Result:=CPUGetMemoryHandler(address,length);
  end
 else
  begin
   address:=CPU_MEMORY_BASE;
   length:=CPU_MEMORY_SIZE;

   Result:=ERROR_SUCCESS;
  end;
end;

{==============================================================================}

function cpu_get_percentage(cpuid: uint32_t): double_t; stdcall;
{Get the last second utilization of the specified CPU in percentage}
{CPUID: The CPU to get utilization from or CPU_ID_ALL for average of all CPUs}
begin
 {}
 Result:=CPUGetPercentage(cpuid);
end;

{==============================================================================}

function cpu_get_utilization(cpuid: uint32_t): uint32_t; stdcall;
{Get the last second utilization of the specified CPU}
{CPUID: The CPU to get utilization from or CPU_ID_ALL for average of all CPUs}
begin
 {}
 Result:=CPUGetUtilization(cpuid);
end;

{==============================================================================}

function cpu_get_model: uint32_t; stdcall;
{Get the CPU model of the current CPU}
begin
 {}
 if Assigned(CPUGetModelHandler) then
  begin
   Result:=CPUGetModelHandler;
  end
 else
  begin
   Result:=CPU_MODEL_UNKNOWN;
  end;
end;

{==============================================================================}

function cpu_get_revision: uint32_t; stdcall;
{Get the CPU revision of the current CPU}
{Note: The return value is specific to the CPU type and model}
begin
 {}
 if Assigned(CPUGetRevisionHandler) then
  begin
   Result:=CPUGetRevisionHandler;
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function cpu_get_description(description: PCHAR; len: uint32_t): uint32_t; stdcall;
{Get the CPU description of the current CPU}
var
 Buffer:String;
begin
 {}
 if Assigned(CPUGetDescriptionHandler) then
  begin
   Buffer:=CPUGetDescriptionHandler;
  end
 else
  begin
   Buffer:='';
  end;

 Result:=APIStringToPCharBuffer(Buffer,description,len);
end;

{==============================================================================}
{FPU Functions}
function fpu_get_type: uint32_t; stdcall;
{Get the FPU type for this board}
begin
 {}
 if Assigned(FPUGetTypeHandler) then
  begin
   Result:=FPUGetTypeHandler;
  end
 else
  begin
   Result:=FPU_TYPE;
  end;
end;

{==============================================================================}

function fpu_get_state: uint32_t; stdcall;
{Get the current FPU state}
begin
 {}
 if Assigned(FPUGetStateHandler) then
  begin
   Result:=FPUGetStateHandler;
  end
 else
  begin
   Result:=FPU_STATE_NONE;
  end;
end;

{==============================================================================}
{GPU Functions}
function gpu_get_type: uint32_t; stdcall;
{Get the GPU type for this board}
begin
 {}
 if Assigned(GPUGetTypeHandler) then
  begin
   Result:=GPUGetTypeHandler;
  end
 else
  begin
   Result:=GPU_TYPE;
  end;
end;

{==============================================================================}

function gpu_get_state: uint32_t; stdcall;
{Get the current GPU state}
begin
 {}
 if Assigned(GPUGetStateHandler) then
  begin
   Result:=GPUGetStateHandler;
  end
 else
  begin
   Result:=GPU_STATE_NONE;
  end;
end;

{==============================================================================}

function gpu_get_memory(var address: SIZE_T; var length: uint64_t): uint32_t; stdcall;
{Get the memory start and size available to the GPU}
begin
 {}
 if Assigned(GPUGetMemoryHandler) then
  begin
   Result:=GPUGetMemoryHandler(address,length);
  end
 else
  begin
   address:=GPU_MEMORY_BASE;
   length:=GPU_MEMORY_SIZE;

   Result:=ERROR_SUCCESS;
  end;
end;

{==============================================================================}
{Cache Functions}
function l1_cache_get_type: uint32_t; stdcall;
{Get the L1 cache type for this board}
begin
 {}
 if Assigned(L1CacheGetTypeHandler) then
  begin
   Result:=L1CacheGetTypeHandler;
  end
 else
  begin
   Result:=CACHE_TYPE_NONE;
  end;
end;

{==============================================================================}

function l1_data_cache_get_size: uint32_t; stdcall;
{Get the L1 data cache size for this board}
{Note: If data cache is not supported, the size returned is zero}
{Note: If separate data and instruction caches are not supported, the size returned is the unified size}
begin
 {}
 if Assigned(L1DataCacheGetSizeHandler) then
  begin
   Result:=L1DataCacheGetSizeHandler;
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function l1_data_cache_get_linesize: uint32_t; stdcall;
{Get the L1 data cache line size for this board}
{Note: If data cache is not supported, the size returned is zero}
{Note: If separate data and instruction caches are not supported, the size returned is the unified size}
begin
 {}
 if Assigned(L1DataCacheGetLineSizeHandler) then
  begin
   Result:=L1DataCacheGetLineSizeHandler;
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function l1_instruction_cache_get_size: uint32_t; stdcall;
{Get the L1 instruction cache size for this board}
{Note: If instruction cache is not supported, the size returned is zero}
{Note: If separate data and instruction caches are not supported, the size returned is the unified size}
begin
 {}
 if Assigned(L1InstructionCacheGetSizeHandler) then
  begin
   Result:=L1InstructionCacheGetSizeHandler;
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function l1_instruction_cache_get_linesize: uint32_t; stdcall;
{Get the L1 instruction cache line size for this board}
{Note: If instruction cache is not supported, the size returned is zero}
{Note: If separate data and instruction caches are not supported, the size returned is the unified size}
begin
 {}
 if Assigned(L1InstructionCacheGetLineSizeHandler) then
  begin
   Result:=L1InstructionCacheGetLineSizeHandler;
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function l2_cache_get_type: uint32_t; stdcall;
{Get the L2 cache type for this board}
begin
 {}
 if Assigned(L2CacheGetTypeHandler) then
  begin
   Result:=L2CacheGetTypeHandler;
  end
 else
  begin
   Result:=CACHE_TYPE_NONE;
  end;
end;

{==============================================================================}

function l2_cache_get_size: uint32_t; stdcall;
{Get the L2 cache size for this board}
{Note: If L2 cache is not supported, the size returned is zero}
begin
 {}
 if Assigned(L2CacheGetSizeHandler) then
  begin
   Result:=L2CacheGetSizeHandler;
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function l2_cache_get_linesize: uint32_t; stdcall;
{Get the L2 cache line size for this board}
{Note: If L2 cache is not supported, the size returned is zero}
begin
 {}
 if Assigned(L2CacheGetLineSizeHandler) then
  begin
   Result:=L2CacheGetLineSizeHandler;
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}
{Version Functions}
procedure version_get_info(var major, minor, revision: uint32_t); stdcall;
{Get the version information of the currently running system}
begin
 {}
 VersionGetInfo(major,minor,revision);
end;

{==============================================================================}

function version_get_date(date: PCHAR; len: uint32_t): uint32_t; stdcall;
{Get the version release date of the currently running system}
begin
 {}
 Result:=APIStringToPCharBuffer(VersionGetDate,date,len);
end;

{==============================================================================}

function version_get_name(name: PCHAR; len: uint32_t): uint32_t; stdcall;
{Get the version release name of the currently running system}
begin
 {}
 Result:=APIStringToPCharBuffer(VersionGetName,name,len);
end;

{==============================================================================}

function version_get_version(version: PCHAR; len: uint32_t): uint32_t; stdcall;
{Get the version string of the currently running system}
begin
 {}
 Result:=APIStringToPCharBuffer(VersionGetVersion,version,len);
end;

{==============================================================================}
{Board Functions}
function board_get_type: uint32_t; stdcall;
{Get the current Board type}
begin
 {}
 if Assigned(BoardGetTypeHandler) then
  begin
   Result:=BoardGetTypeHandler;
  end
 else
  begin
   Result:=BOARD_TYPE;
  end;
end;

{==============================================================================}

function board_get_model: uint32_t; stdcall;
{Get the current Board model}
begin
 {}
 if Assigned(BoardGetModelHandler) then
  begin
   Result:=BoardGetModelHandler;
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function board_get_serial: int64_t; stdcall;
{Get the current Board serial number}
begin
 {}
 if Assigned(BoardGetSerialHandler) then
  begin
   Result:=BoardGetSerialHandler;
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function board_get_revision: uint32_t; stdcall;
{Get the current Board revision number}
begin
 {}
 if Assigned(BoardGetRevisionHandler) then
  begin
   Result:=BoardGetRevisionHandler;
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function board_get_mac_address(address: PCHAR; len: uint32_t): uint32_t; stdcall;
{Get the current Board MAC address (Where Applicable)}
var
 Buffer:String;
begin
 {}
 if Assigned(BoardGetMACAddressHandler) then
  begin
   Buffer:=BoardGetMACAddressHandler;
  end
 else
  begin
   Buffer:='';
  end;

 Result:=APIStringToPCharBuffer(Buffer,address,len);
end;

{==============================================================================}
{Chip Functions}
function chip_get_revision: uint32_t; stdcall;
{Get the current Chip revision number}
begin
 {}
 if Assigned(ChipGetRevisionHandler) then
  begin
   Result:=ChipGetRevisionHandler;
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}
{Firmware Functions}
function firmware_get_revision: uint32_t; stdcall;
{Get the current board Firmware Revision}
begin
 {}
 if Assigned(FirmwareGetRevisionHandler) then
  begin
   Result:=FirmwareGetRevisionHandler;
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function firmware_get_throttled: uint32_t; stdcall;
{Get the current throttling state from the firmware}
{Return: A bit mask of FIRMWARE_THROTTLE_* values for the throttling state}
begin
 {}
 if Assigned(FirmwareGetThrottledHandler) then
  begin
   Result:=FirmwareGetThrottledHandler;
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}
{Machine Functions}
function machine_get_type: uint32_t; stdcall;
{Get the current Machine type}
begin
 {}
 if Assigned(MachineGetTypeHandler) then
  begin
   Result:=MachineGetTypeHandler;
  end
 else
  begin
   Result:=MACHINE_TYPE;
  end;
end;

{==============================================================================}
{Memory Functions}
function memory_get_base: SIZE_T; stdcall;
{Get the base address of system memory}
begin
 {}
 if Assigned(MemoryGetBaseHandler) then
  begin
   Result:=MemoryGetBaseHandler;
  end
 else
  begin
   Result:=MEMORY_BASE;
  end;
end;

{==============================================================================}

function memory_get_size: uint64_t; stdcall;
{Get the total size of system memory}
begin
 {}
 if Assigned(MemoryGetSizeHandler) then
  begin
   Result:=MemoryGetSizeHandler;
  end
 else
  begin
   Result:=MEMORY_SIZE;
  end;
end;

{==============================================================================}

function memory_get_pagesize: uint32_t; stdcall;
{Get the page size of system memory}
begin
 {}
 if Assigned(MemoryGetPageSizeHandler) then
  begin
   Result:=MemoryGetPageSizeHandler;
  end
 else
  begin
   Result:=MEMORY_PAGE_SIZE;
  end;
end;

{==============================================================================}

function memory_get_large_pagesize: uint32_t; stdcall;
{Get the large page size of system memory (Where Applicable)}
begin
 {}
 if Assigned(MemoryGetLargePageSizeHandler) then
  begin
   Result:=MemoryGetLargePageSizeHandler;
  end
 else
  begin
   Result:=MEMORY_LARGEPAGE_SIZE;
  end;
end;

{==============================================================================}

function memory_get_section_size: uint32_t; stdcall;
{Get the section size of system memory (Where Applicable)}
begin
 {}
 if Assigned(MemoryGetSectionSizeHandler) then
  begin
   Result:=MemoryGetSectionSizeHandler;
  end
 else
  begin
   Result:=MEMORY_SECTION_SIZE;
  end;
end;

{==============================================================================}

function memory_get_large_section_size: uint32_t; stdcall;
{Get the large section size of system memory (Where Applicable)}
begin
 {}
 if Assigned(MemoryGetLargeSectionSizeHandler) then
  begin
   Result:=MemoryGetLargeSectionSizeHandler;
  end
 else
  begin
   Result:=MEMORY_LARGESECTION_SIZE;
  end;
end;

{==============================================================================}
{Power Functions}
function power_on(powerid: uint32_t): uint32_t; stdcall;
{Power On the specified device}
var
 State:LongWord;
begin
 {}
 State:=PowerGetState(powerid);
 if State = POWER_STATE_OFF then
  begin
   Result:=PowerSetState(powerid,POWER_STATE_ON,True);
  end
 else
  begin
   Result:=ERROR_SUCCESS;
  end;
end;

{==============================================================================}

function power_off(powerid: uint32_t): uint32_t; stdcall;
{Power Off the specified device}
var
 State:LongWord;
begin
 {}
 State:=PowerGetState(powerid);
 if State = POWER_STATE_ON then
  begin
   Result:=PowerSetState(powerid,POWER_STATE_OFF,True);
  end
 else
  begin
   Result:=ERROR_SUCCESS;
  end;
end;

{==============================================================================}

function power_get_wait(powerid: uint32_t): uint32_t; stdcall;
{Get the enable wait time in Microseconds of the specified device}
begin
 {}
 if Assigned(PowerGetWaitHandler) then
  begin
   Result:=PowerGetWaitHandler(powerid);
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function power_get_state(powerid: uint32_t): uint32_t; stdcall;
{Get the power state of the specified device}
begin
 {}
 if Assigned(PowerGetStateHandler) then
  begin
   Result:=PowerGetStateHandler(powerid);
  end
 else
  begin
   Result:=POWER_STATE_OFF;
  end;
end;

{==============================================================================}

function power_set_state(powerid, state: uint32_t; wait: BOOL): uint32_t; stdcall;
{Set the power state of the specified device (Optionally waiting for ready)}
begin
 {}
 if Assigned(PowerSetStateHandler) then
  begin
   Result:=PowerSetStateHandler(powerid,state,wait);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}
{Clock Functions}
function clock_ticks: uint32_t; stdcall;
{Get the current number of clock ticks (When this reaches CLOCK_TICKS_PER_SECOND then ClockSeconds is incremented and this is reset to zero)}
{Return: The current number of clock ticks}
begin
 {}
 Result:=ClockTicks;
end;

{==============================================================================}

function clock_seconds: uint32_t; stdcall;
{Get the number of clock seconds since the system was started (This forms the system clock)}
{Return: The current number of clock seconds}
begin
 {}
 Result:=ClockSeconds;
end;

{==============================================================================}

function clock_milliseconds: int64_t; stdcall;
{Get the number of clock milliseconds since the system was started}
{Return: The current number of clock milliseconds}
begin
 {}
 Result:=ClockMilliseconds;
end;

{==============================================================================}

function clock_microseconds: int64_t; stdcall;
{Get the number of clock microseconds since the system was started}
{Return: The current number of clock microseconds}
begin
 {}
 Result:=ClockMicroseconds;
end;

{==============================================================================}

function clock_nanoseconds: int64_t; stdcall;
{Get the number of clock nanoseconds since the system was started}
{Return: The current number of clock nanoseconds}
begin
 {}
 Result:=ClockNanoseconds;
end;

{==============================================================================}

function clock_get_time: int64_t; stdcall;
{Get the current system time in 100 nanosecond ticks since 1/1/1601}
{Return: The current system time}
{Note: This is the same time format as Windows FILE_TIME and is intended to allow
       compatibility with file system functions etc.}
{Note: By default the time returned by this function is considered to be UTC but
 the actual conversion between UTC and local time is handled at a higher level}
begin
 {}
 Result:=ClockGetTime;
end;

{==============================================================================}

function clock_set_time(const time: int64_t; rtc: BOOL): int64_t; stdcall;
{Set the current system time in 100 nanosecond ticks since 1/1/1601}
{Time: The time to be set}
{RTC: Set the default RTC (real time clock) if available}
{Return: The system time after setting}
{Note: This is the same time format as Windows FILE_TIME and is intended to allow
       compatibility with file system functions etc.}
{Note: By default the time passed to this function is considered to be UTC but
 the actual conversion between UTC and local time is handled at a higher level}
begin
 {}
 Result:=ClockSetTime(time,rtc)
end;

{==============================================================================}

function clock_get_count: uint32_t; stdcall;
{Gets the current system clock count (32 least significant bits of total)}
{Note: This will normally come from the free running system timer in the board
 and is useful as a form of tick count but not for time keeping because
 the actual rate at which this increments is dependent on the system timer clock
 frequency of the specific board and may not be a measure of time in its raw form}
begin
 {}
 if Assigned(ClockGetCountHandler) then
  begin
   Result:=ClockGetCountHandler;
  end
 else
  begin
   Result:=ClockGetTotal;
  end;
end;

{==============================================================================}

function clock_get_total: int64_t; stdcall;
{Gets the total system clock count}
{Note: This will normally come from the free running system timer in the board
 and is useful as a form of tick count but not for time keeping because
 the actual rate at which this increments is dependent on the system timer clock
 frequency of the specific board and may not be a measure of time in its raw form}
begin
 {}
 if Assigned(ClockGetTotalHandler) then
  begin
   Result:=ClockGetTotalHandler;
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function clock_update_offset: uint32_t; stdcall;
{Update the system time offset between UTC and Local}
begin
 {}
 if Assigned(ClockUpdateOffsetHandler) then
  begin
   Result:=ClockUpdateOffsetHandler;
  end
 else
  begin
   Result:=ERROR_SUCCESS;
  end;
end;

{==============================================================================}

function clock_get_rate(clockid: uint32_t): uint32_t; stdcall;
{Get the clock rate in Hz of the specified Clock}
begin
 {}
 if Assigned(ClockGetRateHandler) then
  begin
   Result:=ClockGetRateHandler(ClockId);
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function clock_set_rate(clockid, rate: uint32_t; turbo: BOOL): uint32_t; stdcall;
{Set the clock rate in Hz of the specified Clock}
begin
 {}
 if Assigned(ClockSetRateHandler) then
  begin
   Result:=ClockSetRateHandler(clockid,rate,turbo);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function clock_get_state(clockid: uint32_t): uint32_t; stdcall;
{Get the state of the specified Clock}
begin
 {}
 if Assigned(ClockGetStateHandler) then
  begin
   Result:=ClockGetStateHandler(clockid);
  end
 else
  begin
   Result:=CLOCK_STATE_OFF;
  end;
end;

{==============================================================================}

function clock_set_state(clockid, state: uint32_t): uint32_t; stdcall;
{Set the state of the specified Clock}
begin
 {}
 if Assigned(ClockSetStateHandler) then
  begin
   Result:=ClockSetStateHandler(clockid,state);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function clock_get_min_rate(clockid: uint32_t): uint32_t; stdcall;
{Get the minimum clock rate in Hz of the specified Clock}
begin
 {}
 if Assigned(ClockGetMinRateHandler) then
  begin
   Result:=ClockGetMinRateHandler(clockid);
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function clock_get_max_rate(clockid: uint32_t): uint32_t; stdcall;
{Get the maximum clock rate in Hz of the specified Clock}
begin
 {}
 if Assigned(ClockGetMaxRateHandler) then
  begin
   Result:=ClockGetMaxRateHandler(clockid);
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function clock_get_measured_rate(clockid: uint32_t): uint32_t; stdcall;
{Get the measured or actual clock rate in Hz of the specified Clock}
begin
 {}
 if Assigned(ClockGetMeasuredRateHandler) then
  begin
   Result:=ClockGetMeasuredRateHandler(clockId);
  end
 else
  begin
   {Default to the ClockGetRate value}
   Result:=ClockGetRate(clockId);
  end;
end;

{==============================================================================}
{Turbo Functions}
function turbo_get_state(turboid: uint32_t): uint32_t; stdcall;
{Get the Turbo state (0 equals Off / 1 equals On) of the specified device}
begin
 {}
 if Assigned(TurboGetStateHandler) then
  begin
   Result:=TurboGetStateHandler(turboid);
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function turbo_set_state(turboid, state: uint32_t): uint32_t; stdcall;
{Set the Turbo state (0 equals Off / 1 equals On) of the specified device}
begin
 {}
 if Assigned(TurboSetStateHandler) then
  begin
   Result:=TurboSetStateHandler(turboid,state);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}
{Voltage Functions}
function voltage_get_value(voltageid: uint32_t): uint32_t; stdcall;
{Get the current voltage level of the specified device}
begin
 {}
 if Assigned(VoltageGetValueHandler) then
  begin
   Result:=VoltageGetValueHandler(voltageid);
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function voltage_set_value(voltageid, value: uint32_t): uint32_t; stdcall;
{Set the current voltage level of the specified device}
begin
 {}
 if Assigned(VoltageSetValueHandler) then
  begin
   Result:=VoltageSetValueHandler(voltageid,value);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function voltage_get_min_value(voltageid: uint32_t): uint32_t; stdcall;
{Get the minimum voltage level of the specified device}
begin
 {}
 if Assigned(VoltageGetMinValueHandler) then
  begin
   Result:=VoltageGetMinValueHandler(voltageid);
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function voltage_get_max_value(voltageid: uint32_t): uint32_t; stdcall;
{Get the maximum voltage level of the specified device}
begin
 {}
 if Assigned(VoltageGetMaxValueHandler) then
  begin
   Result:=VoltageGetMaxValueHandler(voltageid);
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}
{Temperature Functions}
function temperature_get_current(temperatureid: uint32_t): uint32_t; stdcall;
{Get the current temperature in thousandths of a degree C of the specified device}
begin
 {}
 if Assigned(TemperatureGetCurrentHandler) then
  begin
   Result:=TemperatureGetCurrentHandler(temperatureid);
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function temperature_get_maximum(temperatureid: uint32_t): uint32_t; stdcall;
{Get the maximum temperature in thousandths of a degree C of the specified device}
begin
 {}
 if Assigned(TemperatureGetMaximumHandler) then
  begin
   Result:=TemperatureGetMaximumHandler(temperatureid);
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}
{GPU Memory Functions}
function gpu_memory_allocate(length, alignment, flags: uint32_t): THANDLE; stdcall;
{Allocate memory from the GPU}
begin
 {}
 if Assigned(GPUMemoryAllocateHandler) then
  begin
   Result:=GPUMemoryAllocateHandler(length,alignment,flags);
  end
 else
  begin
   Result:=INVALID_HANDLE_VALUE;
  end;
end;

{==============================================================================}

function gpu_memory_release(handle: THANDLE): uint32_t; stdcall;
{Release memory allocated from the GPU}
begin
 {}
 if Assigned(GPUMemoryReleaseHandler) then
  begin
   Result:=GPUMemoryReleaseHandler(handle);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function gpu_memory_lock(handle: THANDLE): uint32_t; stdcall;
{Lock memory allocated from the GPU and return an address}
begin
 {}
 if Assigned(GPUMemoryLockHandler) then
  begin
   Result:=GPUMemoryLockHandler(handle);
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function gpu_memory_unlock(handle: THANDLE): uint32_t; stdcall;
{Unlock memory allocated from the GPU}
begin
 {}
 if Assigned(GPUMemoryUnlockHandler) then
  begin
   Result:=GPUMemoryUnlockHandler(handle);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}
{GPU Misc Functions}
function gpu_execute_code(address: PVOID; r0, r1, r2, r3, r4, r5: uint32_t): uint32_t; stdcall;
{Execute a block of code on the GPU}
begin
 {}
 if Assigned(GPUExecuteCodeHandler) then
  begin
   Result:=GPUExecuteCodeHandler(address,r0,r1,r2,r3,r4,r5);
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function dispmanx_handle_get(resource: THANDLE): THANDLE; stdcall;
{Convert a Dispmanx Resource handle to a Memory handle (Which can be passed to Lock/Unlock above)}
begin
 {}
 if Assigned(DispmanxHandleGetHandler) then
  begin
   Result:=DispmanxHandleGetHandler(resource);
  end
 else
  begin
   Result:=INVALID_HANDLE_VALUE;
  end;
end;

{==============================================================================}

function edid_block_get(block: uint32_t; buffer: PVOID; length: uint32_t): uint32_t; stdcall;
{Get an EDID block from HDMI}
begin
 {}
 if Assigned(EDIDBlockGetHandler) then
  begin
   Result:=EDIDBlockGetHandler(block,buffer,length);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}
{Framebuffer Functions}
function framebuffer_available: BOOL; stdcall;
{Check if a framebuffer device is currently available}
begin
 {}
 if Assigned(FramebufferAvailableHandler) then
  begin
   Result:=FramebufferAvailableHandler;
  end
 else
  begin
   Result:=False;
  end;
end;

{==============================================================================}

function framebuffer_allocate(alignment: uint32_t; var address, length: uint32_t): uint32_t; stdcall;
{Allocate a new Framebuffer}
begin
 {}
 if Assigned(FramebufferAllocateHandler) then
  begin
   Result:=FramebufferAllocateHandler(alignment,address,length);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function framebuffer_release: uint32_t; stdcall;
{Release the current Framebuffer}
begin
 {}
 if Assigned(FramebufferReleaseHandler) then
  begin
   Result:=FramebufferReleaseHandler;
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function framebuffer_set_state(state: uint32_t): uint32_t; stdcall;
{Set the current Framebuffer (Display) state (0 for Off / 1 for On)}
begin
 {}
 if Assigned(FramebufferSetStateHandler) then
  begin
   Result:=FramebufferSetStateHandler(state);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function framebuffer_get_dimensions(var width, height, top, bottom, left, right: uint32_t): uint32_t; stdcall;
{Get the default Dimensions of the Framebuffer (Physical Width, Height and Overscan Top, Bottom, Left, Right in Pixels)}
begin
 {}
 if Assigned(FramebufferGetDimensionsHandler) then
  begin
   Result:=FramebufferGetDimensionsHandler(width,height,top,bottom,left,right);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function framebuffer_get_physical(var width, height: uint32_t): uint32_t; stdcall;
{Get the Physical Framebuffer Width and Height in Pixels}
{Note: The "physical" size is the size of the allocated buffer in memory,
       not the resolution of the video signal sent to the display device}
begin
 {}
 if Assigned(FramebufferGetPhysicalHandler) then
  begin
   Result:=FramebufferGetPhysicalHandler(width,height);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function framebuffer_set_physical(var width, height: uint32_t): uint32_t; stdcall;
{Set the Physical Framebuffer Width and Height in Pixels}
begin
 {}
 if Assigned(FramebufferSetPhysicalHandler) then
  begin
   Result:=FramebufferSetPhysicalHandler(width,height);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function framebuffer_test_physical(var width, height: uint32_t): uint32_t; stdcall;
{Test the Physical Framebuffer Width and Height in Pixels}
begin
 {}
 if Assigned(FramebufferTestPhysicalHandler) then
  begin
   Result:=FramebufferTestPhysicalHandler(width,height);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function framebuffer_get_virtual(var width, height: uint32_t): uint32_t; stdcall;
{Get the Virtual Framebuffer Width and Height in Pixels}
{Note: The "virtual" size is the portion of buffer that is sent to the display device,
       not the resolution the buffer itself. This may be smaller than the allocated
       buffer size in order to implement panning}
begin
 {}
 if Assigned(FramebufferGetVirtualHandler) then
  begin
   Result:=FramebufferGetVirtualHandler(width,height);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function framebuffer_set_virtual(var width, height: uint32_t): uint32_t; stdcall;
{Set the Virtual Framebuffer Width and Height in Pixels}
begin
 {}
 if Assigned(FramebufferSetVirtualHandler) then
  begin
   Result:=FramebufferSetVirtualHandler(width,height);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function framebuffer_test_virtual(var width, height: uint32_t): uint32_t; stdcall;
{Test the Virtual Framebuffer Width and Height in Pixels}
begin
 {}
 if Assigned(FramebufferTestVirtualHandler) then
  begin
   Result:=FramebufferTestVirtualHandler(width,height);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function framebuffer_get_depth(var depth: uint32_t): uint32_t; stdcall;
{Get the Framebuffer Depth in Bits per Pixel}
begin
 {}
 if Assigned(FramebufferGetDepthHandler) then
  begin
   Result:=FramebufferGetDepthHandler(depth);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function framebuffer_set_depth(var depth: uint32_t): uint32_t; stdcall;
{Set the Framebuffer Depth in Bits per Pixel}
begin
 {}
 if Assigned(FramebufferSetDepthHandler) then
  begin
   Result:=FramebufferSetDepthHandler(depth);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function framebuffer_test_depth(var depth: uint32_t): uint32_t; stdcall;
{Test the Framebuffer Depth in Bits per Pixel}
begin
 {}
 if Assigned(FramebufferTestDepthHandler) then
  begin
   Result:=FramebufferTestDepthHandler(depth);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function framebuffer_get_pixel_order(var order: uint32_t): uint32_t; stdcall;
{Get the Framebuffer Pixel Order (0 = BGR / 1 = RGB)}
begin
 {}
 if Assigned(FramebufferGetPixelOrderHandler) then
  begin
   Result:=FramebufferGetPixelOrderHandler(order);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function framebuffer_set_pixel_order(var order: uint32_t): uint32_t; stdcall;
{Set the Framebuffer Pixel Order (0 = BGR / 1 = RGB)}
begin
 {}
 if Assigned(FramebufferSetPixelOrderHandler) then
  begin
   Result:=FramebufferSetPixelOrderHandler(order);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function framebuffer_test_pixel_order(var order: uint32_t): uint32_t; stdcall;
{Test the Framebuffer Pixel Order (0 = BGR / 1 = RGB)}
begin
 {}
 if Assigned(FramebufferTestPixelOrderHandler) then
  begin
   Result:=FramebufferTestPixelOrderHandler(order);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function framebuffer_get_alpha_mode(var mode: uint32_t): uint32_t; stdcall;
{Get the Framebuffer Alpha Mode}
begin
 {}
 if Assigned(FramebufferGetAlphaModeHandler) then
  begin
   Result:=FramebufferGetAlphaModeHandler(mode);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function framebuffer_set_alpha_mode(var mode: uint32_t): uint32_t; stdcall;
{Set the Framebuffer Alpha Mode}
begin
 {}
 if Assigned(FramebufferSetAlphaModeHandler) then
  begin
   Result:=FramebufferSetAlphaModeHandler(mode);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function framebuffer_test_alpha_mode(var mode: uint32_t): uint32_t; stdcall;
{Test the Framebuffer Alpha Mode}
begin
 {}
 if Assigned(FramebufferTestAlphaModeHandler) then
  begin
   Result:=FramebufferTestAlphaModeHandler(mode);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function framebuffer_get_pitch: uint32_t; stdcall;
{Get the Framebuffer Pitch in Bytes per Line}
begin
 {}
 if Assigned(FramebufferGetPitchHandler) then
  begin
   Result:=FramebufferGetPitchHandler;
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function framebuffer_get_offset(var x, y: uint32_t): uint32_t; stdcall;
{Get the Framebuffer Virtual Offset in Pixels}
begin
 {}
 if Assigned(FramebufferGetOffsetHandler) then
  begin
   Result:=FramebufferGetOffsetHandler(x,y);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function framebuffer_set_offset(var x, y: uint32_t): uint32_t; stdcall;
{Set the Framebuffer Virtual Offset in Pixels}
begin
 {}
 if Assigned(FramebufferSetOffsetHandler) then
  begin
   Result:=FramebufferSetOffsetHandler(x,y);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function framebuffer_test_offset(var x, y: uint32_t): uint32_t; stdcall;
{Test the Framebuffer Virtual Offset in Pixels}
begin
 {}
 if Assigned(FramebufferTestOffsetHandler) then
  begin
   Result:=FramebufferTestOffsetHandler(x,y);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function framebuffer_get_overscan(var top, bottom, left, right: uint32_t): uint32_t; stdcall;
{Get the Framebuffer Top, Bottom, Left and Right Overscan in Pixels}
begin
 {}
 if Assigned(FramebufferGetOverscanHandler) then
  begin
   Result:=FramebufferGetOverscanHandler(top,bottom,left,right);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function framebuffer_set_overscan(var top, bottom, left, right: uint32_t): uint32_t; stdcall;
{Set the Framebuffer Top, Bottom, Left and Right Overscan in Pixels}
begin
 {}
 if Assigned(FramebufferSetOverscanHandler) then
  begin
   Result:=FramebufferSetOverscanHandler(top,bottom,left,right);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function framebuffer_test_overscan(var top, bottom, left, right: uint32_t): uint32_t; stdcall;
{Test the Framebuffer Top, Bottom, Left and Right Overscan in Pixels}
begin
 {}
 if Assigned(FramebufferTestOverscanHandler) then
  begin
   Result:=FramebufferTestOverscanHandler(top,bottom,left,right);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function framebuffer_get_palette(buffer: PVOID; length: uint32_t): uint32_t; stdcall;
{Get the Framebuffer Palette in RGBA values}
begin
 {}
 if Assigned(FramebufferGetPaletteHandler) then
  begin
   Result:=FramebufferGetPaletteHandler(buffer,length);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function framebuffer_set_palette(start, count: uint32_t; buffer: PVOID; length: uint32_t): uint32_t; stdcall;
{Set the Framebuffer Palette in RGBA values}
begin
 {}
 if Assigned(FramebufferSetPaletteHandler) then
  begin
   Result:=FramebufferSetPaletteHandler(start,count,buffer,length);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function framebuffer_test_palette(start, count: uint32_t; buffer: PVOID; length: uint32_t): uint32_t; stdcall;
{Test the Framebuffer Palette in RGBA values}
begin
 {}
 if Assigned(FramebufferTestPaletteHandler) then
  begin
   Result:=FramebufferTestPaletteHandler(start,count,buffer,length);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function framebuffer_get_layer(var layer: int32_t): uint32_t; stdcall;
{Get the Framebuffer Layer}
begin
 {}
 if Assigned(FramebufferGetLayerHandler) then
  begin
   Result:=FramebufferGetLayerHandler(layer);
  end
 else
  begin
   layer:=0;

   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function framebuffer_set_layer(var layer: int32_t): uint32_t; stdcall;
{Set the Framebuffer Layer}
begin
 {}
 if Assigned(FramebufferSetLayerHandler) then
  begin
   Result:=FramebufferSetLayerHandler(layer);
  end
 else
  begin
   layer:=0;

   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function framebuffer_test_layer(var layer: int32_t): uint32_t; stdcall;
{Test the Framebuffer Layer}
begin
 {}
 if Assigned(FramebufferTestLayerHandler) then
  begin
   Result:=FramebufferTestLayerHandler(layer);
  end
 else
  begin
   layer:=0;

   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function framebuffer_test_vsync: uint32_t; stdcall;
{Test the Framebuffer Vertical Sync (Where Applicable)}
begin
 {}
 if Assigned(FramebufferTestVsyncHandler) then
  begin
   Result:=FramebufferTestVsyncHandler;
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function framebuffer_set_vsync: uint32_t; stdcall;
{Set (Wait For) the Framebuffer Vertical Sync (Where Applicable)}
begin
 {}
 if Assigned(FramebufferSetVsyncHandler) then
  begin
   Result:=FramebufferSetVsyncHandler;
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function framebuffer_set_backlight(brightness: uint32_t): uint32_t; stdcall;
{Set the Framebuffer Backlight brightness (Where Applicable)}
begin
 {}
 if Assigned(FramebufferSetBacklightHandler) then
  begin
   Result:=FramebufferSetBacklightHandler(brightness);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function framebuffer_get_num_displays(var numdisplays: uint32_t): uint32_t; stdcall;
{Get the number of framebuffer displays (Where Applicable)}
begin
 {}
 if Assigned(FramebufferGetNumDisplaysHandler) then
  begin
   Result:=FramebufferGetNumDisplaysHandler(numdisplays);
  end
 else
  begin
   numdisplays:=0;

   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function framebuffer_get_display_id(displaynum: uint32_t): uint32_t; stdcall;
{Get the display id for the specified display number (Where Applicable)}
begin
 {}
 if Assigned(FramebufferGetDisplayIdHandler) then
  begin
   Result:=FramebufferGetDisplayIdHandler(displaynum);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function framebuffer_set_display_num(displaynum: uint32_t): uint32_t; stdcall;
{Set the current framebuffer display number (Where Applicable)}
begin
 {}
 if Assigned(FramebufferSetDisplayNumHandler) then
  begin
   Result:=FramebufferSetDisplayNumHandler(displaynum);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function framebuffer_get_display_settings(displaynum: uint32_t; var displaysettings: TDISPLAY_SETTINGS): uint32_t; stdcall;
{Get the display settings for the specified display number (Where Applicable)}
begin
 {}
 if Assigned(FramebufferGetDisplaySettingsHandler) then
  begin
   Result:=FramebufferGetDisplaySettingsHandler(displaynum,displaysettings);
  end
 else
  begin
   FillChar(displaysettings,SizeOf(TDISPLAY_SETTINGS),0);

   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function framebuffer_display_id_to_name(displayid: uint32_t; name: PCHAR; len: uint32_t): uint32_t; stdcall;
{Get the name for the specified display id (Where Applicable)}
var
 Buffer:String;
begin
 {}
 if Assigned(FramebufferDisplayIdToNameHandler) then
  begin
   Buffer:=FramebufferDisplayIdToNameHandler(displayid);
  end
 else
  begin
   Buffer:='Unknown';
  end;

 Result:=APIStringToPCharBuffer(Buffer,name,len);
end;

{==============================================================================}
{Touch Functions}
function touch_get_buffer(var address: SIZE_T): uint32_t; stdcall;
{Get the Touchscreen memory buffer (Where Applicable)}
begin
 {}
 if Assigned(TouchGetBufferHandler) then
  begin
   Result:=TouchGetBufferHandler(address);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function touch_set_buffer(address: SIZE_T): uint32_t; stdcall;
{Set the Touchscreen memory buffer (Where Applicable)}
begin
 {}
 if Assigned(TouchSetBufferHandler) then
  begin
   Result:=TouchSetBufferHandler(address);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}
{Cursor Functions}
function cursor_set_default: uint32_t; stdcall;
{Set the default Cursor Info (Where Applicable)}
begin
 {}
 if Assigned(CursorSetDefaultHandler) then
  begin
   Result:=CursorSetDefaultHandler;
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function cursor_set_info(width, height, hotspotx, hotspoty: uint32_t; pixels: PVOID; length: uint32_t): uint32_t; stdcall;
{Set the Cursor Info (Width and Height, Hotspot and Pixel image)}
begin
 {}
 if Assigned(CursorSetInfoHandler) then
  begin
   Result:=CursorSetInfoHandler(width,height,hotspotx,hotspoty,pixels,length);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function cursor_set_state(enabled: BOOL; x, y: uint32_t; relative: BOOL): uint32_t; stdcall;
{Set the Cursor State (Enabled, X and Y)}
{Relative: X, Y is relative to Display (Virtual) not Framebuffer (Physical)}
begin
 {}
 if Assigned(CursorSetStateHandler) then
  begin
   Result:=CursorSetStateHandler(enabled,x,y,relative);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}
{DMA Functions}
function dma_available: BOOL; stdcall;
{Check if DMA is currently available}
begin
 {}
 if Assigned(DMAAvailableHandler) then
  begin
   Result:=DMAAvailableHandler;
  end
 else
  begin
   Result:=False;
  end;
end;

{==============================================================================}

function dma_transfer(data: PDMA_DATA; direction, peripheral: uint32_t): uint32_t; stdcall;
{Perform a DMA transfer using the list of DMA data blocks provided}
{Data: A linked list of DMA data blocks for the transfer}
{Direction: The direction of the DMA request (eg DMA_DIR_MEM_TO_MEM)}
{Peripheral: The peripheral ID for data request gating (eg DMA_DREQ_ID_NONE)}
begin
 {}
 if Assigned(DMATransferHandler) then
  begin
   Result:=DMATransferHandler(data,direction,peripheral);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function dma_fill_memory(dest: PVOID; size: uint32_t; value: Byte): uint32_t; stdcall;
{Fill memory at the destination address using DMA}
{Dest: The address to start the memory fill}
{Size: The size of memory to fill in bytes}
{Value: The value to fill the memory with}
begin
 {}
 if Assigned(DMAFillMemoryHandler) then
  begin
   Result:=DMAFillMemoryHandler(dest,size,value);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function dma_copy_memory(source, dest: PVOID; size: uint32_t): uint32_t; stdcall;
{Copy memory from the source to the destination address using DMA}
{Source: The source address to start the memory copy}
{Dest: The destination address to start the memory copy}
{Size: The size of memory to copy in bytes}
begin
 {}
 if Assigned(DMACopyMemoryHandler) then
  begin
   Result:=DMACopyMemoryHandler(source,dest,size);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function dma_read_peripheral(address, dest: PVOID; size, peripheral: uint32_t): uint32_t; stdcall;
{Read from a peripheral address to the destination address using DMA}
{Address: The address of the peripheral register to read from}
{Dest: The destination address to start writing to}
{Size: The size of the read in bytes}
{Peripheral: The peripheral ID for data request gating (eg DMA_DREQ_ID_UART_RX)}
begin
 {}
 if Assigned(DMAReadPeripheralHandler) then
  begin
   Result:=DMAReadPeripheralHandler(address,dest,size,peripheral);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function dma_write_peripheral(source, address: PVOID; size, peripheral: uint32_t): uint32_t; stdcall;
{Write to a peripheral address from the source address using DMA}
{Source: The source address to start reading from}
{Address: The address of the peripheral register to write to}
{Size: The size of the write in bytes}
{Peripheral: The peripheral ID for data request gating (eg DMA_DREQ_ID_UART_TX)}
begin
 {}
 if Assigned(DMAWritePeripheralHandler) then
  begin
   Result:=DMAWritePeripheralHandler(source,address,size,peripheral);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function dma_allocate_buffer(size: uint32_t): PVOID; stdcall;
{Allocate a buffer compatible with DMA memory reads or writes}
{Size: The size of the buffer to allocate}
begin
 {}
 if Assigned(DMAAllocateBufferHandler) then
  begin
   Result:=DMAAllocateBufferHandler(size);
  end
 else
  begin
   Result:=nil;
  end;
end;

{==============================================================================}

function dma_allocate_buffer_ex(var size: uint32_t): PVOID; stdcall;
{Allocate a buffer compatible with DMA memory reads or writes}
{Size: The size of the buffer to allocate (Updated on return to actual size)}
begin
 {}
 if Assigned(DMAAllocateBufferExHandler) then
  begin
   Result:=DMAAllocateBufferExHandler(size);
  end
 else
  begin
   Result:=nil;
  end;
end;

{==============================================================================}

function dma_release_buffer(buffer: PVOID): uint32_t; stdcall;
{Release a buffer allocated with DMAAllocateBuffer}
{Buffer: The buffer to be released}
begin
 {}
 if Assigned(DMAReleaseBufferHandler) then
  begin
   Result:=DMAReleaseBufferHandler(buffer);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function dma_get_channels: uint32_t; stdcall;
{Get the currently enabled DMA channel bitmap (If supported)}
begin
 {}
 if Assigned(DMAGetChannelsHandler) then
  begin
   Result:=DMAGetChannelsHandler;
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}
{Handle Functions}
function handle_create(data: THANDLE; _type: uint32_t): THANDLE; stdcall;
{Create and Open a new unnamed handle of the supplied type}
{Data: Purpose specific data to be referenced by the new handle (Optional)}
{AType: The type of the new handle (eg HANDLE_TYPE_FILE)}
{Return: The newly created handle or INVALID_HANDLE_VALUE on failure}
var
 HandleEntry:PHandleEntry;
begin
 {}
 Result:=INVALID_HANDLE_VALUE;

 {Create Handle}
 HandleEntry:=HandleCreateEx('',HANDLE_FLAG_NONE,data,_type);
 if HandleEntry <> nil then
  begin
   Result:=HandleEntry.Handle;
  end;
end;

{==============================================================================}

function handle_create_ex(const name: PCHAR; flags: uint32_t; data: THANDLE; _type: uint32_t): PHANDLE_ENTRY;  stdcall;
{Create and Open a new named or unnamed handle of the supplied type}
{Name: The name of the new handle (Optional)}
{Flags: The flags for the new handle (eg HANDLE_FLAG_DUPLICATE)}
{Data: Purpose specific data to be referenced by the new handle (Optional)}
{AType: The type of the new handle (eg HANDLE_TYPE_FILE)}
{Return: The newly created handle entry or nil on failure}
begin
 {}
 Result:=HandleCreateEx(String(name),flags,data,_type);
end;

{==============================================================================}

function handle_destroy(handle: THANDLE): uint32_t; stdcall;
{Close and Destroy a named or unnamed handle}
{Handle: The handle to be closed and destroyed}
{Return: ERROR_SUCCESS if completed successfully or another error code on failure}

{Note: For handles which have been opened multiple times, the handle is not destroyed until the last reference is closed.
       If there are still open references to the handle the return value will be ERROR_IN_USE instead of ERROR_SUCCESS}
begin
 {}
 Result:=HandleDestroy(handle);
end;

{==============================================================================}

function handle_get(handle: THANDLE): PHANDLE_ENTRY; stdcall;
{Get the handle entry for the supplied handle}
{Handle: The handle to get the entry for}
{Return: The handle entry on success or nil on failure}
begin
 {}
 Result:=HandleGet(handle);
end;

{==============================================================================}

function handle_find(const name: PCHAR): PHANDLE_ENTRY; stdcall;
{Find an existing named handle of the supplied type}
{Name: The name of the handle to find}
{Return: The handle entry on success or nil on failure}
begin
 {}
 Result:=HandleFind(String(name));
end;

{==============================================================================}

function handle_enumerate(callback: handle_enumerate_cb; data: PVOID): uint32_t; stdcall;
{Enumerate all handles in the handle table}
{Callback: The callback function to call for each handle in the table}
{Data: A private data pointer to pass to callback for each device in the table}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=HandleEnumerate(callback,data);
end;

{==============================================================================}

function handle_open(const name: PCHAR): THANDLE; stdcall;
{Open an existing named handle}
{Name: The name of the handle to open}
{Return: The handle matching the name or INVALID_HANDLE_VALUE on failure}
begin
 {}
 Result:=HandleOpen(String(name));
end;

{==============================================================================}

function handle_close(handle: THANDLE): uint32_t; stdcall;
{Close a named or unnamed handle}
{Handle: The handle to be closed}
{Return: ERROR_SUCCESS if completed successfully or another error code on failure}

{Note: For handles which have been opened multiple times, the handle is destroyed when the last reference is closed}
begin
 {}
 Result:=HandleClose(handle);
end;

{==============================================================================}

function handle_duplicate(handle: THANDLE): THANDLE; stdcall;
{Duplicate an existing named or unnamed handle}
{Handle: The handle to be duplicated}
{Return: The newly duplicated handle or INVALID_HANDLE_VALUE on failure}

{Note: Handles must be marked as HANDLE_FLAG_DUPLICATE to support duplication}
begin
 {}
 Result:=HandleDuplicate(handle);
end;

{==============================================================================}
{GPIO Functions}
function gpio_available: BOOL; stdcall;
{Check if a GPIO device is available}
begin
 {}
 if Assigned(GPIOAvailableHandler) then
  begin
   Result:=GPIOAvailableHandler;
  end
 else
  begin
   Result:=False;
  end;
end;

{==============================================================================}

function gpio_read(reg: uint32_t): uint32_t; stdcall;
{Perform a direct read from a GPIO register}
{Reg: The memory register to read from}
{Return: The value of the memory register}
begin
 {}
 if Assigned(GPIOReadHandler) then
  begin
   Result:=GPIOReadHandler(reg);
  end
 else
  begin
   {Read Value}
   Result:=PLongWord(GPIO_REGS_BASE + reg)^;

   {Memory Barrier}
   DataMemoryBarrier; {After the Last Read}
  end;
end;

{==============================================================================}

procedure gpio_write(reg, value: uint32_t); stdcall;
{Perform a direct write to a GPIO register}
{Reg: The memory register to write to}
{Value: The value to write to the register}
begin
 {}
 if Assigned(GPIOWriteHandler) then
  begin
   GPIOWriteHandler(reg,value);
  end
 else
  begin
   {Memory Barrier}
   DataMemoryBarrier; {Before the First Write}

   {Write Value}
   PLongWord(GPIO_REGS_BASE + reg)^:=value;
  end;
end;

{==============================================================================}

function gpio_input_get(pin: uint32_t): uint32_t; stdcall;
{Get the current state of a GPIO input pin}
{Pin: The pin to get the state for (eg GPIO_PIN_1)}
{Return: The current state (eg GPIO_LEVEL_HIGH) or GPIO_LEVEL_UNKNOWN on failure}
begin
 {}
 if Assigned(GPIOInputGetHandler) then
  begin
   Result:=GPIOInputGetHandler(pin);
  end
 else
  begin
   Result:=GPIO_LEVEL_UNKNOWN;
  end;
end;

{==============================================================================}

function gpio_input_wait(pin, trigger, timeout: uint32_t): uint32_t; stdcall;
{Wait for the state of a GPIO input pin to change}
{Pin: The pin to wait for the state to change (eg GPIO_PIN_1)}
{Trigger: The trigger event to wait for (eg GPIO_TRIGGER_HIGH)}
{Timeout: Number of milliseconds to wait for the change (INFINITE to wait forever)}
{Return: The state after the change (eg GPIO_LEVEL_HIGH) or GPIO_LEVEL_UNKNOWN on failure or timeout}
begin
 {}
 if Assigned(GPIOInputWaitHandler) then
  begin
   Result:=GPIOInputWaitHandler(pin,trigger,timeout);
  end
 else
  begin
   Result:=GPIO_LEVEL_UNKNOWN;
  end;
end;

{==============================================================================}

function gpio_input_event(pin, trigger, timeout: uint32_t; callback: gpio_event_cb; data: PVOID): uint32_t; stdcall;
{Schedule a function to be called when the state of a GPIO input pin changes}
{Pin: The pin to schedule the state change for (eg GPIO_PIN_1)}
{Trigger: The trigger event which will cause the function to be called (eg GPIO_TRIGGER_HIGH)}
{Timeout: The number of milliseconds before the scheduled trigger expires (INFINITE to never expire)}
{Callback: The function to be called when the trigger occurs}
{Data: A pointer to be pass to the function when the trigger occurs (Optional)}
{Return: ERROR_SUCCESS if the trigger was scheduled successfully or another error code on failure}

{Note: The pin and trigger that caused the event will be passed to the callback function}
begin
 {}
 if Assigned(GPIOInputEventHandler) then
  begin
   Result:=GPIOInputEventHandler(pin,trigger,timeout,callback,data);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function gpio_output_set(pin, level: uint32_t): uint32_t; stdcall;
{Set the state of a GPIO output pin}
{Pin: The pin to set the state for (eg GPIO_PIN_1)}
{Level: The state to set the pin to (eg GPIO_LEVEL_HIGH)}
{Return: ERROR_SUCCESS if completed successfully or another error code on failure}
begin
 {}
 if Assigned(GPIOOutputSetHandler) then
  begin
   Result:=GPIOOutputSetHandler(pin,level);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function gpio_level_get(pin: uint32_t): uint32_t; stdcall;
{Get the current level (state) of a GPIO pin}
{Pin: The pin to get the level for (eg GPIO_PIN_1)}
{Return: The current level (eg GPIO_LEVEL_HIGH) or GPIO_LEVEL_UNKNOWN on failure}
{Note: This function is a synonym for GPIOInputGet as in many cases the
       level can be read from a pin regardless of input or output mode. This
       may help to make code clearer or easier to understand in some cases}
begin
 {}
 Result:=gpio_input_get(pin);
end;

{==============================================================================}

function gpio_level_set(pin, level: uint32_t): uint32_t; stdcall;
{Set the level (state) of a GPIO pin}
{Pin: The pin to set the level for (eg GPIO_PIN_1)}
{Level: The level to set the pin to (eg GPIO_LEVEL_HIGH)}
{Return: ERROR_SUCCESS if completed successfully or another error code on failure}
{Note: This function is a synonym for GPIOOutputSet as in many cases the
       level can be set for a pin regardless of input or output mode. This
       may help to make code clearer or easier to understand in some cases}
begin
 {}
 Result:=gpio_output_set(pin,level);
end;

{==============================================================================}

function gpio_pull_get(pin: uint32_t): uint32_t; stdcall;
{Get the current pull state of a GPIO pin}
{Pin: The pin to get the pull state for (eg GPIO_PIN_1)}
{Return: The current pull state of the pin (eg GPIO_PULL_UP) or GPIO_PULL_UNKNOWN on failure}
begin
 {}
 if Assigned(GPIOPullGetHandler) then
  begin
   Result:=GPIOPullGetHandler(pin);
  end
 else
  begin
   Result:=GPIO_PULL_UNKNOWN;
  end;
end;

{==============================================================================}

function gpio_pull_select(pin, mode: uint32_t): uint32_t; stdcall;
{Change the pull state of a GPIO pin}
{Pin: The pin to change the pull state for (eg GPIO_PIN_1)}
{Mode: The pull state to set for the pin (eg GPIO_PULL_UP)}
{Return: ERROR_SUCCESS if completed successfully or another error code on failure}
begin
 {}
 if Assigned(GPIOPullSelectHandler) then
  begin
   Result:=GPIOPullSelectHandler(pin,mode);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function gpio_function_get(pin: uint32_t): uint32_t; stdcall;
{Get the current function of a GPIO pin}
{Pin: The pin to get the function for (eg GPIO_PIN_1)}
{Return: The current function of the pin (eg GPIO_FUNCTION_IN) or GPIO_FUNCTION_UNKNOWN on failure}
begin
 {}
 if Assigned(GPIOFunctionGetHandler) then
  begin
   Result:=GPIOFunctionGetHandler(pin);
  end
 else
  begin
   Result:=GPIO_FUNCTION_UNKNOWN;
  end;
end;

{==============================================================================}

function gpio_function_select(pin, mode: uint32_t): uint32_t; stdcall;
{Change the function of a GPIO pin}
{Pin: The pin to change the function for (eg GPIO_PIN_1)}
{Mode: The function to set for the pin (eg GPIO_FUNCTION_OUT)}
{Return: ERROR_SUCCESS if completed successfully or another error code on failure}
begin
 {}
 if Assigned(GPIOFunctionSelectHandler) then
  begin
   Result:=GPIOFunctionSelectHandler(pin,mode);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}
{Virtual gpio_ Functions}
function virtual_gpio_input_get(pin: uint32_t): uint32_t; stdcall;
{Get the current state of a virtual GPIO input pin}
{Pin: The pin to get the state for (eg VIRTUAL_GPIO_PIN_1)}
{Return: The current state (eg GPIO_LEVEL_HIGH) or GPIO_LEVEL_UNKNOWN on failure}
begin
 {}
 if Assigned(VirtualGPIOInputGetHandler) then
  begin
   Result:=VirtualGPIOInputGetHandler(pin);
  end
 else
  begin
   Result:=GPIO_LEVEL_UNKNOWN;
  end;
end;

{==============================================================================}

function virtual_gpio_output_set(pin, level: uint32_t): uint32_t; stdcall;
{Set the state of a virtual GPIO output pin}
{Pin: The pin to set the state for (eg GPIO_PIN_1)}
{Level: The state to set the pin to (eg GPIO_LEVEL_HIGH)}
{Return: ERROR_SUCCESS if completed successfully or another error code on failure}
begin
 {}
 if Assigned(VirtualGPIOOutputSetHandler) then
  begin
   Result:=VirtualGPIOOutputSetHandler(pin,level);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function virtual_gpio_level_get(pin: uint32_t): uint32_t; stdcall;
{Get the current level (state) of a virtual GPIO pin}
{Pin: The pin to get the level for (eg GPIO_PIN_1)}
{Return: The current level (eg GPIO_LEVEL_HIGH) or GPIO_LEVEL_UNKNOWN on failure}
{Note: This function is a synonym for VirtualGPIOInputGet as in many cases the
       level can be read from a pin regardless of input or output mode. This
       may help to make code clearer or easier to understand in some cases}
begin
 {}
 Result:=virtual_gpio_input_get(Pin);
end;

{==============================================================================}

function virtual_gpio_level_set(pin, level: uint32_t): uint32_t; stdcall;
{Set the level (state) of a virtual GPIO pin}
{Pin: The pin to set the level for (eg GPIO_PIN_1)}
{Level: The level to set the pin to (eg GPIO_LEVEL_HIGH)}
{Return: ERROR_SUCCESS if completed successfully or another error code on failure}
{Note: This function is a synonym for VirtualGPIOOutputSet as in many cases the
       level can be set for a pin regardless of input or output mode. This
       may help to make code clearer or easier to understand in some cases}
begin
 {}
 Result:=virtual_gpio_output_set(Pin,Level);
end;

{==============================================================================}

function virtual_gpio_function_get(pin: uint32_t): uint32_t; stdcall;
{Get the current function of a virtual GPIO pin}
{Pin: The pin to get the function for (eg GPIO_PIN_1)}
{Return: The current function of the pin (eg GPIO_FUNCTION_IN) or GPIO_FUNCTION_UNKNOWN on failure}
begin
 {}
 if Assigned(VirtualGPIOFunctionGetHandler) then
  begin
   Result:=VirtualGPIOFunctionGetHandler(pin);
  end
 else
  begin
   Result:=GPIO_FUNCTION_UNKNOWN;
  end;
end;

{==============================================================================}

function virtual_gpio_function_select(pin, mode: uint32_t): uint32_t; stdcall;
{Change the function of a virtual GPIO pin}
{Pin: The pin to change the function for (eg GPIO_PIN_1)}
{Mode: The function to set for the pin (eg GPIO_FUNCTION_OUT)}
{Return: ERROR_SUCCESS if completed successfully or another error code on failure}
begin
 {}
 if Assigned(VirtualGPIOFunctionSelectHandler) then
  begin
   Result:=VirtualGPIOFunctionSelectHandler(pin,mode);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}
{SPI Functions}
function spi_available: BOOL; stdcall;
{Check if an SPI device is available}
begin
 {}
 if Assigned(SPIAvailableHandler) then
  begin
   Result:=SPIAvailableHandler;
  end
 else
  begin
   Result:=False;
  end;
end;

{==============================================================================}

function spi_start(mode, clockrate, clockphase, clockpolarity: uint32_t): uint32_t; stdcall;
{Start the default SPI device ready for writing and reading}
{Mode: The device mode to set (eg SPI_MODE_4WIRE)}
{ClockRate: The clock rate to set for the device}
{ClockPhase: The clock phase to set (eg SPI_CLOCK_PHASE_LOW)}
{ClockPolarity: The clock polarity to set (eg SPI_CLOCK_POLARITY_LOW)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 if Assigned(SPIStartHandler) then
  begin
   Result:=SPIStartHandler(mode,clockrate,clockphase,clockpolarity);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function spi_stop: uint32_t; stdcall;
{Stop the default SPI device and terminate writing and reading}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 if Assigned(SPIStopHandler) then
  begin
   Result:=SPIStopHandler;
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function spi_read(chipselect: uint16_t; dest: PVOID; size: uint32_t; var count: uint32_t): uint32_t; stdcall;
{Read data from the default SPI device}
{Because SPI writes and then reads for each byte, dummy data will be written for each byte to be read}
{ChipSelect: The chip select for the slave to read from (eg SPI_CS_0)}
{Dest: Pointer to a buffer to receive the data}
{Size: The size of the buffer}
{Count: The number of bytes read on return}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 if Assigned(SPIReadHandler) then
  begin
   Result:=SPIReadHandler(chipselect,dest,size,count);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function spi_write(chipselect: uint16_t; source: PVOID; size: uint32_t; var count: uint32_t): uint32_t; stdcall;
{Write data to the default SPI device}
{Because SPI writes and then reads for each byte, received data will be discarded for each byte written}
{ChipSelect: The chip select for the slave to write to (eg SPI_CS_0)}
{Source: Pointer to a buffer of data to transmit}
{Size: The size of the buffer}
{Count: The number of bytes written on return}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 if Assigned(SPIWriteHandler) then
  begin
   Result:=SPIWriteHandler(chipselect,source,size,count);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function spi_write_read(chipselect: uint16_t; source, dest: PVOID; size: uint32_t; var count: uint32_t): uint32_t; stdcall;
{Write data to and Read data from the default SPI device in one operation}
{Because SPI writes and then reads for each byte, both the source and dest buffers must be the same size}
{ChipSelect: The chip select for the slave to write to and read from (eg SPI_CS_0)}
{Source: Pointer to a buffer of data to transmit}
{Dest: Pointer to a buffer to receive the data}
{Size: The size of the buffer}
{Count: The number of bytes written and read on return}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 if Assigned(SPIWriteReadHandler) then
  begin
   Result:=SPIWriteReadHandler(chipselect,source,dest,size,count);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function spi_get_mode: uint32_t; stdcall;
{Get the device mode of the default SPI device}
{Return: The device mode or SPI_MODE_UNKNOWN on failure}
begin
 {}
 if Assigned(SPIGetModeHandler) then
  begin
   Result:=SPIGetModeHandler;
  end
 else
  begin
   Result:=SPI_MODE_UNKNOWN;
  end;
end;

{==============================================================================}

function spi_set_mode(mode: uint32_t): uint32_t; stdcall;
{Set the device mode for the default SPI device}
{Mode: The device mode to set (eg SPI_MODE_4WIRE)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 if Assigned(SPISetModeHandler) then
  begin
   Result:=SPISetModeHandler(mode);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function spi_get_clock_rate(chipselect: uint16_t): uint32_t; stdcall;
{Get the clock rate of the default SPI device}
{ChipSelect: The chip select number to get clock rate from (SPI_CS_NONE for default)}
{Return: The clock rate in Hz or 0 on failure}
begin
 {}
 if Assigned(SPIGetClockRateHandler) then
  begin
   Result:=SPIGetClockRateHandler(chipselect);
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function spi_set_clock_rate(chipselect: uint16_t; clockrate: uint32_t): uint32_t; stdcall;
{Set the clock rate for the default SPI device}
{ClockRate: The clock rate to set in Hz}
{ChipSelect: The chip select number to set clock rate for (SPI_CS_NONE for default)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 if Assigned(SPISetClockRateHandler) then
  begin
   Result:=SPISetClockRateHandler(chipselect,clockrate);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function spi_get_clock_phase: uint32_t; stdcall;
{Get the clock phase of the default SPI device}
{Return: The clock phase or SPI_CLOCK_PHASE_UNKNOWN on failure}
begin
 {}
 if Assigned(SPIGetClockPhaseHandler) then
  begin
   Result:=SPIGetClockPhaseHandler;
  end
 else
  begin
   Result:=SPI_CLOCK_PHASE_UNKNOWN;
  end;
end;

{==============================================================================}

function spi_set_clock_phase(clockphase: uint32_t): uint32_t; stdcall;
{Set the clock phase for the default SPI device}
{ClockPhase: The clock phase to set (eg SPI_CLOCK_PHASE_LOW)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 if Assigned(SPISetClockPhaseHandler) then
  begin
   Result:=SPISetClockPhaseHandler(clockphase);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function spi_get_clock_polarity: uint32_t; stdcall;
{Get the clock polarity of the default SPI device}
{Return: The clock polarity or SPI_CLOCK_POLARITY_UNKNOWN on failure}
begin
 {}
 if Assigned(SPIGetClockPolarityHandler) then
  begin
   Result:=SPIGetClockPolarityHandler;
  end
 else
  begin
   Result:=SPI_CLOCK_POLARITY_UNKNOWN;
  end;
end;

{==============================================================================}

function spi_set_clock_polarity(clockpolarity: uint32_t): uint32_t; stdcall;
{Set the clock polarity for the default SPI device}
{ClockPolarity: The clock polarity to set (eg SPI_CLOCK_POLARITY_LOW)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 if Assigned(SPISetClockPolarityHandler) then
  begin
   Result:=SPISetClockPolarityHandler(clockpolarity);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function spi_get_select_polarity(chipselect: uint16_t): uint32_t; stdcall;
{Get the chip select polarity of the default SPI device}
{ChipSelect: The chip select number to get polarity from (SPI_CS_NONE for default)}
{Return: The chip select polarity or SPI_CS_POLARITY_UNKNOWN on failure}
begin
 {}
 if Assigned(SPIGetSelectPolarityHandler) then
  begin
   Result:=SPIGetSelectPolarityHandler(chipselect);
  end
 else
  begin
   Result:=SPI_CS_POLARITY_UNKNOWN;
  end;
end;

{==============================================================================}

function spi_set_select_polarity(chipselect: uint16_t; selectpolarity: uint32_t): uint32_t; stdcall;
{Set the chip select polarity for the default SPI device}
{ChipSelect: The chip select number to set polarity for (SPI_CS_NONE for default)}
{SelectPolarity: The chip select polarity to set (eg SPI_CS_POLARITY_LOW)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 if Assigned(SPISetSelectPolarityHandler) then
  begin
   Result:=SPISetSelectPolarityHandler(chipselect,selectpolarity);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function spi_get_description(id: uint32_t; description: PCHAR; len: uint32_t): uint32_t; stdcall;
{Return the device description of an SPI device}
{Id: The Id number of the SPI device as shown in the official documentation}
{Return: The correct device description suitable for passing to SPIDeviceFindByDescription}
{Note: The Id number supplied to this function may differ from the Ultibo device id value}
var
 Buffer:String;
begin
 {}
 if Assigned(SPIGetDescriptionHandler) then
  begin
   Buffer:=SPIGetDescriptionHandler(id);
  end
 else
  begin
   Buffer:='';
  end;

 Result:=APIStringToPCharBuffer(Buffer,description,len);
end;

{==============================================================================}
{I2C Functions}
function i2c_available: BOOL; stdcall;
{Check if an I2C device is available}
begin
 {}
 if Assigned(I2CAvailableHandler) then
  begin
   Result:=I2CAvailableHandler;
  end
 else
  begin
   Result:=False;
  end;
end;

{==============================================================================}

function i2c_start(rate: uint32_t): uint32_t; stdcall;
{Start the default I2C device ready for reading and writing}
{Rate: The clock rate to set for the device (0 to use the default rate)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 if Assigned(I2CStartHandler) then
  begin
   Result:=I2CStartHandler(rate);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function i2c_stop: uint32_t; stdcall;
{Stop the default I2C device and terminate reading and writing}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 if Assigned(I2CStopHandler) then
  begin
   Result:=I2CStopHandler;
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function i2c_read(address: uint16_t; buffer: PVOID; size: uint32_t; var count: uint32_t): uint32_t; stdcall;
{Read data from the default I2C device}
{Address: The slave address to read from (I2C_ADDRESS_INVALID to use the current address)}
{Buffer: Pointer to a buffer to receive the data}
{Size: The size of the buffer}
{Count: The number of bytes read on return}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 if Assigned(I2CReadHandler) then
  begin
   Result:=I2CReadHandler(address,buffer,size,count);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function i2c_write(address: uint16_t; buffer: PVOID; size: uint32_t; var count: uint32_t): uint32_t; stdcall;
{Write data to the default I2C device}
{Address: The slave address to write to (I2C_ADDRESS_INVALID to use the current address)}
{Buffer: Pointer to a buffer of data to transmit}
{Size: The size of the buffer}
{Count: The number of bytes written on return}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 if Assigned(I2CWriteHandler) then
  begin
   Result:=I2CWriteHandler(address,buffer,size,count);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function i2c_write_read(address: uint16_t; initial: PVOID; len: uint32_t; data: PVOID; size: uint32_t; var count: uint32_t): uint32_t; stdcall;
{Write data to and Read data from the default I2C device in one operation}
{Useful for devices that require a register address specified before a read (eg EEPROM devices)}
{Address: The slave address to write to (I2C_ADDRESS_INVALID to use the current address)}
{Initial: Pointer to the initial buffer to transmit}
{Len: The size of the initial buffer}
{Data: Pointer to a buffer to receive the data}
{Size: The size of the data buffer}
{Count: The number of bytes read on return}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 if Assigned(I2CWriteReadHandler) then
  begin
   Result:=I2CWriteReadHandler(address,initial,len,data,size,count);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function i2c_write_write(address: uint16_t; initial: PVOID; len: uint32_t; data: PVOID; size: uint32_t; var count: uint32_t): uint32_t; stdcall;
{Write 2 data blocks to the default I2C device in one operation}
{Useful for devices that require a register address specified before a write (eg EEPROM devices)}
{Address: The slave address to write to (I2C_ADDRESS_INVALID to use the current address)}
{Initial: Pointer to the initial buffer to transmit}
{Len: The size of the initial buffer}
{Data: Pointer to a buffer of data to transmit}
{Size: The size of the data buffer}
{Count: The number of bytes of data written on return}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 if Assigned(I2CWriteWriteHandler) then
  begin
   Result:=I2CWriteWriteHandler(address,initial,len,data,size,count);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function i2c_get_rate: uint32_t; stdcall;
{Get the clock rate of the default I2C device}
{Return: The clock rate in Hz or 0 on failure}
begin
 {}
 if Assigned(I2CGetRateHandler) then
  begin
   Result:=I2CGetRateHandler;
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function i2c_set_rate(rate: uint32_t): uint32_t; stdcall;
{Set the clock rate for the default I2C device}
{Rate: The clock rate to set in Hz}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 if Assigned(I2CSetRateHandler) then
  begin
   Result:=I2CSetRateHandler(rate);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function i2c_get_address: uint16_t; stdcall;
{Get the slave address for the default I2C device}
{Return: The slave address or I2C_ADDRESS_INVALID on failure}
begin
 {}
 if Assigned(I2CGetAddressHandler) then
  begin
   Result:=I2CGetAddressHandler;
  end
 else
  begin
   Result:=I2C_ADDRESS_INVALID;
  end;
end;

{==============================================================================}

function i2c_set_address(address: uint16_t): uint32_t; stdcall;
{Set the slave address for the default I2C device}
{Address: The slave address to set}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 if Assigned(I2CSetAddressHandler) then
  begin
   Result:=I2CSetAddressHandler(address);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function i2c_get_description(id: uint32_t; description: PCHAR; len: uint32_t): uint32_t; stdcall;
{Get the device description of an I2C device}
{Id: The Id number of the I2C device as shown in the official documentation}
{Return: The correct device description suitable for passing to I2CDeviceFindByDescription}
{Note: The Id number supplied to this function may differ from the Ultibo device id value}
var
 Buffer:String;
begin
 {}
 if Assigned(I2CGetDescriptionHandler) then
  begin
   Buffer:=I2CGetDescriptionHandler(id);
  end
 else
  begin
   Buffer:='';
  end;

 Result:=APIStringToPCharBuffer(Buffer,description,len);
end;

{==============================================================================}

function i2c_slave_get_description(id: uint32_t; description: PCHAR; len: uint32_t): uint32_t; stdcall;
{Get the device description of an I2C slave device}
{Id: The Id number of the I2C slave device as shown in the official documentation}
{Return: The correct device description suitable for passing to I2CSlaveFindByDescription}
{Note: The Id number supplied to this function may differ from the Ultibo device id value}
var
 Buffer:String;
begin
 {}
 if Assigned(I2CSlaveGetDescriptionHandler) then
  begin
   Buffer:=I2CSlaveGetDescriptionHandler(id);
  end
 else
  begin
   Buffer:='';
  end;

 Result:=APIStringToPCharBuffer(Buffer,description,len);
end;

{==============================================================================}
{PWM Functions}
function pwm_available: BOOL; stdcall;
{Check if a PWM device is available}
begin
 {}
 if Assigned(PWMAvailableHandler) then
  begin
   Result:=PWMAvailableHandler;
  end
 else
  begin
   Result:=False;
  end;
end;

{==============================================================================}

function pwm_start: uint32_t; stdcall;
{Start the default PWM device}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 if Assigned(PWMStartHandler) then
  begin
   Result:=PWMStartHandler;
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function pwm_stop: uint32_t; stdcall;
{Stop the default PWM device}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 if Assigned(PWMStopHandler) then
  begin
   Result:=PWMStopHandler;
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function pwm_write(value: uint32_t): uint32_t; stdcall;
{Write a value to the default PWM device}
{Value: The value to write}
{Return: ERROR_SUCCESS if completed or another error code on failure}

{Note: The exact meaning of value may depend on the device and other configured options,
       in many cases the value will represent the "on" time of each pulse with regard to
       the duty cycle of the waveform output by the device}
begin
 {}
 if Assigned(PWMWriteHandler) then
  begin
   Result:=PWMWriteHandler(value);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function pwm_set_mode(mode: uint32_t): uint32_t; stdcall;
{Set the mode for the default PWM device}
{Mode: The mode value to set (eg PWM_MODE_MARKSPACE)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 if Assigned(PWMSetModeHandler) then
  begin
   Result:=PWMSetModeHandler(mode);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function pwm_set_range(range: uint32_t): uint32_t; stdcall;
{Set the range for the default PWM device}
{Range: The range value to set}
{Return: ERROR_SUCCESS if completed or another error code on failure}

{Note: The exact meaning of range may depend on the device and other configured options,
       in many cases the range will represent the period of one full cycle of the
       waveform output by the device}
begin
 {}
 if Assigned(PWMSetRangeHandler) then
  begin
   Result:=PWMSetRangeHandler(range);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function pwm_set_frequency(frequency: uint32_t): uint32_t; stdcall;
{Set the clock frequency for the default PWM device}
{Frequency: The frequency to set in Hz}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 if Assigned(PWMSetFrequencyHandler) then
  begin
   Result:=PWMSetFrequencyHandler(frequency);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function pwm_configure(dutyns, periodns: uint32_t): uint32_t; stdcall;
{Set the configuration of the default PWM device}
{DutyNS: The "on" time part of the cycle (Nanoseconds)}
{PeriodNS: The duration of one full cycle (Nanoseconds)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 if Assigned(PWMConfigureHandler) then
  begin
   Result:=PWMConfigureHandler(dutyns,periodns);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function pwm_get_description(id, channel: uint32_t; description: PCHAR; len: uint32_t): uint32_t; stdcall;
{Get the device description of an PWM device}
{Id: The Id number of the PWM device as shown in the official documentation}
{Channel: The channel number of the PWM device as shown in the official documentation}
{Return: The correct device description suitable for passing to PWMDeviceFindByDescription}
{Note: The Id number supplied to this function may differ from the Ultibo device id value}
var
 Buffer:String;
begin
 {}
 if Assigned(PWMGetDescriptionHandler) then
  begin
   Buffer:=PWMGetDescriptionHandler(id,channel);
  end
 else
  begin
   Buffer:='';
  end;

 Result:=APIStringToPCharBuffer(Buffer,description,len);
end;

{==============================================================================}
{RTC Functions}
function rtc_available: BOOL; stdcall;
{Check if a Real Time Clock (RTC) device is available}
begin
 {}
 if Assigned(RTCAvailableHandler) then
  begin
   Result:=RTCAvailableHandler;
  end
 else
  begin
   Result:=False;
  end;
end;

{==============================================================================}

function rtc_get_time: int64_t; stdcall;
{Get the current time from a Real Time Clock device}
{Returned time is 100 nanosecond ticks since 1 January 1601}
{The same format as the ClockGetTime function}
begin
 {}
 if Assigned(RTCGetTimeHandler) then
  begin
   Result:=RTCGetTimeHandler;
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function rtc_set_time(const time: int64_t): int64_t; stdcall;
{Set the current time for a Real Time Clock device}
{Time: The time to be set}
{Return: The device time after setting (or 0 on failure)}
{Time and returned time is 100 nanosecond ticks since 1 January 1601}
{The same format as the ClockSetTime function}
begin
 {}
 if Assigned(RTCSetTimeHandler) then
  begin
   Result:=RTCSetTimeHandler(time);
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}
{UART Functions}
function uart_get_description(id: uint32_t; description: PCHAR; len: uint32_t): uint32_t; stdcall;
{Get the device description of a UART device}
{Id: The Id number of the UART device as shown in the official documentation}
{Return: The correct device description suitable for passing to UARTDeviceFindByDescription}
{Note: The Id number supplied to this function may differ from the Ultibo device id value}
var
 Buffer:String;
begin
 {}
 if Assigned(UARTGetDescriptionHandler) then
  begin
   Buffer:=UARTGetDescriptionHandler(id);
  end
 else
  begin
   Buffer:='';
  end;

 Result:=APIStringToPCharBuffer(Buffer,description,len);
end;

{==============================================================================}
{Serial Functions}
function serial_available: BOOL; stdcall;
{Check if a Serial device is available}
begin
 {}
 if Assigned(SerialAvailableHandler) then
  begin
   Result:=SerialAvailableHandler;
  end
 else
  begin
   Result:=False;
  end;
end;

{==============================================================================}

function serial_open(baudrate, databits, stopbits, parity, flowcontrol, receivedepth, transmitdepth: uint32_t): uint32_t; stdcall;
{Open the default Serial device ready for sending and receiving}
{BaudRate: Baud rate for the connection (eg 9600, 57600, 115200 etc}
{DataBits: Size of the data (eg SERIAL_DATA_8BIT)}
{StopBits: Number of stop bits (eg SERIAL_STOP_1BIT)}
{Parity: Parity type for the data (eg SERIAL_PARITY_NONE)}
{FlowControl: Flow control for the connection (eg SERIAL_FLOW_NONE)}
{ReceiveDepth: Size of the receive buffer (0 = Default size)}
{TransmitDepth: Size of the transmit buffer (0 = Default size)}
begin
 {}
 if Assigned(SerialOpenHandler) then
  begin
   Result:=SerialOpenHandler(baudrate,databits,stopbits,parity,flowcontrol,receivedepth,transmitdepth);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function serial_close: uint32_t; stdcall;
{Close the default Serial device and terminate sending and receiving}
begin
 {}
 if Assigned(SerialCloseHandler) then
  begin
   Result:=SerialCloseHandler;
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function serial_read(buffer: PVOID; size: uint32_t; var count: uint32_t): uint32_t; stdcall;
{Read data from the default Serial device}
{Buffer: Pointer to a buffer to receive the data}
{Size: The size of the buffer}
{Count: The number of bytes read on return}
begin
 {}
 if Assigned(SerialReadHandler) then
  begin
   Result:=SerialReadHandler(buffer,size,count);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function serial_write(buffer: PVOID; size: uint32_t; var count: uint32_t): uint32_t; stdcall;
{Write data to the default Serial device}
{Buffer: Pointer to a buffer of data to transmit}
{Size: The size of the buffer}
{Count: The number of bytes written on return}
begin
 {}
 if Assigned(SerialWriteHandler) then
  begin
   Result:=SerialWriteHandler(buffer,size,count);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}
{Peripheral Functions}
function peripheral_get_base: SIZE_T; stdcall;
begin
 {}
 if Assigned(PeripheralGetBaseHandler) then
  begin
   Result:=PeripheralGetBaseHandler;
  end
 else
  begin
   Result:=PERIPHERALS_BASE;
  end;
end;

{==============================================================================}

function peripheral_get_size: uint32_t; stdcall;
begin
 {}
 if Assigned(PeripheralGetSizeHandler) then
  begin
   Result:=PeripheralGetSizeHandler;
  end
 else
  begin
   Result:=PERIPHERALS_SIZE;
  end;
end;

{==============================================================================}

function peripheral_read(base, reg: uint32_t): uint32_t; stdcall;
{Read from a Peripheral register}
begin
 {}
 if Assigned(PeripheralReadHandler) then
  begin
   Result:=PeripheralReadHandler(base,reg);
  end
 else
  begin
   {Read Value}
   Result:=PLongWord(PERIPHERALS_BASE + base + reg)^;

   {Memory Barrier}
   DataMemoryBarrier; {After the Last Read}
  end;
end;

{==============================================================================}

procedure peripheral_write(base, reg, value: uint32_t); stdcall;
{Write to a Peripheral register}
begin
 {}
 if Assigned(PeripheralWriteHandler) then
  begin
   PeripheralWriteHandler(base,reg,value);
  end
 else
  begin
   {Memory Barrier}
   DataMemoryBarrier; {Before the First Write}

   {Write Value}
   PLongWord(PERIPHERALS_BASE + base + reg)^:=value;
  end;
end;

{==============================================================================}

function local_peripheral_get_base: SIZE_T; stdcall;
{Get the base address of the local peripherals (Peripherals local to each CPU)}
begin
 {}
 if Assigned(LocalPeripheralGetBaseHandler) then
  begin
   Result:=LocalPeripheralGetBaseHandler;
  end
 else
  begin
   Result:=LOCAL_PERIPHERALS_BASE;
  end;
end;

{==============================================================================}

function local_peripheral_get_size: uint32_t; stdcall;
{Get the total size of the local peripherals (Peripherals local to each CPU)}
begin
 {}
 if Assigned(LocalPeripheralGetSizeHandler) then
  begin
   Result:=LocalPeripheralGetSizeHandler;
  end
 else
  begin
   Result:=LOCAL_PERIPHERALS_SIZE;
  end;
end;

{==============================================================================}
{System Functions}
function get_sp: SIZE_T; stdcall;
{Get the current stack pointer (SP)}
begin
 {}
 if Assigned(GetSPHandler) then
  begin
   Result:=GetSPHandler;
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function get_pc: SIZE_T; stdcall;
{Get the current program counter (PC)}
begin
 {}
 if Assigned(GetPCHandler) then
  begin
   Result:=GetPCHandler;
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function get_irq: BOOL; stdcall;
{Get Interrupts (IRQ) state}
{Return: True is enabled, False if disabled}
begin
 {}
 if Assigned(GetIRQHandler) then
  begin
   Result:=GetIRQHandler;
  end
 else
  begin
   Result:=True;
  end;
end;

{==============================================================================}

procedure enable_irq; stdcall;
{Enable Interrupts (IRQ) unconditionally}
begin
 {}
 if Assigned(EnableIRQHandler) then
  begin
   EnableIRQHandler;
  end;
end;

{==============================================================================}

procedure disable_irq; stdcall;
{Disable Interrupts (IRQ) unconditionally}
begin
 {}
 if Assigned(DisableIRQHandler) then
  begin
   DisableIRQHandler;
  end;
end;

{==============================================================================}

function save_irq: TIRQ_MASK; stdcall;
{Disable Interrupts (IRQ) and return the previous state}
{Return: IRQ state when called}
begin
 {}
 if Assigned(SaveIRQHandler) then
  begin
   Result:=SaveIRQHandler;
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function restore_irq(irqmask: TIRQ_MASK): TIRQ_MASK; stdcall;
{Restore Interrupts (IRQ) to a previous state}
{IRQMask: IRQ state to restore}
{Return: IRQ state when called}
begin
 {}
 if Assigned(RestoreIRQHandler) then
  begin
   Result:=RestoreIRQHandler(irqmask);
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function get_fiq: BOOL; stdcall;
{Get Fast Interrupts (FIQ) state}
{Return: True is enabled, False if disabled}
begin
 {}
 if Assigned(GetFIQHandler) then
  begin
   Result:=GetFIQHandler;
  end
 else
  begin
   Result:=True;
  end;
end;

{==============================================================================}

procedure enable_fiq; stdcall;
{Enable Fast Interrupts (FIQ) unconditionally}
begin
 {}
 if Assigned(EnableFIQHandler) then
  begin
   EnableFIQHandler;
  end;
end;

{==============================================================================}

procedure disable_fiq; stdcall;
{Disable Fast Interrupts (FIQ) unconditionally}
begin
 {}
 if Assigned(DisableFIQHandler) then
  begin
   DisableFIQHandler;
  end;
end;

{==============================================================================}

function save_fiq: TFIQ_MASK; stdcall;
{Disable Fast Interrupts (FIQ) and return the previous state}
{Return: FIQ state when called}
begin
 {}
 if Assigned(SaveFIQHandler) then
  begin
   Result:=SaveFIQHandler;
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function restore_fiq(fiqmask: TFIQ_MASK): TFIQ_MASK; stdcall;
{Restore Fast Interrupts (FIQ) to a previous state}
{FIQMask: FIQ state to restore}
{Return: FIQ state when called}
begin
 {}
 if Assigned(RestoreFIQHandler) then
  begin
   Result:=RestoreFIQHandler(fiqmask);
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

procedure enable_irq_fiq; stdcall;
{Enable Interrupts and Fast Interrupts (IRQ/FIQ) unconditionally}
begin
 {}
 if Assigned(EnableIRQFIQHandler) then
  begin
   EnableIRQFIQHandler;
  end;
end;

{==============================================================================}

procedure disable_irq_fiq; stdcall;
{Disable Interrupts and Fast Interrupts (IRQ/FIQ) unconditionally}
begin
 {}
 if Assigned(DisableIRQFIQHandler) then
  begin
   DisableIRQFIQHandler;
  end;
end;

{==============================================================================}

function save_irq_fiq: TIRQ_FIQ_MASK; stdcall;
{Disable Interrupts and Fast Interrupts (IRQ/FIQ) and return the previous state}
{Return: IRQ/FIQ state when called}
begin
 {}
 if Assigned(SaveIRQFIQHandler) then
  begin
   Result:=SaveIRQFIQHandler;
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function restore_irq_fiq(irqfiqmask: TIRQ_FIQ_MASK): TIRQ_FIQ_MASK; stdcall;
{Restore Interrupts and Fast Interrupts (IRQ/FIQ) to a previous state}
{IRQFIQMask: IRQ/FIQ state to restore}
{Return: IRQ/FIQ state when called}
begin
 {}
 if Assigned(RestoreIRQFIQHandler) then
  begin
   Result:=RestoreIRQFIQHandler(irqfiqmask);
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function get_abort: BOOL; stdcall;
{Get Abort state}
{Return: True is enabled, False if disabled}
begin
 {}
 if Assigned(GetAbortHandler) then
  begin
   Result:=GetAbortHandler;
  end
 else
  begin
   Result:=True;
  end;
end;

{==============================================================================}

procedure enable_abort; stdcall;
{Enable Abort unconditionally}
begin
 {}
 if Assigned(EnableAbortHandler) then
  begin
   EnableAbortHandler;
  end;
end;

{==============================================================================}

procedure disable_abort; stdcall;
{Disable Abort unconditionally}
begin
 {}
 if Assigned(DisableAbortHandler) then
  begin
   DisableAbortHandler;
  end;
end;

{==============================================================================}

function save_abort: TABORT_MASK; stdcall;
{Disable Abort and return the previous state}
{Return: Abort state when called}
begin
 {}
 if Assigned(SaveAbortHandler) then
  begin
   Result:=SaveAbortHandler;
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function restore_abort(abortmask: TABORT_MASK): TABORT_MASK; stdcall;
{Restore Abort to a previous state}
{AbortMask: Abort state to restore}
{Return: Abort state when called}
begin
 {}
 if Assigned(RestoreAbortHandler) then
  begin
   Result:=RestoreAbortHandler(abortmask);
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

procedure halt_cpu; stdcall;
{Halt the current processor}
begin
 {}
 if Assigned(HaltHandler) then
  begin
   HaltHandler;
  end;
end;

{==============================================================================}

procedure pause_cpu; stdcall;
{Pause the current processor and wait for an Event or Interrupt (Where Applicable)}
begin
 {}
 if Assigned(PauseHandler) then
  begin
   PauseHandler;
  end;
end;

{==============================================================================}

function halt_thread(exitcode: uint32_t): uint32_t; stdcall;
{Halt the current thread}
begin
 {}
 if Assigned(HaltThreadHandler) then
  begin
   Result:=HaltThreadHandler(exitcode);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

procedure send_event; stdcall;
{Send a signal that an Event has occurred (Where Applicable)}
begin
 {}
 if Assigned(SendEventHandler) then
  begin
   SendEventHandler;
  end;
end;

{==============================================================================}

procedure wait_for_event; stdcall;
{Wait for an Event to occur (Where Applicable)}
begin
 {}
 if Assigned(WaitForEventHandler) then
  begin
   WaitForEventHandler;
  end;
end;

{==============================================================================}

procedure wait_for_interrupt; stdcall;
{Wait for an Interrupt to occur (Where Applicable)}
begin
 {}
 if Assigned(WaitForInterruptHandler) then
  begin
   WaitForInterruptHandler;
  end;
end;

{==============================================================================}

procedure read_memory_barrier; stdcall;
{Perform a Read Memory Barrier operation (Where Applicable)}
begin
 {}
 if Assigned(ReadMemoryBarrierHandler) then
  begin
   ReadMemoryBarrierHandler;
  end;
end;

{==============================================================================}

procedure write_memory_barrier; stdcall;
{Perform a Write Memory Barrier operation (Where Applicable)}
begin
 {}
 if Assigned(WriteMemoryBarrierHandler) then
  begin
   WriteMemoryBarrierHandler;
  end;
end;

{==============================================================================}

procedure data_memory_barrier; stdcall;
{Perform a Data Memory Barrier operation (Where Applicable)}
begin
 {}
 if Assigned(DataMemoryBarrierHandler) then
  begin
   DataMemoryBarrierHandler;
  end;
end;

{==============================================================================}

procedure data_synchronization_barrier; stdcall;
{Perform a Data Synchronization Barrier operation (Where Applicable)}
begin
 {}
 if Assigned(DataSynchronizationBarrierHandler) then
  begin
   DataSynchronizationBarrierHandler;
  end;
end;

{==============================================================================}

procedure instruction_memory_barrier; stdcall;
{Perform an Instruction Memory Barrier operation (Where Applicable)}
begin
 {}
 if Assigned(InstructionMemoryBarrierHandler) then
  begin
   InstructionMemoryBarrierHandler;
  end;
end;

{==============================================================================}

procedure invalidate_tlb; stdcall;
{Perform an Invalidate Entire TLB operation (Where Applicable)}
begin
 {}
 if Assigned(InvalidateTLBHandler) then
  begin
   InvalidateTLBHandler;
  end;
end;

{==============================================================================}

procedure invalidate_data_tlb; stdcall;
{Perform an Invalidate Data TLB operation (Where Applicable)}
begin
 {}
 if Assigned(InvalidateDataTLBHandler) then
  begin
   InvalidateDataTLBHandler;
  end;
end;

{==============================================================================}

procedure invalidate_instruction_tlb; stdcall;
{Perform an Invalidate Instruction TLB operation (Where Applicable)}
begin
 {}
 if Assigned(InvalidateInstructionTLBHandler) then
  begin
   InvalidateInstructionTLBHandler;
  end;
end;

{==============================================================================}

procedure invalidate_cache; stdcall;
{Perform an Invalidate Entire Cache operation (Where Applicable)}
begin
 {}
 if Assigned(InvalidateCacheHandler) then
  begin
   InvalidateCacheHandler;
  end;
end;

{==============================================================================}

procedure clean_data_cache; stdcall;
{Perform a Clean Data Cache operation (Where Applicable)}
begin
 {}
 if Assigned(CleanDataCacheHandler) then
  begin
   CleanDataCacheHandler;
  end;
end;

{==============================================================================}

procedure invalidate_data_cache; stdcall;
{Perform an Invalidate Data Cache operation (Where Applicable)}
begin
 {}
 if Assigned(InvalidateDataCacheHandler) then
  begin
   InvalidateDataCacheHandler;
  end;
end;

{==============================================================================}

procedure clean_and_invalidate_data_cache; stdcall;
{Perform a Clean and Invalidate Data Cache operation (Where Applicable)}
begin
 {}
 if Assigned(CleanAndInvalidateDataCacheHandler) then
  begin
   CleanAndInvalidateDataCacheHandler;
  end;
end;

{==============================================================================}

procedure invalidate_instruction_cache; stdcall;
{Perform an Invalidate Instruction Cache operation (Where Applicable)}
begin
 {}
 if Assigned(InvalidateInstructionCacheHandler) then
  begin
   InvalidateInstructionCacheHandler;
  end;
end;

{==============================================================================}

procedure clean_data_cache_range(address: SIZE_T; size: uint32_t); stdcall;
{Perform a Clean Data Cache Range operation (Where Applicable)}
begin
 {}
 if Assigned(CleanDataCacheRangeHandler) then
  begin
   CleanDataCacheRangeHandler(address,size);
  end;
end;

{==============================================================================}

procedure invalidate_data_cache_range(address: SIZE_T; size: uint32_t); stdcall;
{Perform an Invalidate Data Cache Range operation (Where Applicable)}
begin
 {}
 if Assigned(InvalidateDataCacheRangeHandler) then
  begin
   InvalidateDataCacheRangeHandler(address,size);
  end;
end;

{==============================================================================}

procedure clean_and_invalidate_data_cache_range(address: SIZE_T; size: uint32_t); stdcall;
{Perform a Clean and Invalidate Data Cache Range operation (Where Applicable)}
begin
 {}
 if Assigned(CleanAndInvalidateDataCacheRangeHandler) then
  begin
   CleanAndInvalidateDataCacheRangeHandler(address,size);
  end;
end;

{==============================================================================}

procedure invalidate_instruction_cache_range(address: SIZE_T; size: uint32_t); stdcall;
{Perform an Invalidate Instruction Cache Range operation (Where Applicable)}
begin
 {}
 if Assigned(InvalidateInstructionCacheRangeHandler) then
  begin
   InvalidateInstructionCacheRangeHandler(address,size);
  end;
end;

{==============================================================================}

procedure flush_prefetch_buffer; stdcall;
{Perform a Flush Prefetch Buffer operation (Where Applicable)}
begin
 {}
 if Assigned(FlushPrefetchBufferHandler) then
  begin
   FlushPrefetchBufferHandler;
  end;
end;

{==============================================================================}

procedure flush_branch_target_cache; stdcall;
{Perform a Flush Entire Branch Target Cache operation (Where Applicable)}
begin
 {}
 if Assigned(FlushBranchTargetCacheHandler) then
  begin
   FlushBranchTargetCacheHandler;
  end;
end;

{==============================================================================}

procedure context_switch(oldstack, newstack: PVOID; newthread: TTHREADHANDLE); stdcall;
{Perform a Context Switch from one thread to another}
begin
 {}
 if Assigned(ContextSwitchHandler) then
  begin
   ContextSwitchHandler(oldstack,newstack,newthread);
  end;
end;

{==============================================================================}

procedure context_switch_irq(oldstack, newstack: PVOID; newthread: TTHREADHANDLE); stdcall;
{Perform a Context Switch from one thread to another from an IRQ handler}
begin
 {}
 if Assigned(ContextSwitchIRQHandler) then
  begin
   ContextSwitchIRQHandler(oldstack,newstack,newthread);
  end;
end;

{==============================================================================}

procedure context_switch_fiq(oldstack, newstack: PVOID; newthread: TTHREADHANDLE); stdcall;
{Perform a Context Switch from one thread to another from an FIQ handler}
begin
 {}
 if Assigned(ContextSwitchFIQHandler) then
  begin
   ContextSwitchFIQHandler(oldstack,newstack,newthread);
  end;
end;

{==============================================================================}

procedure context_switch_swi(oldstack, newstack: PVOID; newthread: TTHREADHANDLE); stdcall;
{Perform a Context Switch from one thread to another from a software interrupt handler}
begin
 {}
 if Assigned(ContextSwitchSWIHandler) then
  begin
   ContextSwitchSWIHandler(oldstack,newstack,newthread);
  end;
end;

{==============================================================================}

function interlocked_or(var target: int32_t; value: int32_t): int32_t; stdcall;
{Perform an atomic OR operation}
begin
 {}
 if Assigned(InterlockedOrHandler) then
  begin
   Result:=InterlockedOrHandler(target,value);
  end
 else
  begin
   Result:=Target;
  end;
end;

{==============================================================================}

function interlocked_xor(var target: int32_t; value: int32_t): int32_t; stdcall;
{Perform an atomic XOR operation}
begin
 {}
 if Assigned(InterlockedXorHandler) then
  begin
   Result:=InterlockedXorHandler(target,value);
  end
 else
  begin
   Result:=Target;
  end;
end;

{==============================================================================}

function interlocked_and(var target: int32_t; value: int32_t): int32_t; stdcall;
{Perform an atomic AND operation}
begin
 {}
 if Assigned(InterlockedAndHandler) then
  begin
   Result:=InterlockedAndHandler(target,value);
  end
 else
  begin
   Result:=Target;
  end;
end;

{==============================================================================}

function interlocked_decrement(var target: int32_t): int32_t; stdcall;
{Perform an atomic decrement operation}
begin
 {}
 if Assigned(InterlockedDecrementHandler) then
  begin
   Result:=InterlockedDecrementHandler(target);
  end
 else
  begin
   Result:=Target;
  end;
end;

{==============================================================================}

function interlocked_increment(var target: int32_t): int32_t; stdcall;
{Perform an atomic increment operation}
begin
 {}
 if Assigned(InterlockedIncrementHandler) then
  begin
   Result:=InterlockedIncrementHandler(target);
  end
 else
  begin
   Result:=Target;
  end;
end;

{==============================================================================}

function interlocked_exchange(var target: int32_t; source: int32_t): int32_t; stdcall;
{Perform an atomic exchange operation}
begin
 {}
 if Assigned(InterlockedExchangeHandler) then
  begin
   Result:=InterlockedExchangeHandler(target,source);
  end
 else
  begin
   Result:=Target;
  end;
end;

{==============================================================================}

function interlocked_add_exchange(var target: int32_t; source: int32_t): int32_t; stdcall;
{Perform an atomic add and exchange operation}
begin
 {}
 if Assigned(InterlockedAddExchangeHandler) then
  begin
   Result:=InterlockedAddExchangeHandler(target,source);
  end
 else
  begin
   Result:=Target;
  end;
end;

{==============================================================================}

function interlocked_compare_exchange(var target: int32_t; source, compare: int32_t): int32_t; stdcall;
{Perform an atomic compare and exchange operation}
begin
 {}
 if Assigned(InterlockedCompareExchangeHandler) then
  begin
   Result:=InterlockedCompareExchangeHandler(target,source,compare);
  end
 else
  begin
   Result:=Target;
  end;
end;

{==============================================================================}

function page_table_get_levels: uint32_t; stdcall;
{Get the number of page table levels for the current platform}
begin
 {}
 if Assigned(PageTableGetLevelsHandler) then
  begin
   Result:=PageTableGetLevelsHandler;
  end
 else
  begin
   Result:=PAGE_TABLE_LEVELS;
  end;
end;

{==============================================================================}

function page_directory_get_base: SIZE_T; stdcall;
{Get the base address of the first level page directory (Where applicable)}
begin
 {}
 if Assigned(PageDirectoryGetBaseHandler) then
  begin
   Result:=PageDirectoryGetBaseHandler;
  end
 else
  begin
   Result:=PAGE_DIRECTORY_BASE;
  end;
end;

{==============================================================================}

function page_directory_get_size: uint32_t; stdcall;
{Get the size of the first level page directory (Where applicable)}
begin
 {}
 if Assigned(PageDirectoryGetSizeHandler) then
  begin
   Result:=PageDirectoryGetSizeHandler;
  end
 else
  begin
   Result:=PAGE_DIRECTORY_SIZE;
  end;
end;

{==============================================================================}

function page_table_get_base: SIZE_T; stdcall;
{Get the base address of the first level page table}
begin
 {}
 if Assigned(PageTableGetBaseHandler) then
  begin
   Result:=PageTableGetBaseHandler;
  end
 else
  begin
   Result:=PAGE_TABLE_BASE;
  end;
end;

{==============================================================================}

function page_table_get_size: uint32_t; stdcall;
{Get the size of the first level page table}
begin
 {}
 if Assigned(PageTableGetSizeHandler) then
  begin
   Result:=PageTableGetSizeHandler;
  end
 else
  begin
   Result:=PAGE_TABLE_SIZE;
  end;
end;

{==============================================================================}

procedure page_table_get_entry(address: SIZE_T; var entry: TPAGE_TABLE_ENTRY); stdcall;
{Get the Page Table entry that corresponds to the supplied virtual address}
begin
 {}
 if Assigned(PageTableGetEntryHandler) then
  begin
   PageTableGetEntryHandler(address,entry);
  end
 else
  begin
   FillChar(Entry,SizeOf(TPAGE_TABLE_ENTRY),0);
  end;
end;

{==============================================================================}

function page_table_set_entry(const entry: TPAGE_TABLE_ENTRY): uint32_t; stdcall;
{Set the Page Table entry that corresponds to the supplied virtual address}
begin
 {}
 if Assigned(PageTableSetEntryHandler) then
  begin
   Result:=PageTableSetEntryHandler(entry);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}

function page_table_get_page_size(address: SIZE_T): uint32_t; stdcall;
{Get the Size from the Page Table page that corresponds to the supplied virtual address}
var
 Entry:TPageTableEntry;
begin
 {}
 if Assigned(PageTableGetPageSizeHandler) then
  begin
   Result:=PageTableGetPageSizeHandler(address);
  end
 else
  begin
   {Default Method}
   PageTableGetEntry(address,Entry);

   {Get Page Size}
   Result:=Entry.Size;
  end;
end;

{==============================================================================}

function page_table_get_page_flags(address: SIZE_T): uint32_t; stdcall;
{Get the Flags from the Page Table page that corresponds to the supplied virtual address}
var
 Entry:TPageTableEntry;
begin
 {}
 if Assigned(PageTableGetPageFlagsHandler) then
  begin
   Result:=PageTableGetPageFlagsHandler(address);
  end
 else
  begin
   {Default Method}
   PageTableGetEntry(address,Entry);

   {Get Page Flags}
   Result:=Entry.Flags;
  end;
end;

{==============================================================================}
{$IFDEF CPU32}
function page_table_get_page_range(address: SIZE_T): uint32_t; stdcall;
{Get the Physical Range from the Page Table page that corresponds to the supplied virtual address}
begin
 {}
 Result:=PageTableGetPageRange(address);
end;
{$ENDIF CPU32}
{==============================================================================}

function page_table_get_page_physical(address: SIZE_T): SIZE_T; stdcall;
{Get the Physical Address from the Page Table page that corresponds to the supplied virtual address}
var
 Entry:TPageTableEntry;
begin
 {}
 if Assigned(PageTableGetPagePhysicalHandler) then
  begin
   Result:=PageTableGetPagePhysicalHandler(address);
  end
 else
  begin
   {Default Method}
   PageTableGetEntry(address,Entry);

   {Get Page Physical Address}
   Result:=Entry.PhysicalAddress;
  end;
end;

{==============================================================================}

function page_tables_get_address: SIZE_T; stdcall;
{Get the address of the second level page tables}
begin
 {}
 if Assigned(PageTablesGetAddressHandler) then
  begin
   Result:=PageTablesGetAddressHandler;
  end
 else
  begin
   Result:=PAGE_TABLES_ADDRESS;
  end;
end;

{==============================================================================}

function page_tables_get_length: uint32_t; stdcall;
{Get the size of the second level page tables}
begin
 {}
 if Assigned(PageTablesGetLengthHandler) then
  begin
   Result:=PageTablesGetLengthHandler;
  end
 else
  begin
   Result:=PAGE_TABLES_LENGTH;
  end;
end;

{==============================================================================}

function page_tables_get_count: uint32_t; stdcall;
{Get the number of second level page tables}
begin
 {}
 if Assigned(PageTablesGetCountHandler) then
  begin
   Result:=PageTablesGetCountHandler;
  end
 else
  begin
   Result:=PAGE_TABLES_COUNT;
  end;
end;

{==============================================================================}

function page_tables_get_shift: uint32_t; stdcall;
{Get the multiplier to convert count to actual size of the second level page tables}
begin
 {}
 if Assigned(PageTablesGetShiftHandler) then
  begin
   Result:=PageTablesGetShiftHandler;
  end
 else
  begin
   Result:=PAGE_TABLES_SHIFT;
  end;
end;

{==============================================================================}

function page_tables_get_next: SIZE_T; stdcall;
{Get the address of the next available second level page table}
begin
 {}
 if Assigned(PageTablesGetNextHandler) then
  begin
   Result:=PageTablesGetNextHandler;
  end
 else
  begin
   Result:=PAGE_TABLES_NEXT;
  end;
end;

{==============================================================================}

function page_tables_get_used: uint32_t; stdcall;
{Get the number of used second level page tables}
begin
 {}
 if Assigned(PageTablesGetUsedHandler) then
  begin
   Result:=PageTablesGetUsedHandler;
  end
 else
  begin
   Result:=PAGE_TABLES_USED;
  end;
end;

{==============================================================================}

function page_tables_get_free: uint32_t; stdcall;
{Get the number of available second level page tables}
begin
 {}
 if Assigned(PageTablesGetFreeHandler) then
  begin
   Result:=PageTablesGetFreeHandler;
  end
 else
  begin
   Result:=PAGE_TABLES_FREE;
  end;
end;

{==============================================================================}

function vector_table_get_base: SIZE_T; stdcall;
{Get the base address of the interrupt vector table}
begin
 {}
 if Assigned(VectorTableGetBaseHandler) then
  begin
   Result:=VectorTableGetBaseHandler;
  end
 else
  begin
   Result:=VECTOR_TABLE_BASE;
  end;
end;

{==============================================================================}

function vector_table_get_size: uint32_t; stdcall;
{Get the size in bytes of the interrupt vector table}
begin
 {}
 if Assigned(VectorTableGetSizeHandler) then
  begin
   Result:=VectorTableGetSizeHandler;
  end
 else
  begin
   Result:=VECTOR_TABLE_SIZE;
  end;
end;

{==============================================================================}

function vector_table_get_count: uint32_t; stdcall;
{Get the number of entries in the interrupt vector table}
begin
 {}
 if Assigned(VectorTableGetCountHandler) then
  begin
   Result:=VectorTableGetCountHandler;
  end
 else
  begin
   Result:=VECTOR_TABLE_COUNT;
  end;
end;

{==============================================================================}

function vector_table_get_entry(number: uint32_t): SIZE_T; stdcall;
{Get the interrupt vector table entry that corresponds to the supplied number}
begin
 {}
 if Assigned(VectorTableGetEntryHandler) then
  begin
   Result:=VectorTableGetEntryHandler(number);
  end
 else
  begin
   Result:=0;
  end;
end;

{==============================================================================}

function vector_table_set_entry(number: uint32_t; address: SIZE_T): uint32_t; stdcall;
{Set the interrupt vector table entry that corresponds to the supplied number}
begin
 {}
 if Assigned(VectorTableSetEntryHandler) then
  begin
   Result:=VectorTableSetEntryHandler(number,address);
  end
 else
  begin
   Result:=ERROR_CALL_NOT_IMPLEMENTED;
  end;
end;

{==============================================================================}
{Console Functions}
function console_get_key(var ch: CHAR; userdata: PVOID): BOOL; stdcall;
begin
 {}
 if Assigned(ConsoleGetKeyHandler) then
  begin
   Result:=ConsoleGetKeyHandler(ch,userdata);
  end
 else
  begin
   ch:=#0;

   Result:=False; {Default False}
  end;
end;

{==============================================================================}

function console_peek_key(var ch: CHAR; userdata: PVOID): BOOL; stdcall;
begin
 {}
 if Assigned(ConsolePeekKeyHandler) then
  begin
   Result:=ConsolePeekKeyHandler(ch,userdata);
  end
 else
  begin
   ch:=#0;

   Result:=False; {Default False}
  end;
end;

{==============================================================================}

function console_write_char(ch: CHAR; userdata: PVOID): BOOL; stdcall;
begin
 {}
 if Assigned(ConsoleWriteCharHandler) then
  begin
   Result:=ConsoleWriteCharHandler(ch,userdata);
  end
 else
  begin
   Result:=True; {Default True}
  end;
end;

{==============================================================================}

function console_read_char(var ch: CHAR; userdata: PVOID): BOOL; stdcall;
begin
 {}
 if Assigned(ConsoleReadCharHandler) then
  begin
   Result:=ConsoleReadCharHandler(ch,userdata);
  end
 else
  begin
   ch:=#0;

   Result:=True; {Default True}
  end;
end;

{==============================================================================}

function console_read_widechar(var ch: WIDECHAR; userdata: PVOID): BOOL; stdcall;
begin
 {}
 if Assigned(ConsoleReadWideCharHandler) then
  begin
   Result:=ConsoleReadWideCharHandler(ch,userdata);
  end
 else
  begin
   ch:=#0;

   Result:=True; {Default True}
  end;
end;

{==============================================================================}

function console_hide_mouse(userdata: PVOID): BOOL; stdcall;
begin
 {}
 if Assigned(ConsoleHideMouseHandler) then
  begin
   Result:=ConsoleHideMouseHandler(userdata);
  end
 else
  begin
   Result:=True; {Default True}
  end;
end;

{==============================================================================}

function console_show_mouse(x, y: uint32_t; userdata: PVOID): BOOL; stdcall;
begin
 {}
 if Assigned(ConsoleShowMouseHandler) then
  begin
   Result:=ConsoleShowMouseHandler(x,y,userdata);
  end
 else
  begin
   Result:=True; {Default True}
  end;
end;

{==============================================================================}

function console_read_mouse(var x, y, buttons: uint32_t; userdata: PVOID): BOOL; stdcall;
begin
 {}
 if Assigned(ConsoleReadMouseHandler) then
  begin
   Result:=ConsoleReadMouseHandler(x,y,buttons, userdata);
  end
 else
  begin
   X:=0;
   Y:=0;
   Buttons:=0;

   Result:=True; {Default True}
  end;
end;

{==============================================================================}
{CodePage Functions}
function codepage_to_widechar(ch: CHAR): WIDECHAR; stdcall;
begin
 {}
 if Assigned(CodePageToWideCharHandler) then
  begin
   Result:=CodePageToWideCharHandler(ch);
  end
 else
  begin
   {Default}
   Word(Result):=Byte(ch);
  end;
end;

{==============================================================================}

function widechar_to_codepage(ch: WIDECHAR): CHAR; stdcall;
begin
 {}
 if Assigned(WideCharToCodePageHandler) then
  begin
   Result:=WideCharToCodePageHandler(ch);
  end
 else
  begin
   {Default}
   Byte(Result):=Word(ch) and $FF;
  end;
end;

{==============================================================================}
{Name Functions}
function host_get_name(name: PCHAR; len: uint32_t): uint32_t; stdcall;
var
 Buffer:String;
begin
 {}
 if Assigned(HostGetNameHandler) then
  begin
   Buffer:=HostGetNameHandler;
  end
 else
  begin
   Buffer:=HOST_NAME;
  end;

 Result:=APIStringToPCharBuffer(Buffer,name,len);
end;

{==============================================================================}

function host_set_name(const name: PCHAR): BOOL; stdcall;
var
 Buffer:String;
begin
 {}
 Buffer:=String(name);

 if Assigned(HostSetNameHandler) then
  begin
   Result:=HostSetNameHandler(Buffer);
  end
 else
  begin
   Result:=False;

   if Length(Buffer) = 0 then Exit;

   HOST_NAME:=Buffer;

   Result:=True;
  end;
end;

{==============================================================================}

function host_get_domain(domain: PCHAR; len: uint32_t): uint32_t; stdcall;
var
 Buffer:String;
begin
 {}
 if Assigned(HostGetDomainHandler) then
  begin
   Buffer:=HostGetDomainHandler;
  end
 else
  begin
   Buffer:=HOST_DOMAIN;
  end;

 Result:=APIStringToPCharBuffer(Buffer,domain,len);
end;

{==============================================================================}

function host_set_domain(const domain: PCHAR): BOOL; stdcall;
var
 Buffer:String;
begin
 {}
 Buffer:=String(domain);

 if Assigned(HostSetDomainHandler) then
  begin
   Result:=HostSetDomainHandler(Buffer);
  end
 else
  begin
   Result:=False;

   if Length(Buffer) = 0 then Exit;

   HOST_DOMAIN:=Buffer;

   Result:=True;
  end;
end;

{==============================================================================}
{Module Functions}
function module_load(const name: PCHAR): THANDLE; stdcall;
begin
 {}
 if Assigned(ModuleLoadHandler) then
  begin
   Result:=ModuleLoadHandler(String(name));
  end
 else
  begin
   Result:=INVALID_HANDLE_VALUE;
  end;
end;

{==============================================================================}

function module_load_ex(const name: PCHAR; flags: uint32_t): THANDLE; stdcall;
begin
 {}
 if Assigned(ModuleLoadExHandler) then
  begin
   Result:=ModuleLoadExHandler(String(name),flags);
  end
 else
  begin
   Result:=INVALID_HANDLE_VALUE;
  end;
end;

{==============================================================================}

function module_unload(handle: THANDLE): BOOL; stdcall;
begin
 {}
 if Assigned(ModuleUnloadHandler) then
  begin
   Result:=ModuleUnloadHandler(handle);
  end
 else
  begin
   Result:=False;
  end;
end;

{==============================================================================}

function module_get_name(handle: THANDLE; name: PCHAR; len: uint32_t): uint32_t; stdcall;
var
 Buffer:String;
begin
 {}
 if Assigned(ModuleGetNameHandler) then
  begin
   Buffer:=ModuleGetNameHandler(handle);
  end
 else
  begin
   Buffer:='';
  end;

 Result:=APIStringToPCharBuffer(Buffer,name,len);
end;

{==============================================================================}
{Symbol Functions}
function symbol_add(handle: THANDLE; const name: PCHAR; address: SIZE_T): BOOL; stdcall;
begin
 {}
 if Assigned(SymbolAddHandler) then
  begin
   Result:=SymbolAddHandler(handle,String(name),address);
  end
 else
  begin
   Result:=False;
  end;
end;

{==============================================================================}

function symbol_remove(handle: THANDLE; const name: PCHAR): BOOL; stdcall;
begin
 {}
 if Assigned(SymbolRemoveHandler) then
  begin
   Result:=SymbolRemoveHandler(handle,String(name));
  end
 else
  begin
   Result:=False;
  end;
end;

{==============================================================================}

function symbol_get_address(handle: THANDLE; const name: PCHAR): SIZE_T; stdcall;
begin
 {}
 if Assigned(SymbolGetAddressHandler) then
  begin
   Result:=SymbolGetAddressHandler(handle,String(name));
  end
 else
  begin
   Result:=PtrUInt(nil);
  end;
end;

{==============================================================================}
{Logging Functions}
procedure logging_output(const text: PCHAR); stdcall;
begin
 {}
 if Assigned(LoggingOutputHandler) then
  begin
   LoggingOutputHandler(String(text));
  end;
end;

{==============================================================================}

procedure logging_output_ex(facility, severity: uint32_t; const tag, content: PCHAR); stdcall;
begin
 {}
 if Assigned(LoggingOutputExHandler) then
  begin
   LoggingOutputExHandler(facility,severity,String(tag),String(content));
  end;
end;

{==============================================================================}
{Environment Functions}
function environment_get(const name: PCHAR; value: PCHAR; len: uint32_t): uint32_t; stdcall;
{Locate an environment variable and return the current value}
{Name: The name of the variable to locate (eg TZ)}
{Return: The value of the variable or an empty string if not found}
begin
 {}
 Result:=APIStringToPCharBuffer(EnvironmentGet(String(name)),value,len);
end;

{==============================================================================}

function environment_set(const name, value: PCHAR): uint32_t; stdcall;
{Add an environment variable or update an existing variable}
{Name: The name of the variable to add or update (eg TZ)}
{Value: The new value of the variable (eg EST+5)}
{Return: ERROR_SUCCESS if the value was set or another error code on failure}

{Note: Passing an empty value will delete the environment variable if it exists}
begin
 {}
 Result:=EnvironmentSet(String(name),String(value));
end;

{==============================================================================}

function environment_count(reset: BOOL): uint32_t; stdcall;
{Get the current number of environment variables}
{Reset: If True then force a recount}
{Return: The number of environment variables}
begin
 {}
 Result:=EnvironmentCount(reset);
end;

{==============================================================================}

function environment_index(const name: PCHAR): uint32_t; stdcall;
{Locate an environment variable and return the index}
{Name: The name of the variable to locate (eg TZ)}
{Return: The index of the environment variable or 0 if not found}
begin
 {}
 Result:=EnvironmentIndex(String(name));
end;

{==============================================================================}

function environment_string(index: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Get an environment variable by index}
{Index: The index of the variable to get (1 to EnvironmentCount)}
{Return: The environment variable or an empty string if index is not valid}
begin
 {}
 Result:=APIStringToPCharBuffer(EnvironmentString(index),_string,len);
end;

{==============================================================================}
{Utility Functions}
function first_bit_set(value: uint32_t): uint32_t; stdcall;
{Find the first set bit in a nonzero 32 bit value}
{Returns 31 for MSB and 0 for LSB (0xFFFFFFFF / -1 if no bits are set)}
begin
 {}
 if Assigned(FirstBitSetHandler) then
  begin
   Result:=FirstBitSetHandler(value);
  end
 else
  begin
   Result:=0; {No default behaviour, a default handler must be registered by Platform}
  end;
end;

{==============================================================================}

function last_bit_set(value: uint32_t): uint32_t; stdcall;
{Find the last set bit in a nonzero 32 bit value}
{Returns 31 for MSB and 0 for LSB (0xFFFFFFFF / -1 if no bits are set)}
{Note: Similar in operation to the ffs() builtin, equivalent to ffs() - 1}
begin
 {}
 if Assigned(LastBitSetHandler) then
  begin
   Result:=LastBitSetHandler(value);
  end
 else
  begin
   Result:=0; {No default behaviour, a default handler must be registered by Platform}
  end;
end;

{==============================================================================}

function count_leading_zeros(value: uint32_t): uint32_t; stdcall;
{Count the number of leading 0 bits in a nonzero 32 bit value}
{Returns 32 if no bits are set}
begin
 {}
 if Assigned(CountLeadingZerosHandler) then
  begin
   Result:=CountLeadingZerosHandler(value);
  end
 else
  begin
   Result:=0; {No default behaviour, a default handler must be registered by Platform}
  end;
end;

{==============================================================================}

function count_trailing_zeros(value: uint32_t): uint32_t; stdcall;
{Count the number of trailing 0 bits in a nonzero 32 bit value}
{Returns 32 if no bits are set}
begin
 {}
 if Assigned(CountTrailingZerosHandler) then
  begin
   Result:=CountTrailingZerosHandler(value);
  end
 else
  begin
   Result:=0; {No default behaviour, a default handler must be registered by Platform}
  end;
end;

{==============================================================================}

function physical_to_ioaddress(address: PVOID): SIZE_T; stdcall;
{Convert Physical address to an IO addresses (Where Applicable)}
begin
 {}
 Result:=(PtrUInt(address) - IO_BASE) + IO_ALIAS;
end;

{==============================================================================}

function ioaddress_to_physical(address: PVOID): SIZE_T; stdcall;
{Convert an IO address to a Physical address (Where Applicable)}
begin
 {}
 Result:=(PtrUInt(address) - IO_ALIAS) + IO_BASE;
end;

{==============================================================================}

function physical_to_busaddress(address: PVOID): SIZE_T; stdcall;
{Convert a Physical address to a Bus address (Where Applicable)}
begin
 {}
 Result:=PtrUInt(address) or BUS_ALIAS;
end;

{==============================================================================}

function busaddress_to_physical(address: PVOID): SIZE_T; stdcall;
{Convert a Bus address to a Physical address (Where Applicable)}
begin
 {}
 Result:=PtrUInt(Address) and not(BUS_ALIAS);
end;

{==============================================================================}

procedure nanosecond_delay(nanoseconds: uint32_t); stdcall;
{Non sleep wait for a number of nanoseconds}
{Nanoseconds: Number of nanoseconds to wait}
begin
 {}
 NanosecondDelay(nanoseconds);
end;

{==============================================================================}

procedure microsecond_delay(microseconds: uint32_t); stdcall;
{Non sleep wait for a number of microseconds}
{Microseconds: Number of microseconds to wait}
begin
 {}
 MicrosecondDelay(microseconds);
end;

{==============================================================================}

procedure millisecond_delay(milliseconds: uint32_t); stdcall;
{Non sleep wait for a number of milliseconds}
{Milliseconds: Number of milliseconds to wait}
begin
 {}
 MillisecondDelay(milliseconds);
end;

{==============================================================================}

procedure nanosecond_delay_ex(nanoseconds: uint32_t; wait: BOOL); stdcall;
{Non sleep wait for a number of nanoseconds}
{Nanoseconds: Number of nanoseconds to wait}
{Wait: Use WaitForEvent on each loop to reduce power consumption}
{Note: Not suitable for use by interrupt handlers if wait is true}
begin
 {}
 NanosecondDelayEx(nanoseconds,wait);
end;

{==============================================================================}

procedure microsecond_delay_ex(microseconds: uint32_t; wait: BOOL); stdcall;
{Non sleep wait for a number of microseconds}
{Microseconds: Number of microseconds to wait}
{Wait: Use WaitForEvent on each loop to reduce power consumption}
{Note: Not suitable for use by interrupt handlers if wait is true}
begin
 {}
 MicrosecondDelayEx(microseconds,wait);
end;

{==============================================================================}

procedure millisecond_delay_ex(milliseconds: uint32_t; wait: BOOL); stdcall;
{Non sleep wait for a number of milliseconds}
{Milliseconds: Number of milliseconds to wait}
{Wait: Use WaitForEvent on each loop to reduce power consumption}
{Note: Not suitable for use by interrupt handlers if wait is true}
begin
 {}
 MillisecondDelayEx(milliseconds,wait);
end;

{==============================================================================}
{RTL Functions}
function get_tick_count:uint32_t; stdcall;
begin
 {}
 if CLOCK_CYCLES_PER_MILLISECOND > 0 then
  begin
   Result:=ClockGetCount div CLOCK_CYCLES_PER_MILLISECOND;
  end
 else
  begin
   Result:=ClockGetCount;
  end;
end;

{==============================================================================}

function get_tick_count64:uint64_t; stdcall;
begin
 {}
 if CLOCK_CYCLES_PER_MILLISECOND > 0 then
  begin
   Result:=ClockGetTotal div CLOCK_CYCLES_PER_MILLISECOND;
  end
 else
  begin
   Result:=ClockGetTotal;
  end;
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{Threads Functions}
{$IFDEF API_EXPORT_THREADS}
{Spin Functions}
function spin_create: SPIN_HANDLE; stdcall;
{Create and insert a new Spin entry}
{Return: Handle of new Spin entry or INVALID_HANDLE_VALUE if entry could not be created}
begin
 {}
 Result:=SpinCreateEx(False);
end;

{==============================================================================}

function spin_create_ex(initialowner: BOOL): SPIN_HANDLE; stdcall;
{Create and insert a new Spin entry}
{InitialOwner: If true set the state of the spin to locked and the owner to the current thread}
{Return: Handle of new Spin entry or INVALID_HANDLE_VALUE if entry could not be created}
begin
 {}
 Result:=SpinCreateEx(initialowner);
end;

{==============================================================================}

function spin_destroy(spin: SPIN_HANDLE): uint32_t; stdcall;
{Destroy and remove an existing Spin entry}
{Spin: Handle of Spin entry to destroy}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SpinDestroy(spin);
end;

{==============================================================================}

function spin_owner(spin: SPIN_HANDLE): THREAD_HANDLE; stdcall;
{Get the current owner of an existing Spin entry}
{Spin: Handle of Spin entry to get owner for}
{Return: Handle of owning thread or INVALID_HANDLE_VALUE if not currently owned}
begin
 {}
 Result:=SpinOwner(spin);
end;

{==============================================================================}

function spin_lock(spin: SPIN_HANDLE): uint32_t; stdcall;
{Lock an existing Spin entry}
{Spin: Handle of Spin entry to lock}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SpinLock(spin);
end;

{==============================================================================}

function spin_unlock(spin: SPIN_HANDLE): uint32_t; stdcall;
{Unlock an existing Spin entry}
{Spin: Handle of Spin entry to unlock}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SpinUnlock(spin);
end;

{==============================================================================}

function spin_lock_irq(spin: SPIN_HANDLE): uint32_t; stdcall;
{Lock an existing Spin entry, disable IRQ and save the previous IRQ state}
{Spin: Handle of Spin entry to lock}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SpinLockIRQ(spin);
end;

{==============================================================================}

function spin_unlock_irq(spin: SPIN_HANDLE): uint32_t; stdcall;
{Unlock an existing Spin entry and restore the previous IRQ state}
{Spin: Handle of Spin entry to unlock}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SpinUnlockIRQ(spin);
end;

{==============================================================================}

function spin_lock_fiq(spin: SPIN_HANDLE): uint32_t; stdcall;
{Lock an existing Spin entry, disable FIQ and save the previous FIQ state}
{Spin: Handle of Spin entry to lock}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SpinLockFIQ(spin);
end;

{==============================================================================}

function spin_unlock_fiq(spin: SPIN_HANDLE): uint32_t; stdcall;
{Unlock an existing Spin entry and restore the previous FIQ state}
{Spin: Handle of Spin entry to unlock}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SpinUnlockFIQ(spin);
end;

{==============================================================================}

function spin_lock_irq_fiq(spin: SPIN_HANDLE): uint32_t; stdcall;
{Lock an existing Spin entry, disable IRQ and FIQ and save the previous IRQ and FIQ state}
{Spin: Handle of Spin entry to lock}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SpinLockIRQFIQ(spin);
end;

{==============================================================================}

function spin_unlock_irq_fiq(spin: SPIN_HANDLE): uint32_t; stdcall;
{Unlock an existing Spin entry and restore the previous IRQ and FIQ state}
{Spin: Handle of Spin entry to unlock}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SpinUnlockIRQFIQ(spin);
end;

{==============================================================================}

function spin_lock_preempt(spin: SPIN_HANDLE): uint32_t; stdcall;
{Lock an existing Spin entry, disable IRQ or IRQ/FIQ and save the previous IRQ or IRQ/FIQ state}
{Spin: Handle of Spin entry to lock}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: This is a convenience wrapper which determines the appropriate SpinLock call to disable preemption}
begin
 {}
 Result:=SpinLockPreempt(spin);
end;

{==============================================================================}

function spin_unlock_preempt(spin: SPIN_HANDLE): uint32_t; stdcall;
{Unlock an existing Spin entry and restore the previous IRQ or IRQ/FIQ state}
{Spin: Handle of Spin entry to unlock}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: This is a convenience wrapper which determines the appropriate SpinUnlock call to enable preemption}
begin
 {}
 Result:=SpinUnlockPreempt(spin);
end;

{==============================================================================}

function spin_check_irq(spin: SPIN_HANDLE): BOOL; stdcall;
{Check the mask that stores the previous IRQ state to determine if IRQ is enabled}
{Spin: Handle of Spin entry to check}
{Return: True if the mask would enable IRQ on restore, False if it would not}
{Note: The Spin entry must be locked by the current thread}
begin
 {}
 Result:=SpinCheckIRQ(spin);
end;

{==============================================================================}

function spin_check_fiq(spin: SPIN_HANDLE): BOOL; stdcall;
{Check the mask that stores the previous FIQ state to determine if FIQ is enabled}
{Spin: Handle of Spin entry to check}
{Return: True if the mask would enable FIQ on restore, False if it would not}
{Note: The Spin entry must be locked by the current thread}
begin
 {}
 Result:=SpinCheckFIQ(spin);
end;

{==============================================================================}

function spin_exchange_irq(spin1, spin2: SPIN_HANDLE): uint32_t; stdcall;
{Exchange the previous IRQ state between two Spin entries}
{Spin1: Handle of first Spin entry}
{Spin2: Handle of second Spin entry}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Both Spin entries must be locked by the current thread}
begin
 {}
 Result:=SpinExchangeIRQ(spin1,spin2);
end;

{==============================================================================}

function spin_exchange_fiq(spin1, spin2: SPIN_HANDLE): uint32_t; stdcall;
{Exchange the previous FIQ state between two Spin entries}
{Spin1: Handle of first Spin entry}
{Spin2: Handle of second Spin entry}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Both Spin entries must be locked by the current thread}
begin
 {}
 Result:=SpinExchangeFIQ(spin1,spin2);
end;

{==============================================================================}
{Mutex Functions}
function mutex_create: MUTEX_HANDLE; stdcall;
{Create and insert a new Mutex entry}
{Return: Handle of new Mutex entry or INVALID_HANDLE_VALUE if entry could not be created}
begin
 {}
 Result:=MutexCreateEx(False,MUTEX_DEFAULT_SPINCOUNT,MUTEX_FLAG_NONE);
end;

{==============================================================================}

function mutex_create_ex(initialowner: BOOL; spincount: uint32_t; flags: uint32_t): MUTEX_HANDLE; stdcall;
{Create and insert a new Mutex entry}
{InitialOwner: If true set the state of the mutex to locked and the owner to the current thread}
{SpinCount: The number of times the mutex will spin before yielding (Always 0 if CPU count equals 1)}
{Flags: The flags for the Mutex entry (eg MUTEX_FLAG_RECURSIVE)}
{Return: Handle of new Mutex entry or INVALID_HANDLE_VALUE if entry could not be created}
begin
 {}
 Result:=MutexCreateEx(initialowner,spincount,flags);
end;

{==============================================================================}

function mutex_destroy(mutex: MUTEX_HANDLE): uint32_t; stdcall;
{Destroy and remove an existing Mutex entry}
{Mutex: Handle of Mutex entry to destroy}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=MutexDestroy(mutex);
end;

{==============================================================================}

function mutex_flags(mutex: MUTEX_HANDLE): uint32_t; stdcall;
{Get the current flags of an existing Mutex entry}
{Mutex: Handle of Mutex entry to get flags for}
{Return: Current flags or INVALID_HANDLE_VALUE on error}
begin
 {}
 Result:=MutexFlags(mutex);
end;

{==============================================================================}

function mutex_count(mutex: MUTEX_HANDLE): uint32_t; stdcall;
{Get the current lock count of an existing Mutex entry}
{Mutex: Mutex to get count for}
{Return: Current lock count or INVALID_HANDLE_VALUE on error}
{Note: Count is only valid if Flags includes MUTEX_FLAG_RECURSIVE}
begin
 {}
 Result:=MutexCount(mutex);
end;

{==============================================================================}

function mutex_owner(mutex: MUTEX_HANDLE): THREAD_HANDLE; stdcall;
{Get the current owner of an existing Mutex entry}
{Mutex: Handle of Mutex entry to get owner for}
{Return: Handle of owning thread or INVALID_HANDLE_VALUE if not currently owned}
begin
 {}
 Result:=MutexOwner(mutex);
end;

{==============================================================================}

function mutex_lock(mutex: MUTEX_HANDLE): uint32_t; stdcall;
{Lock an existing Mutex entry}
{Mutex: Handle of Mutex entry to lock}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=MutexLock(mutex);
end;

{==============================================================================}

function mutex_unlock(mutex: MUTEX_HANDLE): uint32_t; stdcall;
{Unlock an existing Mutex entry}
{Mutex: Handle of Mutex entry to unlock}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=MutexUnlock(mutex);
end;

{==============================================================================}

function mutex_try_lock(mutex: MUTEX_HANDLE): uint32_t; stdcall;
{Try to lock an existing Mutex entry

 If the Mutex is not locked then lock it and mark the owner as the current thread

 If the Mutex is already locked then return immediately with an error and do not
 wait for it to be unlocked}
{Mutex: Mutex to try to lock}
{Return: ERROR_SUCCESS if completed, ERROR_LOCKED if already locked or another error code on failure}
begin
 {}
 Result:=MutexTryLock(mutex);
end;

{==============================================================================}
{Critical Section Functions}
function critical_section_create: CRITICAL_SECTION_HANDLE; stdcall;
{Create and insert a new CriticalSection entry}
{Return: Handle of new CriticalSection entry or INVALID_HANDLE_VALUE if entry could not be created}
begin
 {}
 Result:=CriticalSectionCreateEx(False,CRITICAL_SECTION_DEFAULT_SPINCOUNT);
end;

{==============================================================================}

function critical_section_create_ex(initialowner: BOOL; spincount: uint32_t): CRITICAL_SECTION_HANDLE; stdcall;
{Create and insert a new CriticalSection entry}
{InitialOwner: If true set the state of the criticalsection to locked and the owner to the current thread}
{SpinCount: The number of times the criticalsection will spin before waiting (Always 0 if CPU count equals 1)}
{Return: Handle of new CriticalSection entry or INVALID_HANDLE_VALUE if entry could not be created}
begin
 {}
 Result:=CriticalSectionCreateEx(initialowner,spincount);
end;

{==============================================================================}

function critical_section_destroy(criticalsection: CRITICAL_SECTION_HANDLE): uint32_t; stdcall;
{Destroy and remove an existing CriticalSection entry}
{CriticalSection: Handle of CriticalSection entry to destroy}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=CriticalSectionDestroy(criticalsection);
end;

{==============================================================================}

function critical_section_count(criticalsection: CRITICAL_SECTION_HANDLE): uint32_t; stdcall;
{Get the current lock count of an existing CriticalSection entry}
{CriticalSection: CriticalSection to get count for}
{Return: Current lock count or INVALID_HANDLE_VALUE on error}
begin
 {}
 Result:=CriticalSectionCount(criticalsection);
end;

{==============================================================================}

function critical_section_owner(criticalsection: CRITICAL_SECTION_HANDLE): THREAD_HANDLE; stdcall;
{Get the current owner of an existing CriticalSection entry}
{CriticalSection: CriticalSection to get owner for}
{Return: Handle of owning thread or INVALID_HANDLE_VALUE if not currently owned}
begin
 {}
 Result:=CriticalSectionOwner(criticalsection);
end;

{==============================================================================}

function critical_section_set_spin_count(criticalsection: CRITICAL_SECTION_HANDLE; spincount: uint32_t): uint32_t; stdcall;
{Set the spin count of an existing CriticalSection entry}
{CriticalSection: CriticalSection to set spin count for}
{SpinCount: The spin count value to set}
{Return: Current spin count or INVALID_HANDLE_VALUE on error}
begin
 {}
 Result:=CriticalSectionSetSpinCount(criticalsection,spincount);
end;

{==============================================================================}

function critical_section_lock(criticalsection: CRITICAL_SECTION_HANDLE): uint32_t; stdcall;
{Lock an existing CriticalSection entry

 If the CriticalSection is not locked then lock it, set the count to one and
 mark the owner as the current thread

 If the CriticalSection is already locked by the current thread then increment
 the count and return immediately

 If the CriticalSection is already locked by another thread then wait until it
 is unlocked}
{CriticalSection: CriticalSection to lock}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=CriticalSectionLock(criticalsection);
end;

{==============================================================================}

function critical_section_lock_ex(criticalsection: CRITICAL_SECTION_HANDLE; timeout: uint32_t): uint32_t; stdcall;
{Lock an existing CriticalSection entry

 If the CriticalSection is not locked then lock it, set the count to one and
 mark the owner as the current thread

 If the CriticalSection is already locked by the current thread then increment
 the count and return immediately

 If the CriticalSection is already locked by another thread then wait until it
 is unlocked}
{CriticalSection: CriticalSection to lock}
{Timeout: Milliseconds to wait before timeout (0 equals do not wait, INFINITE equals wait forever)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=CriticalSectionLockEx(criticalsection,timeout);
end;

{==============================================================================}

function critical_section_unlock(criticalsection: CRITICAL_SECTION_HANDLE): uint32_t; stdcall;
{Unlock an existing CriticalSection entry

 If the CriticalSection is locked by the current thread then decrement the count

 If the count is greater than zero then return immediately

 If the count reaches zero then unlock the CriticalSection and release the first
 thread waiting for it to be unlocked

 If the CriticalSection is locked by another thread then return an error

 If the CriticalSection is not locked then return an error}
{CriticalSection: CriticalSection to unlock}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=CriticalSectionUnlock(criticalsection);
end;

{==============================================================================}

function critical_section_try_lock(criticalsection: CRITICAL_SECTION_HANDLE): uint32_t; stdcall;
{Try to lock an existing CriticalSection entry

 If the CriticalSection is not locked then lock it, set the count to one and
 mark the owner as the current thread

 If the CriticalSection is already locked by the current thread then increment
 the count and return immediately

 If the CriticalSection is already locked by another thread then return immediately
 with an error and do not wait for it to be unlocked}
{CriticalSection: CriticalSection to try to lock}
{Return: ERROR_SUCCESS if completed, ERROR_LOCKED if locked by another thread or another error code on failure}
begin
 {}
 Result:=CriticalSectionTryLock(criticalsection);
end;

{==============================================================================}
{Semaphore Functions}
function semaphore_create(count: uint32_t): SEMAPHORE_HANDLE; stdcall;
{Create and insert a new Semaphore entry}
{Count: The initial count of the Semaphore (Must be greater than or equal to zero)}
{Return: Handle of new Semaphore entry or INVALID_HANDLE_VALUE if entry could not be created}
begin
 {}
 Result:=SemaphoreCreateEx(count,SEMAPHORE_DEFAULT_MAXIMUM,SEMAPHORE_FLAG_NONE);
end;

{==============================================================================}

function semaphore_create_ex(count, maximum: uint32_t; flags: uint32_t): SEMAPHORE_HANDLE; stdcall;
{Create and insert a new Semaphore entry}
{Count: The initial count of the Semaphore (Must be greater than or equal to zero)}
{Maximum: The maximum count of the Semaphore (Must be greater than one)}
{Flags: The flags for the Semaphore entry (eg SEMAPHORE_FLAG_IRQ)}
{Return: Handle of new Semaphore entry or INVALID_HANDLE_VALUE if entry could not be created}
begin
 {}
 Result:=SemaphoreCreateEx(count,maximum,flags);
end;

{==============================================================================}

function semaphore_destroy(semaphore: SEMAPHORE_HANDLE): uint32_t; stdcall;
{Destroy and remove an existing Semaphore entry}
{Semaphore: Handle of Semaphore entry to destroy}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SemaphoreDestroy(semaphore);
end;

{==============================================================================}

function semaphore_count(semaphore: SEMAPHORE_HANDLE): uint32_t; stdcall;
{Get the current count of an existing Semaphore entry}
{Semaphore: Semaphore to get count for}
{Return: Current count or INVALID_HANDLE_VALUE on error}
begin
 {}
 Result:=SemaphoreCount(semaphore);
end;

{==============================================================================}

function semaphore_wait(semaphore: SEMAPHORE_HANDLE): uint32_t; stdcall;
{Wait on an existing Semaphore entry

 If the Semaphore count is greater than zero it will be decremented
 and this function will return immediately

 If the Semaphore count is zero the current thread will be put on a wait queue
 until the Semaphore is signalled by another thread calling SemaphoreSignal()
 or SemaphoreSignalEx()}
{Semaphore: Semaphore to wait on}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SemaphoreWait(semaphore);
end;

{==============================================================================}

function semaphore_wait_ex(semaphore: SEMAPHORE_HANDLE; timeout: uint32_t): uint32_t; stdcall;
{Wait on an existing Semaphore entry

 If the Semaphore count is greater than zero it will be decremented
 and this function will return immediately

 If the Semaphore count is zero the current thread will be put on a wait queue
 until the Semaphore is signalled by another thread calling SemaphoreSignal()
 or SemaphoreSignalEx()}
{Semaphore: Semaphore to wait on}
{Timeout: Milliseconds to wait before timeout (0 equals do not wait, INFINITE equals wait forever)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SemaphoreWaitEx(semaphore,timeout);
end;

{==============================================================================}

function semaphore_signal(semaphore: SEMAPHORE_HANDLE): uint32_t; stdcall;
{Signal an existing Semaphore entry

 If any threads are waiting on the Semaphore then one thread will be woken up and
 placed on the ready queue

 If no threads are waiting then the Semaphore count will be incremented by one}
{Semaphore: Semaphore to signal}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SemaphoreSignalEx(semaphore,1,nil);
end;

{==============================================================================}

function semaphore_signal_ex(semaphore: SEMAPHORE_HANDLE; count: uint32_t; previous: Puint32_t): uint32_t; stdcall;
{Signal an existing Semaphore entry one or more times

 If any threads are waiting on the Semaphore then one thread will be woken up and
 placed on the ready queue for each iteration of the count passed

 If no threads are waiting then the Semaphore count will be incremented once for each
 iteration of the count passed}
{Semaphore: Semaphore to signal}
{Count: The number is times to signal the Semaphore, must be greater than zero}
{Previous: A pointer to a value that receives the previous count of the Semaphore
           Can be nil if the previous count is not required}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SemaphoreSignalEx(semaphore,count,previous);
end;

{==============================================================================}
{Synchronizer Functions}
function synchronizer_create: SYNCHRONIZER_HANDLE; stdcall;
{Create and insert a new Synchronizer entry}
{Return: Handle of new Synchronizer entry or INVALID_HANDLE_VALUE if entry could not be created}
begin
 {}
 Result:=SynchronizerCreateEx(False,False);
end;

{==============================================================================}

function synchronizer_create_ex(initialreader, initialwriter: BOOL): SYNCHRONIZER_HANDLE; stdcall;
{Create and insert a new Synchronizer entry}
{InitialReader: If true set the state of the synchronizer to locked and the reader count to 1}
{InitialWriter: If true set the state of the synchronizer to locked and the writer owner to the current thread}
{Return: Handle of new Synchronizer entry or INVALID_HANDLE_VALUE if entry could not be created}
begin
 {}
 Result:=SynchronizerCreateEx(initialreader,initialwriter);
end;

{==============================================================================}

function synchronizer_destroy(synchronizer: SYNCHRONIZER_HANDLE): uint32_t; stdcall;
{Destroy and remove an existing Synchronizer entry}
{Synchronizer: Handle of Synchronizer entry to destroy}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SynchronizerDestroy(synchronizer);
end;

{==============================================================================}

function synchronizer_reader_count(synchronizer: SYNCHRONIZER_HANDLE): uint32_t; stdcall;
{Get the current reader count of an existing Synchronizer entry}
{Synchronizer: Synchronizer to get count for}
{Return: Current reader count or INVALID_HANDLE_VALUE on error}
begin
 {}
 Result:=SynchronizerReaderCount(synchronizer);
end;

{==============================================================================}

function synchronizer_reader_last(synchronizer: SYNCHRONIZER_HANDLE): THREAD_HANDLE; stdcall;
{Get the last reader thread of an existing Synchronizer entry}
{Synchronizer: Synchronizer to last reader for}
{Return: Last reader thread or INVALID_HANDLE_VALUE on error}
begin
 {}
 Result:=SynchronizerReaderLast(synchronizer);
end;

{==============================================================================}

function synchronizer_reader_lock(synchronizer: SYNCHRONIZER_HANDLE): uint32_t; stdcall;
{Lock an existing Synchronizer entry for reading

 If the Synchronizer is not locked then lock it and set the reader count to one

 If the Synchronizer is already locked for reading then increment the reader count
 and return immediately

 If the Synchronizer is already locked for writing then wait until it is unlocked}
{Synchronizer: Synchronizer to lock}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SynchronizerReaderLock(synchronizer);
end;

{==============================================================================}

function synchronizer_reader_lock_ex(synchronizer: SYNCHRONIZER_HANDLE; timeout: uint32_t): uint32_t; stdcall;
{Lock an existing Synchronizer entry for reading

 If the Synchronizer is not locked then lock it and set the reader count to one

 If the Synchronizer is already locked for reading then increment the reader count
 and return immediately

 If the Synchronizer is already locked for writing then wait until it is unlocked}
{Synchronizer: Synchronizer to lock}
{Timeout: Milliseconds to wait before timeout (0 equals do not wait, INFINITE equals wait forever)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SynchronizerReaderLockEx(synchronizer,timeout);
end;

{==============================================================================}

function synchronizer_reader_unlock(synchronizer: SYNCHRONIZER_HANDLE): uint32_t; stdcall;
{Unlock an existing Synchronizer entry

 If the Synchronizer is locked for reading then decrement the count

 If the count is greater than zero then return immediately

 If the count reaches zero then unlock the Synchronizer and release the first
 writer thread waiting for it to be unlocked

 If the Synchronizer is locked for writing then return an error

 If the Synchronizer is not locked then return an error}
{Synchronizer: Synchronizer to unlock}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SynchronizerReaderUnlock(synchronizer);
end;

{==============================================================================}

function synchronizer_reader_convert(synchronizer: SYNCHRONIZER_HANDLE): uint32_t; stdcall;
{Convert a reader lock on an existing Synchronizer entry to a writer lock

 If the Synchronizer is locked for reading then decrement the count

 If the count is greater than zero then wait to acquire the writer lock

 If the count reaches zero then convert to writer lock with the current
 thread as the owner

 If the Synchronizer is locked for writing then return an error

 If the Synchronizer is not locked then return an error}
{Synchronizer: Synchronizer to convert}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Since reader locks are recursive but do not maintain reader thread ownership,
 caller must ensure that one and only one reader lock is held by the current thread}
begin
 {}
 Result:=SynchronizerReaderConvert(synchronizer);
end;

{==============================================================================}

function synchronizer_reader_convert_ex(synchronizer: SYNCHRONIZER_HANDLE; timeout: uint32_t): uint32_t; stdcall;
{Convert a reader lock on an existing Synchronizer entry to a writer lock

 If the Synchronizer is locked for reading then decrement the count

 If the count is greater than zero then wait to acquire the writer lock

 If the count reaches zero then convert to writer lock with the current
 thread as the owner

 If the Synchronizer is locked for writing then return an error

 If the Synchronizer is not locked then return an error}
{Synchronizer: Synchronizer to convert}
{Timeout: Milliseconds to wait before timeout (0 equals do not wait, INFINITE equals wait forever)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Since reader locks are recursive but do not maintain reader thread ownership,
 caller must ensure that one and only one reader lock is held by the current thread}
begin
 {}
 Result:=SynchronizerReaderConvertEx(synchronizer,timeout);
end;

{==============================================================================}

function synchronizer_writer_count(synchronizer: SYNCHRONIZER_HANDLE): uint32_t; stdcall;
{Get the current writer count of an existing Synchronizer entry}
{Synchronizer: Synchronizer to get count for}
{Return: Current writer count or INVALID_HANDLE_VALUE on error}
begin
 {}
 Result:=SynchronizerWriterCount(synchronizer);
end;

{==============================================================================}

function synchronizer_writer_owner(synchronizer: SYNCHRONIZER_HANDLE): THREAD_HANDLE; stdcall;
{Get the current writer owner of an existing Synchronizer entry}
{Synchronizer: Synchronizer to get owner for}
{Return: Handle of owning thread or INVALID_HANDLE_VALUE if not currently owned}
begin
 {}
 Result:=SynchronizerWriterOwner(synchronizer);
end;

{==============================================================================}

function synchronizer_writer_lock(synchronizer: SYNCHRONIZER_HANDLE): uint32_t; stdcall;
{Lock an existing Synchronizer entry for writing

 If the Synchronizer is not locked then lock it, set the writer count to one
 and mark the owner as the current thread

 If the Synchronizer is already locked by the current thread then increment
 the writer count and return immediately

 If the Synchronizer is already locked for reading then wait until it is unlocked}
{Synchronizer: Synchronizer to lock}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SynchronizerWriterLock(synchronizer);
end;

{==============================================================================}

function synchronizer_writer_lock_ex(synchronizer: SYNCHRONIZER_HANDLE; timeout: uint32_t): uint32_t; stdcall;
{Lock an existing Synchronizer entry for writing

 If the Synchronizer is not locked then lock it, set the writer count to one
 and mark the owner as the current thread

 If the Synchronizer is already locked by the current thread then increment
 the writer count and return immediately

 If the Synchronizer is already locked for reading then wait until it is unlocked}
{Synchronizer: Synchronizer to lock}
{Timeout: Milliseconds to wait before timeout (0 equals do not wait, INFINITE equals wait forever)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SynchronizerWriterLockEx(synchronizer,timeout);
end;

{==============================================================================}

function synchronizer_writer_unlock(synchronizer: SYNCHRONIZER_HANDLE): uint32_t; stdcall;
{Unlock an existing Synchronizer entry

 If the Synchronizer is locked for writing by the current thread then decrement the count

 If the count is greater than zero then return immediately

 If the count reaches zero then unlock the Synchronizer and release all reader threads
 waiting for it to be unlocked or the first writer thread waiting for it to be unlocked

 If the Synchronizer is locked for reading then return an error

 If the Synchronizer is locked for writing by another thread then return an error

 If the Synchronizer is not locked then return an error}
{Synchronizer: Synchronizer to unlock}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SynchronizerWriterUnlock(synchronizer);
end;

{==============================================================================}

function synchronizer_writer_convert(synchronizer: SYNCHRONIZER_HANDLE): uint32_t; stdcall;
{Convert a writer lock on an existing Synchronizer entry to a reader lock

 If the Synchronizer is locked for writing by the current thread and the count
 is one then decrement the count

 If the count is greater than one then return an error

 If the count reaches zero then convert to reader lock and release all waiting
 reader threads

 If the Synchronizer is locked for reading then return an error

 If the Synchronizer is not locked then return an error}
{Synchronizer: Synchronizer to convert}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Since writer locks are recursive, caller must ensure that one and only
 one writer lock is held by the current thread}
begin
 {}
 Result:=SynchronizerWriterConvert(synchronizer);
end;

{==============================================================================}
{Condition Functions}
function condition_create: CONDITION_HANDLE; stdcall;
{Create and insert a new Condition entry}
{Return: Handle of new Condition entry or INVALID_HANDLE_VALUE if entry could not be created}
begin
 {}
 Result:=ConditionCreate;
end;

{==============================================================================}

function condition_destroy(condition: CONDITION_HANDLE): uint32_t; stdcall;
{Destroy and remove an existing Condition entry}
{Condition: Handle of Condition entry to destroy}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConditionDestroy(condition);
end;

{==============================================================================}

function condition_wait(condition: CONDITION_HANDLE; timeout: uint32_t): uint32_t; stdcall;
{Wait on an existing Condition}
{Condition: Condition to wait on}
{Timeout: Time in milliseconds to wait to be woken
          0 = No Wait
          INFINITE = Wait Indefinitely}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConditionWait(condition,timeout);
end;

{==============================================================================}

function condition_wait_mutex(condition: CONDITION_HANDLE; mutex: MUTEX_HANDLE; timeout: uint32_t): uint32_t; stdcall;
{Release a Mutex and Wait on an existing Condition in an atomic operation}
{Condition: Condition to wait on}
{Mutex: Mutex to release}
{Timeout: Time in milliseconds to wait to be woken
          0 = No Wait
          INFINITE = Wait Indefinitely}
{Return: ERROR_SUCCESS if completed or another error code on failure.
         Before returning (with either success or failure) the thread will reacquire the Mutex}
{Note: Caller must be the owner of the Mutex with a count of one on entry to this function}
begin
 {}
 Result:=ConditionWaitMutex(condition,mutex,timeout);
end;

{==============================================================================}

function condition_wait_synchronizer(condition: CONDITION_HANDLE; synchronizer: SYNCHRONIZER_HANDLE; flags: uint32_t; timeout: uint32_t): uint32_t; stdcall;
{Release a Synchronizer and Wait on an existing Condition in an atomic operation}
{Condition: Condition to wait on}
{Synchronizer: Synchronizer to release}
{Flags: Flags to indicate reader or writer lock for the Synchronizer (eg CONDITION_LOCK_FLAG_WRITER)}
{Timeout: Time in milliseconds to wait to be woken
          0 = No Wait
          INFINITE = Wait Indefinitely}
{Return: ERROR_SUCCESS if completed or another error code on failure.
         Before returning (with either success or failure) the thread will reacquire the Synchronizer
         for either reading or writing depending on the flags value}
{Note: Caller must be the owner of the Synchronizer with a count of one on entry to this function
       and the ownership must match the flags value provided}
begin
 {}
 Result:=ConditionWaitSynchronizer(condition,synchronizer,flags,timeout);
end;

{==============================================================================}

function condition_wait_critical_section(condition: CONDITION_HANDLE; criticalsection: CRITICAL_SECTION_HANDLE; timeout: uint32_t): uint32_t; stdcall;
{Release a Critical Section and Wait on an existing Condition in an atomic operation}
{Condition: Condition to wait on}
{CriticalSection: Critical Section to release}
{Timeout: Time in milliseconds to wait to be woken
          0 = No Wait
          INFINITE = Wait Indefinitely}
{Return: ERROR_SUCCESS if completed or another error code on failure.
         Before returning (with either success or failure) the thread will reacquire the Synchronizer
         for either reading or writing depending on the flags value}
{Note: Caller must be the owner of the Critical Section with a count of one on entry to this function}
begin
 {}
 Result:=ConditionWaitCriticalSection(condition,criticalsection,timeout);
end;

{==============================================================================}

function condition_wake(condition: CONDITION_HANDLE): uint32_t; stdcall;
{Wake one thread waiting on an existing Condition}
{Condition: Condition to wake}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConditionWake(condition);
end;

{==============================================================================}

function condition_wake_all(condition: CONDITION_HANDLE): uint32_t; stdcall;
{Wake all threads waiting on an existing Condition}
{Condition: Condition to wake}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConditionWakeAll(condition);
end;

{==============================================================================}
{Completion Functions}
function completion_create(flags: uint32_t): COMPLETION_HANDLE; stdcall;
{Create and insert a new Completion entry}
{Flags: The flags for the Completion entry (eg COMPLETION_FLAG_IRQ)}
{Return: Handle of new Completion entry or INVALID_HANDLE_VALUE if entry could not be created}
begin
 {}
 Result:=CompletionCreate(flags);
end;

{==============================================================================}

function completion_destroy(completion: COMPLETION_HANDLE): uint32_t; stdcall;
{Destroy and remove an existing Completion entry}
{Completion: Handle of Completion entry to destroy}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=CompletionDestroy(completion);
end;

{==============================================================================}

function completion_state(completion: COMPLETION_HANDLE): uint32_t; stdcall;
{Get the current state of an existing Completion entry}
{Completion: Completion to get the state for}
{Return: Current state (eg COMPLETION_STATE_COMPLETE) or INVALID_HANDLE_VALUE on error}
begin
 {}
 Result:=CompletionState(completion);
end;

{==============================================================================}

function completion_wait(completion: COMPLETION_HANDLE; timeout: uint32_t): uint32_t; stdcall;
{Wait on an existing Completion

 If the completion is set (complete) then return immediately with success

 If the completion is not set then wait for it to be completed before
 returning

 For counted completions, decrement the count if it is not 0 or -1 after
 testing if the completion is set}
{Completion: Completion to wait on}
{Timeout: Time in milliseconds to wait to be woken
          0 = No Wait
          INFINITE = Wait Indefinitely}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=CompletionWait(completion,timeout);
end;

{==============================================================================}

function completion_try_wait(completion: COMPLETION_HANDLE): uint32_t; stdcall;
{Try an existing Completion to see if it is completed

 If the completion is not set (complete) then return immediately with an error
 and do not wait for it to be completed}
{Completion: Completion to try}
{Return: ERROR_SUCCESS if completed, ERROR_NOT_READY if not completed or another error code on failure}
begin
 {}
 Result:=CompletionTryWait(completion);
end;

{==============================================================================}

function completion_reset(completion: COMPLETION_HANDLE): uint32_t; stdcall;
{Reset (uncomplete) the state of an existing Completion entry

 If the completion is not set then return with no action

 If the completion is set then change the state to not set

 For counted completions, reset the counter to 0}
{Completion: Completion to reset the state for}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=CompletionReset(completion);
end;

{==============================================================================}

function completion_complete(completion: COMPLETION_HANDLE): uint32_t; stdcall;
{Set (complete) the state of an existing Completion entry

 If the completion is already set then return with no action

 If the completion is not set then release one waiting thread (if any)
 and return

 For counted completions, release one waiting thread, if there are no
 waiting threads increment the count if it is not -1 and return}
{Completion: Completion to set the state for}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=CompletionComplete(completion);
end;

{==============================================================================}

function completion_complete_all(completion: COMPLETION_HANDLE): uint32_t; stdcall;
{Set (complete) the state of an existing Completion entry

 If the completion is already set then return with no action

 If the completion is not set then release all waiting threads (if any)
 and return

 For counted completions, set the count to -1, release all waiting threads
 (if any) and return}
{Completion: Completion to set the state for}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=CompletionCompleteAll(completion);
end;

{==============================================================================}
{List Functions}
function list_create: LIST_HANDLE; stdcall;
{Create and insert a new List entry}
{Return: Handle of new List entry or INVALID_HANDLE_VALUE if entry could not be created}
begin
 {}
 Result:=ListCreateEx(LIST_TYPE_NOT_SPECIFIED,LIST_FLAG_NONE);
end;

{==============================================================================}

function list_create_ex(listtype: uint32_t; flags: uint32_t): LIST_HANDLE; stdcall;
{Create and insert a new List entry}
{ListType: Type of list to create (eg LIST_TYPE_WAIT_SEMAPHORE)}
{Flags: Flags for the new list (eg LIST_FLAG_IRQ)}
{Return: Handle of new List entry or INVALID_HANDLE_VALUE if entry could not be created}
begin
 {}
 Result:=ListCreateEx(listtype,flags);
end;

{==============================================================================}

function list_destroy(list: LIST_HANDLE): uint32_t; stdcall;
{Destroy and remove an existing List entry}
{List: Handle of List entry to destroy}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: If list is part of a synchronisation object then caller must hold the lock on the object containing the list}
begin
 {}
 Result:=ListDestroy(list);
end;

{==============================================================================}

function list_count(list: LIST_HANDLE): uint32_t; stdcall;
{Get the current count from the supplied list}
{List: Handle of List entry to get from}
{Return: List count on success or INVALID_HANDLE_VALUE on failure}
begin
 {}
 Result:=ListCount(list);
end;

{==============================================================================}

function list_add_first(list: LIST_HANDLE; element: PLIST_ELEMENT): uint32_t; stdcall;
{Add the supplied element as the first item in the List}
{List: Handle of List entry to add to}
{Element: The list element to be added}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: If list is part of a synchronisation object then caller must hold the lock on the object containing the list}
begin
 {}
 Result:=ListAddFirst(list,element);
end;

{==============================================================================}

function list_add_last(list: LIST_HANDLE; element: PLIST_ELEMENT): uint32_t; stdcall;
{Add the supplied element as the last item in the List}
{List: Handle of List entry to add to}
{Element: The list element to be added}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: If list is part of a synchronisation object then caller must hold the lock on the object containing the list}
begin
 {}
 Result:=ListAddLast(list,element);
end;

{==============================================================================}

function list_get_thread(list: LIST_HANDLE; thread: THREAD_HANDLE): PLIST_ELEMENT; stdcall;
{Find the supplied thread in the List and return its element}
{List: Handle of List entry to find from}
{Thread: The thread handle to be found}
{Return: List element on success, nil on failure or list empty}
{Note: If list is part of a synchronisation object then caller must hold the lock on the object containing the list}
begin
 {}
 Result:=ListGetThread(list,thread);
end;

{==============================================================================}

function list_get_first(list: LIST_HANDLE): PLIST_ELEMENT; stdcall;
{Get the first element from the List}
{List: Handle of List entry to get from}
{Return: List element on success, nil on failure or list empty}
{Note: If list is part of a synchronisation object then caller must hold the lock on the object containing the list}
begin
 {}
 Result:=ListGetFirstEx(list,False);
end;

{==============================================================================}

function list_get_first_ex(list: LIST_HANDLE; remove: BOOL): PLIST_ELEMENT; stdcall;
{Get the first element from the List}
{List: Handle of List entry to get from}
{Remove: If true then remove the element from the list}
{Return: List element on success, nil on failure or list empty}
{Note: If list is part of a synchronisation object then caller must hold the lock on the object containing the list}
begin
 {}
 Result:=ListGetFirstEx(list,remove);
end;

{==============================================================================}

function list_get_last(list: LIST_HANDLE): PLIST_ELEMENT; stdcall;
{Get the last element from the List}
{List: Handle of List entry to get from}
{Return: List element on success, nil on failure or list empty}
{Note: If list is part of a synchronisation object then caller must hold the lock on the object containing the list}
begin
 {}
 Result:=ListGetLastEx(list,False);
end;

{==============================================================================}

function list_get_last_ex(list: LIST_HANDLE; remove: BOOL): PLIST_ELEMENT; stdcall;
{Get the last element from the List}
{List: Handle of List entry to get from}
{Remove: If true then remove the element from the list}
{Return: List element on success, nil on failure or list empty}
{Note: If list is part of a synchronisation object then caller must hold the lock on the object containing the list}
begin
 {}
 Result:=ListGetLastEx(list,remove);
end;

{==============================================================================}

function list_insert(list: LIST_HANDLE; previous, element: PLIST_ELEMENT): uint32_t; stdcall;
{Insert a new element in the List}
{List: Handle of List entry to insert into}
{Previous: The element to insert the new element after}
{Element: The list element to be inserted}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: If list is part of a synchronisation object then caller must hold the lock on the object containing the list}
begin
 {}
 Result:=ListInsert(list,previous,element);
end;

{==============================================================================}

function list_remove(list: LIST_HANDLE; element: PLIST_ELEMENT): uint32_t; stdcall;
{Remove an element from the List}
{List: Handle of List entry to remove from}
{Element: The list element to be removed}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: If list is part of a synchronisation object then caller must hold the lock on the object containing the list}
begin
 {}
 Result:=ListRemove(list,element);
end;

{==============================================================================}

function list_is_empty(list: LIST_HANDLE): BOOL; stdcall;
{Check if the supplied List is empty}
{List: Handle of List entry to check}
{Return: True if List is empty or does not exist, False if List is not empty}
{Note: If list is part of a synchronisation object then caller must hold the lock on the object containing the list}
begin
 {}
 Result:=ListIsEmpty(list);
end;

{==============================================================================}

function list_not_empty(list: LIST_HANDLE): BOOL; stdcall;
{Check if the supplied List is empty}
{List: Handle of List entry to check}
{Return: True if List is not empty, False if List is empty or does not exist}
{Note: If list is part of a synchronisation object then caller must hold the lock on the object containing the list}
begin
 {}
 Result:=ListNotEmpty(list);
end;

{==============================================================================}

function list_lock(list: LIST_HANDLE): uint32_t; stdcall;
{Lock the supplied List}
{List: Handle of List entry to lock}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ListLock(list);
end;

{==============================================================================}

function list_unlock(list: LIST_HANDLE): uint32_t; stdcall;
{Unlock the supplied List}
{List: Handle of List entry to unlock}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ListUnlock(list);
end;

{==============================================================================}
{Queue Functions}
function queue_create: QUEUE_HANDLE; stdcall;
{Create and insert a new Queue entry}
{Return: Handle of new Queue entry or INVALID_HANDLE_VALUE if entry could not be created}
begin
 {}
 Result:=QueueCreateEx(QUEUE_TYPE_NOT_SPECIFIED,QUEUE_FLAG_NONE);
end;

{==============================================================================}

function queue_create_ex(queuetype: uint32_t; flags: uint32_t): QUEUE_HANDLE; stdcall;
{Create and insert a new Queue entry}
{QueueType: Type of queue to create (eg QUEUE_TYPE_SCHEDULE_SLEEP)}
{Flags: Flags for the new queue (eg QUEUE_FLAG_DESCENDING)}
{Return: Handle of new Queue entry or INVALID_HANDLE_VALUE if entry could not be created}
begin
 {}
 Result:=QueueCreateEx(queuetype,flags);
end;

{==============================================================================}

function queue_destroy(queue: QUEUE_HANDLE): uint32_t; stdcall;
{Destroy and remove an existing Queue entry}
{Queue: Handle of Queue entry to destroy}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=QueueDestroy(queue);
end;

{==============================================================================}

function queue_count(queue: QUEUE_HANDLE): uint32_t; stdcall;
{Get the current count from the supplied queue}
{List: Handle of Queue entry to get from}
{Return: Queue count on success or INVALID_HANDLE_VALUE on failure}
begin
 {}
 Result:=QueueCount(queue);
end;

{==============================================================================}

function queue_enqueue(queue: QUEUE_HANDLE; thread: THREAD_HANDLE): uint32_t; stdcall;
{Add the supplied thread as the last item in the Queue}
{Queue: Handle of Queue entry to add to}
{Thread: Handle of the Thread to enqueue}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: If queue is a scheduler queue then caller must hold the lock on the thread}
begin
 {}
 Result:=QueueEnqueue(queue,thread);
end;

{==============================================================================}

function queue_dequeue(queue: QUEUE_HANDLE): THREAD_HANDLE; stdcall;
{Get and remove the first thread from the Queue}
{Queue: Handle of Queue entry to get from}
{Return: Handle of dequeued Thread or INVALID_HANDLE_VALUE on failure}
begin
 {}
 Result:=QueueDequeue(queue);
end;

{==============================================================================}

function queue_first_key(queue: QUEUE_HANDLE): int; stdcall;
{Get the first Key value from the Queue}
{Queue: Handle of Queue entry to get from}
{Return: First Key value from queue or QUEUE_KEY_NONE on failure}
begin
 {}
 Result:=QueueFirstKey(queue);
end;

{==============================================================================}

function queue_last_key(queue: QUEUE_HANDLE): int; stdcall;
{Get the last Key value from the Queue}
{Queue: Handle of Queue entry to get from}
{Return: Last Key value from queue or QUEUE_KEY_NONE on failure}
begin
 {}
 Result:=QueueLastKey(queue);
end;

{==============================================================================}

function queue_insert_key(queue: QUEUE_HANDLE; thread: THREAD_HANDLE; key: int): uint32_t; stdcall;
{Insert the supplied thread in the Queue ordered based on Key and the flags of the Queue}
{Queue: Handle of Queue entry to insert into}
{Thread: Handle of thread to be inserted}
{Key: The key to order the insertion on}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: If queue is a scheduler queue then caller must hold the lock on the thread}
begin
 {}
 Result:=QueueInsertKey(queue,thread,key);
end;

{==============================================================================}

function queue_delete_key(queue: QUEUE_HANDLE; thread: THREAD_HANDLE): uint32_t; stdcall;
{Delete the supplied thread from the Queue based on the flags of the Queue}
{Queue: Handle of Queue entry to delete from}
{Thread: Handle of thread to be deleted}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: If queue is a scheduler queue then caller must hold the lock on the thread}
begin
 {}
 Result:=QueueDeleteKey(queue,thread);
end;

{==============================================================================}

function queue_increment_key(queue: QUEUE_HANDLE): int; stdcall;
{Increment the first Key value in the Queue}
{Queue: Handle of Queue entry to increment in}
{Return: First Key value in queue after increment or QUEUE_KEY_NONE on failure}
begin
 {}
 Result:=QueueIncrementKey(queue);
end;

{==============================================================================}

function queue_decrement_key(queue: QUEUE_HANDLE): int; stdcall;
{Decrement the first Key value in the Queue}
{Queue: Handle of Queue entry to decrement in}
{Return: First Key value in queue after decrement or QUEUE_KEY_NONE on failure}
begin
 {}
 Result:=QueueDecrementKey(queue);
end;

{==============================================================================}

function queue_is_empty(queue: QUEUE_HANDLE): BOOL; stdcall;
{Check if the supplied Queue is empty}
{Queue: Handle of Queue entry to check}
{Return: True if Queue is empty or does not exist, False if Queue is not empty}
begin
 {}
 Result:=QueueIsEmpty(queue);
end;

{==============================================================================}

function queue_not_empty(queue: QUEUE_HANDLE): BOOL; stdcall;
{Check if the supplied Queue is not empty}
{Queue: Handle of Queue entry to check}
{Return: True if Queue is not empty, False if Queue is empty or does not exist}
begin
 {}
 Result:=QueueNotEmpty(queue);
end;

{==============================================================================}

function queue_lock(queue: QUEUE_HANDLE): uint32_t; stdcall;
{Lock the supplied Queue}
{Queue: Handle of Queue entry to lock}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=QueueLock(queue);
end;

{==============================================================================}

function queue_unlock(queue: QUEUE_HANDLE): uint32_t; stdcall;
{Unlock the supplied Queue}
{Queue: Handle of Queue entry to unlock}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=QueueUnlock(queue);
end;

{==============================================================================}
{Thread Functions}
function thread_create(startproc: thread_start_proc; stacksize, priority: uint32_t; const name: PCHAR; parameter: PVOID): THREAD_HANDLE; stdcall;
{Create and insert a new Thread entry

 The new thread will be created suspended so it will not start running until it is
 scheduled with either ThreadReady or ThreadResume}
{StartProc: Procedure address where the thread will start running}
{StackSize: Stack size in bytes}
{Priority: Thread priority (eg THREAD_PRIORITY_NORMAL)}
{Name: Name of the thread}
{Parameter: Parameter passed to StartProc of new thread}
{Return: Handle of new thread or INVALID_HANDLE_VALUE if a new thread could not be created}
{Note: Calls ThreadCreateEx with:
         Affinity = SCHEDULER_CPU_MASK (Run on any available CPU)
         CPU = SchedulerThreadNext (Assign to next CPU in round robin)}
{WARNING: ThreadCreate and ThreadCreateEx are only used internally by SysBeginThread and SysBeginThreadEx

          These functions do not handle setting up certain RTL functionality such as thread variables,
          exceptions and standard input/output handles.

          If you need to create a standard thread use either BeginThread (or BeginThreadEx) or use the
          TThread class and its descendants. Only use ThreadCreate and ThreadCreateEx if you need to modify
          the thread creation behaviour and understand that you also need to handle the additional RTL setup}
begin
 {}
 Result:=ThreadCreateEx(startproc,stacksize,priority,SCHEDULER_CPU_MASK,SchedulerGetThreadNext,name,parameter);
end;

{==============================================================================}

function thread_create_ex(startproc: thread_start_proc; stacksize, priority, affinity, cpu: uint32_t; const name: PCHAR; parameter: PVOID): THREAD_HANDLE; stdcall;
{Create and insert a new Thread entry

 The new thread will be created suspended so it will not start running until it is
 scheduled with either ThreadReady or ThreadResume}
{StartProc: Procedure address where the thread will start running}
{StackSize: Stack size in bytes}
{Priority: Thread priority (eg THREAD_PRIORITY_NORMAL)}
{Affinity: Thread affinity (eg CPU_AFFINITY_ALL)}
{CPU: The CPU to assign new thread to (eg CPU_ID_0)}
{Name: Name of the thread}
{Parameter: Parameter passed to StartProc of new thread}
{Return: Handle of new thread or INVALID_HANDLE_VALUE if a new thread could not be created}
{WARNING: ThreadCreate and ThreadCreateEx are only used internally by SysBeginThread and SysBeginThreadEx

          These functions do not handle setting up certain RTL functionality such as thread variables,
          exceptions and standard input/output handles.

          If you need to create a standard thread use either BeginThread (or BeginThreadEx) or use the
          TThread class or its descendants. Only use ThreadCreate and ThreadCreateEx if you need to modify
          the thread creation behaviour and understand that you also need to handle the additional RTL setup}
begin
 {}
 Result:=ThreadCreateEx(startproc,stacksize,priority,affinity,cpu,name,parameter);
end;

{==============================================================================}

function thread_destroy(thread: THREAD_HANDLE): uint32_t; stdcall;
{Destroy and remove an existing Thread entry}
{Thread: Handle of thread to destroy}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ThreadDestroy(thread);
end;

{==============================================================================}

function thread_get_current: THREAD_HANDLE; stdcall;
{Get the Handle of currently executing thread}
{Return: Thread handle of the currently running thread}
begin
 {}
 if Assigned(ThreadGetCurrentHandler) then
  begin
   Result:=ThreadGetCurrentHandler;
  end
 else
  begin
   Result:=INVALID_HANDLE_VALUE;
  end;
end;

{==============================================================================}

function thread_set_current(thread: THREAD_HANDLE): uint32_t; stdcall;
{Set the Handle of currently executing thread}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Must not be called except during initialization}
begin
 {}
 Result:=ThreadSetCurrent(thread);
end;

{==============================================================================}

function thread_get_name(thread: THREAD_HANDLE; name: PCHAR; len: uint32_t): uint32_t; stdcall;
{Get the name of a Thread}
{Thread: Handle of thread to get}
{Return: Name of thread or empty string on failure}
begin
 {}
 Result:=APIStringToPCharBuffer(ThreadGetName(thread),name,len);
end;

{==============================================================================}

function thread_set_name(thread: THREAD_HANDLE; const name: PCHAR): uint32_t; stdcall;
{Set the name of a Thread}
{Thread: Handle of thread to set}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ThreadSetName(thread,String(name));
end;

{==============================================================================}

function thread_get_cpu(thread: THREAD_HANDLE): uint32_t; stdcall;
{Get the current CPU of a thread (eg CPU_ID_0)}
{Thread: Handle of thread to get}
{Return: CPU of the thread or INVALID_HANDLE_VALUE on failure}
begin
 {}
 Result:=ThreadGetCPU(thread);
end;

{==============================================================================}

function thread_set_cpu(thread: THREAD_HANDLE; cpu: uint32_t): uint32_t; stdcall;
{Set the current CPU of a thread (eg CPU_ID_0)

 The new CPU will not take affect until the thread is next rescheduled}
{Thread: Handle of thread to set}
{CPU: New thread CPU (eg CPU_ID_0)}
{Return: Previous CPU of thread or INVALID_HANDLE_VALUE on failure}
begin
 {}
 Result:=ThreadSetCPU(thread,cpu);
end;

{==============================================================================}

function thread_get_state(thread: THREAD_HANDLE): uint32_t; stdcall;
{Get the current state of a thread (eg THREAD_STATE_SUSPENDED)}
{Thread: Handle of thread to get}
{Return: State of the thread or INVALID_HANDLE_VALUE on failure}
begin
 {}
 Result:=ThreadGetState(thread);
end;

{==============================================================================}

function thread_get_flags(thread: THREAD_HANDLE): uint32_t; stdcall;
{Get the current flags of a thread}
{Thread: Handle of thread to get}
{Return: Flags of the thread (eg THREAD_FLAG_PERSIST) or INVALID_HANDLE_VALUE on failure}
begin
 {}
 Result:=ThreadGetFlags(thread);
end;

{==============================================================================}

function thread_set_flags(thread: THREAD_HANDLE; flags: uint32_t): uint32_t; stdcall;
{Set the current flags of a thread}
{Thread: Handle of thread to set}
{Flags: Flags to set (eg THREAD_FLAG_PERSIST)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ThreadSetFlags(thread,flags);
end;

{==============================================================================}

function thread_add_flags(thread: THREAD_HANDLE; flags: uint32_t): uint32_t; stdcall;
{Add flags to the current flags of a thread}
{Thread: Handle of thread to add flags for}
{Flags: Flags to add (eg THREAD_FLAG_PERSIST)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ThreadAddFlags(thread,flags);
end;

{==============================================================================}

function thread_remove_flags(thread: THREAD_HANDLE; flags: uint32_t): uint32_t; stdcall;
{Remove flags from the current flags of a thread}
{Thread: Handle of thread to remove flags from}
{Flags: Flags to remove (eg THREAD_FLAG_PERSIST)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ThreadRemoveFlags(thread,flags);
end;

{==============================================================================}

function thread_get_locale(thread: THREAD_HANDLE): LCID; stdcall;
{Get the current locale of a thread}
{Thread: Handle of thread to get}
{Return: Locale of the thread or INVALID_HANDLE_VALUE on failure}
begin
 {}
 Result:=ThreadGetLocale(thread);
end;

{==============================================================================}

function thread_set_locale(thread: THREAD_HANDLE; locale: LCID): uint32_t; stdcall;
{Set the locale of a thread}
{Thread: Handle of thread to set}
{Locale: Locale id to set}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ThreadSetLocale(thread,locale);
end;

{==============================================================================}

function thread_get_times(thread: THREAD_HANDLE; var createtime, exittime, kerneltime: int64_t): uint32_t; stdcall;
{Get the current times of a thread}
{Thread: Handle of thread to get}
{CreateTime: Buffer to receive the CreateTime value}
{ExitTime: Buffer to receive the ExitTime value}
{KernelTime: Buffer to receive the KernelTime value}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ThreadGetTimes(thread,createtime,exittime,kerneltime);
end;

{==============================================================================}

function thread_get_switch_count(thread: THREAD_HANDLE; var switchcount: int64_t): uint32_t; stdcall;
{Get the current context switch count of a thread (How many times the thread has been scheduled)}
{Thread: Handle of thread to get}
{SwitchCount: Buffer to receive the SwitchCount value}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ThreadGetSwitchCount(thread,switchcount);
end;

{==============================================================================}

function thread_get_stack_free: uint32_t; stdcall;
{Get the free stack size of the current thread}
{Return: Free stack size of the current thread or 0 on error}
{Note: No lock required as only ever called by the thread itself}
begin
 {}
 Result:=ThreadGetStackFree;
end;

{==============================================================================}

function thread_get_stack_size(thread: THREAD_HANDLE): uint32_t; stdcall;
{Get the current stack size of a thread}
{Thread: Handle of thread to get}
{Return: Stack size of the thread or INVALID_HANDLE_VALUE on failure}
begin
 {}
 Result:=ThreadGetStackSize(thread);
end;

{==============================================================================}

function thread_get_stack_base(thread: THREAD_HANDLE): SIZE_T; stdcall;
{Get the current stack base of a thread}
{Thread: Handle of thread to get}
{Return: Stack base of the thread or INVALID_HANDLE_VALUE on failure}
begin
 {}
 Result:=ThreadGetStackBase(thread);
end;

{==============================================================================}

function thread_set_stack_base(thread: THREAD_HANDLE; stackbase: SIZE_T): uint32_t; stdcall;
{Set the current stack base of a thread}
{Thread: Handle of thread to set}
{StackBase: Stack base to set}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Must not be called except during initialization}
begin
 {}
 Result:=ThreadSetStackBase(thread,stackbase);
end;

{==============================================================================}

function thread_get_stack_pointer(thread: THREAD_HANDLE): SIZE_T; stdcall;
{Get the current stack pointer of a thread}
{Thread: Handle of thread to get}
{Return: Stack pointer of the thread or INVALID_HANDLE_VALUE on failure}
begin
 {}
 Result:=ThreadGetStackPointer(thread);
end;

{==============================================================================}

function thread_get_exit_code(thread: THREAD_HANDLE): uint32_t; stdcall;
{Get the exit code of a Thread}
{Thread: Handle of thread to get}
{Return: Exit code of thread, STILL_ACTIVE if the thread has not terminated or INVALID_HANDLE_VALUE on failure}
begin
 {}
 Result:=ThreadGetExitCode(thread);
end;

{==============================================================================}

function thread_get_affinity(thread: THREAD_HANDLE): uint32_t; stdcall;
{Get the scheduling affinity of a Thread}
{Thread: Handle of thread to get}
{Return: Affinity of thread or INVALID_HANDLE_VALUE on failure}
begin
 {}
 Result:=ThreadGetAffinity(thread);
end;

{==============================================================================}

function thread_set_affinity(thread: THREAD_HANDLE; affinity: uint32_t): uint32_t; stdcall;
{Set the scheduling affinity of a Thread

 The new affinity will not take affect until the thread is next rescheduled}
{Thread: Handle of thread to set}
{Affinity: New thread affinity (eg CPU_AFFINITY_0)}
{Return: Previous affinity of thread or INVALID_HANDLE_VALUE on failure}
begin
 {}
 Result:=ThreadSetAffinity(thread,affinity);
end;

{==============================================================================}

function thread_get_priority(thread: THREAD_HANDLE): uint32_t; stdcall;
{Get the scheduling priority of a Thread}
{Thread: Handle of thread to get}
{Return: Priority of thread or INVALID_HANDLE_VALUE on failure}
begin
 {}
 Result:=ThreadGetPriority(thread);
end;

{==============================================================================}

function thread_set_priority(thread: THREAD_HANDLE; priority: uint32_t): uint32_t; stdcall;
{Set the scheduling priority of a Thread

 The new priority will not take affect until the thread is next rescheduled}
{Thread: Handle of thread to set}
{Priority: New thread priority (eg THREAD_PRIORITY_NORMAL)}
{Return: Previous priority of thread or INVALID_HANDLE_VALUE on failure}
begin
 {}
 Result:=ThreadSetPriority(thread,priority);
end;

{==============================================================================}

function thread_get_last_error: uint32_t; stdcall;
{Get the last error value for the current Thread}
{Return: Last Error of thread or ERROR_SUCCESS if no error}
{Note: No lock required as only ever called by the thread itself}
begin
 {}
 Result:=ThreadGetLastError;
end;

{==============================================================================}

procedure thread_set_last_error(lasterror: uint32_t); stdcall;
{Set the last error value for the current Thread}
{Note: No lock required as only ever called by the thread itself}
begin
 {}
 ThreadSetLastError(lasterror);
end;

{==============================================================================}

function thread_set_last_error_ex(lasterror: uint32_t): uint32_t; stdcall;
{Set the last error value for the current Thread}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: No lock required as only ever called by the thread itself}
begin
 {}
 Result:=ThreadSetLastErrorEx(lasterror);
end;

{==============================================================================}

function thread_get_wait_result: uint32_t; stdcall;
{Get the result of the last wait timeout for the current Thread}
{Return: Result of last wait timeout or ERROR_SUCCESS if no error}
{Note: No lock required as only ever called by the thread itself}
begin
 {}
 Result:=ThreadGetWaitResult;
end;

{==============================================================================}

function thread_get_receive_result: uint32_t; stdcall;
{Get the result of the last receive timeout for the current Thread}
{Return: Result of last receive timeout or ERROR_SUCCESS if no error}
{Note: No lock required as only ever called by the thread itself}
begin
 {}
 Result:=ThreadGetReceiveResult;
end;

{==============================================================================}

function thread_get_tls_index(tlsindex: uint32_t): uint32_t; stdcall;
{Get the current status of a TLS index in the TLS index table}
{TlsIndex: The TLS index to get the status for}
{Return: THREAD_TLS_FREE if unused, THREAD_TLS_USED if in use or THREAD_TLS_INVALID on error}
{Note: No lock required as only ever reads from the table}
begin
 {}
 Result:=ThreadGetTlsIndex(tlsindex);
end;

{==============================================================================}

function thread_alloc_tls_index: uint32_t; stdcall;
{Allocate a TLS index in the TLS index table}
{Return: Allocated TLS index or TLS_OUT_OF_INDEXES on failure}
begin
 {}
 Result:=ThreadAllocTlsIndex;
end;

{==============================================================================}

function thread_alloc_tls_index_ex(flags: uint32_t): uint32_t; stdcall;
{Allocate a TLS index in the TLS index table}
{Flags: The flags to apply to the TLS index entries (eg THREAD_TLS_FLAG_FREE)}
{Return: Allocated TLS index or TLS_OUT_OF_INDEXES on failure}
begin
 {}
 Result:=ThreadAllocTlsIndexEx(flags);
end;

{==============================================================================}

function thread_release_tls_index(tlsindex: uint32_t): uint32_t; stdcall;
{Deallocate a TLS index from the TLS index table}
{TlsIndex: The TLS index to deallocate}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ThreadReleaseTlsIndex(tlsindex);
end;

{==============================================================================}

function thread_get_tls_value(tlsindex: uint32_t): PVOID; stdcall;
{Get the pointer associated with the TLS index for the current thread}
{Return: Pointer for the specified TLS index or nil if not set or on error}
{Note: No lock required as only ever called by the thread itself}
begin
 {}
 Result:=ThreadGetTlsValue(tlsindex);
end;

{==============================================================================}

function thread_set_tls_value(tlsindex: uint32_t; tlsvalue: PVOID): uint32_t; stdcall;
{Set the pointer associated with the TLS index for the current thread}
{TlsIndex: The TLS index to get the pointer for}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: No lock required as only ever called by the thread itself}
begin
 {}
 Result:=ThreadSetTlsValue(tlsindex,tlsvalue);
end;

{==============================================================================}

function thread_get_tls_pointer(thread: THREAD_HANDLE): PVOID; stdcall;
{Get the RTL TLS (Thread Local Storage) pointer of a Thread}
{Thread: Handle of thread to get}
{Return: Pointer to the RTL TLS of thread or nil on failure}
begin
 {}
 Result:=ThreadGetTlsPointer(thread);
end;

{==============================================================================}

function thread_set_tls_pointer(thread: THREAD_HANDLE; tlspointer: PVOID): uint32_t; stdcall;
{Set the RTL TLS (Thread Local Storage) pointer of a Thread}
{Thread: Handle of thread to set}
{TlsPointer: Pointer value to set (Can be nil to clear the pointer)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ThreadSetTlsPointer(thread,tlspointer);
end;

{==============================================================================}

function thread_ready(thread: THREAD_HANDLE; reschedule: BOOL): uint32_t; stdcall;
{Place the supplied Thread on the ready queue}
{Thread: Handle of thread to make ready}
{Reschedule: If True then call SchedulerReschedule}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: When called by the scheduler, thread has already been removed from the sleep queue}
begin
 {}
 Result:=ThreadReady(thread,reschedule);
end;

{==============================================================================}

function thread_timeout(thread: THREAD_HANDLE): uint32_t; stdcall;
{Place the supplied Thread on the ready queue after a timeout waiting on a resource}
{Thread: Handle of thread to make ready}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: When called by the scheduler, thread has already been removed from the timeout queue}
begin
 {}
 Result:=ThreadTimeout(thread);
end;

{==============================================================================}

function thread_wake(thread: THREAD_HANDLE): uint32_t; stdcall;
{Remove a thread prematurely from the sleep or timeout queues}
{Thread: Handle of thread to remove}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: A thread that was sleeping will simply return early
       A thread that was waiting or receiving with a timeout will return
       with the error WAIT_TIMEOUT
       A thread that was waiting or receiving with INFINITE timeout will return
       with the error WAIT_ABANDONED}
begin
 {}
 Result:=ThreadWake(thread);
end;

{==============================================================================}

function thread_migrate(thread: THREAD_HANDLE; cpu: uint32_t): uint32_t; stdcall;
{Migrate a thread to a new CPU}
{Thread: Handle of thread to migrate}
{CPU: New CPU for the thread}
{Return: Previous CPU of thread or INVALID_HANDLE_VALUE on failure}
begin
 {}
 Result:=ThreadMigrate(thread,cpu);
end;

{==============================================================================}

procedure thread_end(exitcode: uint32_t); stdcall;
{Terminate the current Thread}
{ExitCode: The return code of the thread}
begin
 {}
 ThreadEnd(exitcode);
end;

{==============================================================================}

function thread_halt(exitcode: uint32_t): uint32_t; stdcall;
{Halt the current thread so it will never be rescheduled.

 Normally only called due to an unhandled exception etc so that the thread
 is put to sleep permanently without being terminated}
{ExitCode: The return code of the thread}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ThreadHalt(exitcode);
end;

{==============================================================================}

function thread_terminate(thread: THREAD_HANDLE; exitcode: uint32_t): uint32_t; stdcall;
{Terminate but do not destroy the supplied Thread

 The terminated thread is placed on the termination queue until any threads
 waiting on it have been released}
{Thread: Handle of thread to terminate}
{ExitCode: The return code of the thread}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ThreadTerminate(thread,exitcode);
end;

{==============================================================================}

function thread_yield: uint32_t; stdcall;
{Make the current thread yield the processor (Same as ThreadSleep(0))}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SchedulerReschedule(True);
end;

{==============================================================================}

function thread_sleep(milliseconds: uint32_t): uint32_t; stdcall;
{Place the current thread on the sleep queue for a specified number of milliseconds}
{Milliseconds: Number of milliseconds to sleep}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ThreadSleep(milliseconds);
end;

{==============================================================================}

function thread_wait(list: LIST_HANDLE; lock: SPIN_HANDLE; flags: uint32_t): uint32_t; stdcall;
{Put the current thread into a wait state on the supplied list}
{List: Handle of List entry to put thread into}
{Lock: Handle of Lock to release before going into wait state}
{Flags: Flag to indicate which unlock method to use}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Caller must hold the lock on the synchronisation object containing the list}
begin
 {}
 Result:=ThreadWaitEx(list,lock,flags,INFINITE);
end;

{==============================================================================}

function thread_wait_ex(list: LIST_HANDLE; lock: SPIN_HANDLE; flags, timeout: uint32_t): uint32_t; stdcall;
{Put the current thread into a wait state with timeout on the supplied list}
{List: Handle of List entry to put thread into}
{Lock: Handle of Lock to release before going into wait state}
{Flags: Flag to indicate which unlock method to use}
{Timeout: Milliseconds to wait before timeout (INFINITE equals wait forever)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Caller must hold the lock on the synchronisation object containing the list}
begin
 {}
 Result:=ThreadWaitEx(list,lock,flags,timeout);
end;

{==============================================================================}

function thread_release(list: LIST_HANDLE): uint32_t; stdcall;
{Release the first thread waiting on the supplied list}
{List: Handle of List entry to release thread from}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Caller must hold the lock on the synchronisation object containing the list}
begin
 {}
 Result:=ThreadRelease(list);
end;

{==============================================================================}

function thread_abandon(list: LIST_HANDLE): uint32_t; stdcall;
{Release the first thread waiting on the supplied list and return with WAIT_ABANDONED}
{List: Handle of List entry to release thread from}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Caller must hold the lock on the synchronisation object containing the list}
begin
 {}
 Result:=ThreadAbandon(list);
end;

{==============================================================================}

function thread_wait_terminate(thread: THREAD_HANDLE; timeout: uint32_t): uint32_t; stdcall;
{Make the current thread wait until the specified thread has terminated}
{Thread: Handle of the thread to wait on}
{Timeout: Milliseconds to wait before timeout (0 equals do not wait, INFINITE equals wait forever)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: The wait can be abandoned by calling ThreadWake with the handle of the waiting thread}
begin
 {}
 Result:=ThreadWaitTerminate(thread,timeout);
end;

{==============================================================================}

function thread_suspend(thread: THREAD_HANDLE): uint32_t; stdcall;
{Suspend a thread, placing it in hibernation}
{Thread: Handle of thread to suspend}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Suspending a thread from another thread is not safe unless specific precautions are taken
       to prevent deadlocks
       It is normally safe for a thread to suspend itself as long as it releases any locks it is
       holding that may be required by other threads before suspending}
begin
 {}
 Result:=ThreadSuspend(thread);
end;

{==============================================================================}

function thread_resume(thread: THREAD_HANDLE): uint32_t; stdcall;
{Resume a suspended thread, making it ready}
{Thread: Handle of thread to resume}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ThreadResume(thread);
end;

{==============================================================================}

function thread_wait_message: uint32_t; stdcall;
{Make the current thread wait until a message is received (indefinitely)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: The received message is not removed from the message list}
begin
 {}
 Result:=ThreadWaitMessage;
end;

{==============================================================================}

function thread_send_message(thread: THREAD_HANDLE; const message: TTHREAD_MESSAGE): uint32_t; stdcall;
{Send a message to another thread}
{Thread: Handle of thread to send to}
{Message: Contents of message to send}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ThreadSendMessage(thread,message);
end;

{==============================================================================}

function thread_receive_message(var message: TTHREAD_MESSAGE): uint32_t; stdcall;
{Make the current thread wait to receive a message (indefinitely)}
{Message: The received message if successful, undefined on error}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ThreadReceiveMessageEx(message,INFINITE,True);
end;

{==============================================================================}

function thread_receive_message_ex(var message: TTHREAD_MESSAGE; timeout: uint32_t; remove: BOOL): uint32_t; stdcall;
{Make the current thread wait to receive a message}
{Message: The received message if successful, undefined on error}
{Timeout: Milliseconds to wait before timeout (0 equals do not wait, INFINITE equals wait forever)}
{Remove: If true then remove the received message from the message list}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ThreadReceiveMessageEx(message,timeout,remove);
end;

{==============================================================================}

function thread_abandon_message(thread: THREAD_HANDLE): uint32_t; stdcall;
{Tell another thread to abandon waiting for a message}
{Thread: Handle of thread to abandon waiting}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: The waiting thread will return with ERROR_WAIT_ABANDONED or ERROR_WAIT_TIMEOUT}
begin
 {}
 Result:=ThreadAbandonMessage(thread);
end;

{==============================================================================}

function thread_lock(thread: THREAD_HANDLE): uint32_t; stdcall;
{Lock a thread allowing access to internal structures such as the thread stack}
{Thread: Handle of thread to lock}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Locking a thread will also disable IRQ or FIQ depending on scheduler
       settings. The lock should only be held for the briefest time possible}
begin
 {}
 Result:=ThreadLock(thread);
end;

{==============================================================================}

function thread_unlock(thread: THREAD_HANDLE): uint32_t; stdcall;
{Unlok a thread that was locked by ThreadLock}
{Thread: Handle of thread to unlock}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Locking a thread will also disable IRQ or FIQ depending on scheduler
       settings. The lock should only be held for the briefest time possible}
begin
 {}
 Result:=ThreadUnlock(thread);
end;

{==============================================================================}
{Scheduler Functions}
function scheduler_check(cpuid: uint32_t): uint32_t; stdcall;
{Check if the sleep queue is empty, if not then decrement the first key
 Then check if the timeout queue is empty, if not then decrement the first key

 If either key reaches zero, return success to indicate there are threads to be
 woken or threads whose timeout has expired

 Finally check if the termination queue is empty, if not then decrement the first
 key

 Items will be removed from the termination queue by SchedulerReschedule}
{CPUID: The ID of the current CPU}
{Return: ERROR_SUCCESS if either first key is zero, ERROR_NO_MORE_ITEMS if both queues are empty or another error code on failure}
{Note: Called by scheduler interrupt with IRQ or FIQ disabled and running on the IRQ or FIQ thread}
begin
 {}
 Result:=SchedulerCheck(cpuid);
end;

{==============================================================================}

function scheduler_wakeup(cpuid: uint32_t): uint32_t; stdcall;
{Remove all threads from the sleep queue that have no more time to sleep

 Threads will be placed back on the ready queue for rescheduling}
{CPUID: The ID of the current CPU}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Called by scheduler interrupt with IRQ or FIQ disabled and running on the IRQ or FIQ thread}
begin
 {}
 Result:=SchedulerWakeup(cpuid);
end;

{==============================================================================}

function scheduler_expire(cpuid: uint32_t): uint32_t; stdcall;
{Remove all threads from the timeout queue that have no more time to wait

 Threads will be placed back on the ready queue for rescheduling but will
 return with an error indicating the timeout expired}
{CPUID: The ID of the current CPU}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Called by scheduler interrupt with IRQ or FIQ disabled and running on the IRQ or FIQ thread}
begin
 {}
 Result:=SchedulerExpire(cpuid);
end;

{==============================================================================}

function scheduler_switch(cpuid: uint32_t; thread: THREAD_HANDLE): THREAD_HANDLE; stdcall;
{Perform a preemptive thread switch operation under an interrupt handler

 The next thread to run will be selected based on remaining quantum of the current
 thread, ready threads at higher priority levels and scheduler priority quantum for
 fair scheduling of lower priority threads}
{CPUID: The ID of the current CPU}
{Thread: The handle of the currently running thread (Before IRQ or FIQ occurred)}
{Return: The handle of the current thread which may be the old thread or a new thread}
{Note: Called by scheduler interrupt with IRQ or FIQ disabled and running on the IRQ or FIQ thread}
begin
 {}
 Result:=SchedulerSwitch(cpuid,thread);
end;

{==============================================================================}

function scheduler_select(cpuid: uint32_t; thread: THREAD_HANDLE; yield: BOOL): THREAD_HANDLE; stdcall;
{Select the next thread to be run based on state, yield, quantum and priority}
{CPUID: The ID of the current CPU}
{Thread: The handle of the currently running thread (Before IRQ or FIQ occurred or when Reschedule was called)}
{Yield: True if the current thread is giving up its remaining time slice}
{Return: The handle of the next thread to run or INVALID_HANDLE_VALUE on no selection or error}
{Note: Called either by scheduler interrupt with IRQ or FIQ disabled and running on the IRQ or FIQ thread
       Or by scheduler reschedule with IRQ or FIQ disabled and running on the current thread}
{Note: Caller must either hold a lock on the current thread or have disabled IRQ or FIQ}
begin
 {}
 Result:=SchedulerSelect(cpuid,thread,yield);
end;

{==============================================================================}

function scheduler_reschedule(yield: BOOL): uint32_t; stdcall;
{Perform a thread switch operation when a thread yields, sleeps or waits

 The next thread to run will be selected based on whether the current thread is
 yielding or no longer ready, remaining quantum of the current thread, ready
 threads at higher priority levels and scheduler priority quantum for fair
 scheduling of lower priority threads}
{Yield: True if the current thread is giving up its remaining time slice}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Called by the currently running thread to force a reschedule before sleeping, waiting etc}
begin
 {}
 Result:=SchedulerReschedule(yield);
end;

{==============================================================================}

function scheduler_migration_enable: uint32_t; stdcall;
{Enable scheduler thread migration}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SchedulerMigrationEnable;
end;

{==============================================================================}

function scheduler_migration_disable: uint32_t; stdcall;
{Disable scheduler thread migration}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SchedulerMigrationDisable;
end;

{==============================================================================}

function scheduler_preempt_enable(cpuid: uint32_t): uint32_t; stdcall;
{Enable thread preemption for the specified CPU}
{CPUID: The ID of the CPU to enable for}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SchedulerPreemptEnable(cpuid);
end;

{==============================================================================}

function scheduler_preempt_disable(cpuid: uint32_t): uint32_t; stdcall;
{Disable thread preemption for the specified CPU}
{CPUID: The ID of the CPU to disable for}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SchedulerPreemptDisable(cpuid);
end;

{==============================================================================}

function scheduler_allocation_enable(cpuid: uint32_t): uint32_t; stdcall;
{Enable thread allocation for the specified CPU}
{CPUID: The ID of the CPU to enable for}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SchedulerAllocationEnable(cpuid);
end;

{==============================================================================}

function scheduler_allocation_disable(cpuid: uint32_t): uint32_t; stdcall;
{Disable thread allocation for the specified CPU}
{CPUID: The ID of the CPU to disable for}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SchedulerAllocationDisable(cpuid);
end;

{==============================================================================}
{Messageslot Functions}
function messageslot_create: MESSAGESLOT_HANDLE; stdcall;
{Create and insert a new Messageslot entry}
{Return: Handle of new Messageslot entry or INVALID_HANDLE_VALUE if entry could not be created}
begin
 {}
 Result:=MessageslotCreateEx(MESSAGESLOT_DEFAULT_MAXIMUM,MESSAGESLOT_FLAG_NONE);
end;

{==============================================================================}

function messageslot_create_ex(maximum: uint32_t; flags: uint32_t): MESSAGESLOT_HANDLE; stdcall;
{Create and insert a new Messageslot entry}
{Maximum: Maximum number of messages allowed for the Messageslot (Must be greater than zero)}
{Flags: The flags for the Messageslot entry (eg MESSAGESLOT_FLAG_IRQ)}
{Return: Handle of new Messageslot entry or INVALID_HANDLE_VALUE if entry could not be created}
begin
 {}
 Result:=MessageslotCreateEx(maximum,flags);
end;

{==============================================================================}

function messageslot_destroy(messageslot: MESSAGESLOT_HANDLE): uint32_t; stdcall;
{Destroy and remove an existing Messageslot entry}
{Messageslot: Handle of Messageslot entry to destroy}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=MessageslotDestroy(messageslot);
end;

{==============================================================================}

function messageslot_count(messageslot: MESSAGESLOT_HANDLE): uint32_t; stdcall;
{Get the number of available messages in a Messageslot entry}
{Messageslot: Messageslot to get from}
{Return: Number of messages or INVALID_HANDLE_VALUE on error}
begin
 {}
 Result:=MessageslotCount(messageslot);
end;

{==============================================================================}

function messageslot_send(messageslot: MESSAGESLOT_HANDLE; const message: TTHREAD_MESSAGE): uint32_t; stdcall;
{Send a message to a Messageslot}
{Messageslot: Messageslot to send to}
{Message: Contents of message to send}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=MessageslotSend(messageslot,message);
end;

{==============================================================================}

function messageslot_receive(messageslot: MESSAGESLOT_HANDLE; var message: TTHREAD_MESSAGE): uint32_t; stdcall;
{Receive a message from a Messageslot}
{Messageslot: Messageslot to receive from}
{Message: The received message if successful, undefined on error}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=MessageslotReceive(messageslot,message);
end;

{==============================================================================}

function messageslot_receive_ex(messageslot: MESSAGESLOT_HANDLE; var message: TTHREAD_MESSAGE; timeout: uint32_t): uint32_t; stdcall;
{Receive a message from a Messageslot}
{Messageslot: Messageslot to receive from}
{Message: The received message if successful, undefined on error}
{Timeout: Milliseconds to wait before timeout (0 equals do not wait, INFINITE equals wait forever)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=MessageslotReceiveEx(messageslot,message,timeout);
end;

{==============================================================================}
{Mailslot Functions}
function mailslot_create(maximum: uint32_t): MAILSLOT_HANDLE; stdcall;
{Create and insert a new Mailslot entry}
{Maximum: Maximum number of messages allowed for the Mailslot (Must be greater than zero)}
{Return: Handle of new Mailslot entry or INVALID_HANDLE_VALUE if entry could not be created}
begin
 {}
 Result:=MailslotCreate(maximum);
end;

{==============================================================================}

function mailslot_destroy(mailslot: MAILSLOT_HANDLE): uint32_t; stdcall;
{Destroy and remove an existing Mailslot entry}
{Mailslot: Handle of Mailslot entry to destroy}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=MailslotDestroy(mailslot);
end;

{==============================================================================}

function mailslot_count(mailslot: MAILSLOT_HANDLE): uint32_t; stdcall;
{Get the number of available messages in a Mailslot entry}
{Mailslot: Mailslot to get from}
{Return: Number of messages or INVALID_HANDLE_VALUE on error}
begin
 {}
 Result:=MailslotCount(mailslot);
end;

{==============================================================================}

function mailslot_send(mailslot: MAILSLOT_HANDLE; data: SSIZE_T): uint32_t; stdcall;
{Send a message to a Mailslot}
{Mailslot: Mailslot to send to}
{Data: Message to send to mailslot}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=MailslotSend(mailslot,data);
end;

{==============================================================================}

function mailslot_send_ex(mailslot: MAILSLOT_HANDLE; data: SSIZE_T; timeout: uint32_t): uint32_t; stdcall;
{Send a message to a Mailslot}
{Mailslot: Mailslot to send to}
{Data: Message to send to mailslot}
{Timeout: Milliseconds to wait before timeout (0 equals do not wait, INFINITE equals wait forever)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=MailslotSendEx(mailslot,data,timeout);
end;

{==============================================================================}

function mailslot_receive(mailslot: MAILSLOT_HANDLE): SSIZE_T; stdcall;
{Receive a message from a Mailslot}
{Mailslot: Mailslot to receive from}
{Return: Received message or INVALID_HANDLE_VALUE on error}
begin
 {}
 Result:=MailslotReceive(mailslot);
end;

{==============================================================================}

function mailslot_receive_ex(mailslot: MAILSLOT_HANDLE; timeout: uint32_t): SSIZE_T; stdcall;
{Receive a message from a Mailslot}
{Mailslot: Mailslot to receive from}
{Timeout: Milliseconds to wait before timeout (0 equals do not wait, INFINITE equals wait forever)}
{Return: Received message or INVALID_HANDLE_VALUE on error}
begin
 {}
 Result:=MailslotReceiveEx(mailslot,timeout);
end;

{==============================================================================}
{Buffer Functions}
function buffer_create(size, count: uint32_t): BUFFER_HANDLE; stdcall;
{Create and insert a new Buffer entry}
{Size: Size of each buffer in bytes}
{Count: Total number of buffers}
{Return: Handle of new Buffer entry or INVALID_HANDLE_VALUE if entry could not be created}
begin
 {}
 Result:=BufferCreateEx(size,count,BUFFER_FLAG_NONE);
end;

{==============================================================================}

function buffer_create_ex(size, count, flags: uint32_t): BUFFER_HANDLE; stdcall;
{Create and insert a new Buffer entry}
{Size: Size of each buffer in bytes}
{Count: Total number of buffers}
{Flags: Flags for buffer (eg BUFFER_FLAG_SHARED)}
{Return: Handle of new Buffer entry or INVALID_HANDLE_VALUE if entry could not be created}
begin
 {}
 Result:=BufferCreateEx(size,count,flags);
end;

{==============================================================================}

function buffer_destroy(buffer: BUFFER_HANDLE): uint32_t; stdcall;
{Destroy and remove an existing Buffer entry}
{Buffer: Handle of Buffer entry to destroy}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=BufferDestroy(buffer);
end;

{==============================================================================}

function buffer_count(buffer: BUFFER_HANDLE): uint32_t; stdcall;
{Get the total count of buffers in an existing Buffer entry}
{Buffer: Buffer to get total count for}
{Return: Total count or INVALID_HANDLE_VALUE on error}
begin
 {}
 Result:=BufferCount(buffer);
end;

{==============================================================================}

function buffer_available(buffer: BUFFER_HANDLE): uint32_t; stdcall;
{Get the available count of buffers in an existing Buffer entry}
{Buffer: Buffer to get available count for}
{Return: Available count or INVALID_HANDLE_VALUE on error}
begin
 {}
 Result:=BufferAvailable(buffer);
end;

{==============================================================================}

function buffer_get(buffer: BUFFER_HANDLE): PVOID; stdcall;
{Allocate an available buffer from an existing Buffer entry}
{Buffer: Handle of Buffer entry to allocate from}
{Return: A pointer to the allocated buffer or nil on error}
begin
 {}
 Result:=BufferGet(buffer);
end;

{==============================================================================}

function buffer_get_ex(buffer: BUFFER_HANDLE; timeout: uint32_t): PVOID; stdcall;
{Allocate an available buffer from an existing Buffer entry}
{Buffer: Handle of Buffer entry to allocate from}
{Timeout: Milliseconds to wait before timeout (0 equals do not wait, INFINITE equals wait forever)}
{Return: A pointer to the allocated buffer or nil on error}
begin
 {}
 Result:=BufferGetEx(buffer,timeout);
end;

{==============================================================================}

function buffer_free(buffer: PVOID): uint32_t; stdcall;
{Release a allocated buffer from an existing Buffer entry}
{Buffer: Pointer to the allocated buffer (As returned by BufferGet/BufferGetEx)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=BufferFree(buffer);
end;

{==============================================================================}

function buffer_iterate(buffer: BUFFER_HANDLE; previous: PVOID): PVOID; stdcall;
{Iterate through each of the buffers in an existing Buffer entry}
{Buffer: Handle of Buffer entry to iterate from}
{Previous: The pointer returned by the previous call or nil on first call}
{Return: A pointer to the next buffer or nil on error}
{Note: Iterate is intended to allow allocating or initializing buffers after
 a Buffer entry is created, or deallocating before a Buffer entry is destroyed.

 The function will fail if any buffers are already in use (if the count and
 available count are not equal)}
begin
 {}
 Result:=BufferIterate(buffer,previous);
end;

{==============================================================================}
{Event Functions}
function event_create(manualreset, initialstate: BOOL): EVENT_HANDLE; stdcall;
{Create and insert a new Event entry}
{ManualReset: Create a manual reset event if true or an auto reset event if false
              An manual reset event must be reset by calling EventReset
              An auto reset event is reset when a single waiting thread is released}
{InitialState: Set the initial state of the event to signaled if true
               or to unsignaled if false}
{Return: Handle of new Event entry or INVALID_HANDLE_VALUE if entry could not be created}
begin
 {}
 Result:=EventCreate(manualreset,initialstate);
end;

{==============================================================================}

function event_create_ex(flags: uint32_t): EVENT_HANDLE; stdcall;
{Create and insert a new Event entry}
{Flags: Event flags to use for the new entry (eg EVENT_FLAG_MANUAL_RESET)}
{Return: Handle of new Event entry or INVALID_HANDLE_VALUE if entry could not be created}
begin
 {}
 Result:=EventCreateEx(flags);
end;

{==============================================================================}

function event_destroy(event: EVENT_HANDLE): uint32_t; stdcall;
{Destroy and remove an existing Event entry}
{Event: Handle of Event entry to destroy}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=EventDestroy(event);
end;

{==============================================================================}

function event_state(event: EVENT_HANDLE): uint32_t; stdcall;
{Get the current state of an existing Event entry}
{Event: Event to get state for}
{Return: Current state or INVALID_HANDLE_VALUE on error}
begin
 {}
 Result:=EventState(event);
end;

{==============================================================================}

function event_wait(event: EVENT_HANDLE): uint32_t; stdcall;
{Wait on an existing Event entry

 If the Event is currently signaled then simply return immediately

 If the Event is currently unsignaled then wait for it to be signaled
 before returning}
{Event: Event to wait on}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=EventWait(event);
end;

{==============================================================================}

function event_wait_ex(event: EVENT_HANDLE; timeout: uint32_t): uint32_t; stdcall;
{Wait on an existing Event entry

 If the Event is currently signaled then simply return immediately

 If the Event is currently unsignaled then wait for it to be signaled
 before returning}
{Event: Event to wait on}
{Timeout: Time in milliseconds to wait for the event to be signaled
          0 = No Wait
          INFINITE = Wait Indefinitely}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=EventWaitEx(event,timeout);
end;

{==============================================================================}

function event_set(event: EVENT_HANDLE): uint32_t; stdcall;
{Set (Signal) an existing Event entry

 If the event is currently signaled then return with no action

 If the event is unsignaled then, if the event is manual reset release
 all waiting threads and return. If the event is auto reset release one
 waiting thread, unsignal the event and return

 If no threads are waiting then simply signal the event and return, if
 the event is auto reset then the next thread to wait will unsignal the
 event}
{Event: Event to set}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=EventSet(event);
end;

{==============================================================================}

function event_reset(event: EVENT_HANDLE): uint32_t; stdcall;
{Reset (Unsignal) an existing Event entry

 If the event is currently unsignaled then return with no action

 If the event is signaled then unsignal the event and return}
{Event: Event to reset}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=EventReset(event);
end;

{==============================================================================}

function event_pulse(event: EVENT_HANDLE): uint32_t; stdcall;
{Pulse (Set then Reset) an existing Event entry

 If the event is currently signaled then unsignal the event and return

 If the event is unsignaled then, if the event is manual reset release
 all waiting threads, unsignal the event and return. If the event is
 auto reset release one waiting thread, unsignal the event and return

 If no threads are waiting then simply unsignal the event and return}
{Event: Event to pulse}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=EventPulse(event);
end;

{==============================================================================}
{Timer Functions}
function timer_create(interval: uint32_t; enabled, reschedule: BOOL; event: timer_event_proc; data: PVOID): TIMER_HANDLE; stdcall;
{Create and insert a new Timer entry}
{Interval: Number of milliseconds between timer events}
{Enabled: If true then timer generates events}
{Reschedule: If true then reschedule timer after each event}
{Event: The function to call when the timer event is generated}
{Data: Data to be passed to the function when the timer event is generated (May be nil)}
{Return: Handle of new Timer entry or INVALID_HANDLE_VALUE if entry could not be created}
begin
 {}
 Result:=TimerCreate(interval,enabled,reschedule,event,data);
end;

{==============================================================================}

function timer_create_ex(interval, state, flags: uint32_t; event: timer_event_proc; data: PVOID): TIMER_HANDLE; stdcall;
{Create and insert a new Timer entry}
{Interval: Number of milliseconds between timer events}
{State: State of timer entry (eg TIMER_STATE_ENABLED)}
{Flags: Flags of timer entry (eg TIMER_FLAG_RESCHEDULE)}
{Event: The function to call when the timer event is generated}
{Data: Data to be passed to the function when the timer event is generated (May be nil)}
{Return: Handle of new Timer entry or INVALID_HANDLE_VALUE if entry could not be created}
begin
 {}
 Result:=TimerCreateEx(interval,state,flags,event,data);
end;

{==============================================================================}

function timer_destroy(timer: TIMER_HANDLE): uint32_t; stdcall;
{Destroy and remove an existing Timer entry}
{Timer: Handle of Timer entry to destroy}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=TimerDestroy(timer);
end;

{==============================================================================}

function timer_enable(timer: TIMER_HANDLE): uint32_t; stdcall;
{Enable an existing Timer entry (Timer events will be generated)}
{Timer: Handle of Timer entry to enable}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=TimerEnable(timer);
end;

{==============================================================================}

function timer_enable_ex(timer: TIMER_HANDLE; interval: uint32_t; event: timer_event_proc; data: PVOID): uint32_t; stdcall;
{Enable and update an existing Timer entry (Timer events will be generated)}
{Timer: Handle of Timer entry to enable}
{Interval: Number of milliseconds between timer events}
{Event: The function to call when the timer event is generated}
{Data: Data to be passed to the function when the timer event is generated (May be nil)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=TimerEnableEx(timer,interval,event,data);
end;

{==============================================================================}

function timer_disable(timer: TIMER_HANDLE): uint32_t; stdcall;
{Disable an existing Timer entry (Timer events will not be generated)}
{Timer: Handle of Timer entry to disable}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=TimerDisable(timer);
end;

{==============================================================================}

function timer_dequeue: TIMER_HANDLE; stdcall;
{Get and remove the first timer from the Timer list}
{Return: Handle of dequeued Timer or INVALID_HANDLE_VALUE on failure}
begin
 {}
 Result:=TimerDequeue;
end;

{==============================================================================}

function timer_first_key: int; stdcall;
{Get the first Key value from the Timer list}
{Return: First Key value from timer list or TIMER_KEY_NONE on failure}
begin
 {}
 Result:=TimerFirstKey;
end;

{==============================================================================}

function timer_insert_key(timer: TIMER_HANDLE; key: int): uint32_t; stdcall;
{Insert the supplied timer in the Timer list in delta ascending order based on Key}
{Timer: Handle of timer to be inserted}
{Key: The key to order the insertion on}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Caller must hold the lock on the timer}
begin
 {}
 Result:=TimerInsertKey(timer,key);
end;

{==============================================================================}

function timer_delete_key(timer: TIMER_HANDLE): uint32_t; stdcall;
{Delete the supplied timer from the Timer list}
{Timer: Handle of timer to be deleted}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Caller must hold the lock on the timer}
begin
 {}
 Result:=TimerDeleteKey(timer);
end;

{==============================================================================}

function timer_decrement_key: int; stdcall;
{Decrement the first Key value in the Timer list}
{Return: First Key value in timer list after decrement or TIMER_KEY_NONE on failure}
begin
 {}
 Result:=TimerDecrementKey;
end;

{==============================================================================}

function timer_is_empty: BOOL; stdcall;
{Check if the Timer list is empty}
{Return: True if Timer list is empty or does not exist, False if Timer list is not empty}
begin
 {}
 Result:=TimerIsEmpty;
end;

{==============================================================================}

function timer_not_empty: BOOL; stdcall;
{Check if the Timer list is not empty}
{Return: True if Timer list is not empty, False if Timer list is empty or does not exist}
begin
 {}
 Result:=TimerNotEmpty;
end;

{==============================================================================}

function timer_check: uint32_t; stdcall;
{Check if the timer list is empty, if not then decrement the first key

 If the key reaches zero, return success to indicate there are timers to
 be triggered}
{Return: ERROR_SUCCESS if the first key is zero, ERROR_NO_MORE_ITEMS if list is empty or another error code on failure}
{Note: Called by clock interrupt with IRQ or FIQ disabled and running on the IRQ or FIQ thread}
begin
 {}
 Result:=TimerCheck;
end;

{==============================================================================}

function timer_trigger: uint32_t; stdcall;
{Remove all entries from the timer list that have reached their interval

 For each timer a message will be sent to the Timer thread to call the event}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Called by clock interrupt with IRQ or FIQ disabled and running on the IRQ or FIQ thread}
begin
 {}
 Result:=TimerTrigger;
end;

{==============================================================================}
{Worker Functions}
function worker_schedule(interval: uint32_t; task: worker_task_proc; data: PVOID; callback: worker_cb): uint32_t; stdcall;
{Schedule a task to be performed by a worker thread now or in the future}
{Interval: The number of milliseconds before the task is to be performed (0 for immediate)}
{Task: The function to be called by the worker when the interval has elapsed}
{Data: A pointer to user defined data which will be passed to the task function (Optional)}
{Callback: The function to be called by the worker when the task has completed (Optional)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=WorkerSchedule(interval,task,data,callback);
end;

{==============================================================================}

function worker_schedule_ex(interval, flags: uint32_t; task: worker_task_proc; data: PVOID; callback: worker_cb): WORKER_HANDLE; stdcall;
{Schedule a task to be performed by a worker thread now or in the future}
{Interval: The number of milliseconds before the task is to be performed (0 for immediate)}
{Flags: The flags for the task (eg WORKER_FLAG_RESCHEDULE)}
{Task: The function to be called by the worker when the interval has elapsed}
{Data: A pointer to user defined data which will be passed to the task function (Optional)}
{Callback: The function to be called by the worker when the task has completed (Optional)}
{Return: Handle of new Worker task or INVALID_HANDLE_VALUE if task could not be created}
{Note: If the flags do not contain WORKER_FLAG_RESCHEDULE then return will be ERROR_SUCCESS}
begin
 {}
 Result:=WorkerScheduleEx(interval,flags,task,data,callback);
end;

{==============================================================================}

function worker_cancel(worker: WORKER_HANDLE): uint32_t; stdcall;
{Cancel a previously scheduled worker thread task}
{Worker: The handle of the worker task to cancel}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=WorkerCancel(worker);
end;

{==============================================================================}

function worker_schedule_irq(affinity: uint32_t; task: worker_task_proc; data: PVOID; callback: worker_cb): uint32_t; stdcall;
{Schedule a task to be performed by a worker thread when the caller is an IRQ handler}
{Affinity: CPU Affinity for memory allocation (eg CPU_AFFINITY_0 or CPU_AFFINITY_NONE)}
{Task: The function to be called by the worker}
{Data: A pointer to user defined data which will be passed to the task function (Optional)}
{Callback: The function to be called by the worker when the task has completed (Optional)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: The task will be performed immediately, for delayed tasks etc see WorkerSchedule(Ex)}
begin
 {}
 Result:=WorkerScheduleIRQEx(affinity,WORKER_FLAG_NONE,task,data,callback);
end;

{==============================================================================}

function worker_schedule_irq_ex(affinity, flags: uint32_t; task: worker_task_proc; data: PVOID; callback: worker_cb): uint32_t; stdcall;
{Schedule a task to be performed by a worker thread when the caller is an IRQ handler}
{Affinity: CPU Affinity for memory allocation (eg CPU_AFFINITY_0 or CPU_AFFINITY_NONE)}
{Flags: The flags for the task (eg WORKER_FLAG_PRIORITY)}
{Task: The function to be called by the worker}
{Data: A pointer to user defined data which will be passed to the task function (Optional)}
{Callback: The function to be called by the worker when the task has completed (Optional)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: The task will be performed immediately, for delayed tasks etc see WorkerSchedule(Ex)}
begin
 {}
 Result:=WorkerScheduleIRQEx(affinity,flags,task,data,callback);
end;

{==============================================================================}

function worker_schedule_fiq(affinity: uint32_t; task: worker_task_proc; data: PVOID; callback: worker_cb): uint32_t; stdcall;
{Schedule a task to be performed by a worker thread when the caller is an FIQ handler}
{Affinity: CPU Affinity for memory allocation (eg CPU_AFFINITY_0 or CPU_AFFINITY_NONE)}
{Task: The function to be called by the worker}
{Data: A pointer to user defined data which will be passed to the task function (Optional)}
{Callback: The function to be called by the worker when the task has completed (Optional)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: The task will be performed immediately, for delayed tasks etc see WorkerSchedule(Ex)}
begin
 {}
 Result:=WorkerScheduleFIQEx(affinity,WORKER_FLAG_NONE,task,data,callback);
end;

{==============================================================================}

function worker_schedule_fiq_ex(affinity, flags: uint32_t; task: worker_task_proc; data: PVOID; callback: worker_cb): uint32_t; stdcall;
{Schedule a task to be performed by a worker thread when the caller is an FIQ handler}
{Affinity: CPU Affinity for memory allocation (eg CPU_AFFINITY_0 or CPU_AFFINITY_NONE)}
{Flags: The flags for the task (eg WORKER_FLAG_PRIORITY)}
{Task: The function to be called by the worker}
{Data: A pointer to user defined data which will be passed to the task function (Optional)}
{Callback: The function to be called by the worker when the task has completed (Optional)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: The task will be performed immediately, for delayed tasks etc see WorkerSchedule(Ex)}
begin
 {}
 Result:=WorkerScheduleFIQEx(affinity,flags,task,data,callback);
end;

{==============================================================================}

function worker_increase(count: uint32_t): uint32_t; stdcall;
{Increase the number of worker threads available}
{Count: Number of worker threads to increase by}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=WorkerIncreaseEx(count,False);
end;

{==============================================================================}

function worker_increase_ex(count: uint32_t; priority: BOOL): uint32_t; stdcall;
{Increase the number of worker threads available}
{Count: Number of worker threads to increase by}
{Priority: If true increase worker priority threads}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=WorkerIncreaseEx(count,priority);
end;

{==============================================================================}

function worker_decrease(count: uint32_t): uint32_t; stdcall;
{Decrease the number of worker threads available}
{Count: Number of worker threads to decrease by}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=WorkerDecreaseEx(Count,False);
end;

{==============================================================================}

function worker_decrease_ex(count: uint32_t; priority: BOOL): uint32_t; stdcall;
{Decrease the number of worker threads available}
{Count: Number of worker threads to decrease by}
{Priority: If true decrease worker priority threads}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=WorkerDecreaseEx(count,priority);
end;

{==============================================================================}
{Tasker Functions}
function tasker_thread_send_message(thread: THREAD_HANDLE; const message: TTHREAD_MESSAGE): uint32_t; stdcall;
{Perform a ThreadSendMessage() function call using the tasker list}
begin
 {}
 Result:=TaskerThreadSendMessage(thread,message);
end;

{==============================================================================}

function tasker_messageslot_send(messageslot: MESSAGESLOT_HANDLE; const message: TTHREAD_MESSAGE): uint32_t; stdcall;
{Perform a MessageslotSend() function call using the tasker list}
begin
 {}
 Result:=TaskerMessageslotSend(messageslot,message);
end;

{==============================================================================}

function tasker_semaphore_signal(semaphore: SEMAPHORE_HANDLE; count: uint32_t): uint32_t; stdcall;
{Perform a SemaphoreSignal() function call using the tasker list}
begin
 {}
 Result:=TaskerSemaphoreSignal(semaphore,count);
end;

{==============================================================================}

function tasker_completion_reset(completion: COMPLETION_HANDLE): uint32_t; stdcall;
{Perform a CompletionReset() function call using the tasker list}
begin
 {}
 Result:=TaskerCompletionReset(completion);
end;

{==============================================================================}

function tasker_completion_complete(completion: COMPLETION_HANDLE; all: BOOL): uint32_t; stdcall;
{Perform a CompletionComplete() or CompletionCompleteAll() function call using the tasker list}
begin
 {}
 Result:=TaskerCompletionComplete(completion,all);
end;

{==============================================================================}

function tasker_enqueue(task: PTASKER_TASK): uint32_t; stdcall;
{Add the supplied task to the end of the Tasker list}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=TaskerEnqueue(task);
end;

{==============================================================================}

function tasker_dequeue: PTASKER_TASK; stdcall;
{Get and remove the first task from the Tasker list}
{Return: Dequeued Task or nil on failure (or list empty)}
begin
 {}
 Result:=TaskerDequeue;
end;

{==============================================================================}

function tasker_check: uint32_t; stdcall;
{Check if the tasker list is empty or contains tasks}
{Return: ERROR_SUCCESS if the list contains tasks, ERROR_NO_MORE_ITEMS if list is empty or another error code on failure}
{Note: Called by clock interrupt with IRQ or FIQ disabled and running on the IRQ or FIQ thread}
begin
 {}
 Result:=TaskerCheck;
end;

{==============================================================================}

function tasker_trigger: uint32_t; stdcall;
{Dequeue all tasks in the tasker list and perform the requested task for each}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Called by clock interrupt with IRQ or FIQ disabled and running on the IRQ or FIQ thread}
begin
 {}
 Result:=TaskerTrigger;
end;

{==============================================================================}
{RTL Thread Functions}
function begin_thread(signalaction: PVOID; stacksize: SIZE_T; threadfunction: thread_func; threadparameter: PVOID; creationflags: uint32_t; var threadid: TTHREAD_ID): TTHREAD_ID; stdcall;
begin
 {}
 Result:=SysBeginThread(signalaction,stacksize,threadfunction,threadparameter,creationflags,threadid);
end;

{==============================================================================}

function begin_thread_ex(signalaction: PVOID; stacksize: SIZE_T; threadfunction: thread_func; threadparameter: PVOID; creationflags: uint32_t; priority, affinity, cpu: uint32_t; const name: PCHAR; var threadid: TTHREAD_ID): TTHREAD_ID; stdcall;
begin
 {}
 Result:=SysBeginThreadEx(signalaction,stacksize,threadfunction,threadparameter,creationflags,priority,affinity,cpu,name,threadid);
end;

{==============================================================================}

procedure end_thread(exitcode: uint32_t); stdcall;
begin
 {}
 SysEndThread(exitcode);
end;

{==============================================================================}
{Thread Helper Functions}
function spin_get_count: uint32_t; stdcall;
{Get the current spin lock count}
begin
 {}
 Result:=SpinGetCount;
end;

{==============================================================================}

function mutex_get_count: uint32_t; stdcall;
{Get the current mutex count}
begin
 {}
 Result:=MutexGetCount;
end;

{==============================================================================}

function critical_section_get_count: uint32_t; stdcall;
{Get the current critical section count}
begin
 {}
 Result:=CriticalSectionGetCount;
end;

{==============================================================================}

function semaphore_get_count: uint32_t; stdcall;
{Get the current semaphore count}
begin
 {}
 Result:=SemaphoreGetCount;
end;

{==============================================================================}

function synchronizer_get_count: uint32_t; stdcall;
{Get the current synchronizer count}
begin
 {}
 Result:=SynchronizerGetCount;
end;

{==============================================================================}

function condition_get_count: uint32_t; stdcall;
{Get the current condition count}
begin
 {}
 Result:=ConditionGetCount;
end;

{==============================================================================}

function completion_get_count: uint32_t; stdcall;
{Get the current completion count}
begin
 {}
 Result:=CompletionGetCount;
end;

{==============================================================================}

function list_get_count: uint32_t; stdcall;
{Get the current list count}
begin
 {}
 Result:=ListGetCount;
end;

{==============================================================================}

function queue_get_count: uint32_t; stdcall;
{Get the current queue count}
begin
 {}
 Result:=QueueGetCount;
end;

{==============================================================================}

function thread_get_count: uint32_t; stdcall;
{Get the current thread count}
begin
 {}
 Result:=ThreadGetCount;
end;

{==============================================================================}

function thread_tls_get_count: uint32_t; stdcall;
{Get the current thread tls count}
begin
 {}
 Result:=ThreadTlsGetCount;
end;

{==============================================================================}

function thread_allocate_stack(stacksize: uint32_t): PVOID; stdcall;
{Allocate memory for a new thread stack}
{StackSize: Number of bytes requested for new thread stack}
{Return: nil if StackSize was 0 or if there is not enough memory to satisfy the
         request
         Otherwise returns a pointer to the top (highest address) of the newly
         allocated memory region
         This address is the base of the stack which grows down in memory}
begin
 {}
 Result:=ThreadAllocateStack(stacksize);
end;

{==============================================================================}

procedure thread_release_stack(stackbase: PVOID; stacksize: uint32_t); stdcall;
{Release a thread stack allocated with ThreadAllocateStack}
{StackBase: Pointer to the top (highest address) of the thread stack
            (as returned by ThreadAllocateStack}
{StackSize: Size of the thread stack, in bytes (Same value passed to ThreadAllocateStack)}
begin
 {}
 ThreadReleaseStack(stackbase,stacksize);
end;

{==============================================================================}

function thread_setup_stack(stackbase: PVOID; startproc: thread_start_proc; returnproc: thread_end_proc; parameter: PVOID): PVOID; stdcall;
begin
 {}
 if Assigned(ThreadSetupStackHandler) then
  begin
   Result:=ThreadSetupStackHandler(stackbase,startproc,returnproc,parameter);
  end
 else
  begin
   Result:=nil;
  end;
end;

{==============================================================================}

function thread_snapshot_create: PTHREAD_SNAPSHOT; stdcall;
begin
 {}
 Result:=ThreadSnapshotCreate;
end;

{==============================================================================}

function thread_snapshot_destroy(snapshot: PTHREAD_SNAPSHOT): uint32_t; stdcall;
begin
 {}
 Result:=ThreadSnapshotDestroy(snapshot);
end;

{==============================================================================}

function messageslot_get_count: uint32_t; stdcall;
{Get the current messageslot count}
begin
 {}
 Result:=MessageslotGetCount;
end;

{==============================================================================}

function mailslot_get_count: uint32_t; stdcall;
{Get the current mailslot count}
begin
 {}
 Result:=MailslotGetCount;
end;

{==============================================================================}

function buffer_get_count: uint32_t; stdcall;
{Get the current buffer count}
begin
 {}
 Result:=BufferGetCount;
end;

{==============================================================================}

function event_get_count: uint32_t; stdcall;
{Get the current event count}
begin
 {}
 Result:=EventGetCount;
end;

{==============================================================================}

function timer_get_count: uint32_t; stdcall;
{Get the current timer count}
begin
 {}
 Result:=TimerGetCount;
end;

{==============================================================================}

function worker_get_count: uint32_t; stdcall;
{Get the current worker thread count}
begin
 {}
 Result:=WorkerGetCount;
end;

{==============================================================================}

function worker_get_priority_count: uint32_t; stdcall;
{Get the current worker priority thread count}
begin
 {}
 Result:=WorkerGetPriorityCount;
end;

{==============================================================================}

function tasker_get_count: uint32_t; stdcall;
{Get the current tasker count}
begin
 {}
 Result:=TaskerGetCount;
end;

{==============================================================================}

function list_type_to_string(listtype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(ListTypeToString(listtype),_string,len);
end;

{==============================================================================}

function queue_type_to_string(queuetype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(QueueTypeToString(queuetype),_string,len);
end;

{==============================================================================}

function thread_type_to_string(threadtype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(ThreadTypeToString(threadtype),_string,len);
end;

{==============================================================================}

function thread_state_to_string(threadstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(ThreadStateToString(threadstate),_string,len);
end;

{==============================================================================}

function thread_priority_to_string(threadpriority: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(ThreadPriorityToString(threadpriority),_string,len);
end;

{==============================================================================}
{Scheduler Helper Functions}
function scheduler_get_list_flags(listtype: uint32_t): uint32_t; stdcall;
{Get the list flags for the specified type of list}
begin
 {}
 Result:=SchedulerGetListFlags(listtype);
end;

{==============================================================================}

function scheduler_get_queue_flags(queuetype: uint32_t): uint32_t; stdcall;
{Get the queue flags for the specified type of scheduler queue}
begin
 {}
 Result:=SchedulerGetQueueFlags(queuetype);
end;

{==============================================================================}

function scheduler_get_queue_handle(cpuid: uint32_t; queuetype: uint32_t): QUEUE_HANDLE; stdcall;
{Get the queue handle for the specified type of scheduler queue on the specified CPU}
begin
 {}
 Result:=SchedulerGetQueueHandle(cpuid,queuetype);
end;

{==============================================================================}

function scheduler_get_queue_handle_ex(cpuid: uint32_t; priority: uint32_t): QUEUE_HANDLE; stdcall;
{Get the queue handle for the specified thread priority on the specified CPU}
begin
 {}
 Result:=SchedulerGetQueueHandleEx(cpuid,priority);
end;

{==============================================================================}

function scheduler_get_thread_count(cpuid: uint32_t): uint32_t; stdcall;
{Get the thread count for the specified CPU}
begin
 {}
 Result:=SchedulerGetThreadCount(cpuid);
end;

{==============================================================================}

function scheduler_get_thread_quantum(cpuid: uint32_t): uint32_t; stdcall;
{Get the current thread quantum for the specified CPU}
begin
 {}
 Result:=SchedulerGetThreadQuantum(cpuid);
end;

{==============================================================================}

function scheduler_get_thread_handle(cpuid: uint32_t; threadtype: uint32_t): THREAD_HANDLE; stdcall;
{Get the thread handle for the specified type of thread on the specified CPU}
begin
 {}
 Result:=SchedulerGetThreadHandle(cpuid,threadtype);
end;

{==============================================================================}

function scheduler_get_priority_mask(cpuid: uint32_t): uint32_t; stdcall;
{Get the current priority mask for the specified CPU}
begin
 {}
 Result:=SchedulerGetPriorityMask(cpuid);
end;

{==============================================================================}

function scheduler_get_priority_quantum(priority: uint32_t): uint32_t; stdcall;
{Get the scheduler quantum for the specified thread priority}
begin
 {}
 Result:=SchedulerGetPriorityQuantum(priority);
end;

{==============================================================================}

function scheduler_set_priority_quantum(priority, quantum: uint32_t): uint32_t; stdcall;
{Set the scheduler quantum for the specified thread priority}
begin
 {}
 Result:=SchedulerSetPriorityQuantum(priority,quantum);
end;

{==============================================================================}

function scheduler_get_migration_quantum: uint32_t; stdcall;
{Get the current migration quantum}
begin
 {}
 Result:=SchedulerGetMigrationQuantum;
end;

{==============================================================================}

function scheduler_get_starvation_quantum(cpuid: uint32_t): uint32_t; stdcall;
{Get the current starvation quantum for the specified CPU}
begin
 {}
 Result:=SchedulerGetStarvationQuantum(cpuid);
end;

{==============================================================================}

function scheduler_get_thread_next: uint32_t; stdcall;
{Get the next CPU for thread allocation}
begin
 {}
 Result:=SchedulerGetThreadNext;
end;

{==============================================================================}

function scheduler_get_thread_migration: uint32_t; stdcall;
{Get the current thread migration setting}
begin
 {}
 Result:=SchedulerGetThreadMigration;
end;

{==============================================================================}

function scheduler_get_thread_preempt(cpuid: uint32_t): uint32_t; stdcall;
{Get the current thread preempt setting for the specified CPU}
begin
 {}
 Result:=SchedulerGetThreadPreempt(cpuid);
end;

{==============================================================================}

function scheduler_get_thread_allocation(cpuid: uint32_t): uint32_t; stdcall;
{Get the current thread allocation setting for the specified CPU}
begin
 {}
 Result:=SchedulerGetThreadAllocation(cpuid);
end;

{==============================================================================}

function scheduler_migration_to_string(migration: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(SchedulerMigrationToString(migration),_string,len);
end;

{==============================================================================}

function scheduler_preempt_to_string(preempt: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(SchedulerPreemptToString(preempt),_string,len);
end;

{==============================================================================}

function scheduler_allocation_to_string(allocation: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(SchedulerAllocationToString(allocation),_string,len);
end;

{==============================================================================}
{Timer Helper Functions}
function timer_get_list_flags: uint32_t; stdcall;
{Get the lock flags for the timer list}
begin
 {}
 Result:=TimerGetListFlags;
end;

{==============================================================================}

function timer_get_messageslot_flags: uint32_t; stdcall;
{Get the lock flags for the timer messageslot}
begin
 {}
 Result:=TimerGetMessageslotFlags;
end;

{==============================================================================}
{Worker Helper Functions}
function worker_get_messageslot_flags: uint32_t; stdcall;
{Get the lock flags for the worker messageslot}
begin
 {}
 Result:=WorkerGetMessageslotFlags;
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{HeapManager Functions}
{$IFDEF API_EXPORT_HEAP}
function get_mem(size: SIZE_T): PVOID; stdcall;
{Allocate a block of normal memory}
begin
 {}
 Result:=SysGetMem(size);
end;

{==============================================================================}

function get_mem_ex(size: SIZE_T; flags, affinity: uint32_t): PVOID; stdcall;
{Allocate a block of memory with the flags and affinity requested}
begin
 {}
 Result:=GetMemEx(size,flags,affinity);
end;

{==============================================================================}

function get_aligned_mem(size, alignment: SIZE_T): PVOID; stdcall;
{Allocate a block of normal memory aligned on a multiple of the alignment value}
{Note: Alignment must be a power of 2}
begin
 {}
 Result:=GetAlignedMem(size,alignment);
end;

{==============================================================================}

function get_aligned_mem_ex(size, alignment: SIZE_T; flags, affinity: uint32_t): PVOID; stdcall;
{Allocate a block of memory aligned on a multiple of the alignment value with the
 flags and affinity requested}
{Note: Alignment must be a power of 2}
begin
 {}
 Result:=GetAlignedMemEx(size,alignment,flags,affinity);
end;

{==============================================================================}

function get_shared_mem(size: SIZE_T): PVOID; stdcall;
{Allocate a block of shared memory}
begin
 {}
 Result:=GetSharedMem(size);
end;

{==============================================================================}

function get_shared_aligned_mem(size, alignment: SIZE_T): PVOID; stdcall;
{Allocate a block of shared memory aligned on a multiple of the alignment value}
{Note: Alignment must be a power of 2}
begin
 {}
 Result:=GetSharedAlignedMem(size,alignment);
end;

{==============================================================================}

function get_local_mem(size: SIZE_T; affinity: uint32_t): PVOID; stdcall;
{Allocate a block of local memory}
begin
 {}
 Result:=GetLocalMem(size,affinity);
end;

{==============================================================================}

function get_local_aligned_mem(size, alignment: SIZE_T; affinity: uint32_t): PVOID; stdcall;
{Allocate a block of local memory aligned on a multiple of the alignment value}
{Note: Alignment must be a power of 2}
begin
 {}
 Result:=GetLocalAlignedMem(size,alignment,affinity);
end;

{==============================================================================}

function get_code_mem(size: SIZE_T; affinity: uint32_t): PVOID; stdcall;
{Allocate a block of code memory}
begin
 {}
 Result:=GetCodeMem(size,affinity);
end;

{==============================================================================}

function get_code_aligned_mem(size, alignment: SIZE_T; affinity: uint32_t): PVOID; stdcall;
{Allocate a block of code memory aligned on a multiple of the alignment value}
{Note: Alignment must be a power of 2}
begin
 {}
 Result:=GetCodeAlignedMem(size,alignment,affinity);
end;

{==============================================================================}

function get_device_mem(size: SIZE_T): PVOID; stdcall;
{Allocate a block of device memory}
begin
 {}
 Result:=GetDeviceMem(size);
end;

{==============================================================================}

function get_device_aligned_mem(size, alignment: SIZE_T): PVOID; stdcall;
{Allocate a block of device memory aligned on a multiple of the alignment value}
{Note: Alignment must be a power of 2}
begin
 {}
 Result:=GetDeviceAlignedMem(size,alignment);
end;

{==============================================================================}

function get_nocache_mem(size: SIZE_T): PVOID; stdcall;
{Allocate a block of non cached memory}
begin
 {}
 Result:=GetNoCacheMem(size);
end;

{==============================================================================}

function get_nocache_aligned_mem(size, alignment: SIZE_T): PVOID; stdcall;
{Allocate a block of non cached memory aligned on a multiple of the alignment value}
{Note: Alignment must be a power of 2}
begin
 {}
 Result:=GetNoCacheAlignedMem(size,alignment);
end;

{==============================================================================}

function get_nonshared_mem(size: SIZE_T): PVOID; stdcall;
{Allocate a block of non shared memory}
begin
 {}
 Result:=GetNonSharedMem(size);
end;

{==============================================================================}

function get_nonshared_aligned_mem(size, alignment: SIZE_T): PVOID; stdcall;
{Allocate a block of non shared memory aligned on a multiple of the alignment value}
{Note: Alignment must be a power of 2}
begin
 {}
 Result:=GetNonSharedAlignedMem(size,alignment);
end;

{==============================================================================}

function get_irq_mem(size: SIZE_T; affinity: uint32_t): PVOID; stdcall;
{Allocate a block of IRQ memory}
{Note: The memory must be freed using FreeIRQMem}
begin
 {}
 Result:=GetIRQMem(size,affinity);
end;

{==============================================================================}

function get_irq_aligned_mem(size, alignment: SIZE_T; affinity: uint32_t): PVOID; stdcall;
{Allocate a block of IRQ memory aligned on a multiple of the alignment value}
{Note: Alignment must be a power of 2}
{Note: The memory must be freed using FreeIRQMem}
begin
 {}
 Result:=GetIRQAlignedMem(size,alignment,affinity);
end;

{==============================================================================}

function get_fiq_mem(size: SIZE_T; affinity: uint32_t): PVOID; stdcall;
{Allocate a block of FIQ memory}
{Note: The memory must be freed using FreeFIQMem}
begin
 {}
 Result:=GetFIQMem(size,affinity);
end;

{==============================================================================}

function get_fiq_aligned_mem(size, alignment: SIZE_T; affinity: uint32_t): PVOID; stdcall;
{Allocate a block of FIQ memory aligned on a multiple of the alignment value}
{Note: Alignment must be a power of 2}
{Note: The memory must be freed using FreeFIQMem}
begin
 {}
 Result:=GetFIQAlignedMem(size,alignment,affinity);
end;

{==============================================================================}

function free_mem(addr: PVOID): SIZE_T; stdcall;
{Free a block of memory}
begin
 {}
 Result:=SysFreeMem(addr);
end;

{==============================================================================}

function free_irq_mem(addr: PVOID): SIZE_T; stdcall;
{Free a block of IRQ memory}
begin
 {}
 Result:=FreeIRQMem(addr);
end;

{==============================================================================}

function free_fiq_mem(addr: PVOID): SIZE_T; stdcall;
{Free a block of FIQ memory}
begin
 {}
 Result:=FreeFIQMem(addr);
end;

{==============================================================================}

function alloc_mem(size: SIZE_T): PVOID; stdcall;
{Allocate and clear a block of normal memory}
begin
 {}
 Result:=SysAllocMem(size);
end;

{==============================================================================}

function alloc_mem_ex(size: SIZE_T; flags, affinity: uint32_t): PVOID; stdcall;
{Allocate and clear a block of memory with the flags and affinity requested}
begin
 {}
 Result:=AllocMemEx(size,flags,affinity);
end;

{==============================================================================}

function realloc_mem(var addr: PVOID; size: SIZE_T): PVOID; stdcall;
{Reallocate a block of normal memory}
begin
 {}
 Result:=SysReAllocMem(addr,size);
end;

{==============================================================================}

function realloc_mem_ex(var addr: PVOID; size: SIZE_T; flags, affinity: uint32_t): PVOID; stdcall;
{Reallocate a block of memory with the flags and affinity requested}
begin
 {}
 Result:=ReAllocMemEx(addr,size,flags,affinity);
end;

{==============================================================================}

function alloc_aligned_mem(size, alignment: SIZE_T): PVOID; stdcall;
{Allocate and clear a block of normal memory aligned on a multiple of the alignment value}
{Note: Alignment must be a power of 2}
begin
 {}
 Result:=AllocAlignedMem(size,alignment);
end;

{==============================================================================}

function alloc_aligned_mem_ex(size, alignment: SIZE_T; flags, affinity: uint32_t): PVOID; stdcall;
{Allocate and clear a block of normal memory aligned on a multiple of the
 alignment value with the flags and affinity requested}
{Note: Alignment must be a power of 2}
begin
 {}
 Result:=AllocAlignedMemEx(size,alignment,flags,affinity);
end;

{==============================================================================}

function realloc_aligned_mem(var addr: PVOID; size, alignment: SIZE_T): PVOID; stdcall;
{Reallocate a block of normal memory aligned on a multiple of the alignment value}
{Note: Alignment must be a power of 2}
begin
 {}
 Result:=ReAllocAlignedMem(addr,size,alignment);
end;

{==============================================================================}

function realloc_aligned_mem_ex(var addr: PVOID; size, alignment: SIZE_T; flags, affinity: uint32_t): PVOID; stdcall;
{Reallocate a block of memory aligned on a multiple of the alignment value with the
 flags and affinity requested}
{Note: Alignment must be a power of 2}
begin
 {}
 Result:=ReAllocAlignedMemEx(addr,size,alignment,flags,affinity);
end;

{==============================================================================}

function alloc_shared_mem(size: SIZE_T): PVOID; stdcall;
{Allocate and clear a block of shared memory}
begin
 {}
 Result:=AllocSharedMem(size);
end;

{==============================================================================}

function alloc_shared_aligned_mem(size, alignment: SIZE_T): PVOID; stdcall;
{Allocate and clear a block of shared memory aligned on a multiple of the alignment value}
{Note: Alignment must be a power of 2}
begin
 {}
 Result:=AllocSharedAlignedMem(size,alignment);
end;

{==============================================================================}

function realloc_shared_mem(var addr: PVOID; size: SIZE_T): PVOID; stdcall;
{Reallocate a block of shared memory}
begin
 {}
 Result:=ReAllocSharedMem(addr,size);
end;

{==============================================================================}

function realloc_shared_aligned_mem(var addr: PVOID; size, alignment: SIZE_T): PVOID; stdcall;
{Reallocate a block of shared memory aligned on a multiple of the alignment value}
{Note: Alignment must be a power of 2}
begin
 {}
 Result:=ReAllocSharedAlignedMem(addr,size,alignment);
end;

{==============================================================================}

function alloc_local_mem(size: SIZE_T; affinity: uint32_t): PVOID; stdcall;
{Allocate and clear a block of local memory}
begin
 {}
 Result:=AllocLocalMem(size,affinity);
end;

{==============================================================================}

function alloc_local_aligned_mem(size, alignment: SIZE_T; affinity: uint32_t): PVOID; stdcall;
{Allocate and clear a block of local memory aligned on a multiple of the alignment value}
{Note: Alignment must be a power of 2}
begin
 {}
 Result:=AllocLocalAlignedMem(size,alignment,affinity);
end;

{==============================================================================}

function realloc_local_mem(var addr: PVOID; size: SIZE_T; affinity: uint32_t): PVOID; stdcall;
{Reallocate a block of local memory}
begin
 {}
 Result:=ReAllocLocalMem(addr,size,affinity);
end;

{==============================================================================}

function realloc_local_aligned_mem(var addr: PVOID; size, alignment: SIZE_T; affinity: uint32_t): PVOID; stdcall;
{Reallocate a block of local memory aligned on a multiple of the alignment value}
{Note: Alignment must be a power of 2}
begin
 {}
 Result:=ReAllocLocalAlignedMem(addr,size,alignment,affinity);
end;

{==============================================================================}

function alloc_code_mem(size: SIZE_T; affinity: uint32_t): PVOID; stdcall;
{Allocate and clear a block of code memory}
begin
 {}
 Result:=AllocCodeMem(size,affinity);
end;

{==============================================================================}

function alloc_code_aligned_mem(size, alignment: SIZE_T; affinity: uint32_t): PVOID; stdcall;
{Allocate and clear a block of code memory aligned on a multiple of the alignment value}
{Note: Alignment must be a power of 2}
begin
 {}
 Result:=AllocCodeAlignedMem(size,alignment,affinity);
end;

{==============================================================================}

function realloc_code_mem(var addr: PVOID; size: SIZE_T; affinity: uint32_t): PVOID; stdcall;
{Reallocate a block of code memory}
begin
 {}
 Result:=ReAllocCodeMem(addr,size,affinity);
end;

{==============================================================================}

function realloc_code_aligned_mem(var addr: PVOID; size, alignment: SIZE_T; affinity: uint32_t): PVOID; stdcall;
{Reallocate a block of code memory aligned on a multiple of the alignment value}
{Note: Alignment must be a power of 2}
begin
 {}
 Result:=ReAllocCodeAlignedMem(addr,size,alignment,affinity);
end;

{==============================================================================}

function alloc_device_mem(size: SIZE_T): PVOID; stdcall;
{Allocate and clear a block of device memory}
begin
 {}
 Result:=AllocDeviceMem(size);
end;

{==============================================================================}

function alloc_device_aligned_mem(size, alignment: SIZE_T): PVOID; stdcall;
{Allocate and clear a block of device memory aligned on a multiple of the alignment value}
{Note: Alignment must be a power of 2}
begin
 {}
 Result:=AllocDeviceAlignedMem(size,alignment);
end;

{==============================================================================}

function realloc_device_mem(var addr: PVOID; size: SIZE_T): PVOID; stdcall;
{Reallocate a block of device memory}
begin
 {}
 Result:=ReAllocDeviceMem(addr,size);
end;

{==============================================================================}

function realloc_device_aligned_mem(var addr: PVOID; size, alignment: SIZE_T): PVOID; stdcall;
{Reallocate a block of device memory aligned on a multiple of the alignment value}
{Note: Alignment must be a power of 2}
begin
 {}
 Result:=ReAllocDeviceAlignedMem(addr,size,alignment);
end;

{==============================================================================}

function alloc_nocache_mem(size: SIZE_T): PVOID; stdcall;
{Allocate and clear a block of non cached memory}
begin
 {}
 Result:=AllocNoCacheMem(size);
end;

{==============================================================================}

function alloc_nocache_aligned_mem(size, alignment: SIZE_T): PVOID; stdcall;
{Allocate and clear a block of non cached memory aligned on a multiple of the alignment value}
{Note: Alignment must be a power of 2}
begin
 {}
 Result:=AllocNoCacheAlignedMem(size,alignment);
end;

{==============================================================================}

function realloc_nocache_mem(var addr: PVOID; size: SIZE_T): PVOID; stdcall;
{Reallocate a block of non cached memory}
begin
 {}
 Result:=ReAllocNoCacheMem(addr,size);
end;

{==============================================================================}

function realloc_nocache_aligned_mem(var addr: PVOID; size, alignment: SIZE_T): PVOID; stdcall;
{Reallocate a block of non cached memory aligned on a multiple of the alignment value}
{Note: Alignment must be a power of 2}
begin
 {}
 Result:=ReAllocNoCacheAlignedMem(addr,size,alignment);
end;

{==============================================================================}

function alloc_nonshared_mem(size: SIZE_T): PVOID; stdcall;
{Allocate and clear a block of non shared memory}
begin
 {}
 Result:=AllocNonSharedMem(size);
end;

{==============================================================================}

function alloc_nonshared_aligned_mem(size, alignment: SIZE_T): PVOID; stdcall;
{Allocate and clear a block of non shared memory aligned on a multiple of the alignment value}
{Note: Alignment must be a power of 2}
begin
 {}
 Result:=AllocNonSharedAlignedMem(size,alignment);
end;

{==============================================================================}

function realloc_nonshared_mem(var addr: PVOID; size: SIZE_T): PVOID; stdcall;
{Reallocate a block of non shared memory}
begin
 {}
 Result:=ReAllocNonSharedMem(addr,size);
end;

{==============================================================================}

function realloc_nonshared_aligned_mem(var addr: PVOID; size, alignment: SIZE_T): PVOID; stdcall;
{Reallocate a block of non shared memory aligned on a multiple of the alignment value}
{Note: Alignment must be a power of 2}
begin
 {}
 Result:=ReAllocNonSharedAlignedMem(addr,size,alignment);
end;

{==============================================================================}

function alloc_irq_mem(size: SIZE_T; affinity: uint32_t): PVOID; stdcall;
{Allocate and clear a block of IRQ memory}
{Note: The memory must be freed using FreeIRQMem}
begin
 {}
 Result:=AllocIRQMem(size,affinity);
end;

{==============================================================================}

function alloc_irq_aligned_mem(size, alignment: SIZE_T; affinity: uint32_t): PVOID; stdcall;
{Allocate and clear a block of IRQ memory aligned on a multiple of the alignment value}
{Note: Alignment must be a power of 2}
{Note: The memory must be freed using FreeIRQMem}
begin
 {}
 Result:=AllocIRQAlignedMem(size,alignment,affinity);
end;

{==============================================================================}

function realloc_irq_mem(var addr: PVOID; size: SIZE_T; affinity: uint32_t): PVOID; stdcall;
{Reallocate a block of IRQ memory}
{Note: The memory must be freed using FreeIRQMem}
begin
 {}
 Result:=ReAllocIRQMem(addr,size,affinity);
end;

{==============================================================================}

function realloc_irq_aligned_mem(var addr: PVOID; size, alignment: SIZE_T; affinity: uint32_t): PVOID; stdcall;
{Reallocate a block of IRQ memory aligned on a multiple of the alignment value}
{Note: Alignment must be a power of 2}
{Note: The memory must be freed using FreeIRQMem}
begin
 {}
 Result:=ReAllocIRQAlignedMem(addr,size,alignment,affinity);
end;

{==============================================================================}

function alloc_fiq_mem(size: SIZE_T; affinity: uint32_t): PVOID; stdcall;
{Allocate and clear a block of FIQ memory}
{Note: The memory must be freed using FreeFIQMem}
begin
 {}
 Result:=AllocFIQMem(size,affinity);
end;

{==============================================================================}

function alloc_fiq_aligned_mem(size, alignment: SIZE_T; affinity: uint32_t): PVOID; stdcall;
{Allocate and clear a block of FIQ memory aligned on a multiple of the alignment value}
{Note: Alignment must be a power of 2}
{Note: The memory must be freed using FreeFIQMem}
begin
 {}
 Result:=AllocFIQAlignedMem(size,alignment,affinity);
end;

{==============================================================================}

function realloc_fiq_mem(var addr: PVOID; size: SIZE_T; affinity: uint32_t): PVOID; stdcall;
{Reallocate a block of FIQ memory}
{Note: The memory must be freed using FreeFIQMem}
begin
 {}
 Result:=ReAllocFIQMem(addr,size,affinity);
end;

{==============================================================================}

function realloc_fiq_aligned_mem(var addr: PVOID; size, alignment: SIZE_T; affinity: uint32_t): PVOID; stdcall;
{Reallocate a block of FIQ memory aligned on a multiple of the alignment value}
{Note: Alignment must be a power of 2}
{Note: The memory must be freed using FreeFIQMem}
begin
 {}
 Result:=ReAllocFIQAlignedMem(addr,size,alignment,affinity);
end;

{==============================================================================}

function size_mem(addr: PVOID): SIZE_T; stdcall;
{Return the size of an allocated block of memory}
begin
 {}
 Result:=SysSizeMem(addr);
end;

{==============================================================================}

function size_irq_mem(addr: PVOID): SIZE_T; stdcall;
{Return the size of an allocated block of IRQ memory}
begin
 {}
 Result:=SizeIRQMem(addr);
end;

{==============================================================================}

function size_fiq_mem(addr: PVOID): SIZE_T; stdcall;
{Return the size of an allocated block of FIQ memory}
begin
 {}
 Result:=SizeFIQMem(addr);
end;

{==============================================================================}

function mem_flags(addr: PVOID): uint32_t; stdcall;
{Return the flags of an allocated block of memory}
begin
 {}
 Result:=MemFlags(addr);
end;

{==============================================================================}

function mem_flags_irq(addr: PVOID): uint32_t; stdcall;
{Return the flags of an allocated block of IRQ memory}
begin
 {}
 Result:=MemFlagsIRQ(addr);
end;

{==============================================================================}

function mem_flags_fiq(addr: PVOID): uint32_t; stdcall;
{Return the flags of an allocated block of FIQ memory}
begin
 {}
 Result:=MemFlagsFIQ(addr);
end;

{==============================================================================}

function get_heap_status: THEAP_STATUS; stdcall;
begin
 {}
 Result:=SysGetHeapStatus;
end;

{==============================================================================}

function get_fpc_heap_status: TFPC_HEAP_STATUS; stdcall;
begin
 {}
 Result:=SysGetFPCHeapStatus;
end;

{==============================================================================}
{$IFDEF HEAP_STATISTICS}
function get_heap_statistics: THEAP_STATISTICS; stdcall;
{Return detailed statistics for the heap manager}
begin
 {}
 Result:=GetHeapStatistics;
end;
{$ENDIF}
{==============================================================================}

function get_heap_block_count(state: uint32_t): uint32_t; stdcall;
{Get the total number of current heap blocks based on state}
begin
 {}
 Result:=GetHeapBlockCountEx(state,HEAP_FLAG_ALL,CPU_AFFINITY_ALL);
end;

{==============================================================================}

function get_heap_block_count_ex(state, flags, affinity: uint32_t): uint32_t; stdcall;
{Get the number of current heap blocks based on state, flags and affinity}
{Note: This uses the block list (not the Free/Used/Small lists) in order to account for all blocks}
begin
 {}
 Result:=GetHeapBlockCountEx(state,flags,affinity);
end;

{==============================================================================}

function get_heap_block_min(state: uint32_t): uint32_t; stdcall;
{Get the minimum size of current heap blocks based on state}
begin
 {}
 Result:=GetHeapBlockMinEx(state,HEAP_FLAG_ALL,CPU_AFFINITY_ALL);
end;

{==============================================================================}

function get_heap_block_min_ex(state, flags, affinity: uint32_t): uint32_t; stdcall;
{Get the minimum size of current heap blocks based on state, flags and affinity}
{Note: This uses the block list (not the Free/Used/Small lists) in order to account for all blocks}
begin
 {}
 Result:=GetHeapBlockMinEx(state,flags,affinity);
end;

{==============================================================================}

function get_heap_block_max(state: uint32_t): uint32_t; stdcall;
{Get the maximum size of current heap blocks based on state}
begin
 {}
 Result:=GetHeapBlockMaxEx(state,HEAP_FLAG_ALL,CPU_AFFINITY_ALL);
end;

{==============================================================================}

function get_heap_block_max_ex(state, flags, affinity: uint32_t): uint32_t; stdcall;
{Get the maximum size of current heap blocks based on state, flags and affinity}
{Note: This uses the block list (not the Free/Used/Small lists) in order to account for all blocks}
begin
 {}
 Result:=GetHeapBlockMaxEx(state,flags,affinity);
end;

{==============================================================================}

function create_heap_snapshot(state: uint32_t): PHEAP_SNAPSHOT; stdcall;
begin
 {}
 Result:=CreateHeapSnapshot(state);
end;

{==============================================================================}

function create_heap_snapshot_ex(state, flags, affinity: uint32_t): PHEAP_SNAPSHOT; stdcall;
begin
 {}
 Result:=CreateHeapSnapshotEx(state,flags,affinity);
end;

{==============================================================================}

function destroy_heap_snapshot(snapshot: PHEAP_SNAPSHOT): uint32_t; stdcall;
begin
 {}
 Result:=DestroyHeapSnapshot(snapshot);
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{Device Tree Functions}
{$IFDEF API_EXPORT_DEVICE_TREE}
function device_tree_validate(address: SIZE_T; var size: uint32_t): BOOL; stdcall;
{Check the data at the supplied address to determine if it is a valid Device Tree Blob}
{Address: The address to be validated}
{Size: On return contains the total size of the Device Tree Blob if valid}
{Return: True if the address points to a valid Device Tree Blob, False if not}
{Note: Does not overwrite passed Size unless the DTB is valid}
begin
 {}
 Result:=DeviceTreeValidate(address,size);
end;

{==============================================================================}

function device_tree_next_node(parent, previous: THANDLE): THANDLE; stdcall;
{Find the next DTB node within the Device Tree}
{Parent: Handle of the parent node to search in, INVALID_HANDLE_VALUE to search the entire tree}
{Previous: Handle of the node to start from, INVALID_HANDLE_VALUE to start from the root node}
{Return: The handle of the next node in the tree or INVALID_HANDLE_VALUE if no node was found}
begin
 {}
 Result:=DeviceTreeNextNode(parent,previous);
end;

{==============================================================================}

function device_tree_next_property(node, previous: THANDLE): THANDLE; stdcall;
{Find the next DTB property within the specified node of the Device Tree}
{Node: Handle of the node to search in}
{Previous: Handle of the property to start from, INVALID_HANDLE_VALUE to start from the first property}
{Return: The handle of the next property in the node or INVALID_HANDLE_VALUE if no property was found}
begin
 {}
 Result:=DeviceTreeNextProperty(node,previous);
end;

{==============================================================================}

function device_tree_get_node(const path: PCHAR; parent: THANDLE): THANDLE; stdcall;
{Get the handle of the node matching the specified path, optionally within a specified parent}
{Path: The path of the node to find, relative to parent node or fully qualified if parent not specified (eg /chosen or /cpus/cpu0)}
{Parent: Handle of the parent node to search in, INVALID_HANDLE_VALUE to search the entire tree}
{Return: The handle of the node which matches the path or INVALID_HANDLE_VALUE if no node was found}
begin
 {}
 Result:=DeviceTreeGetNode(String(path),parent);
end;

{==============================================================================}

function device_tree_get_property(node: THANDLE; const name: PCHAR): THANDLE; stdcall;
{Get the handle of the property matching the specified name}
{Node: Handle of the node to search in}
{Name: The name of the node to find (eg compatible)}
{Return: The handle of the property which matches the name or INVALID_HANDLE_VALUE if no property was found}
begin
 {}
 Result:=DeviceTreeGetProperty(node,String(name));
end;

{==============================================================================}

function device_tree_get_node_name(handle: THANDLE; name: PCHAR; len: uint32_t): uint32_t; stdcall;
{Get the name of the specified node}
{Handle: The handle of the node to get the name of}
{Return: The name of the specified node or an empty string if the node was not valid}
begin
 {}
 Result:=APIStringToPCharBuffer(DeviceTreeGetNodeName(handle),name,len);
end;

{==============================================================================}

function device_tree_split_node_name(handle: THANDLE; nodename: PCHAR; namelen: uint32_t; unitaddress: PCHAR; addresslen: uint32_t): uint32_t; stdcall;
{Split the name of a node into node name and unit address}
{Handle: The handle of the node to split the name of}
{NodeName: The node name on return or an empty string if the node was not valid}
{UnitAddress: The unit address on return (If applicable)}
var
 Name:String;
 Address:String;
begin
 {}
 DeviceTreeSplitNodeName(handle,Name,Address);

 Result:=APIStringToPCharBuffer(Name,nodename,namelen);
 if Result > namelen then Exit;

 Result:=APIStringToPCharBuffer(Address,unitaddress,addresslen);
end;

{==============================================================================}

function device_tree_get_node_parent(handle: THANDLE): THANDLE; stdcall;
{Get the parent node of the specified node}
{Handle: The handle of the node to get the parent of}
{Return: The handle of the parent node or INVALID_HANDLE_VALUE if the node was not valid}
begin
 {}
 Result:=DeviceTreeGetNodeParent(handle);
end;

{==============================================================================}

function device_tree_get_node_reg_cells(handle: THANDLE; var address, size: uint32_t): BOOL; stdcall;
{Get the #address-cells and #size-cells values that apply to reg properties of the specified node}
{Handle: The handle of the node to get the cell sizes for}
{Address: The #address-cells value on return (or the default value if not found)}
{Size: The #size-cells value on return (or the default value if not found)}
{Return: True if the cell sizes were found or False if the node was not valid}
{Note: The address and size values applicable to a given node will be those
       from a parent node, not those found in the node itself (if present)}
{Note: Used by early stage boot stage processing which must limit the use of strings
       and other memory allocations. This function uses a memory compare for names}
begin
 {}
 Result:=DeviceTreeGetNodeRegCells(handle,address,size);
end;

{==============================================================================}

function device_tree_get_node_range_cells(handle: THANDLE; var parentaddress, nodeaddress, nodesize: uint32_t): BOOL; stdcall;
{Get the #address-cells and #size-cells values that apply to range properties of the specified node}
{Handle: The handle of the node to get the cell sizes for}
{ParentAddress: The #address-cells value from the parent on return (or the default value if not found)}
{NodeAddress: The #address-cells value from this node on return (or the default value if not found)}
{NodeSize: The #size-cells value from this node on return (or the default value if not found)}
{Return: True if the cell sizes were found or False if the node was not valid}
{Note: Range properties use the address value from the parent node and the address and size values
       from the node itself to determine the size of each range}
{Note: Used by early stage boot stage processing which must limit the use of strings
       and other memory allocations. This function uses a memory compare for names}
begin
 {}
 Result:=DeviceTreeGetNodeRangeCells(handle,parentaddress,nodeaddress,nodesize);
end;

{==============================================================================}

function device_tree_get_property_name(handle: THANDLE; name: PCHAR; len: uint32_t): uint32_t; stdcall;
{Get the name of the specified property}
{Handle: The handle of the property to get the name of}
{Return: The name of the specified property or an empty string if the property was not valid}
begin
 {}
 Result:=APIStringToPCharBuffer(DeviceTreeGetPropertyName(handle),name,len);
end;

{==============================================================================}

function device_tree_split_property_name(handle: THANDLE; uniqueprefix: PCHAR; prefixlen: uint32_t; propertyname: PCHAR; namelen: uint32_t): uint32_t; stdcall;
{Split the name of a property into property name and unique prefix}
{Handle: The handle of the property to split the name of}
{UniquePrefix: The unique prefix on return (If applicable)}
{PropertyName: The property name on return or an empty string if the property was not valid}
var
 Prefix:String;
 Name:String;
begin
 {}
 DeviceTreeSplitPropertyName(handle,Prefix,Name);

 Result:=APIStringToPCharBuffer(Prefix,uniqueprefix,prefixlen);
 if Result > namelen then Exit;

 Result:=APIStringToPCharBuffer(Name,propertyname,namelen);
end;

{==============================================================================}

function device_tree_get_property_value(handle: THANDLE): PVOID; stdcall;
{Get a pointer to the raw value of the specified property}
{Handle: The handle of the property to get the value of}
{Return: A pointer to the specified property value or nil if the property was not valid}
{Note: The returned value points to the memory block where device tree is stored and should not be modified or freed}
begin
 {}
 Result:=DeviceTreeGetPropertyValue(handle);
end;

{==============================================================================}

function device_tree_get_property_length(handle: THANDLE): uint32_t; stdcall;
{Get the length of the raw value of the specified property}
{Handle: The handle of the property to get the value length of}
{Return: The length of the specified property value in bytes or -1 if the property was not valid}
begin
 {}
 Result:=DeviceTreeGetPropertyLength(handle);
end;

{==============================================================================}

function device_tree_get_property_string(handle: THANDLE; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Get the value of the specified property as a string}
{Handle: The handle of the property to get the value of}
{Return: A string representation of the value or an empty string if the property was not valid}
begin
 {}
 Result:=APIStringToPCharBuffer(DeviceTreeGetPropertyString(handle),_string,len);
end;

{==============================================================================}

function device_tree_get_property_longword(handle: THANDLE): uint32_t; stdcall;
{Get the value of the specified property as a longword}
{Handle: The handle of the property to get the value of}
{Return: A longword representation of the value or 0 if the property was not valid}
begin
 {}
 Result:=DeviceTreeGetPropertyLongWord(handle);
end;

{==============================================================================}

function device_tree_get_property_quadword(handle: THANDLE): uint64_t; stdcall;
{Get the value of the specified property as a quadword}
{Handle: The handle of the property to get the value of}
{Return: A quadword representation of the value or 0 if the property was not valid}
begin
 {}
 Result:=DeviceTreeGetPropertyQuadWord(handle);
end;

{==============================================================================}
{Device Tree Helper Functions}
function device_tree_get_boot_args: PCHAR; stdcall;
{Return a character pointer to the location of the command line in the device tree blob}
{Note: Intended primarily for use by early boot stage processing which must limit the use of strings
       and other memory allocations. For normal use see DeviceTreeGetNode and DeviceTreeGetProperty}
begin
 {}
 Result:=DeviceTreeGetBootArgs;
end;

{==============================================================================}

function device_tree_get_ramdisk(var address: SIZE_T; var size: uint64_t): BOOL; stdcall;
{Return the address and size of the initial ram disk specified in the device tree blob}
{Address: Used to return the address value}
{Size: Used to return the size value}
{Return: True if an initial ram disk was specified in the device tree, False if not}
{Note: Intended primarily for use by early boot stage processing which must limit the use of strings
       and other memory allocations. For normal use see DeviceTreeGetNode and DeviceTreeGetProperty}
begin
 {}
 Result:=DeviceTreeGetRamdisk(address,size);
end;

{==============================================================================}

function device_tree_get_memory(index: uint32_t; {$IFDEF CPU32}var range: uint32_t; {$ENDIF CPU32}var address: SIZE_T; var size: uint64_t): BOOL; stdcall;
{Return the address and size of a memory block specified in the device tree blob}
{Index: The index of the memory block to return (The first block is 0)}
{Range: Used to return the page range value (If applicable)}
{Address: Used to return the address value}
{Size: Used to return the size value}
{Return: True if the memory block requested was found in the device tree, False if not}
{Note: Intended primarily for use by early boot stage processing which must limit the use of strings
       and other memory allocations. For normal use see DeviceTreeGetNode and DeviceTreeGetProperty}
begin
 {}
 Result:=DeviceTreeGetMemory(index,{$IFDEF CPU32}range,{$ENDIF CPU32}address,size);
end;

{==============================================================================}

function device_tree_get_reservation(index: uint32_t; var address: SIZE_T; var size: uint64_t): BOOL; stdcall;
{Return the address and size of a memory reservation specified in the device tree blob}
{Index: The index of the memory reservation to return (The first reservation is 0)}
{Address: Used to return the address value}
{Size: Used to return the size value}
{Return: True if the memory reservation requested was found in the device tree, False if not}
begin
 {}
 Result:=DeviceTreeGetReservation(index,address,size);
end;

{==============================================================================}
{$IFDEF DEVICE_TREE_ENUMERATION}
function device_tree_log_tree: uint32_t; stdcall;
{Print information about all nodes and properties in the device tree}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=DeviceTreeLogTree;
end;

{==============================================================================}

function device_tree_log_tree_ex(node: THANDLE; output: dtb_log_output_cb; decode: dtb_decode_value_cb; data: PVOID): uint32_t; stdcall;
{Print information about one or all nodes and properties in the device tree with custom value decode callback}
{Node: The node to print information about (INVALID_HANDLE_VALUE for all nodes)}
{Output: The log output callback to print information to (nil to use the default output)}
{Decode: The callback to decode a value into a string (nil to use the default decode)}
{Data: A pointer to caller specific data which should be passed to the callbacks (Optional)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=DeviceTreeLogTreeEx(node,output,decode,data);
end;
{$ENDIF DEVICE_TREE_ENUMERATION}
{$ENDIF}
{==============================================================================}
{==============================================================================}
{Devices Functions}
{$IFDEF API_EXPORT_DEVICES}
function device_create: PDEVICE; stdcall;
{Create a new Device entry}
{Return: Pointer to new Device entry or nil if device could not be created}
begin
 {}
 Result:=DeviceCreateEx(SizeOf(TDEVICE));
end;

{==============================================================================}

function device_create_ex(size: uint32_t): PDEVICE; stdcall;
{Create a new Device entry}
{Size: Size in bytes to allocate for new device (Including the device entry)}
{Return: Pointer to new Device entry or nil if device could not be created}
begin
 {}
 Result:=DeviceCreateEx(size);
end;

{==============================================================================}

function device_destroy(device: PDEVICE): uint32_t; stdcall;
{Destroy an existing Device entry}
{Device: The device to destroy}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=DeviceDestroy(device);
end;

{==============================================================================}

function device_get_name(device: PDEVICE; name: PCHAR; len: uint32_t): uint32_t; stdcall;
{Get the name of the supplied Device}
{Device: The device to get the name from}
{Return: The name of the device or a blank string on error}
begin
 {}
 Result:=APIStringToPCharBuffer(DeviceGetName(device),name,len);
end;

{==============================================================================}

function device_set_name(device: PDEVICE; const name: PCHAR): uint32_t; stdcall;
{Set the name of the supplied Device}
{Device: The device to set the name for}
{Name: The device name to set}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=DeviceSetName(device,String(name));
end;

{==============================================================================}

function device_get_description(device: PDEVICE; name: PCHAR; len: uint32_t): uint32_t; stdcall;
{Get the description of the supplied Device}
{Device: The device to get the description from}
{Return: The description of the device or a blank string on error}
begin
 {}
 Result:=APIStringToPCharBuffer(DeviceGetDescription(device),name,len);
end;

{==============================================================================}

function device_set_description(device: PDEVICE; const description: PCHAR): uint32_t; stdcall;
{Set the description of the supplied Device}
{Device: The device to set the description for}
{Description: The device description to set}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=DeviceSetDescription(device,String(description));
end;

{==============================================================================}

function device_register(device: PDEVICE): uint32_t; stdcall;
{Register a new Device in the Device table}
{Device: The device to register}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=DeviceRegister(device);
end;

{==============================================================================}

function device_deregister(device: PDEVICE): uint32_t; stdcall;
{Deregister a Device from the Device table}
{Device: The device to deregister}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=DeviceDeregister(device);
end;

{==============================================================================}

function device_find(deviceclass, deviceid: uint32_t): PDEVICE; stdcall;
{Find a device by ID in the device table}
{DeviceClass: The class of the device to find (DEVICE_CLASS_ANY for all classes)}
{DeviceId: The ID number of the device to find (DEVICE_ID_ANY for all devices)}
{Return: Pointer to device entry or nil if not found}
begin
 {}
 Result:=DeviceFind(deviceclass,deviceid);
end;

{==============================================================================}

function device_find_by_devicedata(devicedata: PVOID): PDEVICE; stdcall;
{Find a device with matching DeviceData property in the device table}
{DeviceData: The value to match against the DeviceData property}
{Return: Pointer to device entry or nil if not found}
begin
 {}
 Result:=DeviceFindByDeviceData(devicedata);
end;

{==============================================================================}

function device_find_by_name(const name: PCHAR): PDEVICE; stdcall;
{Find a device by name in the device table}
{Name: The name of the device to find (eg Timer0)}
{Return: Pointer to device entry or nil if not found}
begin
 {}
 Result:=DeviceFindByName(String(name));
end;

{==============================================================================}

function device_find_by_name_ex(deviceclass: uint32_t; const name: PCHAR): PDEVICE; stdcall;
{Find a device by class and name in the device table}
{DeviceClass: The class of the device to find (eg DEVICE_CLASS_USB) (DEVICE_CLASS_ANY for all classes)}
{Name: The name of the device to find (eg USB0)}
{Return: Pointer to device entry or nil if not found}
begin
 {}
 Result:=DeviceFindByNameEx(deviceclass,String(name));
end;

{==============================================================================}

function device_find_by_description(const description: PCHAR): PDEVICE; stdcall;
{Find a device by description in the device table}
{Description: The description of the device to find (eg BCM2836 ARM Timer)}
{Return: Pointer to device entry or nil if not found}
begin
 {}
 Result:=DeviceFindByDescription(String(description));
end;

{==============================================================================}

function device_find_by_description_ex(deviceclass: uint32_t; const description: PCHAR): PDEVICE; stdcall;
{Find a device by class and description in the device table}
{DeviceClass: The class of the device to find (eg DEVICE_CLASS_USB) (DEVICE_CLASS_ANY for all classes)}
{Description: The description of the device to find (eg BCM2836 ARM Timer)}
{Return: Pointer to device entry or nil if not found}
begin
 {}
 Result:=DeviceFindByDescriptionEx(deviceclass,String(description));
end;

{==============================================================================}

function device_enumerate(deviceclass: uint32_t; callback: device_enumerate_cb; data: PVOID): uint32_t; stdcall;
{Enumerate all devices in the device table}
{DeviceClass: The class of device to enumerate (DEVICE_CLASS_ANY for all classes)}
{Callback: The callback function to call for each device in the table}
{Data: A private data pointer to pass to callback for each device in the table}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=DeviceEnumerate(deviceclass,callback,data);
end;

{==============================================================================}

function device_notification(device: PDEVICE; deviceclass: uint32_t; callback: device_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall;
{Register a notification for device changes}
{Device: The device to notify changes for (Optional, pass nil for all devices)}
{DeviceClass: The class of device to notify changes for (DEVICE_CLASS_ANY for all classes)}
{Callback: The function to call when a notification event occurs}
{Data: A private data pointer to pass to callback when a notification event occurs}
{Notification: The events to register for notification of (eg DEVICE_NOTIFICATION_REGISTER)}
{Flags: The flags to control the notification (eg NOTIFIER_FLAG_WORKER)}
begin
 {}
 Result:=DeviceNotification(device,deviceclass,callback,data,notification,flags);
end;

{==============================================================================}

function device_firmware_create(deviceclass: uint32_t; const name: PCHAR; buffer: PVOID; size: uint32_t): BOOL; stdcall;
{Create a new block (memory) based firmware entry using the standard block firmware handler}
{DeviceClass: The class of device this firmware applies to (eg DEVICE_CLASS_NETWORK)(or DEVICE_CLASS_ANY for all devices)}
{Buffer: A pointer to a block of memory containing the firmware to be provided to requesting devices}
{Size: The size in bytes of the block pointed to by buffer}
{Return: True if the new firmware entry was added or False on failure}
{Note: Can be used by device drivers to register built in firmware as a device firmware provider}
{Note: The supplied buffer can be statically or dynamically allocated but must not be freed once the device firmware has been created}
begin
 {}
 Result:=DeviceFirmwareCreate(deviceclass,String(name),buffer,size);
end;

{==============================================================================}

function device_firmware_register(deviceclass: uint32_t; const name: PCHAR; handler: device_firmware_handler): THANDLE; stdcall;
{Register a new device firmware handler for acquiring device specific firmware}
{DeviceClass: The class of device this firmware applies to (eg DEVICE_CLASS_NETWORK)(or DEVICE_CLASS_ANY for all devices)}
{Name: The name of the device firmware, device specific may be a filename, a device model, id or type}
{Handler: The handler function which is to be called when a device requests this firmware}
{Return: A handle for the new firmware handler on success or INVALID_HANDLE_VALUE on failure}
{Note: Used by device firmware providers to register firmware for device drivers}
begin
 {}
 Result:=DeviceFirmwareRegister(deviceclass,String(name),handler);
end;

{==============================================================================}

function device_firmware_deregister(handle: THANDLE): uint32_t; stdcall;
{Deregister an existing device firmware handler}
{Handle: The handle returned by Register}
{Return: ERROR_SUCCESS on completion or another error code on failure}
{Note: Used by device firmware providers to deregister firmware for device drivers}
begin
 {}
 Result:=DeviceFirmwareDeregister(handle);
end;

{==============================================================================}

function device_firmware_find(deviceclass: uint32_t; const name: PCHAR): PDEVICE_FIRMWARE; stdcall;
{Find an existing device firmware handler for a specified device}
{DeviceClass: The class of device for the firmware (eg DEVICE_CLASS_NETWORK)(or DEVICE_CLASS_ANY for any class)}
{Name: The name of the device firmware which is a device specific value such as a filename, a device model, id or type}
{Return: A pointer to the device firmware entry which contains the details of the handler}
{Note: Used internally to locate compatible firmware for a device firmware open request}
begin
 {}
 Result:=DeviceFirmwareFind(deviceclass,String(name));
end;

{==============================================================================}

function device_firmware_find_by_handle(handle: THANDLE): PDEVICE_FIRMWARE; stdcall;
{Find an existing device firmware handler from a returned handle}
{Handle: A handle to the firmware returned by Open or Acquire}
{Return: A pointer to the device firmware entry which contains the details of the handler}
{Note: Used internally to locate referenced firmware for a device firmware request}
begin
 {}
 Result:=DeviceFirmwareFindByHandle(handle);
end;

{==============================================================================}

function device_firmware_open(deviceclass: uint32_t; const name: PCHAR; timeout: uint32_t; var handle: THANDLE): uint32_t; stdcall;
{Open the firmware for a specified device from a registered handler}
{DeviceClass: The class of device for the firmware (eg DEVICE_CLASS_NETWORK)(or DEVICE_CLASS_ANY for any class)}
{Name: The name of the device firmware which is a device specific value such as a filename, a device model, id or type}
{Timeout: Number of milliseconds to wait for the device firmware to be ready (0 to not wait, INFINITE to wait forever)}
{Handle: A variable to receive a handle to the firmware on return}
{Return: ERROR_SUCCESS on completion, ERROR_NOT_FOUND if no handler can supply firmware or another error code on failure}
{Note: A handler may return ERROR_NOT_READY if the firmware may be accepted but is not available yet}
begin
 {}
 Result:=DeviceFirmwareOpen(deviceclass,String(name),timeout,handle);
end;

{==============================================================================}

function device_firmware_close(handle: THANDLE): uint32_t; stdcall;
{Close a handle to the firmware for a specified device from a registered handler}
{Handle: The handle to the firmware as returned by Open}
{Return: ERROR_SUCCESS on completion, ERROR_NOT_FOUND if no handler accepts this firmware or another error code on failure}
begin
 {}
 Result:=DeviceFirmwareClose(handle);
end;

{==============================================================================}

function device_firmware_size(handle: THANDLE): int32_t; stdcall;
{Return the size of the firmware for a specified device from a registered handler}
{Handle: The handle to the firmware as returned by Open}
{Return: The size of the firmware on success or -1 on failure}
begin
 {}
 Result:=DeviceFirmwareSize(handle);
end;

{==============================================================================}

function device_firmware_seek(handle: THANDLE; position: int32_t): int32_t; stdcall;
{Seek to a position within the firmware for a specified device from a registered handler}
{Handle: The handle to the firmware as returned by Open}
{Position: The byte position within the firmware to seek to}
{Return: The new position within the firmware on success or -1 on failure}
begin
 {}
 Result:=DeviceFirmwareSeek(handle,position);
end;

{==============================================================================}

function device_firmware_read(handle: THANDLE; buffer: PVOID; count: int32_t): int32_t; stdcall;
{Read into a buffer from the firmware for a specified device from a registered handler}
{Handle: The handle to the firmware as returned by Open}
{Buffer: A pointer to a buffer to receive the data}
{Count: The maximum number of bytes to be read}
{Return: The number of bytes read on success or -1 on failure}
begin
 {}
 Result:=DeviceFirmwareRead(handle,buffer,count);
end;

{==============================================================================}

function device_firmware_acquire(deviceclass: uint32_t; const name: PCHAR; timeout: uint32_t; var handle: THANDLE; var buffer: PVOID; var size: uint32_t): uint32_t; stdcall;
{Acquire a memory block containing the firmware for a specified device from a registered handler}
{DeviceClass: The class of device for the firmware (eg DEVICE_CLASS_NETWORK)(or DEVICE_CLASS_ANY for any class)}
{Name: The name of the device firmware which is a device specific value such as a filename, a device model, id or type}
{Timeout: Number of milliseconds to wait for the device firmware to be ready (0 to not wait, INFINITE to wait forever)}
{Handle: A variable to receive a handle to the firmware on return}
{Buffer: A variable to receive a pointer to the block of memory containing the firmware on return}
{Size: A variable to receive the size of the memory block pointed to by buffer on return}
{Return: ERROR_SUCCESS on completion, ERROR_NOT_FOUND if no handler can supply firmware or another error code on failure}
{Note: A handler may return ERROR_NOT_READY if the firmware may be accepted but is not available yet}
{Note: A handler may return ERROR_MORE_DATA if the size of the firmware is larger than can be returned in a single buffer}
begin
 {}
 Result:=DeviceFirmwareAcquire(deviceclass,String(name),timeout,handle,buffer,size);
end;

{==============================================================================}

function device_firmware_release(handle: THANDLE; buffer: PVOID; size: uint32_t): uint32_t; stdcall;
{Release a memory block containing the firmware for a specified device from a registered handler}
{Handle: The handle to the firmware as returned by Acquire}
{Buffer: The pointer to the block of memory containing the firmware as returned by Acquire}
{Size: The size of the memory block as returned by Acquire}
{Return: ERROR_SUCCESS on completion, ERROR_NOT_FOUND if no handler accepts this firmware or another error code on failure}
begin
 {}
 Result:=DeviceFirmwareRelease(handle,buffer,size);
end;

{==============================================================================}

function notifier_allocate(device: PDEVICE; deviceclass: uint32_t; callback: device_notification_cb; data: PVOID; notification, flags: uint32_t): PNOTIFIER; stdcall;
{Create and Register a new Notifier entry in the Notifier table}
begin
 {}
 Result:=NotifierAllocate(device,deviceclass,callback,data,notification,flags);
end;

{==============================================================================}

function notifier_release(notifier: PNOTIFIER): uint32_t; stdcall;
{Deregister and Destroy a Notifier from the Notifier table}
begin
 {}
 Result:=NotifierRelease(notifier);
end;

{==============================================================================}

function notifier_find(device: PDEVICE; deviceclass: uint32_t; callback: device_notification_cb; data: PVOID): PNOTIFIER; stdcall;
begin
 {}
 Result:=NotifierFind(device,deviceclass,callback,data);
end;

{==============================================================================}

function notifier_notify(device: PDEVICE; notification: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=NotifierNotify(device,notification);
end;

{==============================================================================}

procedure notifier_retry(retry: PNOTIFIER_RETRY); stdcall;
begin
 {}
 NotifierRetry(retry);
end;

{==============================================================================}

procedure notifier_worker(task: PNOTIFIER_TASK); stdcall;
begin
 {}
 NotifierWorker(task);
end;

{==============================================================================}
{Driver Functions}
function driver_create: PDRIVER; stdcall;
{Create a new Driver entry}
{Return: Pointer to new Driver entry or nil if driver could not be created}
begin
 {}
 Result:=DriverCreateEx(SizeOf(TDRIVER));
end;

{==============================================================================}

function driver_create_ex(size: uint32_t): PDRIVER; stdcall;
{Create a new Driver entry}
{Size: Size in bytes to allocate for new driver (Including the driver entry)}
{Return: Pointer to new Driver entry or nil if driver could not be created}
begin
 {}
 Result:=DriverCreateEx(size);
end;

{==============================================================================}

function driver_destroy(driver: PDRIVER): uint32_t; stdcall;
{Destroy an existing Driver entry}
{Driver: The driver to destroy}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=DriverDestroy(driver);
end;

{==============================================================================}

function driver_get_name(driver: PDRIVER; name: PCHAR; len: uint32_t): uint32_t; stdcall;
{Get the name of the supplied Driver}
{Driver: The driver to get the name from}
{Return: The name of the driver or a blank string on error}
begin
 {}
 Result:=APIStringToPCharBuffer(DriverGetName(driver),name,len);
end;

{==============================================================================}

function driver_set_name(driver: PDRIVER; const name: PCHAR): uint32_t; stdcall;
{Set the name of the supplied Driver}
{Driver: The driver to set the name for}
{Name: The driver name to set}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=DriverSetName(driver,String(name));
end;

{==============================================================================}

function driver_register(driver: PDRIVER): uint32_t; stdcall;
{Register a new Driver in the Driver table}
{Driver: The driver to register}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=DriverRegister(driver);
end;

{==============================================================================}

function driver_deregister(driver: PDRIVER): uint32_t; stdcall;
{Deregister a Driver from the Driver table}
{Driver: The driver to deregister}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=DriverDeregister(driver);
end;

{==============================================================================}

function driver_find(driverclass, driverid: uint32_t): PDRIVER; stdcall;
{Find a driver by ID in the driver table}
{DriverClass: The class of the driver to find (DRIVER_CLASS_ANY for all classes)}
{DriverId: The ID number of the driver to find}
{Return: Pointer to driver entry or nil if not found}
begin
 {}
 Result:=DriverFind(driverclass,driverid);
end;

{==============================================================================}

function driver_find_by_name(const name: PCHAR): PDRIVER; stdcall;
{Find a driver by name in the driver table}
{Name: The name of the driver to find (eg USB Hub Driver)}
{Return: Pointer to driver entry or nil if not found}
begin
 {}
 Result:=DriverFindByName(String(name));
end;

{==============================================================================}

function driver_enumerate(driverclass: uint32_t; callback: driver_enumerate_cb; data: PVOID): uint32_t; stdcall;
{Enumerate all drivers in the driver table}
{DriverClass: The class of driver to enumerate (DRIVER_CLASS_ANY for all classes)}
{Callback: The callback function to call for each driver in the table}
{Data: A private data pointer to pass to callback for each driver in the table}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=DriverEnumerate(driverclass,callback,data);
end;

{==============================================================================}
{Clock Device Functions}
function clock_device_start(clock: PCLOCK_DEVICE): uint32_t; stdcall;
{Start the counter of the specified Clock device}
{Clock: The Clock device to start}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ClockDeviceStart(clock);
end;

{==============================================================================}

function clock_device_stop(clock: PCLOCK_DEVICE): uint32_t; stdcall;
{Stop the counter of the specified Clock device}
{Clock: The Clock device to stop}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ClockDeviceStop(clock);
end;

{==============================================================================}

function clock_device_read(clock: PCLOCK_DEVICE): uint32_t; stdcall;
{Read the counter value of the specified Clock device}
{Clock: The Clock device to read from}
{Return: The 32 bit counter value of the clock or 0 on failure}
begin
 {}
 Result:=ClockDeviceRead(clock);
end;

{==============================================================================}

function clock_device_read64(clock: PCLOCK_DEVICE): int64_t; stdcall;
{Read the counter value of the specified Clock device}
{Clock: The Clock device to read from}
{Return: The 64 bit counter value of the clock or 0 on failure}
begin
 {}
 Result:=ClockDeviceRead64(clock);
end;

{==============================================================================}

function clock_device_write64(clock: PCLOCK_DEVICE; const value: int64_t): uint32_t; stdcall;
{Write the counter value of the specified Clock device}
{Clock: The Clock device to write to}
{Value: The counter value to write}
{Return: ERROR_SUCCESS if the counter was set or another error code on failure}

{Note: Not all clock devices support setting the counter value, will return an error if unsupported}
begin
 {}
 Result:=ClockDeviceWrite64(clock,value);
end;

{==============================================================================}

function clock_device_get_rate(clock: PCLOCK_DEVICE): uint32_t; stdcall;
{Get the current clock rate in Hz of the specified Clock device}
{Clock: The Clock device to get the rate from}
{Return: The current clock rate in Hz or 0 on failure}
begin
 {}
 Result:=ClockDeviceGetRate(clock);
end;

{==============================================================================}

function clock_device_set_rate(clock: PCLOCK_DEVICE; rate: uint32_t): uint32_t; stdcall;
{Set the current clock rate in Hz of the specified Clock device}
{Clock: The Clock device to set the rate for}
{Rate: The clock rate in Hz to set}
{Return: ERROR_SUCCESS if the clock rate was set or another error code on failure}

{Note: Not all clock devices support setting the clock rate, will return an error if unsupported}
begin
 {}
 Result:=ClockDeviceSetRate(clock,rate);
end;

{==============================================================================}

function clock_device_properties(clock: PCLOCK_DEVICE; properties: PCLOCK_PROPERTIES): uint32_t; stdcall;
{Get the properties for the specified Clock device}
{Clock: The Clock device to get properties from}
{Properties: Pointer to a TClockProperties structure to fill in}
{Return: ERROR_SUCCESS if completed or another error code on failure}

{Note: Replaced by ClockDeviceGetProperties for consistency}
begin
 {}
 Result:=ClockDeviceGetProperties(clock,properties);
end;

{==============================================================================}

function clock_device_get_properties(clock: PCLOCK_DEVICE; properties: PCLOCK_PROPERTIES): uint32_t; stdcall;
{Get the properties for the specified Clock device}
{Clock: The Clock device to get properties from}
{Properties: Pointer to a TClockProperties structure to fill in}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ClockDeviceGetProperties(clock,properties);
end;

{==============================================================================}

function clock_device_create: PCLOCK_DEVICE; stdcall;
{Create a new Clock entry}
{Return: Pointer to new Clock entry or nil if Clock could not be created}
begin
 {}
 Result:=ClockDeviceCreateEx(SizeOf(TCLOCK_DEVICE));
end;

{==============================================================================}

function clock_device_create_ex(size: uint32_t): PCLOCK_DEVICE; stdcall;
{Create a new Clock entry}
{Size: Size in bytes to allocate for new Clock (Including the Clock entry)}
{Return: Pointer to new Clock entry or nil if Clock could not be created}
begin
 {}
 Result:=ClockDeviceCreateEx(size);
end;

{==============================================================================}

function clock_device_destroy(clock: PCLOCK_DEVICE): uint32_t; stdcall;
{Destroy an existing Clock entry}
{Clock: The clock device to destroy}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ClockDeviceDestroy(clock);
end;

{==============================================================================}

function clock_device_register(clock: PCLOCK_DEVICE): uint32_t; stdcall;
{Register a new Clock in the Clock table}
{Clock: The clock device to register}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ClockDeviceRegister(clock);
end;

{==============================================================================}

function clock_device_deregister(clock: PCLOCK_DEVICE): uint32_t; stdcall;
{Deregister a Clock from the Clock table}
{Clock: The clock device to deregister}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ClockDeviceDeregister(clock);
end;

{==============================================================================}

function clock_device_find(clockid: uint32_t): PCLOCK_DEVICE; stdcall;
{Find a clock device by ID in the clock table}
{ClockId: The ID number of the clock to find}
{Return: Pointer to clock device entry or nil if not found}
begin
 {}
 Result:=ClockDeviceFind(clockid);
end;

{==============================================================================}

function clock_device_find_by_name(const name: PCHAR): PCLOCK_DEVICE; stdcall;
{Find a clock device by name in the clock table}
{Name: The name of the clock to find (eg Clock0)}
{Return: Pointer to clock device entry or nil if not found}
begin
 {}
 Result:=ClockDeviceFindByName(String(name));
end;

{==============================================================================}

function clock_device_find_by_description(const description: PCHAR): PCLOCK_DEVICE; stdcall;
{Find a clock device by description in the clock table}
{Description: The description of the clock to find (eg BCM2836 ARM Timer Clock)}
{Return: Pointer to clock device entry or nil if not found}
begin
 {}
 Result:=ClockDeviceFindByDescription(String(description));
end;

{==============================================================================}

function clock_device_enumerate(callback: clock_enumerate_cb; data: PVOID): uint32_t; stdcall;
{Enumerate all clock devices in the clock table}
{Callback: The callback function to call for each clock in the table}
{Data: A private data pointer to pass to callback for each clock in the table}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ClockDeviceEnumerate(callback,data);
end;

{==============================================================================}

function clock_device_notification(clock: PCLOCK_DEVICE; callback: clock_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall;
{Register a notification for clock device changes}
{Clock: The clock device to notify changes for (Optional, pass nil for all clocks)}
{Callback: The function to call when a notification event occurs}
{Data: A private data pointer to pass to callback when a notification event occurs}
{Notification: The events to register for notification of (eg DEVICE_NOTIFICATION_REGISTER)}
{Flags: The flags to control the notification (eg NOTIFIER_FLAG_WORKER)}
begin
 {}
 Result:=ClockDeviceNotification(clock,callback,data,notification,flags);
end;

{==============================================================================}
{Timer Device Functions}
function timer_device_start(timer: PTIMER_DEVICE): uint32_t; stdcall;
{Start the clock and counter of the specified Timer device}
{Timer: The Timer device to start}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=TimerDeviceStart(timer);
end;

{==============================================================================}

function timer_device_stop(timer: PTIMER_DEVICE): uint32_t; stdcall;
{Stop the clock and counter of the specified Timer device}
{Timer: The Timer device to stop}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=TimerDeviceStop(timer);
end;

{==============================================================================}

function timer_device_read(timer: PTIMER_DEVICE): uint32_t; stdcall;
{Read the current value of the specified Timer device}
{Timer: The Timer device to read from}
{Return: The 32 bit current value of the timer or 0 on failure}
begin
 {}
 Result:=TimerDeviceRead(timer);
end;

{==============================================================================}

function timer_device_read64(timer: PTIMER_DEVICE): int64_t; stdcall;
{Read the current value of the specified Timer device}
{Timer: The Timer device to read from}
{Return: The 64 bit current value of the timer or 0 on failure}
begin
 {}
 Result:=TimerDeviceRead64(timer);
end;

{==============================================================================}

function timer_device_wait(timer: PTIMER_DEVICE): uint32_t; stdcall;
{Wait for the current interval to expire on the specified Timer device}
{Timer: The Timer device to wait for}
{Return: ERROR_SUCCESS if the interval expired or another error code on failure}
begin
 {}
 Result:=TimerDeviceWait(timer);
end;

{==============================================================================}

function timer_device_event(timer: PTIMER_DEVICE; flags: uint32_t; callback: timer_cb; data: PVOID): uint32_t; stdcall;
{Schedule a function to be called when the current interval expires on the specified Timer device}
{Timer: The Timer device to schedule the callback for}
{Flags: The flags to control the event (eg TIMER_EVENT_FLAG_REPEAT)}
{Callback: The function to be called when the interval expires}
{Data: A pointer to be passed to the function when the interval expires (Optional)}
{Return: ERROR_SUCCESS if the callback was scheduled successfully or another error code on failure}
begin
 {}
 Result:=TimerDeviceEvent(timer,flags,callback,data);
end;

{==============================================================================}

function timer_device_cancel(timer: PTIMER_DEVICE): uint32_t; stdcall;
{Cancel a previously scheduled event callback function on the specified Timer device}
{Timer: The Timer device to cancel the callback for}
{Return: ERROR_SUCCESS if the callback was cancelled successfully or another error code on failure}
begin
 {}
 Result:=TimerDeviceCancel(timer);
end;

{==============================================================================}

function timer_device_get_rate(timer: PTIMER_DEVICE): uint32_t; stdcall;
{Get the current clock rate in Hz of the specified Timer device}
{Timer: The Timer device to get the rate from}
{Return: The current clock rate in Hz or 0 on failure}
begin
 {}
 Result:=TimerDeviceGetRate(timer);
end;

{==============================================================================}

function timer_device_set_rate(timer: PTIMER_DEVICE; rate: uint32_t): uint32_t; stdcall;
{Set the current clock rate in Hz of the specified Timer device}
{Timer: The Timer device to set the rate for}
{Rate: The clock rate in Hz to set}
{Return: ERROR_SUCCESS if the clock rate was set or another error code on failure}
begin
 {}
 Result:=TimerDeviceSetRate(timer,rate);
end;

{==============================================================================}

function timer_device_get_interval(timer: PTIMER_DEVICE): uint32_t; stdcall;
{Get the current interval in ticks of the specified Timer device}
{Timer: The Timer device to get the interval from}
{Return: The current interval in ticks or 0 on failure (or not set)}

{Note: The tick rate is determined by the clock rate}
begin
 {}
 Result:=TimerDeviceGetInterval(timer);
end;

{==============================================================================}

function timer_device_set_interval(timer: PTIMER_DEVICE; interval: uint32_t): uint32_t; stdcall;
{Set the current interval in ticks of the specified Timer device}
{Timer: The Timer device to set the interval for}
{Interval: The interval in ticks to set}
{Return: ERROR_SUCCESS if the interval was set or another error code on failure}

{Note: The tick rate is determined by the clock rate}
begin
 {}
 Result:=TimerDeviceSetInterval(timer,interval);
end;

{==============================================================================}

function timer_device_properties(timer: PTIMER_DEVICE; properties: PTIMER_PROPERTIES): uint32_t; stdcall;
{Get the properties for the specified Timer device}
{Timer: The Timer device to get properties from}
{Properties: Pointer to a TTimerProperties structure to fill in}
{Return: ERROR_SUCCESS if completed or another error code on failure}

{Note: Replaced by TimerDeviceGetProperties for consistency}
begin
 {}
 Result:=TimerDeviceGetProperties(timer,properties);
end;

{==============================================================================}

function timer_device_get_properties(timer: PTIMER_DEVICE; properties: PTIMER_PROPERTIES): uint32_t; stdcall;
{Get the properties for the specified Timer device}
{Timer: The Timer device to get properties from}
{Properties: Pointer to a TTimerProperties structure to fill in}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=TimerDeviceGetProperties(timer,properties);
end;

{==============================================================================}

function timer_device_create: PTIMER_DEVICE; stdcall;
{Create a new Timer entry}
{Return: Pointer to new Timer entry or nil if Timer could not be created}
begin
 {}
 Result:=TimerDeviceCreateEx(SizeOf(TTIMER_DEVICE));
end;

{==============================================================================}

function timer_device_create_ex(size: uint32_t): PTIMER_DEVICE; stdcall;
{Create a new Timer entry}
{Size: Size in bytes to allocate for new Timer (Including the Timer entry)}
{Return: Pointer to new Timer entry or nil if Timer could not be created}
begin
 {}
 Result:=TimerDeviceCreateEx(size);
end;

{==============================================================================}

function timer_device_destroy(timer: PTIMER_DEVICE): uint32_t; stdcall;
{Destroy an existing Timer entry}
{Timer: The timer device to destroy}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=TimerDeviceDestroy(timer);
end;

{==============================================================================}

function timer_device_register(timer: PTIMER_DEVICE): uint32_t; stdcall;
{Register a new Timer in the Timer table}
{Timer: The timer device to register}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=TimerDeviceRegister(timer);
end;

{==============================================================================}

function timer_device_deregister(timer: PTIMER_DEVICE): uint32_t; stdcall;
{Deregister a Timer from the Timer table}
{Timer: The timer device to deregister}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=TimerDeviceDeregister(timer);
end;

{==============================================================================}

function timer_device_find(timerid: uint32_t): PTIMER_DEVICE; stdcall;
{Find a timer device by ID in the timer table}
{TimerId: The ID number of the timer to find}
{Return: Pointer to timer device entry or nil if not found}
begin
 {}
 Result:=TimerDeviceFind(timerid);
end;

{==============================================================================}

function timer_device_find_by_name(const name: PCHAR): PTIMER_DEVICE; stdcall;
{Find a timer device by name in the timer table}
{Name: The name of the timer to find (eg Timer0)}
{Return: Pointer to timer device entry or nil if not found}
begin
 {}
 Result:=TimerDeviceFindByName(String(name));
end;

{==============================================================================}

function timer_device_find_by_description(const description: PCHAR): PTIMER_DEVICE; stdcall;
{Find a timer device by description in the timer table}
{Description: The description of the timer to find (eg BCM2836 ARM Timer)}
{Return: Pointer to timer device entry or nil if not found}
begin
 {}
 Result:=TimerDeviceFindByDescription(String(description));
end;

{==============================================================================}

function timer_device_enumerate(callback: timer_enumerate_cb; data: PVOID): uint32_t; stdcall;
{Enumerate all timer devices in the timer table}
{Callback: The callback function to call for each timer in the table}
{Data: A private data pointer to pass to callback for each timer in the table}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=TimerDeviceEnumerate(callback,data);
end;

{==============================================================================}

function timer_device_notification(timer: PTIMER_DEVICE; callback: timer_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall;
{Register a notification for timer device changes}
{Timer: The timer device to notify changes for (Optional, pass nil for all timers)}
{Callback: The function to call when a notification event occurs}
{Data: A private data pointer to pass to callback when a notification event occurs}
{Notification: The events to register for notification of (eg DEVICE_NOTIFICATION_REGISTER)}
{Flags: The flags to control the notification (eg NOTIFIER_FLAG_WORKER)}
begin
 {}
 Result:=TimerDeviceNotification(timer,callback,data,notification,flags);
end;

{==============================================================================}
{Random Device Functions}
function random_device_start(random: PRANDOM_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=RandomDeviceStart(random);
end;

{==============================================================================}

function random_device_stop(random: PRANDOM_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=RandomDeviceStop(random);
end;

{==============================================================================}

function random_device_seed(random: PRANDOM_DEVICE; seed: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=RandomDeviceSeed(random,seed);
end;

{==============================================================================}

function random_device_read_byte(random: PRANDOM_DEVICE): uint8_t; stdcall;
begin
 {}
 Result:=RandomDeviceReadByte(random);
end;

{==============================================================================}

function random_device_read_word(random: PRANDOM_DEVICE): uint16_t; stdcall;
begin
 {}
 Result:=RandomDeviceReadWord(random);
end;

{==============================================================================}

function random_device_read_longword(random: PRANDOM_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=RandomDeviceReadLongWord(random);
end;

{==============================================================================}

function random_device_read_quadword(random: PRANDOM_DEVICE): int64_t; stdcall;
begin
 {}
 Result:=RandomDeviceReadQuadWord(random);
end;

{==============================================================================}

function random_device_read_double(random: PRANDOM_DEVICE): double_t; stdcall;
begin
 {}
 Result:=RandomDeviceReadDouble(random);
end;

{==============================================================================}

function random_device_read_extended(random: PRANDOM_DEVICE): double_t; stdcall;
{Note: Replaced by RandomDeviceReadDouble}
begin
 {}
 Result:=RandomDeviceReadDouble(random);
end;

{==============================================================================}

function random_device_create: PRANDOM_DEVICE; stdcall;
{Create a new Random entry}
{Return: Pointer to new Random entry or nil if Random could not be created}
begin
 {}
 Result:=RandomDeviceCreateEx(SizeOf(TRANDOM_DEVICE));
end;

{==============================================================================}

function random_device_create_ex(size: uint32_t): PRANDOM_DEVICE; stdcall;
{Create a new Random entry}
{Size: Size in bytes to allocate for new Random (Including the Random entry)}
{Return: Pointer to new Random entry or nil if Random could not be created}
begin
 {}
 Result:=RandomDeviceCreateEx(size);
end;

{==============================================================================}

function random_device_destroy(random: PRANDOM_DEVICE): uint32_t; stdcall;
{Destroy an existing Random entry}
begin
 {}
 Result:=RandomDeviceDestroy(random);
end;

{==============================================================================}

function random_device_register(random: PRANDOM_DEVICE): uint32_t; stdcall;
{Register a new Random in the Random table}
begin
 {}
 Result:=RandomDeviceRegister(random);
end;

{==============================================================================}

function random_device_deregister(random: PRANDOM_DEVICE): uint32_t; stdcall;
{Deregister a Random from the Random table}
begin
 {}
 Result:=RandomDeviceDeregister(random);
end;

{==============================================================================}

function random_device_find(randomid: uint32_t): PRANDOM_DEVICE; stdcall;
begin
 {}
 Result:=RandomDeviceFind(randomid);
end;

{==============================================================================}

function random_device_find_by_name(const name: PCHAR): PRANDOM_DEVICE; stdcall;
begin
 {}
 Result:=RandomDeviceFindByName(String(name));
end;

{==============================================================================}

function random_device_find_by_description(const description: PCHAR): PRANDOM_DEVICE; stdcall;
begin
 {}
 Result:=RandomDeviceFindByDescription(String(description));
end;

{==============================================================================}

function random_device_enumerate(callback: random_enumerate_cb; data: PVOID): uint32_t; stdcall;
begin
 {}
 Result:=RandomDeviceEnumerate(callback,data);
end;

{==============================================================================}

function random_device_notification(random: PRANDOM_DEVICE; callback: random_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=RandomDeviceNotification(random,callback,data,notification,flags);
end;

{==============================================================================}
{Mailbox Device Functions}
function mailbox_device_start(mailbox: PMAILBOX_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=MailboxDeviceStart(mailbox);
end;

{==============================================================================}

function mailbox_device_stop(mailbox: PMAILBOX_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=MailboxDeviceStop(mailbox);
end;

{==============================================================================}

function mailbox_device_receive(mailbox: PMAILBOX_DEVICE; channel: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=MailboxDeviceReceive(mailbox,channel);
end;

{==============================================================================}

function mailbox_device_send(mailbox: PMAILBOX_DEVICE; channel, data: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=MailboxDeviceSend(mailbox,channel,data);
end;

{==============================================================================}

function mailbox_device_call(mailbox: PMAILBOX_DEVICE; channel, data: uint32_t; var response: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=MailboxDeviceCall(mailbox,channel,data,response);
end;

{==============================================================================}

function mailbox_device_get_timeout(mailbox: PMAILBOX_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=MailboxDeviceGetTimeout(mailbox);
end;

{==============================================================================}

function mailbox_device_set_timeout(mailbox: PMAILBOX_DEVICE; timeout: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=MailboxDeviceSetTimeout(mailbox,timeout);
end;

{==============================================================================}

function mailbox_device_create: PMAILBOX_DEVICE; stdcall;
{Create a new Mailbox entry}
{Return: Pointer to new Mailbox entry or nil if Mailbox could not be created}
begin
 {}
 Result:=MailboxDeviceCreateEx(SizeOf(TMAILBOX_DEVICE));
end;

{==============================================================================}

function mailbox_device_create_ex(size: uint32_t): PMAILBOX_DEVICE; stdcall;
{Create a new Mailbox entry}
{Size: Size in bytes to allocate for new Mailbox (Including the Mailbox entry)}
{Return: Pointer to new Mailbox entry or nil if Mailbox could not be created}
begin
 {}
 Result:=MailboxDeviceCreateEx(size);
end;

{==============================================================================}

function mailbox_device_destroy(mailbox: PMAILBOX_DEVICE): uint32_t; stdcall;
{Destroy an existing Mailbox entry}
begin
 {}
 Result:=MailboxDeviceDestroy(mailbox);
end;

{==============================================================================}

function mailbox_device_register(mailbox: PMAILBOX_DEVICE): uint32_t; stdcall;
{Register a new Mailbox in the Mailbox table}
begin
 {}
 Result:=MailboxDeviceRegister(mailbox);
end;

{==============================================================================}

function mailbox_device_deregister(mailbox: PMAILBOX_DEVICE): uint32_t; stdcall;
{Deregister a Mailbox from the Mailbox table}
begin
 {}
 Result:=MailboxDeviceDeregister(mailbox);
end;

{==============================================================================}

function mailbox_device_find(mailboxid: uint32_t): PMAILBOX_DEVICE; stdcall;
begin
 {}
 Result:=MailboxDeviceFind(mailboxid);
end;

{==============================================================================}

function mailbox_device_find_by_name(const name: PCHAR): PMAILBOX_DEVICE; stdcall;
begin
 {}
 Result:=MailboxDeviceFindByName(String(name));
end;

{==============================================================================}

function mailbox_device_find_by_description(const description: PCHAR): PMAILBOX_DEVICE; stdcall;
begin
 {}
 Result:=MailboxDeviceFindByDescription(String(description));
end;

{==============================================================================}

function mailbox_device_enumerate(callback: mailbox_enumerate_cb; data: PVOID): uint32_t; stdcall;
begin
 {}
 Result:=MailboxDeviceEnumerate(callback,data);
end;

{==============================================================================}

function mailbox_device_notification(mailbox: PMAILBOX_DEVICE; callback: mailbox_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=MailboxDeviceNotification(mailbox,callback,data,notification,flags);
end;

{==============================================================================}
{Watchdog Device Functions}
function watchdog_device_start(watchdog: PWATCHDOG_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=WatchdogDeviceStart(watchdog);
end;

{==============================================================================}

function watchdog_device_stop(watchdog: PWATCHDOG_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=WatchdogDeviceStop(watchdog);
end;

{==============================================================================}

function watchdog_device_refresh(watchdog: PWATCHDOG_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=WatchdogDeviceRefresh(watchdog);
end;

{==============================================================================}

function watchdog_device_get_remain(watchdog: PWATCHDOG_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=WatchdogDeviceGetRemain(watchdog);
end;

{==============================================================================}

function watchdog_device_get_timeout(watchdog: PWATCHDOG_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=WatchdogDeviceGetTimeout(watchdog);
end;

{==============================================================================}

function watchdog_device_set_timeout(watchdog: PWATCHDOG_DEVICE; timeout: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=WatchdogDeviceSetTimeout(watchdog,timeout);
end;

{==============================================================================}

function watchdog_device_create: PWATCHDOG_DEVICE; stdcall;
{Create a new Watchdog entry}
{Return: Pointer to new Watchdog entry or nil if Watchdog could not be created}
begin
 {}
 Result:=WatchdogDeviceCreateEx(SizeOf(TWATCHDOG_DEVICE));
end;

{==============================================================================}

function watchdog_device_create_ex(size: uint32_t): PWATCHDOG_DEVICE; stdcall;
{Create a new Watchdog entry}
{Size: Size in bytes to allocate for new Watchdog (Including the Watchdog entry)}
{Return: Pointer to new Watchdog entry or nil if Watchdog could not be created}
begin
 {}
 Result:=WatchdogDeviceCreateEx(size);
end;

{==============================================================================}

function watchdog_device_destroy(watchdog: PWATCHDOG_DEVICE): uint32_t; stdcall;
{Destroy an existing Watchdog entry}
begin
 {}
 Result:=WatchdogDeviceDestroy(watchdog);
end;

{==============================================================================}

function watchdog_device_register(watchdog: PWATCHDOG_DEVICE): uint32_t; stdcall;
{Register a new Watchdog in the Watchdog table}
begin
 {}
 Result:=WatchdogDeviceRegister(watchdog);
end;

{==============================================================================}

function watchdog_device_deregister(watchdog: PWATCHDOG_DEVICE): uint32_t; stdcall;
{Deregister a Watchdog from the Watchdog table}
begin
 {}
 Result:=WatchdogDeviceDeregister(watchdog);
end;

{==============================================================================}

function watchdog_device_find(watchdogid: uint32_t): PWATCHDOG_DEVICE; stdcall;
begin
 {}
 Result:=WatchdogDeviceFind(watchdogid);
end;

{==============================================================================}

function watchdog_device_find_by_name(const name: PCHAR): PWATCHDOG_DEVICE; stdcall;
begin
 {}
 Result:=WatchdogDeviceFindByName(String(name));
end;

{==============================================================================}

function watchdog_device_find_by_description(const description: PCHAR): PWATCHDOG_DEVICE; stdcall;
begin
 {}
 Result:=WatchdogDeviceFindByDescription(String(description));
end;

{==============================================================================}

function watchdog_device_enumerate(callback: watchdog_enumerate_cb; data: PVOID): uint32_t; stdcall;
begin
 {}
 Result:=WatchdogDeviceEnumerate(callback,data);
end;

{==============================================================================}

function watchdog_device_notification(watchdog: PWATCHDOG_DEVICE; callback: watchdog_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=WatchdogDeviceNotification(watchdog,callback,data,notification,flags);
end;

{==============================================================================}
{Device Helper Functions}
function device_get_count: uint32_t; stdcall;
{Get the current device count}
begin
 {}
 Result:=DeviceGetCount;
end;

{==============================================================================}

function device_check(device: PDEVICE): PDEVICE; stdcall;
{Check if the supplied Device is in the device table}
begin
 {}
 Result:=DeviceCheck(device);
end;

{==============================================================================}

function notifier_get_count: uint32_t; stdcall;
{Get the current notifier count}
begin
 {}
 Result:=NotifierGetCount;
end;

{==============================================================================}

function notifier_check(notifier: PNOTIFIER): PNOTIFIER; stdcall;
{Check if the supplied Notifier is in the notifier table}
begin
 {}
 Result:=NotifierCheck(notifier);
end;

{==============================================================================}

function device_bus_to_string(devicebus: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(DeviceBusToString(devicebus),_string,len);
end;

{==============================================================================}

function device_state_to_string(devicestate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(DeviceStateToString(devicestate),_string,len);
end;

{==============================================================================}

function device_class_to_string(deviceclass: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(DeviceClassToString(deviceclass),_string,len);
end;

{==============================================================================}

function notification_to_string(notification: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(NotificationToString(notification),_string,len);
end;

{==============================================================================}
{Driver Helper Functions}
function driver_get_count: uint32_t; stdcall;
{Get the current driver count}
begin
 {}
 Result:=DriverGetCount;
end;

{==============================================================================}

function driver_check(driver: PDRIVER): PDRIVER; stdcall;
{Check if the supplied Driver is in the driver table}
begin
 {}
 Result:=DriverCheck(driver);
end;

{==============================================================================}

function driver_state_to_string(driverstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(DriverStateToString(driverstate),_string,len);
end;

{==============================================================================}

function driver_class_to_string(driverclass: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(DriverClassToString(driverclass),_string,len);
end;

{==============================================================================}
{Clock Device Helper Functions}
function clock_device_get_count: uint32_t; stdcall;
{Get the current clock device count}
begin
 {}
 Result:=ClockDeviceGetCount;
end;

{==============================================================================}

function clock_device_get_default: PCLOCK_DEVICE; stdcall;
{Get the current default clock device}
begin
 {}
 Result:=ClockDeviceGetDefault;
end;

{==============================================================================}

function clock_device_set_default(clock: PCLOCK_DEVICE): uint32_t; stdcall;
{Set the current default clock device}
begin
 {}
 Result:=ClockDeviceSetDefault(clock);
end;

{==============================================================================}

function clock_device_check(clock: PCLOCK_DEVICE): PCLOCK_DEVICE; stdcall;
{Check if the supplied Clock is in the Clock table}
begin
 {}
 Result:=ClockDeviceCheck(clock);
end;

{==============================================================================}

function clock_type_to_string(clocktype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Convert a Clock type value to a string}
begin
 {}
 Result:=APIStringToPCharBuffer(ClockTypeToString(clocktype),_string,len);
end;

{==============================================================================}

function clock_state_to_string(clockstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Convert a Clock state value to a string}
begin
 {}
 Result:=APIStringToPCharBuffer(ClockStateToString(clockstate),_string,len);
end;

{==============================================================================}
{Timer Device Helper Functions}
function timer_device_get_count: uint32_t; stdcall;
{Get the current timer device count}
begin
 {}
 Result:=TimerDeviceGetCount;
end;

{==============================================================================}

function timer_device_get_default: PTIMER_DEVICE; stdcall;
{Get the current default timer device}
begin
 {}
 Result:=TimerDeviceGetDefault;
end;

{==============================================================================}

function timer_device_set_default(timer: PTIMER_DEVICE): uint32_t; stdcall;
{Set the current default timer device}
begin
 {}
 Result:=TimerDeviceSetDefault(timer);
end;

{==============================================================================}

function timer_device_check(timer: PTIMER_DEVICE): PTIMER_DEVICE; stdcall;
{Check if the supplied Timer is in the Timer table}
begin
 {}
 Result:=TimerDeviceCheck(timer);
end;

{==============================================================================}

function timer_type_to_string(timertype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Convert a Timer type value to a string}
begin
 {}
 Result:=APIStringToPCharBuffer(TimerTypeToString(timertype),_string,len);
end;

{==============================================================================}

function timer_state_to_string(timerstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Convert a Timer state value to a string}
begin
 {}
 Result:=APIStringToPCharBuffer(TimerStateToString(timerstate),_string,len);
end;

{==============================================================================}

function timer_device_create_waiter(timer: PTIMER_DEVICE; callback: timer_cb; data: PVOID): PTIMER_WAITER; stdcall;
{Create a new waiter using the supplied parameters}

{Note: Waiter must be registered by calling TimerDeviceRegisterWaiter}
{Note: Caller must hold the Timer device lock}
begin
 {}
 Result:=TimerDeviceCreateWaiter(timer,callback,data);
end;

{==============================================================================}

function timer_device_destroy_waiter(timer: PTIMER_DEVICE; waiter: PTIMER_WAITER): uint32_t; stdcall;
{Destroy an existing waiter}

{Note: Waiter must be deregistered first by calling TimerDeviceDeregisterWaiter}
{Note: Caller must hold the Timer device lock}
begin
 {}
 Result:=TimerDeviceDestroyWaiter(timer,waiter);
end;

{==============================================================================}

function timer_device_register_waiter(timer: PTIMER_DEVICE; waiter: PTIMER_WAITER): uint32_t; stdcall;
{Register a waiter in the waiter list of the supplied Timer}

{Note: Waiter must be created by calling TimerDeviceCreateWaiter}
{Note: Caller must hold the Timer device lock}
begin
 {}
 Result:=TimerDeviceRegisterWaiter(timer,waiter);
end;

{==============================================================================}

function timer_device_deregister_waiter(timer: PTIMER_DEVICE; waiter: PTIMER_WAITER): uint32_t; stdcall;
{Deregister a waiter from the waiter list of the supplied Timer}

{Note: Waiter must be destroyed by calling TimerDeviceDestroyWaiter}
{Note: Caller must hold the Timer device lock}
begin
 {}
 Result:=TimerDeviceDeregisterWaiter(timer,waiter);
end;

{==============================================================================}
{Random Device Helper Functions}
function random_device_get_count: uint32_t; stdcall;
{Get the current random device count}
begin
 {}
 Result:=RandomDeviceGetCount;
end;

{==============================================================================}

function random_device_get_default: PRANDOM_DEVICE; stdcall;
{Get the current default random device}
begin
 {}
 Result:=RandomDeviceGetDefault;
end;

{==============================================================================}

function random_device_set_default(random: PRANDOM_DEVICE): uint32_t; stdcall;
{Set the current default random device}
begin
 {}
 Result:=RandomDeviceSetDefault(random);
end;

{==============================================================================}

function random_device_check(random: PRANDOM_DEVICE): PRANDOM_DEVICE; stdcall;
{Check if the supplied Random is in the Random table}
begin
 {}
 Result:=RandomDeviceCheck(random);
end;

{==============================================================================}

function random_type_to_string(randomtype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Convert a Random type value to a string}
begin
 {}
 Result:=APIStringToPCharBuffer(RandomTypeToString(randomtype),_string,len);
end;

{==============================================================================}

function random_state_to_string(randomstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Convert a Random state value to a string}
begin
 {}
 Result:=APIStringToPCharBuffer(RandomStateToString(randomstate),_string,len);
end;

{==============================================================================}
{Mailbox Device Helper Functions}
function mailbox_device_get_count: uint32_t; stdcall;
{Get the current mailbox device count}
begin
 {}
 Result:=MailboxDeviceGetCount;
end;

{==============================================================================}

function mailbox_device_get_default: PMAILBOX_DEVICE; stdcall;
{Get the current default mailbox device}
begin
 {}
 Result:=MailboxDeviceGetDefault;
end;

{==============================================================================}

function mailbox_device_set_default(mailbox: PMAILBOX_DEVICE): uint32_t; stdcall;
{Set the current default mailbox device}
begin
 {}
 Result:=MailboxDeviceSetDefault(mailbox);
end;

{==============================================================================}

function mailbox_device_check(mailbox: PMAILBOX_DEVICE): PMAILBOX_DEVICE; stdcall;
{Check if the supplied Mailbox is in the Mailbox table}
begin
 {}
 Result:=MailboxDeviceCheck(mailbox);
end;

{==============================================================================}

function mailbox_type_to_string(mailboxtype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Convert a Mailbox type value to a string}
begin
 {}
 Result:=APIStringToPCharBuffer(MailboxTypeToString(mailboxtype),_string,len);
end;

{==============================================================================}

function mailbox_state_to_string(mailboxstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Convert a Mailbox state value to a string}
begin
 {}
 Result:=APIStringToPCharBuffer(MailboxStateToString(mailboxstate),_string,len);
end;

{==============================================================================}
{Watchdog Device Helper Functions}
function watchdog_device_get_count: uint32_t; stdcall;
{Get the current watchdog device count}
begin
 {}
 Result:=WatchdogDeviceGetCount;
end;

{==============================================================================}

function watchdog_device_get_default: PWATCHDOG_DEVICE; stdcall;
{Get the current default watchdog device}
begin
 {}
 Result:=WatchdogDeviceGetDefault;
end;

{==============================================================================}

function watchdog_device_set_default(watchdog: PWATCHDOG_DEVICE): uint32_t; stdcall;
{Set the current default watchdog device}
begin
 {}
 Result:=WatchdogDeviceSetDefault(watchdog);
end;

{==============================================================================}

function watchdog_device_check(watchdog: PWATCHDOG_DEVICE): PWATCHDOG_DEVICE; stdcall;
{Check if the supplied Watchdog is in the Watchdog table}
begin
 {}
 Result:=WatchdogDeviceCheck(watchdog);
end;

{==============================================================================}

function watchdog_type_to_string(watchdogtype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Convert a Watchdog type value to a string}
begin
 {}
 Result:=APIStringToPCharBuffer(WatchdogTypeToString(watchdogtype),_string,len);
end;

{==============================================================================}

function watchdog_state_to_string(watchdogstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Convert a Watchdog state value to a string}
begin
 {}
 Result:=APIStringToPCharBuffer(WatchdogStateToString(watchdogstate),_string,len);
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{Console Functions}
{$IFDEF API_EXPORT_CONSOLE}
function console_device_open(console: PCONSOLE_DEVICE): uint32_t; stdcall;
{Open a console device ready for drawing}
{Console: The console device to open}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleDeviceOpen(console);
end;

{==============================================================================}

function console_device_close(console: PCONSOLE_DEVICE): uint32_t; stdcall;
{Close a console device to prevent drawing}
{Console: The console device to close}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleDeviceClose(console);
end;

{==============================================================================}

function console_device_clear(console: PCONSOLE_DEVICE; color: uint32_t): uint32_t; stdcall;
{Clear a console device using the specified color}
{Console: The console device to clear}
{Color: The color to use when clearing the console}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Color must be specified in the default color format (See COLOR_FORMAT_DEFAULT)}
begin
 {}
 Result:=ConsoleDeviceClear(console,color);
end;

{==============================================================================}

function console_device_scroll(console: PCONSOLE_DEVICE; x1, y1, x2, y2, count, direction: uint32_t): uint32_t; stdcall;
{Scroll all or part of a console device in the specified direction}
{Console: The console device to scroll}
{X1: The left edge of the area to scroll (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Y1: The top edge of the area to scroll (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{X2: The right edge of the area to scroll (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Y2: The bottom edge of the area to scroll (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Count: The number of pixels or characters (depending on console mode) to scroll}
{Direction: The direction to scroll (eg CONSOLE_DIRECTION_UP)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleDeviceScroll(console,x1,y1,x2,y2,count,direction);
end;

{==============================================================================}

function console_device_draw_box(console: PCONSOLE_DEVICE; x1, y1, x2, y2, color, width: uint32_t): uint32_t; stdcall;
{Draw an outline of a box on a console device}
{Console: The console device to draw on}
{X1: The left edge of the box (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Y1: The top edge of the box (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{X2: The right edge of the box (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Y2: The bottom edge of the box (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Color: The color to draw with (eg COLOR_WHITE)}
{Width: The width of the box outline (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Color must be specified in the default color format (See COLOR_FORMAT_DEFAULT)}
begin
 {}
 Result:=ConsoleDeviceDrawBox(console,x1,y1,x2,y2,color,width);
end;

{==============================================================================}

function console_device_draw_line(console: PCONSOLE_DEVICE; x1, y1, x2, y2, color, width: uint32_t): uint32_t; stdcall;
{Draw a horizontal or vertical line on a console device}
{Console: The console device to draw on}
{X1: The left starting point of the line (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Y1: The top starting point of the line (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{X2: The right ending point of the line (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Y2: The bottom ending point of the line (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Color: The color to draw with (eg COLOR_WHITE)}
{Width: The width of the line (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Color must be specified in the default color format (See COLOR_FORMAT_DEFAULT)}
begin
 {}
 Result:=ConsoleDeviceDrawLine(console,x1,y1,x2,y2,color,width);
end;

{==============================================================================}

function console_device_plot_line(console: PCONSOLE_DEVICE; x1, y1, x2, y2, color, width: uint32_t): uint32_t; stdcall;
{Draw a line in any direction on a console device}
{Console: The console device to draw on}
{X1: The left starting point of the line (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Y1: The top starting point of the line (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{X2: The right ending point of the line (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Y2: The bottom ending point of the line (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Color: The color to draw with (eg COLOR_WHITE)}
{Width: The width of the line (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Color must be specified in the default color format (See COLOR_FORMAT_DEFAULT)}
{Note: Character consoles may implement plot line but the default method only supports pixel consoles}
begin
 {}
 Result:=ConsoleDevicePlotLine(console,x1,y1,x2,y2,color,width);
end;

{==============================================================================}

function console_device_draw_char(console: PCONSOLE_DEVICE; handle: FONT_HANDLE; ch: CHAR; x, y, forecolor, backcolor: uint32_t): uint32_t; stdcall;
{Draw a character on a console device}
{Console: The console device to draw on}
{Handle: The handle of the font to draw with}
{Ch: The character to draw}
{X: The left starting point of the character (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Y: The top starting point of the character (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Forecolor: The foreground color for the character (eg COLOR_WHITE)}
{Backcolor: The background color for the character (eg COLOR_BLACK)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Forecolor and Backcolor must be specified in the default color format (See COLOR_FORMAT_DEFAULT)}
begin
 {}
 Result:=ConsoleDeviceDrawChar(console,handle,ch,x,y,forecolor,backcolor);
end;

{==============================================================================}

function console_device_draw_text(console: PCONSOLE_DEVICE; handle: FONT_HANDLE; const text: PCHAR; x, y, forecolor, backcolor, len: uint32_t): uint32_t; stdcall;
{Draw a text string on a console device}
{Console: The console device to draw on}
{Handle: The handle of the font to draw with}
{Text: The text to draw}
{X: The left starting point of the text (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Y: The top starting point of the text (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Forecolor: The foreground color for the text (eg COLOR_WHITE)}
{Backcolor: The background color for the text (eg COLOR_BLACK)}
{Len: The length of the text (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Forecolor and Backcolor must be specified in the default color format (See COLOR_FORMAT_DEFAULT)}
begin
 {}
 Result:=ConsoleDeviceDrawText(console,handle,String(text),x,y,forecolor,backcolor,len);
end;

{==============================================================================}

function console_device_draw_pixel(console: PCONSOLE_DEVICE; x, y, color: uint32_t): uint32_t; stdcall;
{Draw a pixel on a console device}
{Console: The console device to draw on}
{X: The column to draw the pixel (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Y: The row to draw the pixel (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Color: The color to draw with (eg COLOR_WHITE)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Color must be specified in the default color format (See COLOR_FORMAT_DEFAULT)}
begin
 {}
 Result:=ConsoleDeviceDrawPixel(console,x,y,color);
end;

{==============================================================================}

function console_device_draw_block(console: PCONSOLE_DEVICE; x1, y1, x2, y2, color: uint32_t): uint32_t; stdcall;
{Draw a filled block on a console device}
{Console: The console device to draw on}
{X1: The left edge of the block (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Y1: The top edge of the block (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{X2: The right edge of the block (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Y2: The bottom edge of the block (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Color: The color to draw with (eg COLOR_WHITE)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Color must be specified in the default color format (See COLOR_FORMAT_DEFAULT)}
begin
 {}
 Result:=ConsoleDeviceDrawBlock(console,x1,y1,x2,y2,color);
end;

{==============================================================================}

function console_device_draw_circle(console: PCONSOLE_DEVICE; x, y, color, width, radius: uint32_t): uint32_t; stdcall;
{Draw a circle on a console device}
{Console: The console device to draw on}
{X: The column center point of the circle (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Y: The row center point of the circle (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Color: The color to draw with (eg COLOR_WHITE)}
{Width: The width of the circle outline (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Radius: The radius of the circle (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Color must be specified in the default color format (See COLOR_FORMAT_DEFAULT)}
{Note: Character consoles may implement draw circle but the default method only supports pixel consoles}
begin
 {}
 Result:=ConsoleDeviceDrawCircle(console,x,y,color,width,radius);
end;

{==============================================================================}

function console_device_draw_image(console: PCONSOLE_DEVICE; x, y: uint32_t; buffer: PVOID; width, height, format, skip: uint32_t): uint32_t; stdcall;
{Draw an image on a console device}
{Console: The console device to draw on}
{X: The starting column of the image (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Y: The starting row of the image (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Buffer: Pointer to a block of memory containing the pixels of the image in a contiguous block of rows}
{Width: The number of columns in the image (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Height: The number of rows in the image (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Format: The color format of the image (eg COLOR_FORMAT_RGB24)}
{Skip: The number of pixels to skip in the buffer after each row (Optional)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleDeviceDrawImage(console,x,y,buffer,width,height,format,skip);
end;

{==============================================================================}

function console_device_draw_window(console: PCONSOLE_DEVICE; handle: WINDOW_HANDLE; flags: uint32_t): uint32_t; stdcall;
{Draw a console window on a console device}
{Console: The console device to draw on}
{Handle: The handle of the console window to draw}
{Flags: Flags to specify what should be drawn (eg WINDOW_DRAW_FLAG_BORDER)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleDeviceDrawWindow(console,handle,flags);
end;

{==============================================================================}

function console_device_get_pixel(console: PCONSOLE_DEVICE; x, y: uint32_t; var color: uint32_t): uint32_t; stdcall;
{Read a pixel from a console device}
{Console: The console device to read from}
{X: The column to read the pixel from (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Y: The row to read the pixel from (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Color: The color value read from the console (eg COLOR_WHITE)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Color is returned in the default color format (See COLOR_FORMAT_DEFAULT)}
begin
 {}
 Result:=ConsoleDeviceGetPixel(console,x,y,color);
end;

{==============================================================================}

function console_device_get_image(console: PCONSOLE_DEVICE; x, y: uint32_t; buffer: PVOID; width, height, format, skip: uint32_t): uint32_t; stdcall;
{Read an image from a console device}
{Console: The console device to read from}
{X: The starting column to read the image from (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Y: The starting row to read the image from (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Buffer: Pointer to a block of memory large enough to hold the pixels of the image in a contiguous block of rows}
{Width: The number of columns to store in the image (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Height: The number of rows to store in the image (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Format: The color format to store the image in (eg COLOR_FORMAT_RGB24)}
{Skip: The number of pixels to skip in the buffer after each row (Optional)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleDeviceGetImage(console,x,y,buffer,width,height,format,skip);
end;

{==============================================================================}

function console_device_put_text(console: PCONSOLE_DEVICE; handle: FONT_HANDLE; const source, dest: TCONSOLE_POINT; buffer: PCONSOLE_CHAR; width, height, skip: uint32_t): uint32_t; stdcall;
{Output a rectangular area of text to a console device}
{Console: The console device to output to}
{Source: The X and Y point in the source buffer to copy text from (Characters)}
{Dest: The X and Y point on the console device to copy text to (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Buffer: A pointer to a buffer of TConsoleChar structures which represent rows of text}
{Width: The width of the area to be output (Characters)}
{Height: The height of the area to be output (Characters)}
{Skip: The number of characters to skip in the buffer after each row (Optional)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Source, Width, Height and Skip are based on character rows and columns not screen pixels}
begin
 {}
 Result:=ConsoleDevicePutText(console,handle,source,dest,buffer,width,height,skip);
end;

{==============================================================================}

function console_device_copy_image(console: PCONSOLE_DEVICE; const source, dest: TCONSOLE_POINT; width, height: uint32_t): uint32_t; stdcall;
{Copy an image within a console device}
{Console: The console device to copy on}
{Source: The starting point for the source of the copy (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Dest: The starting point for the destination of the copy (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Width: The number of columns in the image (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Height: The number of rows in the image (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleDeviceCopyImage(console,source,dest,width,height);
end;

{==============================================================================}

function console_device_add_caret(console: PCONSOLE_DEVICE; width, height, offsetx, offsety: uint32_t): THANDLE; stdcall;
{Create a new caret (cursor) of the specified size}
{Console: The console device to create the caret on}
{Width: The width of the new caret (Pixels for CONSOLE_MODE_PIXEL / Always 1 for CONSOLE_MODE_CHARACTER)}
{Height: The height of the new caret (Pixels for CONSOLE_MODE_PIXEL / Always 1 for CONSOLE_MODE_CHARACTER)}
{OffsetX: The X offset of the new caret (Optional)(Pixels for CONSOLE_MODE_PIXEL / Always 0 for CONSOLE_MODE_CHARACTER)}
{OffsetY: The Y offset of the new caret (Optional)(Pixels for CONSOLE_MODE_PIXEL / Always 0 for CONSOLE_MODE_CHARACTER)}
{Return: Handle to new caret on success or INVALID_HANDLE_VALUE on failure}
begin
 {}
 Result:=ConsoleDeviceAddCaret(console,width,height,offsetx,offsety);
end;

{==============================================================================}

function console_device_delete_caret(console: PCONSOLE_DEVICE; handle: THANDLE): uint32_t; stdcall;
{Delete an existing caret (cursor)}
{Console: The console device to delete the caret on}
{Handle: The handle of the caret to delete (as returned from ConsoleDeviceAddCaret)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleDeviceDeleteCaret(console,handle);
end;

{==============================================================================}

function console_device_update_caret(console: PCONSOLE_DEVICE; handle: THANDLE; x, y: uint32_t; visible, blink: BOOL): uint32_t; stdcall;
{Update an existing carets position, visibility or blink}
{Console: The console device to update the caret on}
{Handle: The handle of the caret to update (as returned from ConsoleDeviceAddCaret)}
{X: The X position of the caret (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Y: The Y position of the caret (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Visible: If true then show the caret else hide it}
{Blink: If true then blink the caret at the default blink rate}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleDeviceUpdateCaret(console,handle,x,y,visible,blink);
end;

{==============================================================================}

function console_device_update_caret_ex(console: PCONSOLE_DEVICE; handle: THANDLE; x, y, forecolor, backcolor: uint32_t; visible, blink, reverse: BOOL): uint32_t; stdcall;
{Update an existing carets position, colors, visibility, blink or reverse}
{Console: The console device to update the caret on}
{Handle: The handle of the caret to update (as returned from ConsoleDeviceAddCaret)}
{X: The X position of the caret (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Y: The Y position of the caret (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Forecolor: The cursor foreground color if set or COLOR_NONE to disable}
{Backcolor: The cursor background color if set or COLOR_NONE to disable}
{Visible: If true then show the caret else hide it}
{Blink: If true then blink the caret at the default blink rate}
{Reverse: If true then enable reverse color else enable inverse color}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Forecolor and Backcolor must be specified in the default color format (See COLOR_FORMAT_DEFAULT)}
begin
 {}
 Result:=ConsoleDeviceUpdateCaretEx(console,handle,x,y,forecolor,backcolor,visible,blink,reverse);
end;

{==============================================================================}

function console_device_set_cursor(console: PCONSOLE_DEVICE; width, height: uint32_t; chars: PCHAR): uint32_t; stdcall;
{Set the mouse cursor properties of a console device (CONSOLE_MODE_CHARACTER only)}
{Console: The console device to set the cursor}
{Width: The width of the cursor in characters}
{Height: The height of the cursor in characters}
{Chars: A buffer containing the cursor characters}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For devices that don't support hardware mouse cursor a software cursor will be implemented
       If chars is nil then the default cursor will be used}
begin
 {}
 Result:=ConsoleDeviceSetCursor(console,width,height,chars);
end;

{==============================================================================}

function console_device_update_cursor(console: PCONSOLE_DEVICE; enabled: BOOL; x, y: int32_t; relative: BOOL): uint32_t; stdcall;
{Update the position and state for the mouse cursor of a console device (CONSOLE_MODE_CHARACTER only)}
{Console: The console device to update the cursor}
{Enabled: If true then show the cursor else hide it}
{X: The cursor X location in characters}
{Y: The cursor Y location in characters}
{Relative: If true then X and Y are considered relative to the current position}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For devices that don't support hardware mouse cursor a software cursor will be implemented}
begin
 {}
 Result:=ConsoleDeviceUpdateCursor(console,enabled,x,y,relative);
end;

{==============================================================================}

function console_device_get_position(console: PCONSOLE_DEVICE; position: uint32_t; var x1, y1, x2, y2: uint32_t): uint32_t; stdcall;
{Get the coordinates of a console position from a console device}
{Console: The console device to get from}
{Position: The console position to get the coordinates for (eg CONSOLE_POSITION_FULL)}
{X1: The left edge of the console position (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Y1: The top edge of the console position (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{X2: The right edge of the console position (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Y2: The bottom edge of the console position (Pixels for CONSOLE_MODE_PIXEL / Characters for CONSOLE_MODE_CHARACTER)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleDeviceGetPosition(console,position,x1,y1,x2,y2);
end;

{==============================================================================}

function console_device_get_properties(console: PCONSOLE_DEVICE; properties: PCONSOLE_PROPERTIES): uint32_t; stdcall;
{Get the current properties from a console device}
{Console: The console device to get properties from}
{Properties: Pointer to a TConsoleProperties structure to return}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleDeviceGetProperties(console,properties);
end;

{==============================================================================}

function console_device_check_flag(console: PCONSOLE_DEVICE; flag: uint32_t): BOOL; stdcall;
{Check if a console device supports a flag value}
{Console: The console device to check}
{Flag: The console flag to check (eg CONSOLE_FLAG_FULLSCREEN)}
{Return: True if flag is supported, False if not or on error}
begin
 {}
 Result:=ConsoleDeviceCheckFlag(console,flag);
end;

{==============================================================================}

function console_device_update_flag(console: PCONSOLE_DEVICE; flag: uint32_t; clear: BOOL): uint32_t; stdcall;
{Set or clear a flag on a console device}
{Console: The console device to set or clear the flag on}
{Flag: The console flag to set or clear (eg CONSOLE_FLAG_LINE_WRAP)}
{Clear: If true clear the flag, else set it}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleDeviceUpdateFlag(console,flag,clear);
end;

{==============================================================================}

function console_device_get_mode(console: PCONSOLE_DEVICE): uint32_t; stdcall;
{Get the mode of a console device}
{Console: The console device to get from}
{Return: The mode of the console (eg CONSOLE_MODE_PIXEL) or CONSOLE_MODE_NONE on error}
begin
 {}
 Result:=ConsoleDeviceGetMode(console);
end;

{==============================================================================}

function console_device_get_state(console: PCONSOLE_DEVICE): uint32_t; stdcall;
{Get the state of a console device}
{Console: The console device to get from}
{Return: The current state of the console (eg CONSOLE_STATE_OPEN)}
begin
 {}
 Result:=ConsoleDeviceGetState(console);
end;

{==============================================================================}

function console_device_create: PCONSOLE_DEVICE; stdcall;
{Create a new Console entry}
{Return: Pointer to new Console entry or nil if Console could not be created}
begin
 {}
 Result:=ConsoleDeviceCreate;
end;

{==============================================================================}

function console_device_create_ex(size: uint32_t): PCONSOLE_DEVICE; stdcall;
{Create a new Console entry}
{Size: Size in bytes to allocate for new Console (Including the Console entry)}
{Return: Pointer to new Console entry or nil if Console could not be created}
begin
 {}
 Result:=ConsoleDeviceCreateEx(size);
end;

{==============================================================================}

function console_device_destroy(console: PCONSOLE_DEVICE): uint32_t; stdcall;
{Destroy an existing Console entry}
{Console: The console device to destroy}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleDeviceDestroy(console);
end;

{==============================================================================}

function console_device_register(console: PCONSOLE_DEVICE): uint32_t; stdcall;
{Register a new Console in the Console table}
{Console: The console device to register}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleDeviceRegister(console);
end;

{==============================================================================}

function console_device_deregister(console: PCONSOLE_DEVICE): uint32_t; stdcall;
{Deregister a Console from the Console table}
{Console: The console device to deregister}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleDeviceDeregister(console);
end;

{==============================================================================}

function console_device_find(consoleid: uint32_t): PCONSOLE_DEVICE; stdcall;
{Find a console device by ID in the console table}
{ConsoleId: The ID number of the console to find}
{Return: Pointer to console device entry or nil if not found}
begin
 {}
 Result:=ConsoleDeviceFind(consoleid);
end;

{==============================================================================}

function console_device_find_by_device(device: PDEVICE): PCONSOLE_DEVICE; stdcall;
{Find a console device by its related device in the console table}
{Device: Pointer to the related device to find}
{Return: Pointer to console device entry or nil if not found}
begin
 {}
 Result:=ConsoleDeviceFindByDevice(device);
end;

{==============================================================================}

function console_device_find_by_name(const name: PCHAR): PCONSOLE_DEVICE; stdcall;
{Find a console device by name in the console table}
{Name: The name of the console to find (eg Console0)}
{Return: Pointer to console device entry or nil if not found}
begin
 {}
 Result:=ConsoleDeviceFindByName(String(name));
end;

{==============================================================================}

function console_device_find_by_description(const description: PCHAR): PCONSOLE_DEVICE; stdcall;
{Find a console device by description in the console table}
{Description: The description of the console to find (eg Framebuffer Console (Framebuffer0))}
{Return: Pointer to console device entry or nil if not found}
begin
 {}
 Result:=ConsoleDeviceFindByDescription(String(description));
end;

{==============================================================================}

function console_device_enumerate(callback: console_enumerate_cb; data: PVOID): uint32_t; stdcall;
{Enumerate all console devices in the console table}
{Callback: The callback function to call for each console in the table}
{Data: A private data pointer to pass to callback for each console in the table}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleDeviceEnumerate(callback,data);
end;

{==============================================================================}

function console_device_notification(console: PCONSOLE_DEVICE; callback: console_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall;
{Register a notification for console device changes}
{Console: The console device to notify changes for (Optional, pass nil for all console devices)}
{Callback: The function to call when a notification event occurs}
{Data: A private data pointer to pass to callback when a notification event occurs}
{Notification: The events to register for notification of (eg DEVICE_NOTIFICATION_REGISTER)}
{Flags: The flags to control the notification (eg NOTIFIER_FLAG_WORKER)}
begin
 {}
 Result:=ConsoleDeviceNotification(console,callback,data,notification,flags);
end;

{==============================================================================}
{Text Console Functions}
function console_window_create(console: PCONSOLE_DEVICE; position: uint32_t; default: BOOL): WINDOW_HANDLE; stdcall;
{Create a new Console window}
{Console: The console device to create the new window on}
{Position: The console position to create the new window at (eg CONSOLE_POSITION_FULL)}
{Default: If true allow the new window to be the default window if there is no current default}
{Return: Handle to new Console window or INVALID_HANDLE_VALUE if Console window could not be created}
begin
 {}
 Result:=ConsoleWindowCreate(console,position,default);
end;

{==============================================================================}

function console_window_create_ex(console: PCONSOLE_DEVICE; font: FONT_HANDLE; size, state, mode, position: uint32_t; default: BOOL): WINDOW_HANDLE; stdcall;
{Create a new Console window}
{Console: The console device to create the new window on}
{Font: The handle of the default font for the new console window}
{Size: The size in bytes to allocate for the new window entry (Defaults to SizeOf(TConsoleWindow))}
{State: The state of the new console window (WINDOW_STATE_VISIBLE or WINDOW_STATE_INVISIBLE)}
{Mode: The mode of the new console window (Normally WINDOW_MODE_TEXT)}
{Position: The console position to create the new window at (eg CONSOLE_POSITION_FULL)}
{Default: If true allow the new window to be the default window if there is no current default}
{Return: Handle to new Console window or INVALID_HANDLE_VALUE if Console window could not be created}
begin
 {}
 Result:=ConsoleWindowCreateEx(console,font,size,state,mode,position,default);
end;

{==============================================================================}

function console_window_destroy(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Close and Destroy an existing console window}
{Handle: The handle of the window to destroy}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleWindowDestroy(handle);
end;

{==============================================================================}

function console_window_show(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Make an existing console window visible and show it on screen}
{Handle: The handle of the window to show}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleWindowShow(handle);
end;

{==============================================================================}

function console_window_hide(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Make an existing console window invisible and hide it on screen}
{Handle: The handle of the window to hide}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleWindowHide(handle);
end;

{==============================================================================}

function console_window_activate(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Make an existing console window the active window}
{Handle: The handle of the window to activate}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleWindowActivate(handle);
end;

{==============================================================================}

function console_window_deactivate(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Make an existing console window inactive}
{Handle: The handle of the window to deactivate}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: On success there will be no active window set}
begin
 {}
 Result:=ConsoleWindowDeactivate(handle);
end;

{==============================================================================}

function console_window_next(console: PCONSOLE_DEVICE; visible: BOOL): WINDOW_HANDLE; stdcall;
{Get the next console window starting with the active window}
{Console: The console device to change the active window on}
{Visible: If true only return windows that are visible}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleWindowNext(console,visible);
end;

{==============================================================================}

function console_window_previous(console: PCONSOLE_DEVICE; visible: BOOL): WINDOW_HANDLE; stdcall;
{Get the previous console window starting with the active window}
{Console: The console device to change the active window on}
{Visible: If true only return windows that are visible}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleWindowPrevious(console,visible);
end;

{==============================================================================}

function console_window_at(console: PCONSOLE_DEVICE; x, y: uint32_t; visible: BOOL): WINDOW_HANDLE; stdcall;
{Find the console window that X and Y coordinates are within}
{Console: The console device to find the window on}
{X: The X coordinate to find the window for}
{Y: The Y coordinate to find the window for}
{Visible: If true only return windows that are visible}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For Text Console functions, X and Y are based on character columns not screen pixels}
begin
 {}
 Result:=ConsoleWindowAt(console,x,y,visible);
end;

{==============================================================================}

function console_window_find(console: PCONSOLE_DEVICE; position: uint32_t): WINDOW_HANDLE; stdcall;
{Find an existing console window in the position specified}
{Console: The console device to find the window on}
{Position: The window position to find (eg CONSOLE_POSITION_FULL)}
{Return: The handle of the existing window or INVALID_HANDLE_VALUE if not found}
begin
 {}
 Result:=ConsoleWindowFind(console,position);
end;

{==============================================================================}

function console_window_enumerate(console: PCONSOLE_DEVICE; callback: console_window_enumerate_cb; data: PVOID): uint32_t; stdcall;
{Enumerate existing console windows on the specified console device}
{Console: The console device to enumerate windows for}
{Callback: The function to call for each window enumerated}
{Data: A pointer to private data to be passed to the callback (Optional)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleWindowEnumerate(console,callback,data);
end;

{==============================================================================}

function console_window_check_flag(handle: WINDOW_HANDLE; flag: uint32_t): BOOL; stdcall;
{Check an existing console window to determine if a flag is set or not}
{Handle: The handle of the window to check}
{Flag: The window flag to check for (eg WINDOW_FLAG_LINE_WRAP)}
{Return: True if the flag is set, False if not set}
begin
 {}
 Result:=ConsoleWindowCheckFlag(handle,flag);
end;

{==============================================================================}

function console_window_update_flag(handle: WINDOW_HANDLE; flag: uint32_t; clear: BOOL): uint32_t; stdcall;
{Set or clear a flag on an existing console window}
{Handle: The handle of the window to set or clear the flag on}
{Flag: The window flag to set or clear (eg WINDOW_FLAG_LINE_WRAP)}
{Clear: If true clear the flag, else set it}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleWindowUpdateFlag(handle,flag,clear);
end;

{==============================================================================}

function console_window_get_mode(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Get the window mode of an existing console window}
{Handle: The handle of the window to get the mode for}
{Return: The window mode (eg WINDOW_MODE_TEXT)}
begin
 {}
 Result:=ConsoleWindowGetMode(handle);
end;

{==============================================================================}

function console_window_get_state(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Get the window state of an existing console window}
{Handle: The handle of the window to get the state for}
{Return: The window state (eg WINDOW_STATE_INVISIBLE)}
begin
 {}
 Result:=ConsoleWindowGetState(handle);
end;

{==============================================================================}

function console_window_get_position(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Get the position of an existing console window}
{Handle: The handle of the window to get the position for}
{Return: The window position (eg CONSOLE_POSITION_FULL)}
begin
 {}
 Result:=ConsoleWindowGetPosition(handle);
end;

{==============================================================================}

function console_window_set_position(handle: WINDOW_HANDLE; position: uint32_t): uint32_t; stdcall;
{Set the position of an existing console window}
{Handle: The handle of the window to set the position for}
{Position: The new window position to set}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: The function will return ERROR_INVALID_PARAMETER if another window exists at the position}
begin
 {}
 Result:=ConsoleWindowSetPosition(handle,position);
end;

{==============================================================================}

function console_window_get_properties(handle: WINDOW_HANDLE; properties: PWINDOW_PROPERTIES): uint32_t; stdcall;
{Get the properties for the specified console window}
{Handle: The handle of the window to get the properties from}
{Properties: Pointer to a TWindowProperties structure to fill in}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleWindowGetProperties(handle,properties);
end;

{==============================================================================}

function console_window_get_min_x(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Get the current minimum X of the window viewport for an existing console window}
{Handle: The handle of the window to get MinX for}
{Return: The minimum X value for the current window viewport}
{Note: For Text Console functions, X is based on character columns not screen pixels}
begin
 {}
 Result:=ConsoleWindowGetMinX(handle);
end;

{==============================================================================}

function console_window_get_min_y(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Get the current minimum Y of the window viewport for an existing console window}
{Handle: The handle of the window to get MinY for}
{Return: The minimum Y value for the current window viewport}
{Note: For Text Console functions, Y is based on character rows not screen pixels}
begin
 {}
 Result:=ConsoleWindowGetMinY(handle);
end;

{==============================================================================}

function console_window_get_max_x(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Get the current maximum X of the window viewport for an existing console window}
{Handle: The handle of the window to get MaxX for}
{Return: The maximum X value for the current window viewport}
{Note: For Text Console functions, X is based on character columns not screen pixels}
begin
 {}
 Result:=ConsoleWindowGetMaxX(handle);
end;

{==============================================================================}

function console_window_get_max_y(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Get the current maximum Y of the window viewport for an existing console window}
{Handle: The handle of the window to get MaxY for}
{Return: The maximum Y value for the current window viewport}
{Note: For Text Console functions, Y is based on character rows not screen pixels}
begin
 {}
 Result:=ConsoleWindowGetMaxY(handle);
end;

{==============================================================================}

function console_window_get_rect(handle: WINDOW_HANDLE): TCONSOLE_RECT; stdcall;
{Get the rectangle X1,Y1,X2,Y2 of the window viewport for an existing console window}
{Handle: The handle of the window to get the rectangle for}
{Return: The rectangle of the current window viewport}
{Note: For Text Console functions, Rect is based on character rows and columns not screen pixels}
begin
 {}
 Result:=ConsoleWindowGetRect(handle);
end;

{==============================================================================}

function console_window_set_rect(handle: WINDOW_HANDLE; const rect: TCONSOLE_RECT): uint32_t; stdcall;
{Set the rectangle X1,Y1,X2,Y2 of the window viewport for an existing console window}
{Handle: The handle of the window to set the rectangle for}
{Rect: The rectangle to set for the window viewport}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For Text Console functions, Rect is based on character rows and columns not screen pixels}
begin
 {}
 Result:=ConsoleWindowSetRect(handle,rect);
end;

{==============================================================================}

function console_window_reset_rect(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Reset the window viewport for an existing console window to the maximum size}
{Handle: The handle of the window to reset the viewport for}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleWindowResetRect(handle);
end;

{==============================================================================}

function console_window_get_viewport(handle: WINDOW_HANDLE; var x1, y1, x2, y2: uint32_t): uint32_t; stdcall;
{Get the X1,Y1,X2,Y2 of the window viewport for an existing console window}
{Handle: The handle of the window to get the viewport for}
{X1: The left edge of the current viewport}
{Y1: The top edge of the current viewport}
{X2: The right edge of the current viewport}
{Y2: The bottom edge of the current viewport}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For Text Console functions, Viewport is based on character rows and columns not screen pixels}
begin
 {}
 Result:=ConsoleWindowGetViewport(handle,x1,y1,x2,y2);
end;

{==============================================================================}

function console_window_set_viewport(handle: WINDOW_HANDLE; x1, y1, x2, y2: uint32_t): uint32_t; stdcall;
{Set the X1,Y1,X2,Y2 of the window viewport for an existing console window}
{Handle: The handle of the window to get the viewport for}
{X1: The left edge of the window viewport}
{Y1: The top edge of the window viewport}
{X2: The right edge of the window viewport}
{Y2: The bottom edge of the window viewport}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For Text Console functions, Viewport is based on character rows and columns not screen pixels}
begin
 {}
 Result:=ConsoleWindowSetViewport(handle,x1,y1,x2,y2);
end;

{==============================================================================}

function console_window_reset_viewport(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Reset the window viewport for an existing console window to the maximum size}
{Handle: The handle of the window to reset the viewport for}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleWindowResetViewport(handle);
end;

{==============================================================================}

function console_window_get_x(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Get the current X (Column) position of an existing console window}
{Handle: The handle of the window to get X for}
{Return: The X value for the window}
{Note: For Text Console functions, X is based on character columns not screen pixels}
begin
 {}
 Result:=ConsoleWindowGetX(handle);
end;

{==============================================================================}

function console_window_set_x(handle: WINDOW_HANDLE; x: uint32_t): uint32_t; stdcall;
{Set the current X (Column) position of an existing console window}
{Handle: The handle of the window to set X for}
{X: The new X value to set}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For Text Console functions, X is based on character columns not screen pixels}
begin
 {}
 Result:=ConsoleWindowSetX(handle,x);
end;

{==============================================================================}

function console_window_get_y(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Get the current Y (Row) position of an existing console window}
{Handle: The handle of the window to get Y for}
{Return: The Y value for the window}
{Note: For Text Console functions, Y is based on character rows not screen pixels}
begin
 {}
 Result:=ConsoleWindowGetY(handle);
end;

{==============================================================================}

function console_window_set_y(handle: WINDOW_HANDLE; y: uint32_t): uint32_t; stdcall;
{Set the current Y (Row) position of an existing console window}
{Handle: The handle of the window to set Y for}
{Y: The new Y value to set}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For Text Console functions, Y is based on character rows not screen pixels}
begin
 {}
 Result:=ConsoleWindowSetY(handle,y);
end;

{==============================================================================}

function console_window_get_xy(handle: WINDOW_HANDLE; var x, y: uint32_t): uint32_t; stdcall;
{Get the current X and Y positions of an existing console window}
{Handle: The handle of the window to get X and Y for}
{X: The returned X value}
{Y: The returned Y value}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For Text Console functions, X and Y are based on character rows and columns not screen pixels}
begin
 {}
 Result:=ConsoleWindowGetXY(handle,x,y);
end;

{==============================================================================}

function console_window_set_xy(handle: WINDOW_HANDLE; x, y: uint32_t): uint32_t; stdcall;
{Set the current X and Y positions of an existing console window}
{Handle: The handle of the window to set X and Y for}
{X: The new X value}
{Y: The new Y value}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For Text Console functions, X and Y are based on character rows and columns not screen pixels}
begin
 {}
 Result:=ConsoleWindowSetXY(handle,x,y);
end;

{==============================================================================}

function console_window_get_point(handle: WINDOW_HANDLE): TCONSOLE_POINT; stdcall;
{Get the point X,Y of an existing console window}
{Handle: The handle of the window to get the point for}
{Return: The current point of the window}
{Note: For Text Console functions, Point is based on character rows and columns not screen pixels}
begin
 {}
 Result:=ConsoleWindowGetPoint(handle);
end;

{==============================================================================}

function console_window_set_point(handle: WINDOW_HANDLE; const point: TCONSOLE_POINT): uint32_t; stdcall;
{Set the point X,Y of an existing console window}
{Handle: The handle of the window to set the point for}
{Point: The new point to set for the window}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For Text Console functions, Point is based on character rows and columns not screen pixels}
begin
 {}
 Result:=ConsoleWindowSetPoint(handle,point);
end;

{==============================================================================}

function console_window_get_cols(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Get the current columns of the window viewport for an existing console window}
{Handle: The handle of the window to get columns for}
{Return: The columns value for the current window viewport}
{Note: For Text Console functions, Columns is based on character columns not screen pixels}
begin
 {}
 Result:=ConsoleWindowGetCols(handle);
end;

{==============================================================================}

function console_window_get_rows(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Get the current rows of the window viewport for an existing console window}
{Handle: The handle of the window to get rows for}
{Return: The rows value for the current window viewport}
{Note: For Text Console functions, Rows is based on character rows not screen pixels}
begin
 {}
 Result:=ConsoleWindowGetRows(handle);
end;

{==============================================================================}

function console_window_get_width(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Get the absolute width of an existing console window}
{Handle: The handle of the window to get the width for}
{Return: The absolute width of the window}
{Note: For Text Console functions, Width is based on character columns not screen pixels}
begin
 {}
 Result:=ConsoleWindowGetWidth(handle);
end;

{==============================================================================}

function console_window_get_height(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Get the absolute height of an existing console window}
{Handle: The handle of the window to get the height for}
{Return: The absolute height of the window}
{Note: For Text Console functions, Height is based on character rows not screen pixels}
begin
 {}
 Result:=ConsoleWindowGetHeight(handle);
end;

{==============================================================================}

function console_window_get_format(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Get the color format of an existing console window}
{Handle: The handle of the window to get the format for}
{Return: The color format of the window (eg COLOR_FORMAT_ARGB32)}
begin
 {}
 Result:=ConsoleWindowGetFormat(handle);
end;

{==============================================================================}

function console_window_get_forecolor(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Get the current foreground color of an existing console window}
{Handle: The handle of the window to get the foreground color for}
{Return: The foreground color of the window (eg COLOR_WHITE)}
begin
 {}
 Result:=ConsoleWindowGetForecolor(handle);
end;

{==============================================================================}

function console_window_set_forecolor(handle: WINDOW_HANDLE; color: uint32_t): uint32_t; stdcall;
{Set the current foreground color of an existing console window}
{Handle: The handle of the window to set the foreground color for}
{Color: The foreground color to set (eg COLOR_WHITE)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleWindowSetForecolor(handle,color);
end;

{==============================================================================}

function console_window_get_backcolor(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Get the current background color of an existing console window}
{Handle: The handle of the window to get the background color for}
{Return: The background color of the window (eg COLOR_BLACK)}
begin
 {}
 Result:=ConsoleWindowGetBackcolor(handle);
end;

{==============================================================================}

function console_window_set_backcolor(handle: WINDOW_HANDLE; color: uint32_t): uint32_t; stdcall;
{Set the current background color of an existing console window}
{Handle: The handle of the window to set the background color for}
{Color: The background color to set (eg COLOR_BLACK)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleWindowSetBackcolor(handle,color);
end;

{==============================================================================}

function console_window_get_font(handle: WINDOW_HANDLE): FONT_HANDLE; stdcall;
{Get the default font of an existing console window}
{Handle: The handle of the window to get the default font for}
{Return: The font handle of the default font or INVALID_HANDLE_VALUE on error}
begin
 {}
 Result:=ConsoleWindowGetFont(handle);
end;

{==============================================================================}

function console_window_set_font(handle: WINDOW_HANDLE; font: FONT_HANDLE): uint32_t; stdcall;
{Set the default font of an existing console window}
{Handle: The handle of the window to set the default font for}
{Font: The font handle of the default font to set}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For Text Console windows, setting the font also clears the window}
begin
 {}
 Result:=ConsoleWindowSetFont(handle,font);
end;

{==============================================================================}

function console_window_get_cursor_xy(handle: WINDOW_HANDLE; var x, y: uint32_t): uint32_t; stdcall;
{Get the current cursor X and Y positions of an existing console window}
{Handle: The handle of the window to get cursor X and Y for}
{X: The returned cursor X value}
{Y: The returned cursor Y value}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For Text Console functions, cursor X and Y are based on character rows and columns not screen pixels}
begin
 {}
 Result:=ConsoleWindowGetCursorXY(handle,x,y);
end;

{==============================================================================}

function console_window_set_cursor_xy(handle: WINDOW_HANDLE; x, y: uint32_t): uint32_t; stdcall;
{Set the current cursor X and Y positions of an existing console window}
{Handle: The handle of the window to set cursor X and Y for}
{X: The new cursor X value}
{Y: The new cursor Y value}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For Text Console functions, cursor X and Y are based on character rows and columns not screen pixels}
begin
 {}
 Result:=ConsoleWindowSetCursorXY(handle,x,y);
end;

{==============================================================================}

function console_window_get_cursor_mode(handle: WINDOW_HANDLE): CURSOR_MODE; stdcall;
{Get the current cursor mode of an existing console window}
{Handle: The handle of the window to get the mode for}
{Return: The current cursor mode (eg CURSOR_MODE_INSERT)}
begin
 {}
 Result:=ConsoleWindowGetCursorMode(handle);
end;

{==============================================================================}

function console_window_set_cursor_mode(handle: WINDOW_HANDLE; cursormode: CURSOR_MODE): uint32_t; stdcall;
{Set the current cursor mode of an existing console window}
{Handle: The handle of the window to set the mode for}
{CursorMode: The cursor mode to set (eg CURSOR_MODE_INSERT)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleWindowSetCursorMode(handle,cursormode);
end;

{==============================================================================}

function console_window_get_cursor_blink(handle: WINDOW_HANDLE): BOOL; stdcall;
{Get the current cursor blink state of an existing console window}
{Handle: The handle of the window to get blink state for}
{Return: True if blink is enabled, False if not or on error}
begin
 {}
 Result:=ConsoleWindowGetCursorBlink(handle);
end;

{==============================================================================}

function console_window_set_cursor_blink(handle: WINDOW_HANDLE; cursorblink: BOOL): uint32_t; stdcall;
{Set the current cursor blink state of an existing console window}
{Handle: The handle of the window to set the blink state for}
{CursorBlink: True to enable blink, False to disable}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleWindowSetCursorBlink(handle,cursorblink);
end;

{==============================================================================}

function console_window_get_cursor_state(handle: WINDOW_HANDLE): CURSOR_STATE; stdcall;
{Get the current cursor state of an existing console window}
{Handle: The handle of the window to get the state for}
{Return: The current cursor state (eg CURSOR_STATE_ON)}
begin
 {}
 Result:=ConsoleWindowGetCursorState(handle);
end;

{==============================================================================}

function console_window_set_cursor_state(handle: WINDOW_HANDLE; cursorstate: CURSOR_STATE): uint32_t; stdcall;
{Set the current cursor state of an existing console window}
{Handle: The handle of the window to set the state for}
{CursorState: The cursor state to set (eg CURSOR_STATE_ON)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleWindowSetCursorState(handle,cursorstate);
end;

{==============================================================================}

function console_window_get_cursor_shape(handle: WINDOW_HANDLE): CURSOR_SHAPE; stdcall;
{Get the current cursor shape of an existing console window}
{Handle: The handle of the window to get the shape for}
{Return: The current cursor shape (eg CURSOR_SHAPE_LINE)}
begin
 {}
 Result:=ConsoleWindowGetCursorShape(handle);
end;

{==============================================================================}

function console_window_set_cursor_shape(handle: WINDOW_HANDLE; cursorshape: CURSOR_SHAPE): uint32_t; stdcall;
{Set the current cursor shape of an existing console window}
{Handle: The handle of the window to set the shape for}
{CursorShape: The cursor shape to set (eg CURSOR_SHAPE_LINE)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleWindowSetCursorShape(handle,cursorshape);
end;

{==============================================================================}

function console_window_get_cursor_color(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Get the current cursor color of an existing console window}
{Handle: The handle of the window to get cursor color for}
{Return: The cursor color of the window (eg COLOR_WHITE)}
{Note: Color will be returned in the default color format (See COLOR_FORMAT_DEFAULT)}
begin
 {}
 Result:=ConsoleWindowGetCursorColor(handle);
end;

{==============================================================================}

function console_window_set_cursor_color(handle: WINDOW_HANDLE; color: uint32_t): uint32_t; stdcall;
{Set the current cursor color of an existing console window}
{Handle: The handle of the window to set the cursor color for}
{Color: The cursor color to set (eg COLOR_WHITE)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Color must be specified in the default color format (See COLOR_FORMAT_DEFAULT)}
begin
 {}
 Result:=ConsoleWindowSetCursorColor(handle,color);
end;

{==============================================================================}

function console_window_get_cursor_reverse(handle: WINDOW_HANDLE): BOOL; stdcall;
{Get the current cursor reverse state of an existing console window}
{Handle: The handle of the window to get reverse state for}
{Return: True if reverse color is enabled, False if inverse color is enabled}
begin
 {}
 Result:=ConsoleWindowGetCursorReverse(handle);
end;

{==============================================================================}

function console_window_set_cursor_reverse(handle: WINDOW_HANDLE; cursorreverse: BOOL): uint32_t; stdcall;
{Set the current cursor reverse state of an existing console window}
{Handle: The handle of the window to set the reverse state for}
{CursorReverse: True to enable reverse color, False to enable inverse color}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleWindowSetCursorReverse(handle,cursorreverse);
end;

{==============================================================================}

function console_window_cursor_on(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Enable the cursor on an existing console window}
{Handle: The handle of the window to enable the cursor for}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleWindowCursorOn(handle);
end;

{==============================================================================}

function console_window_cursor_off(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Disable the cursor on an existing console window}
{Handle: The handle of the window to disable the cursor for}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleWindowCursorOff(handle);
end;

{==============================================================================}

function console_window_cursor_line(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Change the cursor to a vertical line on an existing console window}
{Handle: The handle of the window to change the cursor for}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleWindowCursorLine(handle);
end;

{==============================================================================}

function console_window_cursor_bar(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Change the cursor to a horizontal bar on an existing console window}
{Handle: The handle of the window to change the cursor for}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleWindowCursorBar(handle);
end;

{==============================================================================}

function console_window_cursor_block(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Change the cursor to a solid block on an existing console window}
{Handle: The handle of the window to change the cursor for}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleWindowCursorBlock(handle);
end;

{==============================================================================}

function console_window_cursor_move(handle: WINDOW_HANDLE; x, y: uint32_t): uint32_t; stdcall;
{Move the cursor on an existing console window}
{Handle: The handle of the window to move the cursor for}
{X: The column to move the cursor to}
{Y: The row to move the cursor to}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For Text Console functions, X and Y are based on character rows and columns not screen pixels}
begin
 {}
 Result:=ConsoleWindowCursorMove(handle,x,y);
end;

{==============================================================================}

function console_window_cursor_blink(handle: WINDOW_HANDLE; enabled: BOOL): uint32_t; stdcall;
{Set the blink state of the cursor on an existing console window}
{Handle: The handle of the window to set the blink state for}
{Enabled: True if the cursor is blinking, False if not}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleWindowCursorBlink(handle,enabled);
end;

{==============================================================================}

function console_window_cursor_color(handle: WINDOW_HANDLE; color: uint32_t): uint32_t; stdcall;
{Set the color of the cursor on an existing console window}
{Handle: The handle of the window to set the color for}
{Color: The cursor color to set (eg COLOR_WHITE)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Color must be specified in the default color format (See COLOR_FORMAT_DEFAULT)}
begin
 {}
 Result:=ConsoleWindowCursorColor(handle,color);
end;

{==============================================================================}

function console_window_cursor_reverse(handle: WINDOW_HANDLE; enabled: BOOL): uint32_t; stdcall;
{Set the reverse state of the cursor on an existing console window}
{Handle: The handle of the window to set the reverse state for}
{Enabled: True if the cursor shows in reverse colors, False if it shows in inverse colors}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleWindowCursorReverse(handle,enabled);
end;

{==============================================================================}

function console_window_add_history(handle: WINDOW_HANDLE; const value: PCHAR): uint32_t; stdcall;
{Add a value to the command history table of an existing console window}
{Handle: The handle of the window to add to}
{Value: The text to add to the command history}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: When the number of entries in the table reaches the maximum the first entry will be removed}
begin
 {}
 Result:=ConsoleWindowAddHistory(handle,String(value));
end;

{==============================================================================}

function console_window_clear_history(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Remove all entries from the command history table of an existing console window}
{Handle: The handle of the window to clear}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleWindowClearHistory(handle);
end;

{==============================================================================}

function console_window_first_history(handle: WINDOW_HANDLE; value: PCHAR; len: uint32_t): uint32_t; stdcall;
{Get the first (oldest) command history value from an existing console window}
{Handle: The handle of the window to get from}
{Return: The command history value or an empty string on failure}
begin
 {}
 Result:=APIStringToPCharBuffer(ConsoleWindowFirstHistory(handle),value,len);
end;

{==============================================================================}

function console_window_last_history(handle: WINDOW_HANDLE; value: PCHAR; len: uint32_t): uint32_t; stdcall;
{Get the last (most recent) command history value from an existing console window}
{Handle: The handle of the window to get from}
{Return: The command history value or an empty string on failure}
begin
 {}
 Result:=APIStringToPCharBuffer(ConsoleWindowLastHistory(handle),value,len);
end;

{==============================================================================}

function console_window_next_history(handle: WINDOW_HANDLE; value: PCHAR; len: uint32_t): uint32_t; stdcall;
{Get the next (after current) command history value from an existing console window}
{Handle: The handle of the window to get from}
{Return: The command history value or an empty string on failure}
begin
 {}
 Result:=APIStringToPCharBuffer(ConsoleWindowNextHistory(handle),value,len);
end;

{==============================================================================}

function console_window_previous_history(handle: WINDOW_HANDLE; value: PCHAR; len: uint32_t): uint32_t; stdcall;
{Get the next (before current) command history value from an existing console window}
{Handle: The handle of the window to get from}
{Return: The command history value or an empty string on failure}
{Note: If there is no current history value the last value is returned}
begin
 {}
 Result:=APIStringToPCharBuffer(ConsoleWindowPreviousHistory(handle),value,len);
end;

{==============================================================================}

function console_window_current_history(handle: WINDOW_HANDLE; value: PCHAR; len: uint32_t): uint32_t; stdcall;
{Get the current command history value from an existing console window}
{Handle: The handle of the window to get from}
{Return: The command history value or an empty string on failure}
{Note: If there is no current history value the last value is returned}
begin
 {}
 Result:=APIStringToPCharBuffer(ConsoleWindowCurrentHistory(handle),value,len);
end;

{==============================================================================}

function console_window_scroll_up(handle: WINDOW_HANDLE; row, lines: uint32_t): uint32_t; stdcall;
{Scroll the current viewport of an existing console window up}
{Handle: The handle of the window to scroll}
{Row: The starting row (Y) for the scroll up, all rows from top plus Lines down to Row will be scrolled up}
{Lines: The number of character lines to scroll up, Lines number of rows at the top will be discarded}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: The starting Row will be blanked with the background color}
begin
 {}
 Result:=ConsoleWindowScrollUp(handle,row,lines);
end;

{==============================================================================}

function console_window_scroll_down(handle: WINDOW_HANDLE; row, lines: uint32_t): uint32_t; stdcall;
{Scroll the current viewport of an existing console window down}
{Handle: The handle of the window to scroll}
{Row: The starting row (Y) for the scroll down, all rows from bottom minus Lines up to Row will be scrolled down}
{Lines: The number of character lines to scroll down, Lines number of rows at the bottom will be discarded}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: The starting Row will be blanked with the background color}
begin
 {}
 Result:=ConsoleWindowScrollDown(handle,row,lines);
end;

{==============================================================================}

function console_window_scroll_left(handle: WINDOW_HANDLE; row, col, lines, chars: uint32_t): uint32_t; stdcall;
{Scroll the current viewport of an existing console window left}
{Handle: The handle of the window to scroll}
{Row: The starting row (Y) for the scroll left, all rows from Row down to Row + Lines will be scrolled left}
{Lines: The number of rows to scroll left, all rows from Row down to Row + Lines will be scrolled left}
{Col: The starting column (X) for the scroll left, all cols from left plus Chars to Col with be scrolled left}
{Chars: The number of characters to scroll left, Chars number of columns at the left will be discarded}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: The starting Col will be blanked with the background color}
begin
 {}
 Result:=ConsoleWindowScrollLeft(handle,row,col,lines,chars);
end;

{==============================================================================}

function console_window_scroll_right(handle: WINDOW_HANDLE; row, col, lines, chars: uint32_t): uint32_t; stdcall;
{Scroll the current viewport of an existing console window right}
{Handle: The handle of the window to scroll}
{Row: The starting row (Y) for the scroll right, all rows from Row down to Row + Lines will be scrolled right}
{Lines: The number of rows to scroll right, all rows from Row down to Row + Lines will be scrolled right}
{Col: The starting column (X) for the scroll right, all rows from right minus Chars to Col will be scrolled right}
{Chars: The number of characters to scroll right, Chars number of columns at the right will be discarded}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: The starting Col will be blanked with the background color}
begin
 {}
 Result:=ConsoleWindowScrollRight(handle,row,col,lines,chars);
end;

{==============================================================================}

function console_window_clear(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Clear the current viewport of an existing console window}
{Handle: The handle of the window to clear}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleWindowClear(handle);
end;

{==============================================================================}

function console_window_clear_ex(handle: WINDOW_HANDLE; x1, y1, x2, y2: uint32_t; cursor: BOOL): uint32_t; stdcall;
{Clear part of the the current viewport of an existing console window}
{Handle: The handle of the window to clear}
{X1: The left edge of the area to clear (relative to current viewport)}
{Y1: The top edge of the area to clear (relative to current viewport)}
{X2: The right edge of the area to clear (relative to current viewport)}
{Y2: The bottom edge of the area to clear (relative to current viewport)}
{Cursor: If True update the cursor position after clearing}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For Text Console functions, Window is based on screen character rows and columns not screen pixels}
begin
 {}
 Result:=ConsoleWindowClearEx(handle,x1,y1,x2,y2,cursor);
end;

{==============================================================================}

function console_window_write(handle: WINDOW_HANDLE; const text: PCHAR): uint32_t; stdcall;
{Write text on an existing console window at the current position in the current color}
{Handle: The handle of the window to write text on}
{Text: The text to write}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: The window will not scroll up at the end of the line}
begin
 {}
 Result:=ConsoleWindowWrite(handle,String(text));
end;

{==============================================================================}

function console_window_write_ex(handle: WINDOW_HANDLE; const text: PCHAR; x, y, forecolor, backcolor: uint32_t): uint32_t; stdcall;
{Write text on an existing console window}
{Handle: The handle of the window to write text on}
{Text: The text to write}
{X: The column to start writing the text at}
{Y: The row to start writing the text at}
{Forecolor: The foreground color to use (eg COLOR_WHITE)}
{Backcolor: The background color to use (eg COLOR_BLACK)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For Text Console functions, X and Y are based on screen character rows and columns not screen pixels}
{Note: The window will not scroll up at the end of the line}
begin
 {}
 Result:=ConsoleWindowWriteEx(handle,String(text),x,y,forecolor,backcolor);
end;

{==============================================================================}

function console_window_write_ln(handle: WINDOW_HANDLE; const text: PCHAR): uint32_t; stdcall;
{Write text on an existing console window at the current position in the current color}
{Handle: The handle of the window to write text on}
{Text: The text to write}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: The window will scroll up at the end of the line}
begin
 {}
 Result:=ConsoleWindowWriteLn(handle,String(text));
end;

{==============================================================================}

function console_window_write_ln_ex(handle: WINDOW_HANDLE; const text: PCHAR; x, y, forecolor, backcolor: uint32_t): uint32_t; stdcall;
{Write text on an existing console window}
{Handle: The handle of the window to write text on}
{Text: The text to write}
{X: The column to start writing the text at}
{Y: The row to start writing the text at}
{Forecolor: The foreground color to use (eg COLOR_WHITE)}
{Backcolor: The background color to use (eg COLOR_BLACK)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For Text Console functions, X and Y are based on character rows and columns not screen pixels}
{Note: The window will scroll up at the end of the line}
begin
 {}
 Result:=ConsoleWindowWriteLnEx(handle,String(text),x,y,forecolor,backcolor);
end;

{==============================================================================}

function console_window_write_chr(handle: WINDOW_HANDLE; ch: CHAR): uint32_t; stdcall;
{Write a character on an existing console window at the current position in the current color}
{Handle: The handle of the window to write the character on}
{Chr: The character to write}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleWindowWriteChr(handle,ch);
end;

{==============================================================================}

function console_window_write_chr_ex(handle: WINDOW_HANDLE; ch: CHAR; x, y, forecolor, backcolor: uint32_t): uint32_t; stdcall;
{Write a character on an existing console window}
{Handle: The handle of the window to write the character on}
{Chr: The character to write}
{X: The column to start writing the character at}
{Y: The row to start writing the character at}
{Forecolor: The foreground color to use (eg COLOR_WHITE)}
{Backcolor: The background color to use (eg COLOR_BLACK)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For Text Console functions, X and Y are based on character rows and columns not screen pixels}
begin
 {}
 Result:=ConsoleWindowWriteChrEx(handle,ch,x,y,forecolor,backcolor);
end;

{==============================================================================}

function console_window_output(handle: WINDOW_HANDLE; const source, dest: TCONSOLE_POINT; buffer: PCONSOLE_CHAR; width, height, skip: uint32_t): uint32_t; stdcall;
{Output a rectangular area of text to a console window}
{Handle: The console window to output to}
{Source: The X and Y point in the source buffer to copy text from (Characters)}
{Dest: The X and Y point on the console window to copy text to (Characters)}
{Buffer: A pointer to a buffer of TConsoleChar structures which represent rows of text}
{Width: The width of the area to be output (Characters)}
{Height: The height of the area to be output (Characters)}
{Skip: The number of characters to skip in the buffer after each row (Optional)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For Text Console functions, Source, Dest, Width, Height and Skip are based on character rows and columns not screen pixels}
begin
 {}
 Result:=ConsoleWindowOutput(handle,source,dest,buffer,width,height,skip);
end;

{==============================================================================}

function console_window_read(handle: WINDOW_HANDLE; text: PCHAR; var len: uint32_t): uint32_t; stdcall;
{Read text input from the console and echo to an existing console window at the current position in the current color}
{Handle: The handle of the window to echo input to}
{Text: The text read from the console on return}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: The console window will not scroll up on return}
var
 Buffer:String;
begin
 {}
 Result:=ConsoleWindowRead(handle,Buffer);
 if Result = ERROR_SUCCESS then APIStringToPCharBufferLen(Buffer,text,len);
end;

{==============================================================================}

function console_window_read_ln(handle: WINDOW_HANDLE; text: PCHAR; var len: uint32_t): uint32_t; stdcall;
{Read text input from the console and echo to an existing console window at the current position in the current color}
{Handle: The handle of the window to echo input to}
{Text: The text read from the console on return}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: The console window will scroll up one line on return}
var
 Buffer:String;
begin
 {}
 Result:=ConsoleWindowReadLn(handle,Buffer);
 if Result = ERROR_SUCCESS then APIStringToPCharBufferLen(Buffer,text,len);
end;

{==============================================================================}

function console_window_read_ln_ex(handle: WINDOW_HANDLE; text: PCHAR; var len: uint32_t; prompt: PCHAR; x, y, forecolor, backcolor: uint32_t; scroll, history: BOOL; completion: console_window_completion_cb; data: PVOID): uint32_t; stdcall;
{Read text input from the console and echo to an existing console window at the specified position in the specified color}
{Handle: The handle of the window to echo input to}
{Text: The text read from the console on return}
{Prompt: An optional text prompt to display at the start of the line}
{X: The starting X position for the output (0 for current position)}
{Y: The starting Y position for the output (0 for current position)}
{Forecolor: The text forecolor for the output (COLOR_NONE for current color)}
{Backcolor: The text backcolor for the output (COLOR_NONE for current color)}
{Scroll: If true then scroll up one line on return}
{History: If true then support console history buffer using Up, Down and F3 keys}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Supports common line editing behaviour including Home, End, Left, Right, Up, Down, Insert, Backspace and Delete}
var
 Buffer:String;
begin
 {}
 Result:=ConsoleWindowReadLnEx(handle,Buffer,String(prompt),x,y,forecolor,backcolor,scroll,history,completion,data);
 if Result = ERROR_SUCCESS then APIStringToPCharBufferLen(Buffer,text,len);
end;

{==============================================================================}

function console_window_read_chr(handle: WINDOW_HANDLE; var ch: CHAR): uint32_t; stdcall;
{Read one character input from the console and echo to an existing console window at the current position in the current color}
{Handle: The handle of the window to echo input to}
{Chr: The character read from the console on return}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: The console window will not scroll up on return}
begin
 {}
 Result:=ConsoleWindowReadChr(handle,ch);
end;

{==============================================================================}

function console_window_read_chr_ex(handle: WINDOW_HANDLE; var ch: CHAR; prompt: PCHAR; x, y, forecolor, backcolor: uint32_t; echo, scroll: BOOL): uint32_t; stdcall;
{Read one character input from the console and optionally echo to an existing console window at the specified position in the specified color}
{Handle: The handle of the window to echo input to}
{Chr: The character read from the console on return}
{Prompt: An optional text prompt to display at the start of the line}
{X: The starting X position for the output (0 for current position)}
{Y: The starting Y position for the output (0 for current position)}
{Forecolor: The text forecolor for the output (COLOR_NONE for current color)}
{Backcolor: The text backcolor for the output (COLOR_NONE for current color)}
{Echo: If true then echo the character to the console window}
{Scroll: If true then scroll up one line on return}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleWindowReadChrEx(handle,ch,String(prompt),x,y,forecolor,backcolor,echo,scroll);
end;

{==============================================================================}
{CRT Console Functions}
procedure console_clr_eol; stdcall;
{Compatible with RTL Crt unit function ClrEol}
{See: http://www.freepascal.org/docs-html-3.0.0/rtl/crt/clreol.html}
begin
 {}
 ConsoleClrEol;
end;

{==============================================================================}

procedure console_clr_scr; stdcall;
{Compatible with RTL Crt unit function ClrScr}
{See: http://www.freepascal.org/docs-html-3.0.0/rtl/crt/clrscr.html}
begin
 {}
 ConsoleClrScr;
end;

{==============================================================================}

procedure console_delay(ms: uint16_t); stdcall;
{Compatible with RTL Crt unit function Delay}
{See: http://www.freepascal.org/docs-html-3.0.0/rtl/crt/delay.html}
begin
 {}
 ConsoleDelay(ms);
end;

{==============================================================================}

procedure console_del_line; stdcall;
{Compatible with RTL Crt unit function DelLine}
{See: http://www.freepascal.org/docs-html-3.0.0/rtl/crt/delline.html}
begin
 {}
 ConsoleDelLine;
end;

{==============================================================================}

procedure console_goto_xy(x, y: int); stdcall;
{Compatible with RTL Crt unit function GotoXY}
{See: http://www.freepascal.org/docs-html-3.0.0/rtl/crt/gotoxy.html}
{Note: For CRT Console functions, X and Y are based on character rows and columns not screen pixels}
begin
 {}
 ConsoleGotoXY(x,y);
end;

{==============================================================================}

procedure console_high_video; stdcall;
{Compatible with RTL Crt unit function HighVideo}
{See: http://www.freepascal.org/docs-html-3.0.0/rtl/crt/highvideo.html}
begin
 {}
 ConsoleHighVideo;
end;

{==============================================================================}

procedure console_ins_line; stdcall;
{Compatible with RTL Crt unit function InsLine}
{See: http://www.freepascal.org/docs-html-3.0.0/rtl/crt/insline.html}
begin
 {}
 ConsoleInsLine;
end;

{==============================================================================}

function console_keypressed: BOOL; stdcall;
{Compatible with RTL Crt unit function KeyPressed}
{See: http://www.freepascal.org/docs-html-3.0.0/rtl/crt/keypressed.html}
begin
 {}
 Result:=ConsoleKeypressed;
end;

{==============================================================================}

procedure console_low_video; stdcall;
{Compatible with RTL Crt unit function LowVideo}
{See: http://www.freepascal.org/docs-html-3.0.0/rtl/crt/lowvideo.html}
begin
 {}
 ConsoleLowVideo;
end;

{==============================================================================}

procedure console_norm_video; stdcall;
{Compatible with RTL Crt unit function NormVideo}
{See: http://www.freepascal.org/docs-html-3.0.0/rtl/crt/normvideo.html}
begin
 {}
 ConsoleNormVideo;
end;

{==============================================================================}

procedure console_no_sound; stdcall;
{Compatible with RTL Crt unit function NoSound}
{See: http://www.freepascal.org/docs-html-3.0.0/rtl/crt/nosound.html}
begin
 {}
 ConsoleNoSound;
end;

{==============================================================================}

function console_read_key: CHAR; stdcall;
{Compatible with RTL Crt unit function ReadKey}
{See: http://www.freepascal.org/docs-html-3.0.0/rtl/crt/readkey.html}
{Note: For extended key scan codes see: http://www.freepascal.org/docs-html/rtl/keyboard/kbdscancode.html}
begin
 {}
 Result:=ConsoleReadKey;
end;

{==============================================================================}

procedure console_sound(hz: uint16_t); stdcall;
{Compatible with RTL Crt unit function Sound}
{See: http://www.freepascal.org/docs-html-3.0.0/rtl/crt/sound.html}
begin
 {}
 ConsoleSound(hz);
end;

{==============================================================================}

procedure console_text_background(color: uint32_t); stdcall;
{Compatible with RTL Crt unit function TextBackground}
{See: http://www.freepascal.org/docs-html-3.0.0/rtl/crt/textbackground.html}
begin
 {}
 ConsoleTextBackground(color);
end;

{==============================================================================}

procedure console_text_color(color: uint32_t); stdcall;
{Compatible with RTL Crt unit function TextColor}
{See: http://www.freepascal.org/docs-html-3.0.0/rtl/crt/textcolor.html}
begin
 {}
 ConsoleTextColor(color);
end;

{==============================================================================}

procedure console_text_mode(mode: int); stdcall;
{Compatible with RTL Crt unit function TextMode}
{See: http://www.freepascal.org/docs-html-3.0.0/rtl/crt/textmode.html}
begin
 {}
 ConsoleTextMode(mode);
end;

{==============================================================================}

function console_where_x: int; stdcall;
{Compatible with RTL Crt unit function WhereX}
{See: http://www.freepascal.org/docs-html-3.0.0/rtl/crt/wherex.html}
{Note: For CRT Console functions, X is based on character columns not screen pixels}
begin
 {}
 Result:=ConsoleWhereX;
end;

{==============================================================================}

function console_where_y: int; stdcall;
{Compatible with RTL Crt unit function WhereY}
{See: http://www.freepascal.org/docs-html-3.0.0/rtl/crt/wherey.html}
{Note: For CRT Console functions, Y is based on character row not screen pixels}
begin
 {}
 Result:=ConsoleWhereY;
end;

{==============================================================================}

procedure console_window(x1, y1, x2, y2: int); stdcall;
{Compatible with RTL Crt unit function Window}
{See: http://www.freepascal.org/docs-html-3.0.0/rtl/crt/window.html}
{Note: For CRT Console functions, X1, Y1, X2 and Y2 are based on character rows and columns not screen pixels}
begin
 {}
 ConsoleWindow(x1,y1,x2,y2);
end;

{==============================================================================}

procedure console_scroll_up(row, lines: int); stdcall;
{Scroll the default console window up}
{Row: The starting row (Y) for the scroll up, all rows from top plus Lines down to Row will be scrolled up}
{Lines: The number of character lines to scroll up, Lines number of rows at the top will be discarded}
{Note: For CRT Console functions, Row and Lines are based on character rows and columns not screen pixels}
begin
 {}
 ConsoleScrollUp(row,lines);
end;

{==============================================================================}

procedure console_scroll_down(row, lines: int); stdcall;
{Scroll the default console window down}
{Row: The starting row (Y) for the scroll down, all rows from bottom minus Lines up to Row will be scrolled down}
{Lines: The number of character lines to scroll down, Lines number of rows at the bottom will be discarded}
{Note: For CRT Console functions, Row and Lines are based on character rows and columns not screen pixels}
begin
 {}
 ConsoleScrollDown(row,lines);
end;

{==============================================================================}

procedure console_write(const text: PCHAR); stdcall;
{Write text on the default console window at the current position in the current color}
{Text: The text to write}
{Note: The window will not scroll up at the end of the line}
begin
 {}
 ConsoleWrite(String(text));
end;

{==============================================================================}

procedure console_write_ln(const text: PCHAR); stdcall;
{Write text on the default console window at the current position in the current color}
{Text: The text to write}
{Note: The window will scroll up at the end of the line}
begin
 {}
 ConsoleWriteLn(String(text));
end;

{==============================================================================}

procedure console_write_chr(ch: CHAR); stdcall;
{Write a character on the default console window at the current position in the current color}
{Chr: The character to write}
begin
 {}
 ConsoleWriteChr(ch);
end;

{==============================================================================}

procedure console_read(text: PCHAR; var len: uint32_t); stdcall;
{Read text from console input and echo to the screen}
{Text: The text read from the console input}
var
 Buffer:String;
begin
 {}
 ConsoleRead(Buffer);
 APIStringToPCharBufferLen(Buffer,text,len);
end;

{==============================================================================}

procedure console_read_ln(text: PCHAR; var len: uint32_t); stdcall;
{Read text from console input and echo to the screen}
{Text: The text read from the console input}
var
 Buffer:String;
begin
 {}
 ConsoleReadLn(Buffer);
 APIStringToPCharBufferLen(Buffer,text,len);
end;

{==============================================================================}

procedure console_read_chr(var ch: CHAR); stdcall;
{Read a character from console input and echo to the screen}
{Chr: The character read from the console input}
begin
 {}
 ConsoleReadChr(ch);
end;

{==============================================================================}
{Console Helper Functions}
function console_device_get_count: uint32_t; stdcall;
{Get the current console device count}
begin
 {}
 Result:=ConsoleDeviceGetCount;
end;

{==============================================================================}

function console_device_get_default: PCONSOLE_DEVICE; stdcall;
{Get the current default console device}
begin
 {}
 Result:=ConsoleDeviceGetDefault;
end;

{==============================================================================}

function console_device_set_default(console: PCONSOLE_DEVICE): uint32_t; stdcall;
{Set the current default console device}
begin
 {}
 Result:=ConsoleDeviceSetDefault(console);
end;

{==============================================================================}

function console_device_check(console: PCONSOLE_DEVICE): PCONSOLE_DEVICE; stdcall;
{Check if the supplied Console device is in the Console table}
begin
 {}
 Result:=ConsoleDeviceCheck(console);
end;

{==============================================================================}

function console_device_caret_check(console: PCONSOLE_DEVICE; caret: PCONSOLE_CARET): PCONSOLE_CARET; stdcall;
{Check if a console caret entry is valid}
{Console: The console device to search for the caret}
{Caret: The caret entry to check for validity}
{Return: The supplied caret if successful or nil on failure}
begin
 {}
 Result:=ConsoleDeviceCaretCheck(console,caret);
end;

{==============================================================================}

function console_type_to_string(consoletype: uint32_t; value: PCHAR; len: uint32_t): uint32_t; stdcall;
{Convert a Console type value to a string}
begin
 {}
 Result:=APIStringToPCharBuffer(ConsoleTypeToString(consoletype),value,len);
end;

{==============================================================================}

function console_state_to_string(consolestate: uint32_t; value: PCHAR; len: uint32_t): uint32_t; stdcall;
{Convert a Console state value to a string}
begin
 {}
 Result:=APIStringToPCharBuffer(ConsoleStateToString(consolestate),value,len);
end;

{==============================================================================}

function console_device_get_default_font: FONT_HANDLE; stdcall;
{Get the default console font}
begin
 {}
 Result:=ConsoleDeviceGetDefaultFont;
end;

{==============================================================================}

function console_position_to_string(position: uint32_t; value: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(ConsolePositionToString(position),value,len);
end;

{==============================================================================}
{Text Console Helper Functions}
function console_window_get_count(console: PCONSOLE_DEVICE): uint32_t; stdcall;
{Get the current console window count}
{Console: The console device to get the window count for}
{Return: The current number of console windows on the specified console device}
begin
 {}
 Result:=ConsoleWindowGetCount(console);
end;

{==============================================================================}

function console_window_get_active(console: PCONSOLE_DEVICE): WINDOW_HANDLE; stdcall;
{Get the current console active window}
{Console: The console device to get the active window for}
{Return: The window handle of the current active window or INVALID_HANDLE_VALUE on failure}
begin
 {}
 Result:=ConsoleWindowGetActive(console);
end;

{==============================================================================}

function console_window_get_default(console: PCONSOLE_DEVICE): WINDOW_HANDLE; stdcall;
{Get the current console default window}
{Console: The console device to get the default window for}
{Return: The window handle of the current default window or INVALID_HANDLE_VALUE on failure}
begin
 {}
 Result:=ConsoleWindowGetDefault(console);
end;

{==============================================================================}

function console_window_set_default(console: PCONSOLE_DEVICE; handle: WINDOW_HANDLE): uint32_t; stdcall;
{Set the current console default window}
{Console: The console device to set the default window for}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=ConsoleWindowSetDefault(console,handle);
end;

{==============================================================================}

function console_window_check(console: PCONSOLE_DEVICE; window: PCONSOLE_WINDOW): PCONSOLE_WINDOW; stdcall;
{Check if a console window entry is valid}
{Console: The console device to search for the window}
{Window: The window entry to check for validity}
{Return: The supplied window if successful or nil on failure}
begin
 {}
 Result:=ConsoleWindowCheck(console,window);
end;

{==============================================================================}

function console_window_state_to_string(windowstate: uint32_t; value: PCHAR; len: uint32_t): uint32_t; stdcall;
{Convert a Console Window state value to a string}
begin
 {}
 Result:=APIStringToPCharBuffer(ConsoleWindowStateToString(windowstate),value,len);
end;

{==============================================================================}

function console_window_mode_to_string(windowmode: uint32_t; value: PCHAR; len: uint32_t): uint32_t; stdcall;
{Convert a Console Window mode value to a string}
begin
 {}
 Result:=APIStringToPCharBuffer(ConsoleWindowModeToString(windowmode),value,len);
end;

{==============================================================================}

function console_window_get_default_font: FONT_HANDLE; stdcall;
{Get the default console window font}
begin
 {}
 Result:=ConsoleWindowGetDefaultFont;
end;

{==============================================================================}

function console_window_redirect_output(handle: WINDOW_HANDLE): BOOL; stdcall;
{Redirect standard output to the console window specified by Handle}
{Handle: The window handle to redirect output to (or INVALID_HANDLE_VALUE to stop redirection)}
{Return: True if completed successfully or False if an error occurred}
{Note: Redirects the output of the text files Output, ErrOutput, StdOut and StdErr
       which also redirects the output of Write, WriteLn and the standard C library}
begin
 {}
 Result:=ConsoleWindowRedirectOutput(handle);
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{Logging Functions}
{$IFDEF API_EXPORT_LOGGING}
function logging_device_start(logging: PLOGGING_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=LoggingDeviceStart(logging);
end;

{==============================================================================}

function logging_device_stop(logging: PLOGGING_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=LoggingDeviceStop(logging);
end;

{==============================================================================}

function logging_device_output(logging: PLOGGING_DEVICE; const data: PCHAR): uint32_t; stdcall;
begin
 {}
 Result:=LoggingDeviceOutput(logging,String(data));
end;

{==============================================================================}

function logging_device_output_ex(logging: PLOGGING_DEVICE; facility, severity: uint32_t; const tag, content: PCHAR): uint32_t; stdcall;
begin
 {}
 Result:=LoggingDeviceOutputEx(logging,facility,severity,String(tag),String(content));
end;

{==============================================================================}

function logging_device_get_target(logging: PLOGGING_DEVICE; target: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(LoggingDeviceGetTarget(logging),target,len);
end;

{==============================================================================}

function logging_device_set_target(logging: PLOGGING_DEVICE; const target: PCHAR): uint32_t; stdcall;
begin
 {}
 Result:=LoggingDeviceSetTarget(logging,String(target));
end;

{==============================================================================}

function logging_device_create(default: BOOL): PLOGGING_DEVICE; stdcall;
{Create a new Logging device entry}
{Default: If true make the new device the default logging device if there is no current default}
{Return: Pointer to new Logging device entry or nil if Logging device could not be created}
begin
 {}
 Result:=LoggingDeviceCreate(default);
end;

{==============================================================================}

function logging_device_create_ex(size: uint32_t; default: BOOL): PLOGGING_DEVICE; stdcall;
{Create a new Logging device entry}
{Size: Size in bytes to allocate for new Logging (Including the Logging entry)}
{Default: If true make the new device the default logging device if there is no current default}
{Return: Pointer to new Logging device entry or nil if Logging device could not be created}
begin
 {}
 Result:=LoggingDeviceCreateEx(size,default);
end;

{==============================================================================}

function logging_device_destroy(logging: PLOGGING_DEVICE): uint32_t; stdcall;
{Destroy an existing Logging device entry}
begin
 {}
 Result:=LoggingDeviceDestroy(logging);
end;

{==============================================================================}

function logging_device_register(logging: PLOGGING_DEVICE): uint32_t; stdcall;
{Register a new Logging device in the Logging table}
begin
 {}
 Result:=LoggingDeviceRegister(logging);
end;

{==============================================================================}

function logging_device_deregister(logging: PLOGGING_DEVICE): uint32_t; stdcall;
{Deregister a Logging device from the Logging table}
begin
 {}
 Result:=LoggingDeviceDeregister(logging);
end;

{==============================================================================}

function logging_device_find(loggingid: uint32_t): PLOGGING_DEVICE; stdcall;
begin
 {}
 Result:=LoggingDeviceFind(loggingid);
end;

{==============================================================================}

function logging_device_find_by_type(loggingtype: uint32_t): PLOGGING_DEVICE; stdcall;
begin
 {}
 Result:=LoggingDeviceFindByType(loggingtype);
end;

{==============================================================================}

function logging_device_find_by_device(device: PDEVICE): PLOGGING_DEVICE; stdcall;
begin
 {}
 Result:=LoggingDeviceFindByDevice(device);
end;

{==============================================================================}

function logging_device_find_by_name(const name: PCHAR): PLOGGING_DEVICE; stdcall;
begin
 {}
 Result:=LoggingDeviceFindByName(String(name));
end;

{==============================================================================}

function logging_device_find_by_description(const description: PCHAR): PLOGGING_DEVICE; stdcall;
begin
 {}
 Result:=LoggingDeviceFindByDescription(String(description));
end;

{==============================================================================}

function logging_device_enumerate(callback: logging_enumerate_cb; data: PVOID): uint32_t; stdcall;
begin
 {}
 Result:=LoggingDeviceEnumerate(callback,data);
end;

{==============================================================================}

function logging_device_notification(logging: PLOGGING_DEVICE; callback: logging_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=LoggingDeviceNotification(logging,callback,data,notification,flags);
end;

{==============================================================================}
{Logging Helper Functions}
function logging_device_get_count: uint32_t; stdcall;
{Get the current logging device count}
begin
 {}
 Result:=LoggingDeviceGetCount;
end;

{==============================================================================}

function logging_device_get_default: PLOGGING_DEVICE; stdcall;
{Get the current default logging device}
begin
 {}
 Result:=LoggingDeviceGetDefault;
end;

{==============================================================================}

function logging_device_set_default(logging: PLOGGING_DEVICE): uint32_t; stdcall;
{Set the current default logging device}
begin
 {}
 Result:=LoggingDeviceSetDefault(logging);
end;

{==============================================================================}

function logging_device_check(logging: PLOGGING_DEVICE): PLOGGING_DEVICE; stdcall;
{Check if the supplied Logging device is in the Logging table}
begin
 {}
 Result:=LoggingDeviceCheck(logging);
end;

{==============================================================================}

function logging_type_to_string(loggingtype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Convert a Logging type value to a string}
begin
 {}
 Result:=APIStringToPCharBuffer(LoggingTypeToString(loggingtype),_string,len);
end;

{==============================================================================}

function logging_state_to_string(loggingstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Convert a Logging state value to a string}
begin
 {}
 Result:=APIStringToPCharBuffer(LoggingStateToString(loggingstate),_string,len);
end;

{==============================================================================}

function logging_device_redirect_output(logging: PLOGGING_DEVICE): BOOL; stdcall;
{Redirect standard output to the logging device specified by Logging}
{Logging: The logging device to redirect output to (or nil to stop redirection)}
{Return: True if completed successfully or False if an error occurred}
{Note: Redirects the output of the text files Output, ErrOutput, StdOut and StdErr
       which also redirects the output of Write, WriteLn and the standard C library}
begin
 {}
 Result:=LoggingDeviceRedirectOutput(logging);
end;

{==============================================================================}

function logging_get_messageslot_flags: uint32_t; stdcall;
{Get the lock flags for the logging messageslot}
begin
 {}
 Result:=LoggingGetMessageslotFlags;
end;

{==============================================================================}

function logging_console_device_add(console: PCONSOLE_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=LoggingConsoleDeviceAdd(console);
end;

{==============================================================================}

function logging_console_device_remove(console: PCONSOLE_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=LoggingConsoleDeviceRemove(console);
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{DMA Host Functions}
{$IFDEF API_EXPORT_DMA}
function dma_host_start(dma: PDMA_HOST): uint32_t; stdcall;
begin
 {}
 Result:=DMAHostStart(dma);
end;

{==============================================================================}

function dma_host_stop(dma: PDMA_HOST): uint32_t; stdcall;
begin
 {}
 Result:=DMAHostStop(dma);
end;

{==============================================================================}

function dma_host_reset(dma: PDMA_HOST): uint32_t; stdcall;
begin
 {}
 Result:=DMAHostReset(dma);
end;

{==============================================================================}

function dma_host_properties(dma: PDMA_HOST; properties: PDMA_PROPERTIES): uint32_t; stdcall;
begin
 {}
 Result:=DMAHostProperties(dma,properties);
end;

{==============================================================================}

function dma_host_create: PDMA_HOST; stdcall;
{Create a new DMA entry}
{Return: Pointer to new DMA entry or nil if DMA could not be created}
begin
 {}
 Result:=DMAHostCreate;
end;

{==============================================================================}

function dma_host_create_ex(size: uint32_t): PDMA_HOST; stdcall;
{Create a new DMA entry}
{Size: Size in bytes to allocate for new DMA (Including the DMA entry)}
{Return: Pointer to new DMA entry or nil if DMA could not be created}
begin
 {}
 Result:=DMAHostCreateEx(size);
end;

{==============================================================================}

function dma_host_destroy(dma: PDMA_HOST): uint32_t; stdcall;
{Destroy an existing DMA entry}
begin
 {}
 Result:=DMAHostDestroy(dma);
end;

{==============================================================================}

function dma_host_register(dma: PDMA_HOST): uint32_t; stdcall;
{Register a new DMA in the DMA host table}
begin
 {}
 Result:=DMAHostRegister(dma);
end;

{==============================================================================}

function dma_host_deregister(dma: PDMA_HOST): uint32_t; stdcall;
{Deregister a DMA from the DMA host table}
begin
 {}
 Result:=DMAHostDeregister(dma);
end;

{==============================================================================}

function dma_host_find(dmaid: uint32_t): PDMA_HOST; stdcall;
begin
 {}
 Result:=DMAHostFind(dmaid);
end;

{==============================================================================}

function dma_host_enumerate(callback: dma_enumerate_cb; data: PVOID): uint32_t; stdcall;
begin
 {}
 Result:=DMAHostEnumerate(callback,data);
end;

{==============================================================================}

function dma_host_notification(dma: PDMA_HOST; callback: dma_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=DMAHostNotification(dma,callback,data,notification,flags);
end;

{==============================================================================}
{DMA Data Functions}
function dma_data_count(data: PDMA_DATA): uint32_t; stdcall;
{Return the total number of data blocks in the linked list}
begin
 {}
 Result:=DMADataCount(data);
end;

{==============================================================================}

function dma_data_flags(data: PDMA_DATA): uint32_t; stdcall;
{Return the combined flags of the data blocks in the linked list}
begin
 {}
 Result:=DMADataFlags(data);
end;

{==============================================================================}

function dma_data_maximum(data: PDMA_DATA): uint32_t; stdcall;
{Return the size of the largest data block in the linked list}
begin
 {}
 Result:=DMADataMaximum(data);
end;

{==============================================================================}
{DMA Buffer Functions}
function dma_buffer_allocate(dma: PDMA_HOST; size: uint32_t): PVOID; stdcall;
{Allocate a data buffer for a DMA request}
{DMA: The DMA host that the request will be sent to}
{Size: The size of the data buffer to allocate}
{Return: The newly allocated buffer or nil on failure}
begin
 {}
 Result:=DMABufferAllocate(dma,size);
end;

{==============================================================================}

function dma_buffer_allocate_ex(dma: PDMA_HOST; var size: uint32_t): PVOID; stdcall;
{Allocate a data buffer for a DMA request}
{DMA: The DMA host that the request will be sent to}
{Size: The size of the data buffer to allocate (Updated on return to actual size)}
{Return: The newly allocated buffer or nil on failure}
{Note: This differs from DMABufferAllocate in that it updates the size value to reflect
       the actual size of the buffer allocated which may be required for some uses}
begin
 {}
 Result:=DMABufferAllocateEx(dma,size);
end;

{==============================================================================}

function dma_buffer_validate(dma: PDMA_HOST; buffer: PVOID; size: uint32_t): uint32_t; stdcall;
{Validate a data buffer for a DMA request against the DMA host requirements}
{DMA: The DMA host that the request will be sent to}
{Buffer: The data buffer to validate}
{Size: The size of the data buffer}
{Return: ERROR_SUCCESS on success or another error code on failure (ERROR_NOT_COMPATIBLE if not compatible with host)}
{Note: Does not check for cache coherency requirements (Shared, Non Cached) only alignment and size.
       Buffers used as the source of a DMA request do not necessarily need to meet alignment and size
       requirements, however buffers used as a destination must meet these requirements or the caller
       must take appropriate actions to prevent undesirable side effects from cache invalidation.}
begin
 {}
 Result:=DMABufferValidate(dma,buffer,size);
end;

{==============================================================================}

function dma_buffer_release(buffer: PVOID): uint32_t; stdcall;
{Release a data buffer from a DMA request}
{Data: The buffer to be released}
{Return: ERROR_SUCCESS on success or another error code on failure}
begin
 {}
 Result:=DMABufferRelease(buffer);
end;

{==============================================================================}
{DMA Request Functions}
function dma_request_allocate(dma: PDMA_HOST; data: PDMA_DATA; callback: dma_request_completed_cb; driverdata: PVOID; direction, peripheral, flags: uint32_t): PDMA_REQUEST; stdcall;
{Allocate a new DMA request}
{DMA: The DMA host this request will be sent to}
{Data: A linked list of DMA data blocks for the transfer (Optional)}
{Callback: The callback function to be called on completion of the request}
{DriverData: Driver private data for the callback (Optional)}
{Direction: The direction of the DMA request (eg DMA_DIR_MEM_TO_MEM)}
{Peripheral: The peripheral ID for data request gating (eg DMA_DREQ_ID_NONE)}
{Flags: Additional flags for this request (eg DMA_REQUEST_FLAG_CYCLIC)}
{Return: The newly allocated request or nil on failure}
begin
 {}
 Result:=DMARequestAllocate(dma,data,callback,driverdata,direction,peripheral,flags);
end;

{==============================================================================}

function dma_request_release(request: PDMA_REQUEST): uint32_t; stdcall;
{Release and destroy a DMA request}
{Request: The request to be released}
{Return: ERROR_SUCCESS on success or another error code on failure}
begin
 {}
 Result:=DMARequestRelease(request);
end;

{==============================================================================}

function dma_request_submit(request: PDMA_REQUEST): uint32_t; stdcall;
{Submit a DMA request to a DMA host}
{Request: The request to be submitted}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: The request will be completed asynchronously by the DMA host and the
 completion callback will be called when the request has either succeeded or failed}
begin
 {}
 Result:=DMARequestSubmit(request);
end;

{==============================================================================}

function dma_request_cancel(request: PDMA_REQUEST): uint32_t; stdcall;
{Cancel a DMA request previously submitted to a DMA host}
{Request: The request to be cancelled}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=DMARequestCancel(request);
end;

{==============================================================================}

procedure dma_request_complete(request: PDMA_REQUEST); stdcall;
{Called by a DMA host when a DMA request completes}
{Request: The DMA request which has completed}
{Note: DMA host drivers may call this on a worker thread}
begin
 {}
 DMARequestComplete(request);
end;

{==============================================================================}
{DMA Transfer Functions}
function dma_transfer_request(dma: PDMA_HOST; data: PDMA_DATA; direction, peripheral, flags, timeout: uint32_t): uint32_t; stdcall;
{Perform a DMA transfer request with the supplied data blocks on the supplied host}
{DMA: The DMA host to execute the request on}
{Data: A linked list of DMA data blocks for the transfer}
{Direction: The direction of the DMA request (eg DMA_DIR_MEM_TO_MEM)}
{Peripheral: The peripheral ID for data request gating (eg DMA_DREQ_ID_NONE)}
{Flags: Additional flags for this transfer request (eg DMA_REQUEST_FLAG_CYCLIC)}
{Timeout: Milliseconds to wait for request to complete (INFINITE to wait forever)}
{Note: An internal callback will be specified and the function will wait for the transfer to complete}
begin
 {}
 Result:=DMATransferRequest(dma,data,direction,peripheral,flags,timeout);
end;

{==============================================================================}

function dma_transfer_request_ex(dma: PDMA_HOST; data: PDMA_DATA; callback: dma_request_completed_cb; driverdata: PVOID; direction, peripheral, flags: uint32_t): uint32_t; stdcall;
{Perform a DMA transfer request with the supplied data blocks on the supplied host}
{DMA: The DMA host to execute the request on}
{Data: A linked list of DMA data blocks for the transfer}
{Callback: The callback function to be called on completion of the request}
{DriverData: Driver private data for the callback (Optional)}
{Direction: The direction of the DMA request (eg DMA_DIR_MEM_TO_MEM)}
{Peripheral: The peripheral ID for data request gating (eg DMA_DREQ_ID_NONE)}
{Flags: Additional flags for this transfer request (eg DMA_REQUEST_FLAG_CYCLIC)}
{Note: The request will be passed to the callback with the DriverData field set to the DriverData passed to this function.
       On completion of the callback the request will automatically be released by the internal callback handler}
begin
 {}
 Result:=DMATransferRequestEx(dma,data,callback,driverdata,direction,peripheral,flags);
end;

{==============================================================================}

procedure dma_transfer_request_complete(request: PDMA_REQUEST); stdcall;
{Called when a DMA transfer request completes}
{Request: The DMA request which has completed}
{Note: This is the internal callback for DMATransferRequest}
begin
 {}
 DMATransferRequestComplete(request);
end;

{==============================================================================}
{DMA Helper Functions}
function dma_get_count: uint32_t; stdcall;
{Get the current DMA host count}
begin
 {}
 Result:=DMAGetCount;
end;

{==============================================================================}

function dma_host_get_default: PDMA_HOST; stdcall;
{Get the current default DMA host}
begin
 {}
 Result:=DMAHostGetDefault;
end;

{==============================================================================}

function dma_host_set_default(dma: PDMA_HOST): uint32_t; stdcall;
{Set the current default DMA device}
begin
 {}
 Result:=DMAHostSetDefault(dma);
end;

{==============================================================================}

function dma_host_check(dma: PDMA_HOST): PDMA_HOST; stdcall;
{Check if the supplied DMA is in the DMA host table}
begin
 {}
 Result:=DMAHostCheck(dma);
end;

{==============================================================================}

function dma_type_to_string(dmatype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Convert a DMA type value to a string}
begin
 {}
 Result:=APIStringToPCharBuffer(DMATypeToString(dmatype),_string,len);
end;

{==============================================================================}

function dma_state_to_string(dmastate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Convert a DMA state value to a string}
begin
 {}
 Result:=APIStringToPCharBuffer(DMAStateToString(dmastate),_string,len);
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{PCI Functions}
{$IFDEF API_EXPORT_PCI}
//To Do
{$ENDIF}
{==============================================================================}
{==============================================================================}
{USB Functions}
{$IFDEF API_EXPORT_USB}
function usb_start: uint32_t; stdcall;
{Starts all registered USB hosts, starts the USB hub thread and begins the USB
 enumeration process. USB enumeration will continue after this function returns
 as devices are discovered by changes in hub status.}
begin
 {}
 Result:=USBStart;
end;

{==============================================================================}

function usb_stop: uint32_t; stdcall;
begin
 {}
 Result:=USBStop;
end;

{==============================================================================}

procedure usb_async_start(host: PUSB_HOST); stdcall;
begin
 {}
 USBAsyncStart(host);
end;

{==============================================================================}
{USB Device, Driver and Host Functions}
function usb_device_get_address(device: PUSB_DEVICE): uint8_t; stdcall;
{Get the bus address for the specified device}
{Device: The USB device to get the address for}
{Return: Device address or 0 on failure}
begin
 {}
 Result:=USBDeviceGetAddress(device);
end;

{==============================================================================}

function usb_device_set_address(device: PUSB_DEVICE; address: uint8_t): uint32_t; stdcall;
{Set the bus address for the specified device}
{Device: The USB device to set the address for}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=USBDeviceSetAddress(device,address);
end;

{==============================================================================}

function usb_device_get_descriptor(device: PUSB_DEVICE; brequest, bmrequesttype: uint8_t; wvalue, windex: uint16_t; data: PVOID; length: uint16_t): uint32_t; stdcall;
{Read any descriptor from the specified device using USBControlRequest}
{Device: The USB device to read the descriptor from}
{bRequest: See USBControlRequest}
{bmRequestType: See USBControlRequest}
{wValue: See USBControlRequest}
{wIndex: See USBControlRequest}
{Data: See USBControlRequest}
{Length: See USBControlRequest}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=USBDeviceGetDescriptor(device,brequest,bmrequesttype,wvalue,windex,data,length);
end;

{==============================================================================}

function usb_device_get_device_descriptor(device: PUSB_DEVICE; data: PVOID; length: uint16_t): uint32_t; stdcall;
{Read all or part of the device descriptor from the specified device using USBControlRequest}
{Device: The USB device to read the device descriptor from}
{Data: See USBControlRequest}
{Length: See USBControlRequest}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=USBDeviceGetDeviceDescriptor(device,data,length);
end;

{==============================================================================}

function usb_device_create_device_descriptor(device: PUSB_DEVICE; length: uint16_t): uint32_t; stdcall;
{Allocate a device descriptor for the specified device}
{Device: The USB device to create the device descriptor for}
{Length: The length of the descriptor to create}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=USBDeviceCreateDeviceDescriptor(device,length);
end;

{==============================================================================}

function usb_device_read_device_descriptor(device: PUSB_DEVICE; length: uint16_t): uint32_t; stdcall;
{Read all or part of the device descriptor from the specified device using USBControlRequest}
{Device: The USB device to read the device descriptor from}
{Length: The amount of the descriptor to read which may be less than the full size}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=USBDeviceReadDeviceDescriptor(device,length);
end;

{==============================================================================}

function usb_device_read_device_descriptor_ex(device: PUSB_DEVICE; length: uint16_t; allowshort: BOOL): uint32_t; stdcall;
{Read all or part of the device descriptor from the specified device using USBControlRequest}
{Device: The USB device to read the device descriptor from}
{Length: The amount of the descriptor to read which may be less than the full size}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=USBDeviceReadDeviceDescriptorEx(device,length,allowshort);
end;

{==============================================================================}

function usb_device_create_configurations(device: PUSB_DEVICE): uint32_t; stdcall;
{Allocate the available configurations for this device}
{Device: The USB device to create the configurations for}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=USBDeviceCreateConfigurations(device);
end;

{==============================================================================}

function usb_device_read_configurations(device: PUSB_DEVICE): uint32_t; stdcall;
{Read and parse the available configurations for this device}
{Device: The USB device to read the configurations for}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=USBDeviceReadConfigurations(device);
end;

{==============================================================================}

function usb_device_create_configuration(device: PUSB_DEVICE; index: uint8_t; size: uint16_t): uint32_t; stdcall;
{Allocate the specified configuration for this device}
{Device: The USB device to create the configuration for}
{Index: The index of the configuration to create}
{Size: The size of the configuration descriptor to create}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=USBDeviceCreateConfiguration(device,index,size);
end;

{==============================================================================}

function usb_device_read_configuration(device: PUSB_DEVICE; index: uint8_t): uint32_t; stdcall;
{Read and parse the specified configuration for this device}
{Device: The USB device to read the configuration for}
{Index: The index of the configuration to read}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=USBDeviceReadConfiguration(device,index);
end;

{==============================================================================}

function usb_device_get_string_descriptor(device: PUSB_DEVICE; index: uint8_t; data: PVOID; length: uint16_t): uint32_t; stdcall;
{Read all or part of the specified string descriptor from the specified device using USBControlRequest}
{Device: The USB device to read the string descriptor from}
{Index: The index of the string descriptor to read}
{Data: See USBControlRequest}
{Length: See USBControlRequest}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=USBDeviceGetStringDescriptor(device,index,data,length);
end;

{==============================================================================}

function usb_device_get_string_descriptor_ex(device: PUSB_DEVICE; index: uint8_t; languageid: uint16_t; data: PVOID; length: uint16_t): uint32_t; stdcall;
{Read all or part of the specified string descriptor from the specified device using USBControlRequest}
{Device: The USB device to read the string descriptor from}
{Index: The index of the string descriptor to read}
{LanguageId: The language identifier of the string descriptor to read (eg USB_LANGID_US_ENGLISH)}
{Data: See USBControlRequest}
{Length: See USBControlRequest}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=USBDeviceGetStringDescriptorEx(device,index,languageid,data,length);
end;

{==============================================================================}

procedure usb_device_read_string_language_ids(device: PUSB_DEVICE; var languageids: TUSB_STRING_DESCRIPTOR_LANGIDS); stdcall;
{Get the list of supported string language identifiers from the specified device}
{Device: The USB device to read the language identifiers from}
{Return: An array of supported language identifiers (Unused values are returned as zero)}
begin
 {}
 languageids:=USBDeviceReadStringLanguageIds(device);
end;

{==============================================================================}

function usb_device_read_string_descriptor(device: PUSB_DEVICE; index: uint8_t; value: PCHAR; len: uint32_t): uint32_t; stdcall;
{Get the content of the specified string descriptor from the specified device}
{Device: The USB device to read the string descriptor from}
{Index: The index of the string descriptor to read}
{Return: The ANSI string content of the string descriptor or an empty string on failure}
begin
 {}
 Result:=APIStringToPCharBuffer(USBDeviceReadStringDescriptor(device,index),value,len);
end;

{==============================================================================}

function usb_device_read_string_descriptor_ex(device: PUSB_DEVICE; index: uint8_t; languageid: uint16_t; value: PCHAR; len: uint32_t): uint32_t; stdcall;
{Get the content of the specified string descriptor from the specified device}
{Device: The USB device to read the string descriptor from}
{Index: The index of the string descriptor to read}
{LanguageId: The language identifier of the string descriptor to read (eg USB_LANGID_US_ENGLISH)}
{Return: The ANSI string content of the string descriptor or an empty string on failure}
begin
 {}
 Result:=APIStringToPCharBuffer(USBDeviceReadStringDescriptorEx(device,index,languageid),value,len);
end;

{==============================================================================}

function usb_device_read_string_descriptor_w(device: PUSB_DEVICE; index: uint8_t; value: PWIDECHAR; len: uint32_t): uint32_t; stdcall;
{Get the content of the specified string descriptor from the specified device}
{Device: The USB device to read the string descriptor from}
{Index: The index of the string descriptor to read}
{Return: The Unicode string content of the string descriptor or an empty string on failure}
begin
 {}
 Result:=APIUnicodeStringToPWideCharBuffer(USBDeviceReadStringDescriptorW(device,index),value,len);
end;

{==============================================================================}

function usb_device_read_string_descriptor_ex_w(device: PUSB_DEVICE; index: uint8_t; languageid: uint16_t; value: PWIDECHAR; len: uint32_t): uint32_t; stdcall;
{Get the content of the specified string descriptor from the specified device}
{Device: The USB device to read the string descriptor from}
{Index: The index of the string descriptor to read}
{LanguageId: The language identifier of the string descriptor to read (eg USB_LANGID_US_ENGLISH)}
{Return: The Unicode string content of the string descriptor or an empty string on failure}
begin
 {}
 Result:=APIUnicodeStringToPWideCharBuffer(USBDeviceReadStringDescriptorExW(device,index,languageid),value,len);
end;

{==============================================================================}

function usb_device_get_configuration_descriptor(device: PUSB_DEVICE; index: uint8_t; data: PVOID; length: uint16_t): uint32_t; stdcall;
{Read all or part of the specified configuration descriptor from the specified device using USBControlRequest}
{Device: The USB device to read the configuration descriptor from}
{Index: The index of the configuration descriptor to read}
{Data: See USBControlRequest}
{Length: See USBControlRequest}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=USBDeviceGetConfigurationDescriptor(device,index,data,length);
end;

{==============================================================================}

function usb_device_get_configuration(device: PUSB_DEVICE; var configurationvalue: uint8_t): uint32_t; stdcall;
{Get the current configuration for the specified device}
{Device: The USB device to get the current configuration for}
{ConfigurationValue: The current configuration (As per bConfigurationValue in the configuration descriptor)}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=USBDeviceGetConfiguration(device,configurationvalue);
end;

{==============================================================================}

function usb_device_set_configuration(device: PUSB_DEVICE; configurationvalue: uint8_t): uint32_t; stdcall;
{Set the configuration for the specified device}
{Device: The USB device to set the configuration for}
{ConfigurationValue: The configuration to set (As per bConfigurationValue in the configuration descriptor)}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=USBDeviceSetConfiguration(device,configurationvalue);
end;

{==============================================================================}

function usb_device_find_configuration_by_value(device: PUSB_DEVICE; configurationvalue: uint8_t): PUSB_CONFIGURATION; stdcall;
{Find the configuration represented by configuration value for the specified device}
{Device: The USB device to find the configuration for}
{ConfigurationValue: The configuration value to find (As per bConfigurationValue in the configuration descriptor)}
{Return: USB Configuration if completed or nil on failure}
begin
 {}
 Result:=USBDeviceFindConfigurationByValue(device,configurationvalue);
end;

{==============================================================================}

function usb_device_get_hub(device: PUSB_DEVICE): PUSB_HUB; stdcall;
{Get the USB Hub that the specified device is connected to}
{Device: The USB device to get the hub for}
{Return: USB Hub if successful or nil on failure}
begin
 {}
 Result:=USBDeviceGetHub(device);
end;

{==============================================================================}

function usb_device_get_port(device: PUSB_DEVICE): PUSB_PORT; stdcall;
{Get the USB Port that the specified device is connected to}
{Device: The USB device to get the port for}
{Return: USB Port if successful or nil on failure}
begin
 {}
 Result:=USBDeviceGetPort(device);
end;

{==============================================================================}

function usb_device_get_interface(device: PUSB_DEVICE; index: uint8_t; var alternatesetting: uint8_t): uint32_t; stdcall;
{Get the interface alternate setting for the specified device}
{Device: The USB device to get the interface alternate setting for}
{Index: The index of the interface to get (As per bInterfaceNumber in the interface descriptor)}
{AlternateSetting: The current alternate setting of the specified interface (As per bAlternateSetting in the interface descriptor)}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=USBDeviceGetInterface(device,index,alternatesetting);
end;

{==============================================================================}

function usb_device_set_interface(device: PUSB_DEVICE; index, alternatesetting: uint8_t): uint32_t; stdcall;
{Set the interface alternate setting for the specified device}
{Device: The USB device to set the interface alternate setting for}
{Index: The index of the interface to set (As per bInterfaceNumber in the interface descriptor)}
{AlternateSetting: The alternate setting to set on the specified interface (As per bAlternateSetting in the interface descriptor)}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=USBDeviceSetInterface(device,index,alternatesetting);
end;

{==============================================================================}

function usb_device_find_interface_by_index(device: PUSB_DEVICE; index: uint8_t): PUSB_INTERFACE; stdcall;
{Find the interface with the specified index on the specified device}
{Device: The USB device to find the interface from}
{Index: The index of the interface to find  (As per bInterfaceNumber in the interface descriptor)}
{Return: The interface for the matching interface of nil if no interface matched}
begin
 {}
 Result:=USBDeviceFindInterfaceByIndex(device,index);
end;

{==============================================================================}

function usb_device_find_interface_by_class_only(device: PUSB_DEVICE; interfaceclass: uint8_t): PUSB_INTERFACE; stdcall;
{Find an interface of the specified class on the specified device}
{Device: The USB device to find the interface from}
{InterfaceClass: The interface class to match}
{Return: The matching interface or nil if no interface matched}
begin
 {}
 Result:=USBDeviceFindInterfaceByClass(device,interfaceclass);
end;

{==============================================================================}

function usb_device_find_interface_by_class(device: PUSB_DEVICE; interfaceclass, interfacesubclass, interfaceprotocol: uint8_t): PUSB_INTERFACE; stdcall;
{Find an interface of the specified class, subclass and protocol on the specified device}
{Device: The USB device to find the interface from}
{InterfaceClass: The interface class to match}
{InterfaceSubClass: The interface subclass to match}
{InterfaceProtocol: The interface protocol to match}
{Return: The matching interface or nil if no interface matched}
begin
 {}
 Result:=USBDeviceFindInterfaceByClass(device,interfaceclass,interfacesubclass,interfaceprotocol);
end;

{==============================================================================}

function usb_device_find_endpoint_by_index(device: PUSB_DEVICE; interrface: PUSB_INTERFACE; index: uint8_t): PUSB_ENDPOINT_DESCRIPTOR; stdcall;
{Find the endpoint with the specified index on the specified interface of the specified device}
{Device: The USB device to find the endpoint from}
{Interrface: The interface to find the endpoint from}
{Index: The index of the endpoint to find (First endpoint is zero)}
{Return: The endpoint for the matching endpoint of nil if no endpoint matched}
begin
 {}
 Result:=USBDeviceFindEndpointByIndex(device,interrface,index);
end;

{==============================================================================}

function usb_device_find_endpoint_by_type(device: PUSB_DEVICE; interrface: PUSB_INTERFACE; direction, transfertype: uint8_t): PUSB_ENDPOINT_DESCRIPTOR; stdcall;
{Find an endpoint of the specified type and direction on the specified interface of the specified device}
{Device: The USB device to find the endpoint from}
{Interrface: The interface to find the endpoint from}
{Direction: The direction of the endpoint to find (eg USB_DIRECTION_OUT)}
{TransferType: The transfer type of the endpoint to find (eg USB_TRANSFER_TYPE_BULK)}
{Return: The endpoint for the matching endpoint of nil if no endpoint matched}
begin
 {}
 Result:=USBDeviceFindEndpointByType(device,interrface,direction,transfertype);
end;

{==============================================================================}

function usb_device_find_endpoint_by_type_ex(device: PUSB_DEVICE; interrface: PUSB_INTERFACE; direction, transfertype: uint8_t; var index: uint8_t): PUSB_ENDPOINT_DESCRIPTOR; stdcall;
{Find the next endpoint of the specified type and direction on the specified interface of the specified device}
{Device: The USB device to find the endpoint from}
{Interrface: The interface to find the endpoint from}
{Direction: The direction of the endpoint to find (eg USB_DIRECTION_OUT)}
{TransferType: The transfer type of the endpoint to find (eg USB_TRANSFER_TYPE_BULK)}
{Index: The index returned from the last call, pass 0 on the first call]
{Return: The endpoint for the matching endpoint of nil if no endpoint matched}
begin
 {}
 Result:=USBDeviceFindEndpointByTypeEx(device,interrface,direction,transfertype,index);
end;

{==============================================================================}

function usb_device_count_endpoints_by_type(device: PUSB_DEVICE; interrface: PUSB_INTERFACE; direction, transfertype: uint8_t): uint8_t; stdcall;
{Count the number of endpoints of the specified type and direction on the specified interface of the specified device}
{Device: The USB device to find the endpoint from}
{Interrface: The interface to find the endpoint from}
{Direction: The direction of the endpoint to find (eg USB_DIRECTION_OUT)}
{TransferType: The transfer type of the endpoint to find (eg USB_TRANSFER_TYPE_BULK)}
{Return: The number of matching endpoints on the specified interface}
begin
 {}
 Result:=USBDeviceCountEndpointsByType(device,interrface,direction,transfertype);
end;

{==============================================================================}

function usb_device_find_alternate_by_index(device: PUSB_DEVICE; interrface: PUSB_INTERFACE; index: uint8_t): PUSB_ALTERNATE; stdcall;
{Find the alternate setting with the specified index on the specified interface of the specified device}
{Device: The USB device to find the alternate setting from}
{Interrface: The interface to find the alternate setting from}
{Index: The index of the alternate setting to find (First alternate setting is zero)}
{Return: The alternate setting for the matching alternate setting of nil if no alternate setting matched}
begin
 {}
 Result:=USBDeviceFindAlternateByIndex(device,interrface,index);
end;

{==============================================================================}

function usb_device_find_alternate_by_setting(device: PUSB_DEVICE; interrface: PUSB_INTERFACE; alternatesetting: uint8_t): PUSB_ALTERNATE; stdcall;
{Find the alternate setting with the specified value on the specified interface of the specified device}
{Device: The USB device to find the alternate setting from}
{Interrface: The interface to find the alternate setting from}
{AlternateSetting: The value of the alternate setting to find}
{Return: The alternate setting for the matching alternate setting of nil if no alternate setting matched}
begin
 {}
 Result:=USBDeviceFindAlternateBySetting(device,interrface,alternatesetting);
end;

{==============================================================================}

function usb_device_find_alternate_endpoint_by_index(device: PUSB_DEVICE; interrface: PUSB_INTERFACE; alternate: PUSB_ALTERNATE; index: uint8_t): PUSB_ENDPOINT_DESCRIPTOR; stdcall;
{Find the endpoint with the specified index on the specified alternate setting interface of the specified device}
{Device: The USB device to find the endpoint from}
{Interrface: The interface to find the endpoint from}
{Alternate: The alternate setting to find the endpoint from}
{Index: The index of the endpoint to find (First endpoint is zero)}
{Return: The endpoint for the matching endpoint of nil if no endpoint matched}
begin
 {}
 Result:=USBDeviceFindAlternateEndpointByIndex(device,interrface,alternate,index);
end;

{==============================================================================}

function usb_device_find_alternate_endpoint_by_type(device: PUSB_DEVICE; interrface: PUSB_INTERFACE; alternate: PUSB_ALTERNATE; direction, transfertype: uint8_t): PUSB_ENDPOINT_DESCRIPTOR; stdcall;
{Find an endpoint of the specified type and direction on the specified alternate setting interface of the specified device}
{Device: The USB device to find the endpoint from}
{Interrface: The interface to find the endpoint from}
{Alternate: The alternate setting to find the endpoint from}
{Direction: The direction of the endpoint to find (eg USB_DIRECTION_OUT)}
{TransferType: The transfer type of the endpoint to find (eg USB_TRANSFER_TYPE_BULK)}
{Return: The endpoint for the matching endpoint of nil if no endpoint matched}
begin
 {}
 Result:=USBDeviceFindAlternateEndpointByType(device,interrface,alternate,direction,transfertype);
end;

{==============================================================================}

function usb_device_set_feature(device: PUSB_DEVICE; endpoint: PUSB_ENDPOINT_DESCRIPTOR; feature, index: uint16_t): uint32_t; stdcall;
{Enable a feature on the specified endpoint on the specified device}
{Device: The USB device to enable the feature for}
{Endpoint: The endpoint to enable the feature on}
{Feature: The feature to enable}
{Index: ??????}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=USBDeviceSetFeature(device,endpoint,feature,index);
end;

{==============================================================================}

function usb_device_clear_feature(device: PUSB_DEVICE; endpoint: PUSB_ENDPOINT_DESCRIPTOR; feature: uint16_t): uint32_t; stdcall;
{Disable a feature on the specified endpoint on the specified device}
{Device: The USB device to disable the feature for}
{Endpoint: The endpoint to disable the feature on}
{Feature: The feature to disable}
{Index: ??????}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=USBDeviceClearFeature(device,endpoint,feature);
end;

{==============================================================================}

function usb_device_set_state(device: PUSB_DEVICE; state: uint32_t): uint32_t; stdcall;
{Set the state of the specified device and send a notification}
{Device: The USB device to set the state for}
{State: The new state to set and notify (eg USB_STATE_ATTACHED)}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=USBDeviceSetState(device,state);
end;

{==============================================================================}

function usb_device_set_status(device: PUSB_DEVICE; status: uint32_t): uint32_t; stdcall;
{Set the status of the specified device and send a notification}
{Device: The USB device to set the status for}
{Status: The new status to set and notify (eg USB_STATUS_BOUND)}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=USBDeviceSetStatus(device,status);
end;

{==============================================================================}

function usb_device_bind(device: PUSB_DEVICE): uint32_t; stdcall;
{Attempt to bind a device to one of the registered drivers}
{Device: The device to attempt to bind a driver to}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=USBDeviceBind(device);
end;

{==============================================================================}

function usb_device_unbind(device: PUSB_DEVICE; driver: PUSB_DRIVER): uint32_t; stdcall;
{Unbind a device from a driver}
{Device: The device to unbind a driver from}
{Driver: The driver to unbind the device from (nil to unbind from current driver)}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=USBDeviceUnbind(device,driver);
end;

{==============================================================================}

function usb_device_attach(device: PUSB_DEVICE): uint32_t; stdcall;
{Configure and initialize a newly attached USB device}
{Device: New USB device to configure and initialize}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=USBDeviceAttach(device);
end;

{==============================================================================}

function usb_device_detach(device: PUSB_DEVICE): uint32_t; stdcall;
{Shutdown and detach a USB device}
{Device: The USB device to shutdown and detach}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=USBDeviceDetach(device);
end;

{==============================================================================}

function usb_device_allocate(host: PUSB_HOST; parent: PUSB_DEVICE): PUSB_DEVICE; stdcall;
{Create and Register a new Device entry in the Device table}
{Host: The Host this device is attached to}
{Parent: The Parent device (Hub) this device is attached to (nil if this device is a root hub)}
{Return: Pointer to new Device entry or nil if device could not be created}
begin
 {}
 Result:=USBDeviceAllocate(host,parent);
end;

{==============================================================================}

function usb_device_release(device: PUSB_DEVICE): uint32_t; stdcall;
{Deregister and Destroy a Device from the Device table}
{Device: The device to deregister and destroy}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=USBDeviceRelease(device);
end;

{==============================================================================}

function usb_device_find(usbid: uint32_t): PUSB_DEVICE; stdcall;
begin
 {}
 Result:=USBDeviceFind(usbid);
end;

{==============================================================================}

function usb_device_find_by_id(vendorid, productid: uint16_t): PUSB_DEVICE; stdcall;
begin
 {}
 Result:=USBDeviceFindById(vendorid,productid);
end;

{==============================================================================}

function usb_device_find_by_name(const name: PCHAR): PUSB_DEVICE; stdcall;
begin
 {}
 Result:=USBDeviceFindByName(String(name));
end;

{==============================================================================}

function usb_device_find_by_description(const description: PCHAR): PUSB_DEVICE; stdcall;
begin
 {}
 Result:=USBDeviceFindByDescription(String(description));
end;

{==============================================================================}

function usb_device_enumerate(callback: usb_device_enumerate_cb; data: PVOID): uint32_t; stdcall;
begin
 {}
 Result:=USBDeviceEnumerate(callback,data);
end;

{==============================================================================}

function usb_device_notification(device: PUSB_DEVICE; callback: usb_device_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=USBDeviceNotification(device,callback,data,notification,flags);
end;

{==============================================================================}

function usb_driver_create: PUSB_DRIVER; stdcall;
{Create a new USB Driver entry}
{Return: Pointer to new Driver entry or nil if driver could not be created}
begin
 {}
 Result:=USBDriverCreate;
end;

{==============================================================================}

function usb_driver_create_ex(size: uint32_t): PUSB_DRIVER; stdcall;
{Create a new USB Driver entry}
{Size: Size in bytes to allocate for new driver (Including the driver entry)}
{Return: Pointer to new Driver entry or nil if driver could not be created}
begin
 {}
 Result:=USBDriverCreateEx(size);
end;

{==============================================================================}

function usb_driver_destroy(driver: PUSB_DRIVER): uint32_t; stdcall;
{Destroy an existing USB Driver entry}
begin
 {}
 Result:=USBDriverDestroy(driver);
end;

{==============================================================================}

function usb_driver_register(driver: PUSB_DRIVER): uint32_t; stdcall;
{Register a new Driver in the USB Driver table}
begin
 {}
 Result:=USBDriverRegister(driver);
end;

{==============================================================================}

function usb_driver_deregister(driver: PUSB_DRIVER): uint32_t; stdcall;
{Deregister a Driver from the USB Driver table}
begin
 {}
 Result:=USBDriverDeregister(driver);
end;

{==============================================================================}

function usb_driver_find(driverid: uint32_t): PUSB_DRIVER; stdcall;
{Find a driver by Id in the USB Driver table}
begin
 {}
 Result:=USBDriverFind(driverid);
end;

{==============================================================================}

function usb_driver_find_by_name(const name: PCHAR): PUSB_DRIVER; stdcall;
{Find a driver by name in the Driver table}
begin
 {}
 Result:=USBDriverFindByName(String(name));
end;

{==============================================================================}

function usb_driver_enumerate(callback: usb_driver_enumerate_cb; data: PVOID): uint32_t; stdcall;
{Enumerate all drivers in the USB Driver table}
begin
 {}
 Result:=USBDriverEnumerate(callback,data);
end;

{==============================================================================}

function usb_host_set_state(host: PUSB_HOST; state: uint32_t): uint32_t; stdcall;
{Set the state of the specified host and send a notification}
{Host: The USB host to set the state for}
{State: The new state to set and notify (eg USBHOST_STATE_ENABLED)}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=USBHostSetState(host,state);
end;

{==============================================================================}

function usb_host_create: PUSB_HOST; stdcall;
{Create a new Host entry}
{Return: Pointer to new Host entry or nil if host could not be created}
begin
 {}
 Result:=USBHostCreate;
end;

{==============================================================================}

function usb_host_create_ex(size: uint32_t): PUSB_HOST; stdcall;
{Create a new Host entry}
{Size: Size in bytes to allocate for new host (Including the host entry)}
{Return: Pointer to new Host entry or nil if host could not be created}
begin
 {}
 Result:=USBHostCreateEx(size);
end;

{==============================================================================}

function usb_host_destroy(host: PUSB_HOST): uint32_t; stdcall;
{Destroy an existing Host entry}
begin
 {}
 Result:=USBHostDestroy(host);
end;

{==============================================================================}

function usb_host_register(host: PUSB_HOST): uint32_t; stdcall;
{Register a new Host in the Host table}
begin
 {}
 Result:=USBHostRegister(host);
end;

{==============================================================================}

function usb_host_deregister(host: PUSB_HOST): uint32_t; stdcall;
{Deregister a Host from the Host table}
begin
 {}
 Result:=USBHostDeregister(host);
end;

{==============================================================================}

function usb_host_find(hostid: uint32_t): PUSB_HOST; stdcall;
begin
 {}
 Result:=USBHostFind(hostid);
end;

{==============================================================================}

function usb_host_find_by_name(const name: PCHAR): PUSB_HOST; stdcall;
begin
 {}
 Result:=USBHostFindByName(String(name));
end;

{==============================================================================}

function usb_host_find_by_description(const description: PCHAR): PUSB_HOST; stdcall;
begin
 {}
 Result:=USBHostFindByDescription(String(description));
end;

{==============================================================================}

function usb_host_enumerate(callback: usb_host_enumerate_cb; data: PVOID): uint32_t; stdcall;
begin
 {}
 Result:=USBHostEnumerate(callback,data);
end;

{==============================================================================}

function usb_host_notification(host: PUSB_HOST; callback: usb_host_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=USBHostNotification(host,callback,data,notification,flags);
end;

{==============================================================================}

function usb_buffer_allocate(device: PUSB_DEVICE; size: uint32_t): PVOID; stdcall;
{Allocate a data buffer for a USB request}
{Device: The device that the request will be sent to}
{Size: The size of the data buffer to allocate}
{Return: The newly allocated buffer or nil on failure}
begin
 {}
 Result:=USBBufferAllocate(device,size);
end;

{==============================================================================}

function usb_buffer_allocate_ex(device: PUSB_DEVICE; size: uint32_t; var flags: uint32_t): PVOID; stdcall;
{Allocate a data buffer for a USB request}
{Device: The device that the request will be sent to}
{Size: The size of the data buffer to allocate}
{Flags: The returned flags for the allocated buffer (eg USB_REQUEST_FLAG_SHARED)}
{Return: The newly allocated buffer or nil on failure}
begin
 {}
 Result:=USBBufferAllocateEx(device,size,flags);
end;

{==============================================================================}

function usb_buffer_validate(device: PUSB_DEVICE; buffer: PVOID; size: uint32_t; var flags: uint32_t): uint32_t; stdcall;
{Validate a data buffer for a USB request against the USB host requirements}
{Device: The device that the request will be sent to}
{Buffer: The data buffer to validate}
{Size: The size of the data buffer}
{Flags: The returned flags for the validated buffer (eg USB_REQUEST_FLAG_SHARED)}
{Return: USB_STATUS_SUCCESS on success or another error code on failure}
begin
 {}
 Result:=USBBufferValidate(device,buffer,size,flags);
end;

{==============================================================================}

function usb_buffer_release(buffer: PVOID): uint32_t; stdcall;
{Release a data buffer from a USB request}
{Data: The buffer to be released}
{Return: USB_STATUS_SUCCESS on success or another error code on failure}
begin
 {}
 Result:=USBBufferRelease(buffer);
end;

{==============================================================================}

function usb_request_allocate(device: PUSB_DEVICE; endpoint: PUSB_ENDPOINT_DESCRIPTOR; callback: usb_request_completed_cb; size: uint32_t; driverdata: PVOID): PUSB_REQUEST; stdcall;
{Allocate a new USB request}
{Device: The USB device this request will be sent to}
{Endpoint: The Endpoint descriptor this request will be sent to (Or nil for the default control endpoint)}
{Callback: The callback function to be called on completion of the request}
{Size: The size of the data buffer for the request}
{DriverData: Device driver private data for the callback (Optional)}
{Return: The newly allocated request or nil on failure}
begin
 {}
 Result:=USBRequestAllocate(device,endpoint,callback,size,driverdata);
end;

{==============================================================================}

function usb_request_allocate_ex(device: PUSB_DEVICE; endpoint: PUSB_ENDPOINT_DESCRIPTOR; callback: usb_request_completed_cb; var data: PVOID; size: uint32_t; driverdata: PVOID): PUSB_REQUEST; stdcall;
{Allocate a new USB request}
{Device: The USB device this request will be sent to}
{Endpoint: The Endpoint descriptor this request will be sent to (Or nil for the default control endpoint)}
{Callback: The callback function to be called on completion of the request}
{Data: The returned data buffer allocated for the request (Or nil if size is zero)(Pass an existing buffer to prevent allocation)}
{Size: The size of the data buffer for the request}
{DriverData: Device driver private data for the callback (Optional)}
{Return: The newly allocated request or nil on failure}
begin
 {}
 Result:=USBRequestAllocateEx(device,endpoint,callback,data,size,driverdata);
end;

{==============================================================================}

function usb_request_release(request: PUSB_REQUEST): uint32_t; stdcall;
{Release and destroy a USB request}
{Request: The request to be released}
{Return: USB_STATUS_SUCCESS on success or another error code on failure}
begin
 {}
 Result:=USBRequestRelease(request);
end;

{==============================================================================}

function usb_request_initialize(request: PUSB_REQUEST; callback: usb_request_completed_cb; data: PVOID; size: uint32_t; driverdata: PVOID): uint32_t; stdcall;
{Initialize or Reinitialize an existing USB request}
{Request: The request to be initialized}
{Callback: The callback function to be called on completion of the request}
{Data: The returned data buffer allocated for the request (Or nil if size is zero)}
{Size: The size of the data buffer for the request}
{DriverData: Device driver private data for the callback (Optional)}
{Return: USB_STATUS_SUCCESS on success or another error code on failure}
begin
 {}
 Result:=USBRequestInitialize(request,callback,data,size,driverdata);
end;

{==============================================================================}

function usb_request_submit(request: PUSB_REQUEST): uint32_t; stdcall;
{Submit a USB request to a host controller for execution}
{Request: The request to be submitted}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
{Note: The request will be completed asynchronously by the host controller and the
 completion callback will be called when the request has either succeeded or failed}
begin
 {}
 Result:=USBRequestSubmit(request);
end;

{==============================================================================}

function usb_request_cancel(request: PUSB_REQUEST): uint32_t; stdcall;
{Cancel a USB request previously submitted to a host controller}
{Request: The request to be cancelled}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=USBRequestCancel(request);
end;

{==============================================================================}

function usb_control_request(device: PUSB_DEVICE; endpoint: PUSB_ENDPOINT_DESCRIPTOR; brequest, bmrequesttype: uint8_t; wvalue, windex: uint16_t; data: PVOID; wlength: uint16_t): uint32_t; stdcall;
{Send a USB control request to the specified device and wait for the request to complete}
{Device: The USB device to send the control request to}
{Endpoint: The Endpoint to use for the control request (or nil for the default control endpoint)}
{bRequest: The request to send (See Section 9.4 of the USB 2.0 specification for Standard requests)}
{bmRequestType: Type of request to send (See Section 9.3.1 of the USB 2.0 specification for Standard request types)}
{wValue: Request specific data}
{wIndex: Request specific data}
{Data: Buffer for the data to be sent or received from the request (Ignored if wLength is 0)}
{wLength: Length of the Data buffer in bytes}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=USBControlRequest(device,endpoint,brequest,bmrequesttype,wvalue,windex,data,wlength);
end;

{==============================================================================}

function usb_control_request_ex(device: PUSB_DEVICE; endpoint: PUSB_ENDPOINT_DESCRIPTOR; brequest, bmrequesttype: uint8_t; wvalue, windex: uint16_t; data: PVOID; wlength: uint16_t; timeout: uint32_t; allowshort: BOOL): uint32_t; stdcall;
{Send a USB control request to the specified device and wait for the request to complete}
{Device: The USB device to send the control request to}
{Endpoint: The Endpoint to use for the control request (or nil for the default control endpoint)}
{bRequest: The request to send (See Section 9.4 of the USB 2.0 specification for Standard requests)}
{bmRequestType: Type of request to send (See Section 9.3.1 of the USB 2.0 specification for Standard request types)}
{wValue: Request specific data}
{wIndex: Request specific data}
{Data: Buffer for the data to be sent or received from the request (Ignored if wLength is 0)}
{wLength: Length of the Data buffer in bytes}
{Timeout: Milliseconds to wait for request to complete (INFINITE to wait forever)}
{AllowShort: Allow the return size to be less than the requested size}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=USBControlRequestEx(device,endpoint,brequest,bmrequesttype,wvalue,windex,data,wlength,timeout,allowshort);
end;

{==============================================================================}

function usb_control_transfer(device: PUSB_DEVICE; endpoint: PUSB_ENDPOINT_DESCRIPTOR; brequest, bmrequesttype: uint8_t; wvalue, windex: uint16_t; data: PVOID; wlength: uint16_t; var count: uint32_t; timeout: uint32_t): uint32_t; stdcall;
{Perform a synchronous control transfer to a USB device and endpoint}
{Device: The USB device to send the control request to}
{Endpoint: The Endpoint to use for the control request (or nil for the default control endpoint)}
{bRequest: The request to send (See Section 9.4 of the USB 2.0 specification for Standard requests)}
{bmRequestType: Type of request to send (See Section 9.3.1 of the USB 2.0 specification for Standard request types)}
{wValue: Request specific data}
{wIndex: Request specific data}
{Data: Buffer for the data to be sent or received from the request (Ignored if wLength is 0)}
{wLength: Length of the Data buffer in bytes}
{Count: The actual number of bytes transferred on completion (May apply even on failure or timeout)}
{Timeout: Milliseconds to wait for request to complete (INFINITE to wait forever)}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
{Note: This function is very similar to USBControlRequest(Ex) but also returns the actual number of bytes transferred}
begin
 {}
 Result:=USBControlTransfer(device,endpoint,brequest,bmrequesttype,wvalue,windex,data,wlength,count,timeout);
end;

{==============================================================================}

function usb_bulk_transfer(device: PUSB_DEVICE; endpoint: PUSB_ENDPOINT_DESCRIPTOR; data: PVOID; size: uint32_t; var count: uint32_t; timeout: uint32_t): uint32_t; stdcall;
{Perform a synchronous bulk transfer to a USB device and endpoint}
{Device: The USB device to send the bulk request to}
{Endpoint: The Endpoint to use for the bulk request}
{Data: Buffer for the data to be sent or received from the request (Ignored if Size is 0)}
{Size: Size of the Data buffer in bytes}
{Count: The actual number of bytes transferred on completion (May apply even on failure or timeout)}
{Timeout: Milliseconds to wait for request to complete (INFINITE to wait forever)}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
{Note: The type and direction of the transfer is determined from the type and direction of the endpoint}
begin
 {}
 Result:=USBBulkTransfer(device,endpoint,data,size,count,timeout);
end;

{==============================================================================}

function usb_interrupt_transfer(device: PUSB_DEVICE; endpoint: PUSB_ENDPOINT_DESCRIPTOR; data: PVOID; size: uint32_t; var count: uint32_t; timeout: uint32_t): uint32_t; stdcall;
{Perform a synchronous interrupt transfer to a USB device and endpoint}
{Device: The USB device to send the interrupt request to}
{Endpoint: The Endpoint to use for the interrupt request}
{Data: Buffer for the data to be sent or received from the request (Ignored if Size is 0)}
{Size: Size of the Data buffer in bytes}
{Count: The actual number of bytes transferred on completion (May apply even on failure or timeout)}
{Timeout: Milliseconds to wait for request to complete (INFINITE to wait forever)}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
{Note: The type and direction of the transfer is determined from the type and direction of the endpoint}
begin
 {}
 Result:=USBInterruptTransfer(device,endpoint,data,size,count,timeout);
end;

{==============================================================================}
{USB Hub Functions}
function usb_hub_create_ports(hub: PUSB_HUB): uint32_t; stdcall;
{Create and initialize the ports for a Hub}
{Hub: The hub to initialize ports for}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=USBHubCreatePorts(hub);
end;

{==============================================================================}

function usb_hub_power_on_ports(hub: PUSB_HUB): uint32_t; stdcall;
{Power on all ports on a Hub}
{Hub: The hub to power on ports for}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=USBHubPowerOnPorts(hub);
end;

{==============================================================================}

function usb_hub_create_hub_descriptor(hub: PUSB_HUB): uint32_t; stdcall;
{Allocate the hub descriptor for the specified hub}
{Hub: The hub to create the descriptor for}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
{Note: The class specific hub descriptor is not the same as the device descriptor}
begin
 {}
 Result:=USBHubCreateHubDescriptor(hub);
end;

{==============================================================================}

function usb_hub_read_hub_descriptor(hub: PUSB_HUB): uint32_t; stdcall;
{Read the hub descriptor for the specified hub}
{Hub: The hub to read the descriptor for}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
{Note: The class specific hub descriptor is not the same as the device descriptor}
begin
 {}
 Result:=USBHubReadHubDescriptor(hub);
end;

{==============================================================================}

function usb_hub_lock(hub: PUSB_HUB): uint32_t; stdcall;
{Lock the specified Hub to prevent changes}
{Hub: The hub to lock}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=USBHubLock(hub);
end;

{==============================================================================}

function usb_hub_unlock(hub: PUSB_HUB): uint32_t; stdcall;
{Unlock the specified Hub to allow changes}
{Hub: The hub to unlock}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=USBHubUnlock(hub);
end;

{==============================================================================}

function usb_hub_set_state(hub: PUSB_HUB; state: uint32_t): uint32_t; stdcall;
{Set the state of the specified hub and send a notification}
{Hub: The hub to set the state for}
{State: The new state to set and notify}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=USBHubSetState(hub,state);
end;

{==============================================================================}

function usb_hub_allocate(device: PUSB_DEVICE): PUSB_HUB; stdcall;
{Create and Register a new Hub device}
{Device: The USB device that represents this hub}
{Return: Pointer to new Hub entry or nil if hub could not be created}
begin
 {}
 Result:=USBHubAllocate(device);
end;

{==============================================================================}

function usb_hub_release(hub: PUSB_HUB): uint32_t; stdcall;
{Deregister and Destroy a Hub device}
{Hub: The hub to deregister and destroy}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=USBHubRelease(hub);
end;

{==============================================================================}

function usb_hub_find(hubid: uint32_t): PUSB_HUB; stdcall;
begin
 {}
 Result:=USBHubFind(hubid);
end;

{==============================================================================}

function usb_hub_find_by_name(const name: PCHAR): PUSB_HUB; stdcall;
begin
 {}
 Result:=USBHubFindByName(String(name));
end;

{==============================================================================}

function usb_hub_find_by_description(const description: PCHAR): PUSB_HUB; stdcall;
begin
 {}
 Result:=USBHubFindByDescription(String(description));
end;

{==============================================================================}

function usb_hub_enumerate(callback: usb_hub_enumerate_cb; data: PVOID): uint32_t; stdcall;
begin
 {}
 Result:=USBHubEnumerate(callback,data);
end;

{==============================================================================}

function usb_hub_notification(hub: PUSB_HUB; callback: usb_hub_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=USBHubNotification(hub,callback,data,notification,flags);
end;

{==============================================================================}

procedure usb_hub_bind_devices(device: PUSB_DEVICE; callback: usb_device_bind_proc); stdcall;
{Enumerate each device in the USB tree and call a bind callback for each one}
{Device: USB device at which to start the enumeration (Must be a hub device)}
{Callback: Bind callback function to execute for each device}
begin
 {}
 USBHubBindDevices(device,callback);
end;

{==============================================================================}

procedure usb_hub_unbind_devices(device: PUSB_DEVICE; driver: PUSB_DRIVER; callback: usb_device_unbind_proc); stdcall;
{Enumerate each device in the USB tree and call an unbind callback for each one}
{Device: USB device at which to start the enumeration}
{Driver: The driver to unbind the device from (nil to unbind from current driver)}
{Callback: Unbind callback function to execute for each device}
begin
 {}
 USBHubUnbindDevices(device,driver,callback);
end;

{==============================================================================}

procedure usb_hub_enumerate_devices(device: PUSB_DEVICE; callback: usb_device_enumerate_cb; data: PVOID); stdcall;
{Enumerate each device in the USB tree and call an enumerate callback for each one}
{Device: USB device at which to start the enumeration}
{Callback: Enumerate callback function to execute for each device}
begin
 {}
 USBHubEnumerateDevices(device,callback,data);
end;

{==============================================================================}

function usb_hub_port_reset(port: PUSB_PORT; delay: uint32_t): uint32_t; stdcall;
{Reset the specified USB port}
{Port: USB port to reset}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
{Note: Caller must hold the hub lock}
begin
 {}
 Result:=USBHubPortReset(port,delay);
end;

{==============================================================================}

function usb_hub_port_disable(port: PUSB_PORT): uint32_t; stdcall;
{Disable the specified USB port}
{Port: USB port to disable}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
{Note: Caller must hold the hub lock}
{Note: A port cannot be enabled in software, only disabled}
begin
 {}
 Result:=USBHubPortDisable(port);
end;

{==============================================================================}

function usb_hub_port_power_on(port: PUSB_PORT): uint32_t; stdcall;
{Power on the specified USB port}
{Port: USB port to power on}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
{Note: Caller must hold the hub lock}
{Note: Not all hubs support powering on and off individual ports, you must check
       if the hub includes the USB_HUB_CHARACTERISTIC_LPSM_PORT in its descriptor}
begin
 {}
 Result:=USBHubPortPowerOn(port);
end;

{==============================================================================}

function usb_hub_port_power_off(port: PUSB_PORT): uint32_t; stdcall;
{Power off the specified USB port}
{Port: USB port to power off}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
{Note: Caller must hold the hub lock}
{Note: Not all hubs support powering on and off individual ports, you must check
       if the hub includes the USB_HUB_CHARACTERISTIC_LPSM_PORT in its descriptor}
begin
 {}
 Result:=USBHubPortPowerOff(port);
end;

{==============================================================================}

function usb_hub_port_get_status(port: PUSB_PORT): uint32_t; stdcall;
{Read the status of the specified USB port}
{Port: USB port to read status for}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
{Note: Caller must hold the hub lock}
begin
 {}
 Result:=USBHubPortGetStatus(port);
end;

{==============================================================================}

function usb_hub_port_set_feature(port: PUSB_PORT; feature: uint16_t): uint32_t; stdcall;
{Enable a feature on the specified USB port}
{Port: USB port to enable the feature on}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
{Note: Caller must hold the hub lock}
begin
 {}
 Result:=USBHubPortSetFeature(port,feature);
end;

{==============================================================================}

function usb_hub_port_clear_feature(port: PUSB_PORT; feature: uint16_t): uint32_t; stdcall;
{Disable a feature on the specified USB port}
{Port: USB port to disable the feature on}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
{Note: Caller must hold the hub lock}
begin
 {}
 Result:=USBHubPortClearFeature(port,feature);
end;

{==============================================================================}

function usb_hub_port_change_feature(port: PUSB_PORT; feature: uint16_t; enable: BOOL): uint32_t; stdcall;
{Enable or disable a feature on the specified USB port}
{Port: USB port to enable or disable the feature on}
{Feature: The feature to enable or disable}
{Enable: True to enable the feature or False to disable the feature}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
{Note: Caller must hold the hub lock}
begin
 {}
 Result:=USBHubPortChangeFeature(port,feature,enable);
end;

{==============================================================================}

function usb_hub_port_attach_device(port: PUSB_PORT): uint32_t; stdcall;
{Attach a newly connected USB device to the specified USB port}
{Port: USB port to attach the new device to}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
{Note: Caller must hold the hub lock}
{Note: Only called in response to a status change on the hub}
begin
 {}
 Result:=USBHubPortAttachDevice(port);
end;

{==============================================================================}

function usb_hub_port_detach_device(port: PUSB_PORT): uint32_t; stdcall;
{Detach a disconnected USB device from the specified USB port}
{Port: USB port to detach the device from}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
{Note: Caller must hold the hub lock}
{Note: Only called in response to a status change on the hub}
begin
 {}
 Result:=USBHubPortDetachDevice(port);
end;

{==============================================================================}

function usb_hub_port_status_changed(port: PUSB_PORT): uint32_t; stdcall;
{Process a status change for the specified USB port}
{Port: USB port to process the status change for}
{Return: USB_STATUS_SUCCESS if completed or another error code on failure}
{Note: Caller must hold the hub lock}
{Note: Only called in response to a status change on the hub}
begin
 {}
 Result:=USBHubPortStatusChanged(port);
end;

{==============================================================================}
{USB Device, Driver and Host Helper Functions}
function usb_device_get_count: uint32_t; stdcall;
{Get the current device count}
begin
 {}
 Result:=USBDeviceGetCount;
end;

{==============================================================================}

function usb_device_check(device: PUSB_DEVICE): PUSB_DEVICE; stdcall;
{Check if the supplied Device is in the device table}
begin
 {}
 Result:=USBDeviceCheck(device);
end;

{==============================================================================}

function usb_driver_get_count: uint32_t; stdcall;
{Get the current USB driver count}
begin
 {}
 Result:=USBDriverGetCount;
end;

{==============================================================================}

function usb_driver_check(driver: PUSB_DRIVER): PUSB_DRIVER; stdcall;
{Check if the supplied USB Driver is in the driver table}
begin
 {}
 Result:=USBDriverCheck(driver);
end;

{==============================================================================}

function usb_host_get_count: uint32_t; stdcall;
{Get the current host count}
begin
 {}
 Result:=USBHostGetCount;
end;

{==============================================================================}

function usb_host_check(host: PUSB_HOST): PUSB_HOST; stdcall;
{Check if the supplied Host is in the host table}
begin
 {}
 Result:=USBHostCheck(host);
end;

{==============================================================================}

function usb_is_hub(device: PUSB_DEVICE): BOOL; stdcall;
{Returns True if Device is a Hub or False if not}
begin
 {}
 Result:=USBIsHub(device);
end;

{==============================================================================}

function usb_is_root_hub(device: PUSB_DEVICE): BOOL; stdcall;
{Returns True if Device is a Root Hub or False if not}
begin
 {}
 Result:=USBIsRootHub(device);
end;

{==============================================================================}

function usb_is_control_request(request: PUSB_REQUEST): BOOL; stdcall;
{Returns True if Request is a control request or False if not}
begin
 {}
 Result:=USBIsControlRequest(request);
end;

{==============================================================================}

function usb_is_bulk_request(request: PUSB_REQUEST): BOOL; stdcall;
{Returns True if Request is a bulk request or False if not}
begin
 {}
 Result:=USBIsBulkRequest(request);
end;

{==============================================================================}

function usb_is_interrupt_request(request: PUSB_REQUEST): BOOL; stdcall;
{Returns True if Request is an interrupt request or False if not}
begin
 {}
 Result:=USBIsInterruptRequest(request);
end;

{==============================================================================}

function usb_is_isochronous_request(request: PUSB_REQUEST): BOOL; stdcall;
{Returns True if Request is an isochronous request or False if not}
begin
 {}
 Result:=USBIsIsochronousRequest(request);
end;

{==============================================================================}

function usb_is_in_endpoint(endpoint: PUSB_ENDPOINT_DESCRIPTOR): BOOL; stdcall;
{Returns True is Endpoint is an IN endpoint or False if not}
begin
 {}
 Result:=USBIsInEndpoint(endpoint);
end;

{==============================================================================}

function usb_is_out_endpoint(endpoint: PUSB_ENDPOINT_DESCRIPTOR): BOOL; stdcall;
{Returns True is Endpoint is an OUT endpoint or False if not}
begin
 {}
 Result:=USBIsOutEndpoint(endpoint);
end;

{==============================================================================}

function usb_is_bulk_endpoint(endpoint: PUSB_ENDPOINT_DESCRIPTOR): BOOL; stdcall;
{Returns True is Endpoint is a BULK endpoint or False if not}
begin
 {}
 Result:=USBIsBulkEndpoint(endpoint);
end;

{==============================================================================}

function usb_is_interrupt_endpoint(endpoint: PUSB_ENDPOINT_DESCRIPTOR): BOOL; stdcall;
{Returns True is Endpoint is a INTERRUPT endpoint or False if not}
begin
 {}
 Result:=USBIsInterruptEndpoint(endpoint);
end;

{==============================================================================}

function usb_is_isochronous_endpoint(endpoint: PUSB_ENDPOINT_DESCRIPTOR): BOOL; stdcall;
{Returns True is Endpoint is a ISOCHRONOUS endpoint or False if not}
begin
 {}
 Result:=USBIsIsochronousEndpoint(endpoint);
end;

{==============================================================================}

function usb_status_to_string(status: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Translates a USB status code into a string}
begin
 {}
 Result:=APIStringToPCharBuffer(USBStatusToString(status),_string,len);
end;

{==============================================================================}

function usb_device_type_to_string(usbtype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(USBDeviceTypeToString(usbtype),_string,len);
end;

{==============================================================================}

function usb_device_state_to_string(usbstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(USBDeviceStateToString(usbstate),_string,len);
end;

{==============================================================================}

function usb_device_status_to_string(usbstatus: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(USBDeviceStatusToString(usbstatus),_string,len);
end;

{==============================================================================}

function usb_device_state_to_notification(state: uint32_t): uint32_t; stdcall;
{Convert a Device state value into the notification code for device notifications}
begin
 {}
 Result:=USBDeviceStateToNotification(state);
end;

{==============================================================================}

function usb_device_status_to_notification(status: uint32_t): uint32_t; stdcall;
{Convert a Device status value into the notification code for device notifications}
begin
 {}
 Result:=USBDeviceStatusToNotification(status);
end;

{==============================================================================}

function usb_host_type_to_string(hosttype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(USBHostTypeToString(hosttype),_string,len);
end;

{==============================================================================}

function usb_host_state_to_string(hoststate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(USBHostStateToString(hoststate),_string,len);
end;

{==============================================================================}

function usb_host_state_to_notification(state: uint32_t): uint32_t; stdcall;
{Convert a Host state value into the notification code for device notifications}
begin
 {}
 Result:=USBHostStateToNotification(state);
end;

{==============================================================================}

procedure usb_log_device_configuration(device: PUSB_DEVICE; output: usb_log_output_proc; data: PVOID); stdcall;
begin
 {}
 USBLogDeviceConfiguration(device,output,data);
end;

{==============================================================================}

procedure usb_log_device_descriptor(device: PUSB_DEVICE; descriptor: PUSB_DEVICE_DESCRIPTOR; output: usb_log_output_proc; data: PVOID); stdcall;
begin
 {}
 USBLogDeviceDescriptor(device,descriptor,output,data);
end;

{==============================================================================}

procedure usb_log_configuration_descriptor(device: PUSB_DEVICE; descriptor: PUSB_CONFIGURATION_DESCRIPTOR; output: usb_log_output_proc; data: PVOID); stdcall;
begin
 {}
 USBLogConfigurationDescriptor(device,descriptor,output,data);
end;

{==============================================================================}

procedure usb_log_interface_descriptor(device: PUSB_DEVICE; descriptor: PUSB_INTERFACE_DESCRIPTOR; output: usb_log_output_proc; data: PVOID); stdcall;
begin
 {}
 USBLogInterfaceDescriptor(device,descriptor,output,data);
end;

{==============================================================================}

procedure usb_log_endpoint_descriptor(device: PUSB_DEVICE; descriptor: PUSB_ENDPOINT_DESCRIPTOR; output: usb_log_output_proc; data: PVOID); stdcall;
begin
 {}
 USBLogEndpointDescriptor(device,descriptor,output,data);
end;

{==============================================================================}

function usb_log_devices: uint32_t; stdcall;
{Print information about all devices attached to the USB}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=USBLogDevices;
end;

{==============================================================================}

function usb_log_devices_ex(device: PUSB_DEVICE; output: usb_log_output_proc; devicecallback, treecallback: usb_device_enumerate_cb; data: PVOID): uint32_t; stdcall;
{Print information about one or all devices attached to the USB with custom output and callbacks}
{Device: The device to print information about (nil for all devices)}
{Output: The log output callback to print information to (nil to use the default output)}
{Device Callback: The callback to print device information (nil if no device information should be printed)}
{Tree Callback: The callback to print tree information (nil if no tree information should be printed)}
{Data: A pointer to caller specific data which should be passed to the callbacks (Optional)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=USBLogDevicesEx(device,output,devicecallback,treecallback,data);
end;

{==============================================================================}

function usb_log_device_callback(device: PUSB_DEVICE; data: PVOID): uint32_t; stdcall;
begin
 {}
 Result:=USBLogDeviceCallback(device,data);
end;

{==============================================================================}

function usb_log_tree_callback(device: PUSB_DEVICE; data: PVOID): uint32_t; stdcall;
begin
 {}
 Result:=USBLogTreeCallback(device,data);
end;

{==============================================================================}
{USB Hub Helper Functions}
function usb_hub_get_count: uint32_t; stdcall;
{Get the current hub count}
begin
 {}
 Result:=USBHubGetCount;
end;

{==============================================================================}

function usb_hub_check(hub: PUSB_HUB): PUSB_HUB; stdcall;
{Check if the supplied Hub is in the hub table}
begin
 {}
 Result:=USBHubCheck(hub);
end;

{==============================================================================}

function usb_hub_is_multi_tt(hub: PUSB_HUB): BOOL; stdcall;
{Returns True if Hub has multiple Transaction Translators or False if not}
begin
 {}
 Result:=USBHubIsMultiTT(hub);
end;

{==============================================================================}

function usb_hub_is_compound(hub: PUSB_HUB): BOOL; stdcall;
{Returns True if Hub is part of a Compound Device or False if not}
begin
 {}
 Result:=USBHubIsCompound(hub);
end;

{==============================================================================}

function usb_hub_has_port_indicator(hub: PUSB_HUB): BOOL; stdcall;
{Returns True if Hub supports Port Indicators or False if not}
begin
 {}
 Result:=USBHubHasPortIndicator(hub);
end;

{==============================================================================}

function usb_hub_has_port_power_switching(hub: PUSB_HUB): BOOL; stdcall;
{Returns True if Hub supports per port Power Switching or False if not}
begin
 {}
 Result:=USBHubHasPortPowerSwitching(hub);
end;

{==============================================================================}

function usb_hub_has_port_current_protection(hub: PUSB_HUB): BOOL; stdcall;
{Returns True if Hub supports per port Over Current Power Protection or False if not}
begin
 {}
 Result:=USBHubHasPortCurrentProtection(hub);
end;

{==============================================================================}

function usb_hub_get_tt_think_time(hub: PUSB_HUB): uint8_t; stdcall;
{Get the TT Think Time from a Hub}
begin
 {}
 Result:=USBHubGetTTThinkTime(hub);
end;

{==============================================================================}

function usb_hub_type_to_string(hubtype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Return a string describing the supplied Hub type value}
begin
 {}
 Result:=APIStringToPCharBuffer(USBHubTypeToString(hubtype),_string,len);
end;

{==============================================================================}

function usb_hub_state_to_string(hubstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Return a string describing the supplied Hub state value}
begin
 {}
 Result:=APIStringToPCharBuffer(USBHubStateToString(hubstate),_string,len);
end;

{==============================================================================}

function usb_hub_state_to_notification(state: uint32_t): uint32_t; stdcall;
{Convert a Hub state value into the notification code for device notifications}
begin
 {}
 Result:=USBHubStateToNotification(state);
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{MMC Functions}
{$IFDEF API_EXPORT_MMC}
function mmc_start: uint32_t; stdcall;
begin
 {}
 Result:=MMCStart;
end;

{==============================================================================}

function mmc_stop: uint32_t; stdcall;
begin
 {}
 Result:=MMCStop;
end;

{==============================================================================}

procedure mmc_async_start(sdhci: PSDHCI_HOST); stdcall;
begin
 {}
 MMCAsyncStart(sdhci);
end;

{==============================================================================}
{MMC Functions}
function mmc_device_read_blocks(mmc: PMMC_DEVICE; const start, count: int64_t; buffer: PVOID): uint32_t; stdcall;
begin
 {}
 Result:=MMCDeviceReadBlocks(mmc,start,count,buffer);
end;

{==============================================================================}

function mmc_device_write_blocks(mmc: PMMC_DEVICE; const start, count: int64_t; buffer: PVOID): uint32_t; stdcall;
begin
 {}
 Result:=MMCDeviceWriteBlocks(mmc,start,count,buffer);
end;

{==============================================================================}

function mmc_device_erase_blocks(mmc: PMMC_DEVICE; const start, count: int64_t): uint32_t; stdcall;
begin
 {}
 Result:=MMCDeviceEraseBlocks(mmc,start,count);
end;

{==============================================================================}

function mmc_device_go_idle(mmc: PMMC_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=MMCDeviceGoIdle(mmc);
end;

{==============================================================================}

function mmc_device_set_clock(mmc: PMMC_DEVICE; clock: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=MMCDeviceSetClock(mmc,clock);
end;

{==============================================================================}

function mmc_device_set_timing(mmc: PMMC_DEVICE; timing: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=MMCDeviceSetTiming(mmc,timing);
end;

{==============================================================================}

function mmc_device_set_bus_width(mmc: PMMC_DEVICE; width: uint32_t): uint32_t; stdcall;
{Reference: Section 3.4 of SD Host Controller Simplified Specification V3.0 partA2_300.pdf}
begin
 {}
 Result:=MMCDeviceSetBusWidth(mmc,width);
end;

{==============================================================================}

function mmc_device_set_block_length(mmc: PMMC_DEVICE; length: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=MMCDeviceSetBlockLength(mmc,length);
end;

{==============================================================================}

function mmc_device_set_block_count(mmc: PMMC_DEVICE; count: uint32_t; relative: BOOL): uint32_t; stdcall;
begin
 {}
 Result:=MMCDeviceSetBlockCount(mmc,count,relative);
end;

{==============================================================================}

function mmc_device_set_driver_stage(mmc: PMMC_DEVICE; driverstage: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=MMCDeviceSetDriverStage(mmc,driverstage);
end;

{==============================================================================}

function mmc_device_stop_transmission(mmc: PMMC_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=MMCDeviceStopTransmission(mmc);
end;

{==============================================================================}

function mmc_device_select_card(mmc: PMMC_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=MMCDeviceSelectCard(mmc);
end;

{==============================================================================}

function mmc_device_deselect_card(mmc: PMMC_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=MMCDeviceDeselectCard(mmc);
end;

{==============================================================================}

function mmc_device_switch(mmc: PMMC_DEVICE; setting, index, value: uint8_t; timeout: uint32_t): uint32_t; stdcall;
{Modifies an Extended CSD register for the specificed MMC device}
{MMC: The MMC Device to modify}
{Setting: The Extended CSD command set (eg EXT_CSD_CMD_SET_NORMAL)}
{Index: The index of the Extended CSD register to be set}
{Value: The value to be set in the Extended CSD register}
{Timeout: Command timeout in milliseconds}
begin
 {}
 Result:=MMCDeviceSwitch(mmc,setting,index,value,timeout);
end;

{==============================================================================}

function mmc_device_switch_ex(mmc: PMMC_DEVICE; setting, index, value: uint8_t; timeout, timing: uint32_t; sendstatus, retrycrcerror: BOOL): uint32_t; stdcall;
{Modifies an Extended CSD register for the specificed MMC device}
{MMC: The MMC Device to modify}
{Setting: The Extended CSD command set (eg EXT_CSD_CMD_SET_NORMAL)}
{Index: The index of the Extended CSD register to be set}
{Value: The value to be set in the Extended CSD register}
{Timeout: Command timeout in milliseconds}
{Timing: New timing to enable after change (eg MMC_TIMING_MMC_HS)}
{SendStatus: Use the MMC_CMD_SEND_STATUS command to poll for busy}
{RetryCRCError: Retry if CRC error occurs when polling for busy}
begin
 {}
 Result:=MMCDeviceSwitchEx(mmc,setting,index,value,timeout,timing,sendstatus,retrycrcerror);
end;

{==============================================================================}

function mmc_device_poll_for_busy(mmc: PMMC_DEVICE; timeout, command: uint32_t): uint32_t; stdcall;
{Poll the specified MMC device for command completion using busy status}
begin
 {}
 Result:=MMCDevicePollForBusy(mmc,timeout,command);
end;

{==============================================================================}

function mmc_device_poll_for_busy_ex(mmc: PMMC_DEVICE; timeout, command: uint32_t; sendstatus, retrycrcerror: BOOL): uint32_t; stdcall;
{Poll the specified MMC device for command completion using busy status}
begin
 {}
 Result:=MMCDevicePollForBusyEx(mmc,timeout,command,sendstatus,retrycrcerror);
end;

{==============================================================================}

function mmc_device_send_card_status(mmc: PMMC_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=MMCDeviceSendCardStatus(mmc);
end;

{==============================================================================}

function mmc_device_send_operation_condition(mmc: PMMC_DEVICE; probe: BOOL): uint32_t; stdcall;
{See: }
begin
 {}
 Result:=MMCDeviceSendOperationCondition(mmc,probe);
end;

{==============================================================================}

function mmc_device_send_card_specific(mmc: PMMC_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=MMCDeviceSendCardSpecific(mmc);
end;

{==============================================================================}

function mmc_device_decode_card_specific(mmc: PMMC_DEVICE): uint32_t; stdcall;
{Given a 128-bit response, decode to our card CSD structure}
begin
 {}
 Result:=MMCDeviceDecodeCardSpecific(mmc);
end;

{==============================================================================}

function mmc_device_send_card_identification(mmc: PMMC_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=MMCDeviceSendCardIdentification(mmc);
end;

{==============================================================================}

function mmc_device_send_all_card_identification(mmc: PMMC_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=MMCDeviceSendAllCardIdentification(mmc);
end;

{==============================================================================}

function mmc_device_decode_card_identification(mmc: PMMC_DEVICE): uint32_t; stdcall;
{Given a 128-bit response, decode to our card CID structure}
begin
 {}
 Result:=MMCDeviceDecodeCardIdentification(mmc);
end;

{==============================================================================}

function mmc_device_get_extended_card_specific(mmc: PMMC_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=MMCDeviceGetExtendedCardSpecific(mmc);
end;

{==============================================================================}

function mmc_device_send_extended_card_specific(mmc: PMMC_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=MMCDeviceSendExtendedCardSpecific(mmc);
end;

{==============================================================================}

function mmc_device_decode_extended_card_specific(mmc: PMMC_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=MMCDeviceDecodeExtendedCardSpecific(mmc);
end;

{==============================================================================}

function mmc_device_set_relative_address(mmc: PMMC_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=MMCDeviceSetRelativeAddress(mmc);
end;

{==============================================================================}

function mmc_device_spi_set_crc(mmc: PMMC_DEVICE; enable: BOOL): uint32_t; stdcall;
begin
 {}
 Result:=MMCDeviceSPISetCRC(mmc,enable);
end;

{==============================================================================}

function mmc_device_spi_read_operation_condition(mmc: PMMC_DEVICE; highcapacity: BOOL): uint32_t; stdcall;
begin
 {}
 Result:=MMCDeviceSPIReadOperationCondition(mmc,highcapacity);
end;

{==============================================================================}

function mmc_device_insert(mmc: PMMC_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=MMCDeviceInsert(mmc);
end;

{==============================================================================}

function mmc_device_remove(mmc: PMMC_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=MMCDeviceRemove(mmc);
end;

{==============================================================================}

function mmc_device_initialize(mmc: PMMC_DEVICE): uint32_t; stdcall;
{Reference: Section 3.6 of SD Host Controller Simplified Specification V3.0 partA2_300.pdf}
begin
 {}
 Result:=MMCDeviceInitialize(mmc);
end;

{==============================================================================}

function mmc_device_deinitialize(mmc: PMMC_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=MMCDeviceDeinitialize(mmc);
end;

{==============================================================================}

function mmc_device_get_card_detect(mmc: PMMC_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=MMCDeviceGetCardDetect(mmc);
end;

{==============================================================================}

function mmc_device_get_write_protect(mmc: PMMC_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=MMCDeviceGetWriteProtect(mmc);
end;

{==============================================================================}

function mmc_device_send_command(mmc: PMMC_DEVICE; command: PMMC_COMMAND): uint32_t; stdcall;
begin
 {}
 Result:=MMCDeviceSendCommand(mmc,command);
end;

{==============================================================================}

function mmc_device_set_ios(mmc: PMMC_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=MMCDeviceSetIOS(mmc);
end;

{==============================================================================}

function mmc_device_create: PMMC_DEVICE; stdcall;
{Create a new MMC entry}
{Return: Pointer to new MMC entry or nil if MMC could not be created}
begin
 {}
 Result:=MMCDeviceCreate;
end;

{==============================================================================}

function mmc_device_create_ex(size: uint32_t): PMMC_DEVICE; stdcall;
{Create a new MMC entry}
{Size: Size in bytes to allocate for new MMC (Including the MMC entry)}
{Return: Pointer to new MMC entry or nil if MMC could not be created}
begin
 {}
 Result:=MMCDeviceCreateEx(size);
end;

{==============================================================================}

function mmc_device_destroy(mmc: PMMC_DEVICE): uint32_t; stdcall;
{Destroy an existing MMC entry}
begin
 {}
 Result:=MMCDeviceDestroy(mmc);
end;

{==============================================================================}

function mmc_device_register(mmc: PMMC_DEVICE): uint32_t; stdcall;
{Register a new MMC in the MMC table}
begin
 {}
 Result:=MMCDeviceRegister(mmc);
end;

{==============================================================================}

function mmc_device_deregister(mmc: PMMC_DEVICE): uint32_t; stdcall;
{Deregister a MMC from the MMC table}
begin
 {}
 Result:=MMCDeviceDeregister(mmc);
end;

{==============================================================================}

function mmc_device_find(mmcid: uint32_t): PMMC_DEVICE; stdcall;
begin
 {}
 Result:=MMCDeviceFind(mmcid);
end;

{==============================================================================}

function mmc_device_find_by_device(device: PDEVICE): PMMC_DEVICE; stdcall;
{Find an MMC/SD device by the matching DeviceData property}
{Device: The device entry to match with the DeviceData value}
{Return: The MMC/SD device matched or nil if none found}
begin
 {}
 Result:=MMCDeviceFindByDevice(device);
end;

{==============================================================================}

function mmc_device_find_by_name(const name: PCHAR): PMMC_DEVICE; stdcall;
begin
 {}
 Result:=MMCDeviceFindByName(String(name));
end;

{==============================================================================}

function mmc_device_find_by_description(const description: PCHAR): PMMC_DEVICE; stdcall;
begin
 {}
 Result:=MMCDeviceFindByDescription(String(description));
end;

{==============================================================================}

function mmc_device_enumerate(callback: mmc_enumerate_cb; data: PVOID): uint32_t; stdcall;
begin
 {}
 Result:=MMCDeviceEnumerate(callback,data);
end;

{==============================================================================}

function mmc_device_notification(mmc: PMMC_DEVICE; callback: mmc_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=MMCDeviceNotification(mmc,callback,data,notification,flags);
end;

{==============================================================================}
{SD Functions}
function sd_device_switch(mmc: PMMC_DEVICE; mode, group: int; value: uint8_t; buffer: PVOID): uint32_t; stdcall;
{See: 4.3.10 of SD Physical Layer Simplified Specification V4.10}
{Buffer must point to a 64 byte buffer for Switch Status information}
begin
 {}
 Result:=SDDeviceSwitch(mmc,mode,group,value,buffer);
end;

{==============================================================================}

function sd_device_switch_highspeed(mmc: PMMC_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=SDDeviceSwitchHighspeed(mmc);
end;

{==============================================================================}

function sd_device_set_bus_width(mmc: PMMC_DEVICE; width: uint32_t): uint32_t; stdcall;
{See: Table 4-30 in Section 4.7.4 of SD Physical Layer Simplified Specification V4.10}
begin
 {}
 Result:=SDDeviceSetBusWidth(mmc,width);
end;

{==============================================================================}

function sd_device_send_interface_condition(mmc: PMMC_DEVICE): uint32_t; stdcall;
{See: 4.3.13 of SD Physical Layer Simplified Specification V4.10

 CMD8 (SEND_IF_COND) must be invoked to support SD 2.0 cards
 The card must be in Idle State before issuing this command

 This command will fail harmlessly for SD 1.0 cards
}
begin
 {}
 Result:=SDDeviceSendInterfaceCondition(mmc);
end;

{==============================================================================}

function sd_device_send_operation_condition(mmc: PMMC_DEVICE; probe: BOOL): uint32_t; stdcall;
{See: 4.2.3.1 of SD Physical Layer Simplified Specification V4.10}
begin
 {}
 Result:=SDDeviceSendOperationCondition(mmc,probe);
end;

{==============================================================================}

function sd_device_get_card_specific(mmc: PMMC_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=SDDeviceGetCardSpecific(mmc);
end;

{==============================================================================}

function sd_device_decode_card_specific(mmc: PMMC_DEVICE): uint32_t; stdcall;
{Given a 128-bit response, decode to our card CSD structure}
begin
 {}
 Result:=SDDeviceDecodeCardSpecific(mmc);
end;

{==============================================================================}

function sd_device_get_card_identification(mmc: PMMC_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=SDDeviceGetCardIdentification(mmc);
end;

{==============================================================================}

function sd_device_decode_card_identification(mmc: PMMC_DEVICE): uint32_t; stdcall;
{Given a 128-bit response, decode to our card CID structure}
begin
 {}
 Result:=SDDeviceDecodeCardIdentification(mmc);
end;

{==============================================================================}

function sd_device_send_sd_status(mmc: PMMC_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=SDDeviceSendSDStatus(mmc);
end;

{==============================================================================}

function sd_device_decode_sd_status(mmc: PMMC_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=SDDeviceDecodeSDStatus(mmc);
end;

{==============================================================================}

function sd_device_send_sd_switch(mmc: PMMC_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=SDDeviceSendSDSwitch(mmc);
end;

{==============================================================================}

function sd_device_decode_sd_switch(mmc: PMMC_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=SDDeviceDecodeSDSwitch(mmc);
end;

{==============================================================================}

function sd_device_send_sd_configuration(mmc: PMMC_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=SDDeviceSendSDConfiguration(mmc);
end;

{==============================================================================}

function sd_device_decode_sd_configuration(mmc: PMMC_DEVICE): uint32_t; stdcall;
{Given a 64-bit response, decode to our card SCR structure}
begin
 {}
 Result:=SDDeviceDecodeSDConfiguration(mmc);
end;

{==============================================================================}

function sd_device_send_relative_address(mmc: PMMC_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=SDDeviceSendRelativeAddress(mmc);
end;

{==============================================================================}

function sd_device_send_application_command(mmc: PMMC_DEVICE; command: PMMC_COMMAND): uint32_t; stdcall;
begin
 {}
 Result:=SDDeviceSendApplicationCommand(mmc,command);
end;

{==============================================================================}
{SDIO Functions}
function sdio_device_reset(mmc: PMMC_DEVICE): uint32_t; stdcall;
{See: SDIO Simplified Specification V2.0, 4.4 Reset for SDIO}
begin
 {}
 Result:=SDIODeviceReset(mmc);
end;

{==============================================================================}

function sdio_device_enable_wide_bus(mmc: PMMC_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=SDIODeviceEnableWideBus(mmc);
end;

{==============================================================================}

function sdio_device_disable_wide_bus(mmc: PMMC_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=SDIODeviceDisableWideBus(mmc);
end;

{==============================================================================}

function sdio_device_enable_highspeed(mmc: PMMC_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=SDIODeviceEnableHighspeed(mmc);
end;

{==============================================================================}

function sdio_device_switch_highspeed(mmc: PMMC_DEVICE; enable: BOOL): uint32_t; stdcall;
begin
 {}
 Result:=SDIODeviceSwitchHighspeed(mmc,enable);
end;

{==============================================================================}

function sdio_device_send_operation_condition(mmc: PMMC_DEVICE; probe: BOOL): uint32_t; stdcall;
begin
 {}
 Result:=SDIODeviceSendOperationCondition(mmc,probe);
end;

{==============================================================================}

function sdio_device_read_write_direct(mmc: PMMC_DEVICE; write: BOOL; operation, address: uint32_t; input: uint8_t; output: Puint8_t): uint32_t; stdcall;
begin
 {}
 Result:=SDIODeviceReadWriteDirect(mmc,write,operation,address,input,output);
end;

{==============================================================================}

function sdio_device_read_write_extended(mmc: PMMC_DEVICE; write: BOOL; operation, address: uint32_t; increment: BOOL; buffer: PVOID; blockcount, blocksize: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=SDIODeviceReadWriteExtended(mmc,write,operation,address,increment,buffer,blockcount,blocksize);
end;

{==============================================================================}

function sdio_device_read_byte(mmc: PMMC_DEVICE; address: uint32_t; output: Puint8_t): uint32_t; stdcall;
{Wrapper for reading a single byte from Function 0}
begin
 {}
 Result:=SDIODeviceReadByte(mmc,address,output);
end;

{==============================================================================}

function sdio_device_write_byte(mmc: PMMC_DEVICE; address: uint32_t; input: uint8_t): uint32_t; stdcall;
{Wrapper for writing a single byte to Function 0}
begin
 {}
 Result:=SDIODeviceWriteByte(mmc,address,input);
end;

{==============================================================================}

function sdio_device_read_cccr(mmc: PMMC_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=SDIODeviceReadCCCR(mmc);
end;

{==============================================================================}

function sdio_device_read_fbr(func: PSDIO_FUNCTION): uint32_t; stdcall;
begin
 {}
 Result:=SDIODeviceReadFBR(func);
end;

{==============================================================================}

function sdio_device_read_cis(mmc: PMMC_DEVICE; func: PSDIO_FUNCTION): uint32_t; stdcall;
begin
 {}
 Result:=SDIODeviceReadCIS(mmc,func);
end;

{==============================================================================}

function sdio_device_read_common_cis(mmc: PMMC_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=SDIODeviceReadCommonCIS(mmc);
end;

{==============================================================================}

function sdio_device_read_function_cis(func: PSDIO_FUNCTION): uint32_t; stdcall;
begin
 {}
 Result:=SDIODeviceReadFunctionCIS(func);
end;

{==============================================================================}

function sdio_device_process_interrupts(mmc: PMMC_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=SDIODeviceProcessInterrupts(mmc);
end;

{==============================================================================}

function sdio_device_register_interrupt(mmc: PMMC_DEVICE; func: PSDIO_FUNCTION; handler: sdio_interrupt_handler): uint32_t; stdcall;
begin
 {}
 Result:=SDIODeviceRegisterInterrupt(mmc,func,handler);
end;

{==============================================================================}

function sdio_device_deregister_interrupt(mmc: PMMC_DEVICE; func: PSDIO_FUNCTION): uint32_t; stdcall;
begin
 {}
 Result:=SDIODeviceDeregisterInterrupt(mmc,func);
end;

{==============================================================================}

function sdio_device_bind_functions(mmc: PMMC_DEVICE): uint32_t; stdcall;
{Attempt to bind SDIO functions on an MMC device to one of the registered drivers}
{MMC: The MMC device to attempt to bind a driver to}
{Return: MMC_STATUS_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SDIODeviceBindFunctions(mmc);
end;

{==============================================================================}

function sdio_device_unbind_functions(mmc: PMMC_DEVICE; driver: PSDIO_DRIVER): uint32_t; stdcall;
{Unbind SDIO functions on an MMC device from a driver}
{MMC: The MMC device to unbind a driver from}
{Driver: The driver to unbind the MMC device from (nil to unbind from current driver)}
{Return: MMC_STATUS_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SDIODeviceUnbindFunctions(mmc,driver);
end;

{==============================================================================}

function sdio_function_allocate(mmc: PMMC_DEVICE; number: uint32_t): PSDIO_FUNCTION; stdcall;
begin
 {}
 Result:=SDIOFunctionAllocate(mmc,number);
end;

{==============================================================================}

function sdio_function_release(func: PSDIO_FUNCTION): uint32_t; stdcall;
begin
 {}
 Result:=SDIOFunctionRelease(func);
end;

{==============================================================================}

function sdio_function_find(mmc: PMMC_DEVICE; number: uint32_t): PSDIO_FUNCTION; stdcall;
begin
 {}
 Result:=SDIOFunctionFind(mmc,number);
end;

{==============================================================================}

function sdio_function_find_by_id(mmc: PMMC_DEVICE; vendorid, deviceid: uint16_t): PSDIO_FUNCTION; stdcall;
begin
 {}
 Result:=SDIOFunctionFindById(mmc,vendorid,deviceid);
end;

{==============================================================================}

function sdio_function_enumerate(mmc: PMMC_DEVICE; callback: sdio_function_enumerate_cb; data: PVOID): uint32_t; stdcall;
begin
 {}
 Result:=SDIOFunctionEnumerate(mmc,callback,data);
end;

{==============================================================================}

function sdio_function_bind(func: PSDIO_FUNCTION; driver: PSDIO_DRIVER): uint32_t; stdcall;
begin
 {}
 Result:=SDIOFunctionBind(func,driver);
end;

{==============================================================================}

function sdio_function_unbind(func: PSDIO_FUNCTION; driver: PSDIO_DRIVER): uint32_t; stdcall;
begin
 {}
 Result:=SDIOFunctionUnbind(func,driver);
end;

{==============================================================================}

function sdio_function_enable(func: PSDIO_FUNCTION): uint32_t; stdcall;
begin
 {}
 Result:=SDIOFunctionEnable(func);
end;

{==============================================================================}

function sdio_function_disable(func: PSDIO_FUNCTION): uint32_t; stdcall;
begin
 {}
 Result:=SDIOFunctionDisable(func);
end;

{==============================================================================}

function sdio_function_set_block_size(func: PSDIO_FUNCTION; blocksize: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=SDIOFunctionSetBlockSize(func,blocksize);
end;

{==============================================================================}

function sdio_function_read_write_extended(func: PSDIO_FUNCTION; write: BOOL; address: uint32_t; increment: BOOL; buffer: PVOID; size: uint32_t): uint32_t; stdcall;
{Perform an SDIO read or write to the specified function at the specified address}
{Handles splitting any size read or write into multiple IO_RW_EXTENDED requests, accounting for maximum block sizes}
begin
 {}
 Result:=SDIOFunctionReadWriteExtended(func,write,address,increment,buffer,size);
end;

{==============================================================================}

function sdio_function_read(func: PSDIO_FUNCTION; address: uint32_t; buffer: PVOID; size: uint32_t): uint32_t; stdcall;
{Wrapper for reading multiple bytes from an SDIO function}
begin
 {}
 Result:=SDIOFunctionRead(func,address,buffer,size);
end;

{==============================================================================}

function sdio_function_write(func: PSDIO_FUNCTION; address: uint32_t; buffer: PVOID; size: uint32_t): uint32_t; stdcall;
{Wrapper for writing multiple bytes to an SDIO function}
begin
 {}
 Result:=SDIOFunctionWrite(func,address,buffer,size);
end;

{==============================================================================}

function sdio_function_read_byte(func: PSDIO_FUNCTION; address: uint32_t; output: Puint8_t): uint32_t; stdcall;
{Wrapper for reading a single byte from an SDIO function}
begin
 {}
 Result:=SDIOFunctionReadByte(func,address,output);
end;

{==============================================================================}

function sdio_function_write_byte(func: PSDIO_FUNCTION; address: uint32_t; input: uint8_t): uint32_t; stdcall;
{Wrapper for writing a single byte to an SDIO function}
begin
 {}
 Result:=SDIOFunctionWriteByte(func,address,input);
end;

{==============================================================================}

function sdio_function_write_read_byte(func: PSDIO_FUNCTION; address: uint32_t; input: uint8_t; output: Puint8_t): uint32_t; stdcall;
{Wrapper for performing a read after write (RAW) operation on an SDIO function}
begin
 {}
 Result:=SDIOFunctionWriteReadByte(func,address,input,output);
end;

{==============================================================================}

function sdio_function_read_word(func: PSDIO_FUNCTION; address: uint32_t; output: Puint16_t): uint32_t; stdcall;
{Wrapper for reading a single word from an SDIO function}
begin
 {}
 Result:=SDIOFunctionReadWord(func,address,output);
end;

{==============================================================================}

function sdio_function_write_word(func: PSDIO_FUNCTION; address: uint32_t; input: uint16_t): uint32_t; stdcall;
{Wrapper for writing a single word to an SDIO function}
begin
 {}
 Result:=SDIOFunctionWriteWord(func,address,input);
end;

{==============================================================================}

function sdio_function_read_long(func: PSDIO_FUNCTION; address: uint32_t; output: Puint32_t): uint32_t; stdcall;
{Wrapper for reading a single longword from an SDIO function}
begin
 {}
 Result:=SDIOFunctionReadLong(func,address,output);
end;

{==============================================================================}

function sdio_function_write_long(func: PSDIO_FUNCTION; address: uint32_t; input: uint32_t): uint32_t; stdcall;
{Wrapper for writing a single longword to an SDIO function}
begin
 {}
 Result:=SDIOFunctionWriteLong(func,address,input);
end;

{==============================================================================}

function sdio_function_register_interrupt(func: PSDIO_FUNCTION; handler: sdio_interrupt_handler): uint32_t; stdcall;
begin
 {}
 Result:=SDIOFunctionRegisterInterrupt(func,handler);
end;

{==============================================================================}

function sdio_function_deregister_interrupt(func: PSDIO_FUNCTION): uint32_t; stdcall;
begin
 {}
 Result:=SDIOFunctionDeregisterInterrupt(func);
end;

{==============================================================================}

function sdio_host_dispatch_interrupt(sdhci: PSDHCI_HOST; irq, fiq: BOOL): uint32_t; stdcall;
begin
 {}
 Result:=SDIOHostDispatchInterrupt(sdhci,irq,fiq);
end;

{==============================================================================}

function sdio_driver_create: PSDIO_DRIVER; stdcall;
{Create a new SDIO Driver entry}
{Return: Pointer to new Driver entry or nil if driver could not be created}
begin
 {}
 Result:=SDIODriverCreate;
end;

{==============================================================================}

function sdio_driver_create_ex(size: uint32_t): PSDIO_DRIVER; stdcall;
{Create a new SDIO Driver entry}
{Size: Size in bytes to allocate for new driver (Including the driver entry)}
{Return: Pointer to new Driver entry or nil if driver could not be created}
begin
 {}
 Result:=SDIODriverCreateEx(size);
end;

{==============================================================================}

function sdio_driver_destroy(driver: PSDIO_DRIVER): uint32_t; stdcall;
{Destroy an existing SDIO Driver entry}
begin
 {}
 Result:=SDIODriverDestroy(driver);
end;

{==============================================================================}

function sdio_driver_register(driver: PSDIO_DRIVER): uint32_t; stdcall;
{Register a new Driver in the SDIO Driver table}
begin
 {}
 Result:=SDIODriverRegister(driver);
end;

{==============================================================================}

function sdio_driver_deregister(driver: PSDIO_DRIVER): uint32_t; stdcall;
{Deregister a Driver from the SDIO Driver table}
begin
 {}
 Result:=SDIODriverDeregister(driver);
end;

{==============================================================================}

function sdio_driver_find(driverid: uint32_t): PSDIO_DRIVER; stdcall;
{Find a driver by Id in the SDIO Driver table}
begin
 {}
 Result:=SDIODriverFind(driverid);
end;

{==============================================================================}

function sdio_driver_find_by_name(const name: PCHAR): PSDIO_DRIVER; stdcall;
{Find a driver by name in the Driver table}
begin
 {}
 Result:=SDIODriverFindByName(String(name));
end;

{==============================================================================}

function sdio_driver_enumerate(callback: sdio_driver_enumerate_cb; data: PVOID): uint32_t; stdcall;
begin
 {}
 Result:=SDIODriverEnumerate(callback,data);
end;

{==============================================================================}
{SDHCI Functions}
function sdhci_host_reset(sdhci: PSDHCI_HOST; mask: uint8_t): uint32_t; stdcall;
{Default software reset function for SDHCI host controllers}
{Note: Not intended to be called directly by applications, may be used by SDHCI drivers}
{Reference: Section 3.3 of SD Host Controller Simplified Specification V3.0 partA2_300.pdf}
begin
 {}
 Result:=SDHCIHostReset(sdhci,mask);
end;

{==============================================================================}

function sdhci_host_hardware_reset(sdhci: PSDHCI_HOST): uint32_t; stdcall;
{Default hardware reset function for SDHCI host controllers}
{Note: Not intended to be called directly by applications, may be used by SDHCI drivers}
begin
 {}
 Result:=SDHCIHostHardwareReset(sdhci);
end;

{==============================================================================}

function sdhci_host_set_power(sdhci: PSDHCI_HOST; power: uint16_t): uint32_t; stdcall;
{Default set power function for SDHCI host controllers}
{Power: A shift value to indicate the first available value in the Voltages mask}
{       Caller can use FirstBitSet(SDHCI.Voltages) to obtain the value of Power}
{       If there are no values set then Power will be -1 ($FFFF) to indicate nothing or unknown}
{Note: Not intended to be called directly by applications, may be used by SDHCI drivers}
{Reference: Section 3.3 of SD Host Controller Simplified Specification V3.0 partA2_300.pdf}
begin
 {}
 Result:=SDHCIHostSetPower(sdhci,power);
end;

{==============================================================================}

function sdhci_host_set_clock(sdhci: PSDHCI_HOST; clock: uint32_t): uint32_t; stdcall;
{Default set clock function for SDHCI host controllers}
{Note: Not intended to be called directly by applications, may be used by SDHCI drivers}
{Reference: Section 3.2 of SD Host Controller Simplified Specification V3.0 partA2_300.pdf}
begin
 {}
 Result:=SDHCIHostSetClock(sdhci,clock);
end;

{==============================================================================}

function sdhci_host_set_timing(sdhci: PSDHCI_HOST; timing: uint32_t): uint32_t; stdcall;
{Default set timing function for SDHCI host controllers}
{Note: Not intended to be called directly by applications, may be used by SDHCI drivers}
begin
 {}
 Result:=SDHCIHostSetTiming(sdhci,timing);
end;

{==============================================================================}

function sdhci_host_set_bus_width(sdhci: PSDHCI_HOST; buswidth: uint32_t): uint32_t; stdcall;
{Default set bus width function for SDHCI host controllers}
{Note: Not intended to be called directly by applications, may be used by SDHCI drivers}
begin
 {}
 Result:=SDHCIHostSetBusWidth(sdhci,buswidth);
end;

{==============================================================================}

function sdhci_host_prepare_dma(sdhci: PSDHCI_HOST; command: PMMC_COMMAND): uint32_t; stdcall;
{Default DMA transfer prepare function for SDHCI host controllers}
{Note: Not intended to be called directly by applications, may be used by SDHCI drivers}
begin
 {}
 Result:=SDHCIHostPrepareDMA(sdhci,command);
end;

{==============================================================================}

function sdhci_host_start_dma(sdhci: PSDHCI_HOST; command: PMMC_COMMAND): uint32_t; stdcall;
{Default DMA transfer start function for SDHCI host controllers}
{Note: Not intended to be called directly by applications, may be used by SDHCI drivers}
begin
 {}
 Result:=SDHCIHostStartDMA(sdhci,command);
end;

{==============================================================================}

function sdhci_host_stop_dma(sdhci: PSDHCI_HOST; command: PMMC_COMMAND): uint32_t; stdcall;
{Default DMA transfer stop function for SDHCI host controllers}
{Note: Not intended to be called directly by applications, may be used by SDHCI drivers}
begin
 {}
 Result:=SDHCIHostStopDMA(sdhci,command);
end;

{==============================================================================}

procedure sdhci_host_complete_dma(request: PDMA_REQUEST); stdcall; // $IFDEF i386
{Default DMA request completion callback for SDHCI host controllers}
{Note: Not intended to be called directly by applications, may be used by SDHCI drivers}
begin
 {}
 SDHCIHostCompleteDMA(request);
end;

{==============================================================================}

function sdhci_host_setup_card_irq(sdhci: PSDHCI_HOST; enable: LONGBOOL): uint32_t; stdcall;
{Default Card IRQ setup function for SDHCI host controllers}
{Note: Not intended to be called directly by applications, may be used by SDHCI drivers}
begin
 {}
 Result:=SDHCIHostSetupCardIRQ(sdhci,enable);
end;

{==============================================================================}

function sdhci_host_complete_card_irq(sdhci: PSDHCI_HOST): uint32_t; stdcall;
{Default Card IRQ completion function for SDHCI host controllers}
{Note: Not intended to be called directly by applications, may be used by SDHCI drivers}
begin
 {}
 Result:=SDHCIHostCompleteCardIRQ(sdhci);
end;

{==============================================================================}

function sdhci_host_transfer_pio(sdhci: PSDHCI_HOST): uint32_t; stdcall;
{Default PIO transfer function for SDHCI host controllers}
{Note: Not intended to be called directly by applications, may be used by SDHCI drivers}
begin
 {}
 Result:=SDHCIHostTransferPIO(sdhci);
end;

{==============================================================================}

function sdhci_host_transfer_dma(sdhci: PSDHCI_HOST): uint32_t; stdcall;
{Default DMA transfer function for SDHCI host controllers}
{Note: Not intended to be called directly by applications, may be used by SDHCI drivers}
begin
 {}
 Result:=SDHCIHostTransferDMA(sdhci);
end;

{==============================================================================}

function sdhci_host_finish_command(sdhci: PSDHCI_HOST): uint32_t; stdcall;
{Default finish command function for SDHCI host controllers}
{Called by Interrupt Command handler when an SDHCI_INT_RESPONSE is received}
{Note: Not intended to be called directly by applications, may be used by SDHCI drivers}
begin
 {}
 Result:=SDHCIHostFinishCommand(sdhci);
end;

{==============================================================================}

function sdhci_host_finish_data(sdhci: PSDHCI_HOST): uint32_t; stdcall;
{Default finish data function for SDHCI host controllers}
{Called by Interrupt Data handler when data is received}
{Note: Not intended to be called directly by applications, may be used by SDHCI drivers}
begin
 {}
 Result:=SDHCIHostFinishData(sdhci);
end;

{==============================================================================}

function sdhci_host_command_interrupt(sdhci: PSDHCI_HOST; interruptmask: uint32_t; var returnmask: uint32_t): uint32_t; stdcall;
{Default command interrupt processing function for SDHCI host controllers}
{Called by SDHCI controller interrupt handler when a command interrupt is received}
{Note: Not intended to be called directly by applications, may be used by SDHCI drivers}
begin
 {}
 Result:=SDHCIHostCommandInterrupt(sdhci,interruptmask,returnmask);
end;

{==============================================================================}

function sdhci_host_data_interrupt(sdhci: PSDHCI_HOST; interruptmask: uint32_t): uint32_t; stdcall;
{Default data interrupt processing function for SDHCI host controllers}
{Called by SDHCI controller interrupt handler when a data interrupt is received}
{Note: Not intended to be called directly by applications, may be used by SDHCI drivers}
begin
 {}
 Result:=SDHCIHostDataInterrupt(sdhci,interruptmask);
end;

{==============================================================================}

function sdhci_host_start(sdhci: PSDHCI_HOST): uint32_t; stdcall;
{Default host start function for SDHCI host controllers}
{Called automatically to start each registered SDHCI controller when required}
{Note: Not intended to be called directly by applications, may be used by SDHCI drivers}
begin
 {}
 Result:=SDHCIHostStart(sdhci);
end;

{==============================================================================}

function sdhci_host_stop(sdhci: PSDHCI_HOST): uint32_t; stdcall;
{Default host stop function for SDHCI host controllers}
{Called automatically to stop each registered SDHCI controller when required}
{Note: Not intended to be called directly by applications, may be used by SDHCI drivers}
begin
 {}
 Result:=SDHCIHostStop(sdhci);
end;

{==============================================================================}

function sdhci_host_lock(sdhci: PSDHCI_HOST): uint32_t; stdcall;
{Default host lock function for SDHCI host controllers}
{Note: Not intended to be called directly by applications, may be used by SDHCI drivers}
begin
 {}
 Result:=SDHCIHostLock(sdhci);
end;

{==============================================================================}

function sdhci_host_unlock(sdhci: PSDHCI_HOST): uint32_t; stdcall;
{Default host unlock function for SDHCI host controllers}
{Note: Not intended to be called directly by applications, may be used by SDHCI drivers}
begin
 {}
 Result:=SDHCIHostUnlock(sdhci);
end;

{==============================================================================}

function sdhci_host_signal(sdhci: PSDHCI_HOST; semaphore: SEMAPHORE_HANDLE): uint32_t; stdcall;
{Default host semaphore signal function for SDHCI host controllers}
{Note: Not intended to be called directly by applications, may be used by SDHCI drivers}
begin
 {}
 Result:=SDHCIHostSignal(sdhci,semaphore);
end;

{==============================================================================}

function sdhci_host_read_byte(sdhci: PSDHCI_HOST; reg: uint32_t): uint8_t; stdcall;
{Default read byte function for SDHCI host controllers}
{Note: Not intended to be called directly by applications, may be used by SDHCI drivers}
begin
 {}
 Result:=SDHCIHostReadByte(sdhci,reg);
end;

{==============================================================================}

function sdhci_host_read_word(sdhci: PSDHCI_HOST; reg: uint32_t): uint16_t; stdcall;
{Default read word function for SDHCI host controllers}
{Note: Not intended to be called directly by applications, may be used by SDHCI drivers}
begin
 {}
 Result:=SDHCIHostReadWord(sdhci,reg);
end;

{==============================================================================}

function sdhci_host_read_long(sdhci: PSDHCI_HOST; reg: uint32_t): uint32_t; stdcall;
{Default read longword function for SDHCI host controllers}
{Note: Not intended to be called directly by applications, may be used by SDHCI drivers}
begin
 {}
 Result:=SDHCIHostReadLong(sdhci,reg);
end;

{==============================================================================}

procedure sdhci_host_write_byte(sdhci: PSDHCI_HOST; reg: uint32_t; value: uint8_t); stdcall;
{Default write byte function for SDHCI host controllers}
{Note: Not intended to be called directly by applications, may be used by SDHCI drivers}
begin
 {}
 SDHCIHostWriteByte(sdhci,reg,value);
end;

{==============================================================================}

procedure sdhci_host_write_word(sdhci: PSDHCI_HOST; reg: uint32_t; value: uint16_t); stdcall;
{Default write word function for SDHCI host controllers}
{Note: Not intended to be called directly by applications, may be used by SDHCI drivers}
begin
 {}
 SDHCIHostWriteWord(sdhci,reg,value);
end;

{==============================================================================}

procedure sdhci_host_write_long(sdhci: PSDHCI_HOST; reg: uint32_t; value: uint32_t); stdcall;
{Default write longword function for SDHCI host controllers}
{Note: Not intended to be called directly by applications, may be used by SDHCI drivers}
begin
 {}
 SDHCIHostWriteLong(sdhci,reg,value);
end;

{==============================================================================}

function sdhci_host_set_clock_divider(sdhci: PSDHCI_HOST; index: int; divider: uint32_t): uint32_t; stdcall;
{Default set clock divider function for SDHCI host controllers}
{Note: Not intended to be called directly by applications, may be used by SDHCI drivers}
begin
 {}
 Result:=SDHCIHostSetClockDivider(sdhci,index,divider);
end;

{==============================================================================}

function sdhci_host_set_control_register(sdhci: PSDHCI_HOST): uint32_t; stdcall;
{Default set control register function for SDHCI host controllers}
{Note: Not intended to be called directly by applications, may be used by SDHCI drivers}
begin
 {}
 Result:=SDHCIHostSetControlRegister(sdhci);
end;

{==============================================================================}

function sdhci_host_get_adma_address(sdhci: PSDHCI_HOST): SIZE_T; stdcall;
{Get the DMA address of the ADMA table for the current request}
{Note: Not intended to be called directly by applications, may be used by SDHCI drivers}
begin
 {}
 Result:=SDHCIHostGetADMAAddress(sdhci);
end;

{==============================================================================}

procedure sdhci_host_set_adma_address(sdhci: PSDHCI_HOST; address: SIZE_T); stdcall;
{Set the address of the transfer data in the Advanced DMA (ADMA) registers}
{Note: Not intended to be called directly by applications, may be used by SDHCI drivers}
begin
 {}
 SDHCIHostSetADMAAddress(sdhci,address);
end;

{==============================================================================}

function sdhci_host_get_sdma_address(sdhci: PSDHCI_HOST; command: PMMC_COMMAND): SIZE_T; stdcall;
{Get the DMA address of the transfer data for the current request}
{Note: Not intended to be called directly by applications, may be used by SDHCI drivers}
begin
 {}
 Result:=SDHCIHostGetSDMAAddress(sdhci,command);
end;

{==============================================================================}

procedure sdhci_host_set_sdma_address(sdhci: PSDHCI_HOST; address: SIZE_T); stdcall;
{Set the address of the transfer data in the Simple DMA (SDMA) register}
{Note: Not intended to be called directly by applications, may be used by SDHCI drivers}
begin
 {}
 SDHCIHostSetSDMAAddress(sdhci,address);
end;

{==============================================================================}

procedure sdhci_host_write_adma_descriptor(sdhci: PSDHCI_HOST; var descriptor: PVOID; command, len: uint16_t; address: SIZE_T); stdcall;
{Write the properties to an ADMA descriptor}
{Note: Not intended to be called directly by applications, may be used by SDHCI drivers}
begin
 {}
 SDHCIHostWriteADMADescriptor(sdhci,descriptor,command,len,address);
end;

{==============================================================================}

function sdhci_host_create: PSDHCI_HOST; stdcall;
{Create a new SDHCI entry}
{Return: Pointer to new SDHCI entry or nil if SDHCI could not be created}
begin
 {}
 Result:=SDHCIHostCreate;
end;

{==============================================================================}

function sdhci_host_create_ex(size: uint32_t): PSDHCI_HOST; stdcall;
{Create a new SDHCI entry}
{Size: Size in bytes to allocate for new SDHCI (Including the SDHCI entry)}
{Return: Pointer to new SDHCI entry or nil if SDHCI could not be created}
begin
 {}
 Result:=SDHCIHostCreateEx(size);
end;

{==============================================================================}

function sdhci_host_destroy(sdhci: PSDHCI_HOST): uint32_t; stdcall;
{Destroy an existing SDHCI entry}
begin
 {}
 Result:=SDHCIHostDestroy(sdhci);
end;

{==============================================================================}

function sdhci_host_register(sdhci: PSDHCI_HOST): uint32_t; stdcall;
{Register a new SDHCI in the SDHCI table}
begin
 {}
 Result:=SDHCIHostRegister(sdhci);
end;

{==============================================================================}

function sdhci_host_deregister(sdhci: PSDHCI_HOST): uint32_t; stdcall;
{Deregister a SDHCI from the SDHCI table}
begin
 {}
 Result:=SDHCIHostDeregister(sdhci);
end;

{==============================================================================}

function sdhci_host_find(sdhciid: uint32_t): PSDHCI_HOST; stdcall;
begin
 {}
 Result:=SDHCIHostFind(sdhciid);
end;

{==============================================================================}

function sdhci_host_enumerate(callback: sdhci_enumerate_cb; data: PVOID): uint32_t; stdcall;
begin
 {}
 Result:=SDHCIHostEnumerate(callback,data);
end;

{==============================================================================}

function sdhci_host_notification(sdhci: PSDHCI_HOST; callback: sdhci_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=SDHCIHostNotification(sdhci,callback,data,notification,flags);
end;

{==============================================================================}
{MMC Helper Functions}
function mmc_get_count: uint32_t; stdcall;
{Get the current MMC count}
begin
 {}
 Result:=MMCGetCount;
end;

{==============================================================================}

function mmc_device_check(mmc: PMMC_DEVICE): PMMC_DEVICE; stdcall;
{Check if the supplied MMC is in the MMC table}
begin
 {}
 Result:=MMCDeviceCheck(mmc);
end;

{==============================================================================}

function mmc_is_sd(mmc: PMMC_DEVICE): BOOL; stdcall;
begin
 {}
 Result:=MMCIsSD(mmc);
end;

{==============================================================================}

function mmc_is_sdio(mmc: PMMC_DEVICE): BOOL; stdcall;
begin
 {}
 Result:=MMCIsSDIO(mmc);
end;

{==============================================================================}

function mmc_get_sdhci(mmc: PMMC_DEVICE): PSDHCI_HOST; stdcall;
begin
 {}
 Result:=MMCGetSDHCI(mmc);
end;

{==============================================================================}

function mmc_get_cid_value(mmc: PMMC_DEVICE; version, value: uint32_t): uint32_t; stdcall;
{Extract a CID field value from the 128 bit Card Identification register}
begin
 {}
 Result:=MMCGetCIDValue(mmc,version,value);
end;

{==============================================================================}

function mmc_get_csd_value(mmc: PMMC_DEVICE; value: uint32_t): uint32_t; stdcall;
{Extract a CSD field value from the 128 bit Card Specific register}
begin
 {}
 Result:=MMCGetCSDValue(mmc,value);
end;

{==============================================================================}

function mmc_extract_bits(buffer: PVOID; start, size: uint32_t): uint32_t; stdcall;
{Start is the starting bit to extract, Size is the number of bits to extract}
{Start is the LSB so to extract 8 bits from 127 to 120 then Start would be 120 and Size would be 8}
begin
 {}
 Result:=MMCExtractBits(buffer,start,size);
end;

{==============================================================================}

function mmc_extract_bits_ex(buffer: PVOID; length, start, size: uint32_t): uint32_t; stdcall;
{Length is the size of the buffer in LongWords, Start is the starting bit to extract, Size is the number of bits to extract}
{Start is the LSB so to extract 8 bits from 127 to 120 then Start would be 120 and Size would be 8}
{For a 128 bit buffer (16 bytes) Length would be 4}
{For a 512 bit buffer (64 bytes) Length would be 16}
begin
 {}
 Result:=MMCExtractBitsEx(buffer,length,start,size);
end;

{==============================================================================}

function mmc_is_multi_command(command: uint16_t): BOOL; stdcall;
begin
 {}
 Result:=MMCIsMultiCommand(command);
end;

{==============================================================================}

function mmc_is_non_removable(mmc: PMMC_DEVICE): BOOL; stdcall;
begin
 {}
 Result:=MMCIsNonRemovable(mmc);
end;

{==============================================================================}

function mmc_has_extended_csd(mmc: PMMC_DEVICE): BOOL; stdcall;
begin
 {}
 Result:=MMCHasExtendedCSD(mmc);
end;

{==============================================================================}

function mmc_has_set_block_count(mmc: PMMC_DEVICE): BOOL; stdcall;
begin
 {}
 Result:=MMCHasSetBlockCount(mmc);
end;

{==============================================================================}

function mmc_has_auto_block_count(mmc: PMMC_DEVICE): BOOL; stdcall;
begin
 {}
 Result:=MMCHasAutoBlockCount(mmc);
end;

{==============================================================================}

function mmc_has_auto_command_stop(mmc: PMMC_DEVICE): BOOL; stdcall;
begin
 {}
 Result:=MMCHasAutoCommandStop(mmc);
end;

{==============================================================================}

function mmc_status_to_string(status: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Translates an MMC status code into a string describing it}
begin
 {}
 Result:=APIStringToPCharBuffer(MMCStatusToString(status),_string,len);
end;

{==============================================================================}

function mmc_version_to_string(version: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Translates an MMC version into a string}
begin
 {}
 Result:=APIStringToPCharBuffer(MMCVersionToString(version),_string,len);
end;

{==============================================================================}

function mmc_timing_to_string(timing: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Translates an MMC timing into a string}
begin
 {}
 Result:=APIStringToPCharBuffer(MMCTimingToString(timing),_string,len);
end;

{==============================================================================}

function mmc_bus_width_to_string(buswidth: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Translates an MMC bus width into a string}
begin
 {}
 Result:=APIStringToPCharBuffer(MMCBusWidthToString(buswidth),_string,len);
end;

{==============================================================================}

function mmc_driver_type_to_string(drivertype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Translates an MMC driver type into a string}
begin
 {}
 Result:=APIStringToPCharBuffer(MMCDriverTypeToString(drivertype),_string,len);
end;

{==============================================================================}

function mmc_signal_voltage_to_string(signalvoltage: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Translates an MMC signal voltage into a string}
begin
 {}
 Result:=APIStringToPCharBuffer(MMCSignalVoltageToString(signalvoltage),_string,len);
end;

{==============================================================================}

function mmc_device_type_to_string(mmctype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(MMCDeviceTypeToString(mmctype),_string,len);
end;

{==============================================================================}

function mmc_device_state_to_string(mmcstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(MMCDeviceStateToString(mmcstate),_string,len);
end;

{==============================================================================}

function mmc_device_state_to_notification(state: uint32_t): uint32_t; stdcall;
{Convert a Device state value into the notification code for device notifications}
begin
 {}
 Result:=MMCDeviceStateToNotification(state);
end;

{==============================================================================}
{SD Helper Functions}
function sd_get_max_clock(mmc: PMMC_DEVICE): uint32_t; stdcall;
{Determine the Maximum Clock (DTR) for the current card}
begin
 {}
 Result:=SDGetMaxClock(mmc);
end;

{==============================================================================}

function sd_get_cid_value(mmc: PMMC_DEVICE; value: uint32_t): uint32_t; stdcall;
{Extract a CID field value from the 128 bit Card Identification register}
begin
 {}
 Result:=SDGetCIDValue(mmc,value);
end;

{==============================================================================}

function sd_get_csd_value(mmc: PMMC_DEVICE; version, value: uint32_t): uint32_t; stdcall;
{Extract a CSD field value from the 128 bit Card Specific register}
begin
 {}
 Result:=SDGetCSDValue(mmc,version,value);
end;

{==============================================================================}

function sd_get_scr_value(mmc: PMMC_DEVICE; value: uint32_t): uint32_t; stdcall;
{Extract an SCR field value from the 64 bit SD Configuration register}
begin
 {}
 Result:=SDGetSCRValue(mmc,value);
end;

{==============================================================================}

function sd_get_ssr_value(mmc: PMMC_DEVICE; value: uint32_t): uint32_t; stdcall;
{Extract an SCR field value from the 512 bit SD Status register}
begin
 {}
 Result:=SDGetSSRValue(mmc,value);
end;

{==============================================================================}

function sd_get_switch_value(mmc: PMMC_DEVICE; value: uint32_t): uint32_t; stdcall;
{Extract a Switch field value from the 512 bit SD Switch status}
begin
 {}
 Result:=SDGetSwitchValue(mmc,value);
end;

{==============================================================================}

function sd_version_to_string(version: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Translates an SD version into a string}
begin
 {}
 Result:=APIStringToPCharBuffer(SDVersionToString(version),_string,len);
end;

{==============================================================================}

function sd_bus_width_to_string(buswidth: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Translates an SD bus width into a string}
begin
 {}
 Result:=APIStringToPCharBuffer(SDBusWidthToString(buswidth),_string,len);
end;

{==============================================================================}
{SDIO Helper Functions}
function sdio_driver_get_count: uint32_t; stdcall;
{Get the current SDIO driver count}
begin
 {}
 Result:=SDIODriverGetCount;
end;

{==============================================================================}

function sdio_driver_check(driver: PSDIO_DRIVER): PSDIO_DRIVER; stdcall;
{Check if the supplied SDIO Driver is in the driver table}
begin
 {}
 Result:=SDIODriverCheck(driver);
end;

{==============================================================================}

function sdio_device_get_max_clock(mmc: PMMC_DEVICE): uint32_t; stdcall;
{Determine the Maximum Clock (DTR) for the current SDIO device}
begin
 {}
 Result:=SDIODeviceGetMaxClock(mmc);
end;

{==============================================================================}

function sdio_function_get_mmc(func: PSDIO_FUNCTION): PMMC_DEVICE; stdcall;
begin
 {}
 Result:=SDIOFunctionGetMMC(func);
end;

{==============================================================================}

function sdio_function_get_sdhci(func: PSDIO_FUNCTION): PSDHCI_HOST; stdcall;
begin
 {}
 Result:=SDIOFunctionGetSDHCI(func);
end;

{==============================================================================}

function sdio_version_to_string(version: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Translates an SDIO version into a string}
begin
 {}
 Result:=APIStringToPCharBuffer(SDIOVersionToString(version),_string,len);
end;

{==============================================================================}

function sdio_function_state_to_string(sdiostate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(SDIOFunctionStateToString(sdiostate),_string,len);
end;

{==============================================================================}

function sdio_function_status_to_string(sdiostatus: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(SDIOFunctionStatusToString(sdiostatus),_string,len);
end;

{==============================================================================}

function sdio_function_state_to_notification(state: uint32_t): uint32_t; stdcall;
{Convert a Device state value into the notification code for device notifications}
begin
 {}
 Result:=SDIOFunctionStateToNotification(state);
end;

{==============================================================================}

function sdio_function_status_to_notification(status: uint32_t): uint32_t; stdcall;
{Convert a Device status value into the notification code for device notifications}
begin
 {}
 Result:=SDIOFunctionStatusToNotification(status);
end;

{==============================================================================}
{SDHCI Helper Functions}
function sdhci_get_count: uint32_t; stdcall;
{Get the current SDHCI count}
begin
 {}
 Result:=SDHCIGetCount;
end;

{==============================================================================}

function sdhci_host_check(sdhci: PSDHCI_HOST): PSDHCI_HOST; stdcall;
{Check if the supplied SDHCI is in the SDHCI table}
begin
 {}
 Result:=SDHCIHostCheck(sdhci);
end;

{==============================================================================}

function sdhci_is_spi(sdhci: PSDHCI_HOST): BOOL; stdcall;
begin
 {}
 Result:=SDHCIIsSPI(sdhci);
end;

{==============================================================================}

function sdhci_has_dma(sdhci: PSDHCI_HOST): BOOL; stdcall;
begin
 {}
 Result:=SDHCIHasDMA(sdhci);
end;

{==============================================================================}

function sdhci_has_cmd23(sdhci: PSDHCI_HOST): BOOL; stdcall;
begin
 {}
 Result:=SDHCIHasCMD23(sdhci);
end;

{==============================================================================}

function sdhci_auto_cmd12(sdhci: PSDHCI_HOST): BOOL; stdcall;
begin
 {}
 Result:=SDHCIAutoCMD12(sdhci);
end;

{==============================================================================}

function sdhci_auto_cmd23(sdhci: PSDHCI_HOST): BOOL; stdcall;
begin
 {}
 Result:=SDHCIAutoCMD23(sdhci);
end;

{==============================================================================}

function sdhci_get_version(sdhci: PSDHCI_HOST): uint16_t; stdcall;
begin
 {}
 Result:=SDHCIGetVersion(sdhci);
end;

{==============================================================================}

function sdhci_get_command(command: uint16_t): uint16_t; stdcall;
begin
 {}
 Result:=SDHCIGetCommand(command);
end;

{==============================================================================}

function sdhci_make_command(command, flags: uint16_t): uint16_t; stdcall;
begin
 {}
 Result:=SDHCIMakeCommand(command,flags);
end;

{==============================================================================}

function sdhci_make_block_size(dma, blocksize: uint16_t): uint16_t; stdcall;
begin
 {}
 Result:=SDHCIMakeBlockSize(dma,blocksize);
end;

{==============================================================================}

function sdhci_version_to_string(version: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Translate an SDHCI version into a string}
begin
 {}
 Result:=APIStringToPCharBuffer(SDHCIVersionToString(version),_string,len);
end;

{==============================================================================}

function sdhci_power_to_string(power: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Translate an SDHCI power value into a string}
begin
 {}
 Result:=APIStringToPCharBuffer(SDHCIPowerToString(power),_string,len);
end;

{==============================================================================}

function sdhci_device_type_to_string(sdhcitype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(SDHCIDeviceTypeToString(sdhcitype),_string,len);
end;

{==============================================================================}

function sdhci_host_type_to_string(sdhcitype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(SDHCIHostTypeToString(sdhcitype),_string,len);
end;

{==============================================================================}

function sdhci_device_state_to_string(sdhcistate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(SDHCIDeviceStateToString(sdhcistate),_string,len);
end;

{==============================================================================}

function sdhci_host_state_to_string(sdhcistate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(SDHCIHostStateToString(sdhcistate),_string,len);
end;

{==============================================================================}

function sdhci_host_state_to_notification(state: uint32_t): uint32_t; stdcall;
{Convert a Host state value into the notification code for device notifications}
begin
 {}
 Result:=SDHCIHostStateToNotification(state);
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{SPI Functions}
{$IFDEF API_EXPORT_SPI}
function spi_device_start(spi: PSPI_DEVICE; mode, clockrate, clockphase, clockpolarity: uint32_t): uint32_t; stdcall;
{Start the specified SPI device ready for writing and reading}
{SPI: The SPI device to start}
{Mode: The device mode to set (eg SPI_MODE_4WIRE)}
{ClockRate: The clock rate to set for the device}
{ClockPhase: The clock phase to set (eg SPI_CLOCK_PHASE_LOW)}
{ClockPolarity: The clock polarity to set (eg SPI_CLOCK_POLARITY_LOW)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SPIDeviceStart(spi,mode,clockrate,clockphase,clockpolarity);
end;

{==============================================================================}

function spi_device_stop(spi: PSPI_DEVICE): uint32_t; stdcall;
{Stop the specified SPI device and terminate writing and reading}
{SPI: The SPI device to stop}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SPIDeviceStop(spi);
end;

{==============================================================================}

function spi_device_read(spi: PSPI_DEVICE; chipselect: uint16_t; dest: PVOID; size, flags: uint32_t; var count: uint32_t): uint32_t; stdcall;
{Read data from the specified SPI device}
{Because SPI writes and then reads for each byte, dummy data will be written for each byte to be read}
{SPI: The SPI device to read from}
{ChipSelect: The chip select for the slave to read from (eg SPI_CS_0)}
{Dest: Pointer to a buffer to receive the data}
{Size: The size of the buffer}
{Flags: The flags for this transfer (eg SPI_TRANSFER_DMA)}
{Count: The number of bytes read on return}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SPIDeviceRead(spi,chipselect,dest,size,flags,count);
end;

{==============================================================================}

function spi_device_write(spi: PSPI_DEVICE; chipselect: uint16_t; source: PVOID; size, flags: uint32_t; var count: uint32_t): uint32_t; stdcall;
{Write data to the specified SPI device}
{Because SPI writes and then reads for each byte, received data will be discarded for each byte written}
{SPI: The SPI device to write to}
{ChipSelect: The chip select for the slave to write to (eg SPI_CS_0)}
{Source: Pointer to a buffer of data to transmit}
{Size: The size of the buffer}
{Flags: The flags for this transfer (eg SPI_TRANSFER_DMA)}
{Count: The number of bytes written on return}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SPIDeviceWrite(spi,chipselect,source,size,flags,count);
end;

{==============================================================================}

function spi_device_write_read(spi: PSPI_DEVICE; chipselect: uint16_t; source, dest: PVOID; size, flags: uint32_t; var count: uint32_t): uint32_t; stdcall;
{Write data to and Read data from the specified SPI device in one operation}
{Because SPI writes and then reads for each byte, both the source and dest buffers must be the same size}
{SPI: The SPI device to write to and read from}
{ChipSelect: The chip select for the slave to write to and read from (eg SPI_CS_0)}
{Source: Pointer to a buffer of data to transmit}
{Dest: Pointer to a buffer to receive the data}
{Size: The size of the buffer}
{Flags: The flags for this transfer (eg SPI_TRANSFER_DMA)}
{Count: The number of bytes written and read on return}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SPIDeviceWriteRead(spi,chipselect,source,dest,size,flags,count);
end;

{==============================================================================}

function spi_device_get_mode(spi: PSPI_DEVICE): uint32_t; stdcall;
{Get the device mode of the specified SPI device}
{SPI: The SPI device to get device mode from}
{Return: The device mode or SPI_MODE_UNKNOWN on failure}
begin
 {}
 Result:=SPIDeviceGetMode(spi);
end;

{==============================================================================}

function spi_device_set_mode(spi: PSPI_DEVICE; mode: uint32_t): uint32_t; stdcall;
{Set the device mode for the specified SPI device}
{SPI: The SPI device to set device mode for}
{Mode: The device mode to set (eg SPI_MODE_4WIRE)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SPIDeviceSetMode(spi,mode);
end;

{==============================================================================}

function spi_device_get_clock_rate(spi: PSPI_DEVICE; chipselect: uint16_t): uint32_t; stdcall;
{Get the clock rate of the specified SPI device}
{SPI: The SPI device to get clock rate from}
{ChipSelect: The chip select number to get clock rate from (SPI_CS_NONE for default)}
{Return: The clock rate in Hz or 0 on failure}
begin
 {}
 Result:=SPIDeviceGetClockRate(spi,chipselect);
end;

{==============================================================================}

function spi_device_set_clock_rate(spi: PSPI_DEVICE; chipselect: uint16_t; clockrate: uint32_t): uint32_t; stdcall;
{Set the clock rate for the specified SPI device}
{SPI: The SPI device to set clock rate for}
{ChipSelect: The chip select number to set clock rate for (SPI_CS_NONE for default)}
{ClockRate: The clock rate to set in Hz}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SPIDeviceSetClockRate(spi,chipselect,clockrate);
end;

{==============================================================================}

function spi_device_get_clock_phase(spi: PSPI_DEVICE): uint32_t; stdcall;
{Get the clock phase of the specified SPI device}
{SPI: The SPI device to get clock phase from}
{Return: The clock phase or SPI_CLOCK_PHASE_UNKNOWN on failure}
begin
 {}
 Result:=SPIDeviceGetClockPhase(spi);
end;

{==============================================================================}

function spi_device_set_clock_phase(spi: PSPI_DEVICE; clockphase: uint32_t): uint32_t; stdcall;
{Set the clock phase for the specified SPI device}
{SPI: The SPI device to set clock phase for}
{ClockPhase: The clock phase to set (eg SPI_CLOCK_PHASE_LOW)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SPIDeviceSetClockPhase(spi,clockphase);
end;

{==============================================================================}

function spi_device_get_clock_polarity(spi: PSPI_DEVICE): uint32_t; stdcall;
{Get the clock polarity of the specified SPI device}
{SPI: The SPI device to get clock polarity from}
{Return: The clock polarity or SPI_CLOCK_POLARITY_UNKNOWN on failure}
begin
 {}
 Result:=SPIDeviceGetClockPolarity(spi);
end;

{==============================================================================}

function spi_device_set_clock_polarity(spi: PSPI_DEVICE; clockpolarity: uint32_t): uint32_t; stdcall;
{Set the clock polarity for the specified SPI device}
{SPI: The SPI device to set clock polarity for}
{ClockPolarity: The clock polarity to set (eg SPI_CLOCK_POLARITY_LOW)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SPIDeviceSetClockPolarity(spi,clockpolarity);
end;

{==============================================================================}

function spi_device_get_select_polarity(spi: PSPI_DEVICE; chipselect: uint16_t): uint32_t; stdcall;
{Get the chip select polarity of the specified SPI device}
{SPI: The SPI device to get chip select polarity from}
{ChipSelect: The chip select number to get polarity from (SPI_CS_NONE for default)}
{Return: The chip select polarity or SPI_CS_POLARITY_UNKNOWN on failure}
begin
 {}
 Result:=SPIDeviceGetSelectPolarity(spi,chipselect);
end;

{==============================================================================}

function spi_device_set_select_polarity(spi: PSPI_DEVICE; chipselect: uint16_t; selectpolarity: uint32_t): uint32_t; stdcall;
{Set the chip select polarity for the specified SPI device}
{SPI: The SPI device to set chip select polarity for}
{ChipSelect: The chip select number to set polarity for (SPI_CS_NONE for default)}
{SelectPolarity: The chip select polarity to set (eg SPI_CS_POLARITY_LOW)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SPIDeviceSetSelectPolarity(spi,chipselect,selectpolarity);
end;

{==============================================================================}

function spi_device_get_byte_delay(spi: PSPI_DEVICE): uint32_t; stdcall;
{Get the delay between bytes written for the specified SPI device}
{SPI: The SPI device to get the byte delay from}
{Return: The byte delay in microseconds, 0 if not set or on failure}
begin
 {}
 Result:=SPIDeviceGetByteDelay(spi);
end;

{==============================================================================}

function spi_device_set_byte_delay(spi: PSPI_DEVICE; delay: uint32_t): uint32_t; stdcall;
{Set the delay between bytes written for the specified SPI device}
{SPI: The SPI device to set byte delay for}
{Delay: The byte delay to set in microseconds}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SPIDeviceSetByteDelay(spi,delay);
end;

{==============================================================================}

function spi_device_properties(spi: PSPI_DEVICE; properties: PSPI_PROPERTIES): uint32_t; stdcall;
{Get the properties for the specified SPI device}
{SPI: The SPI device to get properties from}
{Properties: Pointer to a TSPIProperties structure to fill in}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Replaced by SPIDeviceGetProperties for consistency}
begin
 {}
 Result:=SPIDeviceProperties(spi,properties);
end;

{==============================================================================}

function spi_device_get_properties(spi: PSPI_DEVICE; properties: PSPI_PROPERTIES): uint32_t; stdcall;
{Get the properties for the specified SPI device}
{SPI: The SPI device to get properties from}
{Properties: Pointer to a TSPIProperties structure to fill in}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SPIDeviceGetProperties(spi,properties);
end;

{==============================================================================}

function spi_device_create: PSPI_DEVICE; stdcall;
{Create a new SPI entry}
{Return: Pointer to new SPI entry or nil if SPI could not be created}
begin
 {}
 Result:=SPIDeviceCreate;
end;

{==============================================================================}

function spi_device_create_ex(size: uint32_t): PSPI_DEVICE; stdcall;
{Create a new SPI entry}
{Size: Size in bytes to allocate for new SPI (Including the SPI entry)}
{Return: Pointer to new SPI entry or nil if SPI could not be created}
begin
 {}
 Result:=SPIDeviceCreateEx(size);
end;

{==============================================================================}

function spi_device_destroy(spi: PSPI_DEVICE): uint32_t; stdcall;
{Destroy an existing SPI entry}
{SPI: The SPI device to destroy}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SPIDeviceDestroy(spi);
end;

{==============================================================================}

function spi_device_register(spi: PSPI_DEVICE): uint32_t; stdcall;
{Register a new SPI in the SPI table}
{SPI: The SPI device to register}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SPIDeviceRegister(spi);
end;

{==============================================================================}

function spi_device_deregister(spi: PSPI_DEVICE): uint32_t; stdcall;
{Deregister an SPI from the SPI table}
{SPI: The SPI device to deregister}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SPIDeviceDeregister(spi);
end;

{==============================================================================}

function spi_device_find(spiid: uint32_t): PSPI_DEVICE; stdcall;
{Find an SPI device by ID in the SPI table}
{SPIId: The ID number of the SPI device to find}
{Return: Pointer to SPI device entry or nil if not found}
begin
 {}
 Result:=SPIDeviceFind(spiid);
end;

{==============================================================================}

function spi_device_find_by_name(const name: PCHAR): PSPI_DEVICE; stdcall;
{Find an SPI device by name in the device table}
{Name: The name of the SPI device to find (eg SPI0)}
{Return: Pointer to SPI device entry or nil if not found}
begin
 {}
 Result:=SPIDeviceFindByName(String(name));
end;

{==============================================================================}

function spi_device_find_by_description(const description: PCHAR): PSPI_DEVICE; stdcall;
{Find an SPI device by description in the device table}
{Description: The description of the SPI to find (eg BCM2837 SPI0 Master)}
{Return: Pointer to SPI device entry or nil if not found}
begin
 {}
 Result:=SPIDeviceFindByDescription(String(description));
end;

{==============================================================================}

function spi_device_enumerate(callback: spi_enumerate_cb; data: PVOID): uint32_t; stdcall;
{Enumerate all SPI devices in the SPI table}
{Callback: The callback function to call for each SPI device in the table}
{Data: A private data pointer to pass to callback for each SPI device in the table}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SPIDeviceEnumerate(callback,data);
end;

{==============================================================================}

function spi_device_notification(spi: PSPI_DEVICE; callback: spi_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall;
{Register a notification for SPI device changes}
{Device: The SPI device to notify changes for (Optional, pass nil for all SPI devices)}
{Callback: The function to call when a notification event occurs}
{Data: A private data pointer to pass to callback when a notification event occurs}
{Notification: The events to register for notification of (eg DEVICE_NOTIFICATION_REGISTER)}
{Flags: The flags to control the notification (eg NOTIFIER_FLAG_WORKER)}
begin
 {}
 Result:=SPIDeviceNotification(spi,callback,data,notification,flags);
end;

{==============================================================================}
{SPI Helper Functions}
function spi_get_count: uint32_t; stdcall;
{Get the current SPI count}
begin
 {}
 Result:=SPIGetCount;
end;

{==============================================================================}

function spi_device_get_default: PSPI_DEVICE; stdcall;
{Get the current default SPI device}
begin
 {}
 Result:=SPIDeviceGetDefault;
end;

{==============================================================================}

function spi_device_set_default(spi: PSPI_DEVICE): uint32_t; stdcall;
{Set the current default SPI device}
begin
 {}
 Result:=SPIDeviceSetDefault(spi);
end;

{==============================================================================}

function spi_device_check(spi: PSPI_DEVICE): PSPI_DEVICE; stdcall;
{Check if the supplied SPI is in the SPI table}
begin
 {}
 Result:=SPIDeviceCheck(spi);
end;

{==============================================================================}

function spi_type_to_string(spitype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Convert an SPI type value to a string}
begin
 {}
 Result:=APIStringToPCharBuffer(SPITypeToString(spitype),_string,len);
end;

{==============================================================================}

function spi_state_to_string(spistate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Convert an SPI state value to a string}
begin
 {}
 Result:=APIStringToPCharBuffer(SPIStateToString(spistate),_string,len);
end;

{==============================================================================}

function spi_chip_select_to_string(chipselect: uint16_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(SPIChipSelectToString(chipselect),_string,len);
end;

{==============================================================================}

function spi_mode_to_string(mode: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(SPIModeToString(mode),_string,len);
end;

{==============================================================================}

function spi_clock_phase_to_string(phase: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(SPIClockPhaseToString(phase),_string,len);
end;

{==============================================================================}

function spi_clock_polarity_to_string(polarity: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(SPIClockPolarityToString(polarity),_string,len);
end;

{==============================================================================}

function spi_select_polarity_to_string(polarity: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(SPISelectPolarityToString(polarity),_string,len);
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{I2C Functions}
{$IFDEF API_EXPORT_I2C}
function i2c_device_start(i2c: PI2C_DEVICE; rate: uint32_t): uint32_t; stdcall;
{Start the specified I2C device ready for reading and writing}
{I2C: The I2C device to start}
{Rate: The clock rate to set for the device (0 to use the default rate)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=I2CDeviceStart(i2c,rate);
end;

{==============================================================================}

function i2c_device_stop(i2c: PI2C_DEVICE): uint32_t; stdcall;
{Stop the specified I2C device and terminate reading and writing}
{I2C: The I2C device to stop}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=I2CDeviceStop(i2c);
end;

{==============================================================================}

function i2c_device_read(i2c: PI2C_DEVICE; address: uint16_t; buffer: PVOID; size: uint32_t; var count: uint32_t): uint32_t; stdcall;
{Read data from the specified I2C device}
{I2C: The I2C device to read from}
{Address: The slave address to read from (I2C_ADDRESS_INVALID to use the current address)}
{Buffer: Pointer to a buffer to receive the data}
{Size: The size of the buffer}
{Count: The number of bytes read on return}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=I2CDeviceRead(i2c,address,buffer,size,count);
end;

{==============================================================================}

function i2c_device_write(i2c: PI2C_DEVICE; address: uint16_t; buffer: PVOID; size: uint32_t; var count: uint32_t): uint32_t; stdcall;
{Write data to the specified I2C device}
{I2C: The I2C device to write to}
{Address: The slave address to write to (I2C_ADDRESS_INVALID to use the current address)}
{Buffer: Pointer to a buffer of data to transmit}
{Size: The size of the buffer}
{Count: The number of bytes written on return}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=I2CDeviceWrite(i2c,address,buffer,size,count);
end;

{==============================================================================}

function i2c_device_write_read(i2c: PI2C_DEVICE; address: uint16_t; initial: PVOID; len: uint32_t; data: PVOID; size: uint32_t; var count: uint32_t): uint32_t; stdcall;
{Write data to and Read data from the specified I2C device in one operation}
{Useful for devices that require a register address specified before a read (eg EEPROM devices)}
{I2C: The I2C device to write to and read from}
{Address: The slave address to write to (I2C_ADDRESS_INVALID to use the current address)}
{Initial: Pointer to the initial buffer to transmit}
{Len: The size of the initial buffer}
{Data: Pointer to a buffer to receive the data}
{Size: The size of the data buffer}
{Count: The number of bytes read on return}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=I2CDeviceWriteRead(i2c,address,initial,len,data,size,count);
end;

{==============================================================================}

function i2c_device_write_write(i2c: PI2C_DEVICE; address: uint16_t; initial: PVOID; len: uint32_t; data: PVOID; size: uint32_t; var count: uint32_t): uint32_t; stdcall;
{Write 2 data blocks to the specified I2C device in one operation}
{Useful for devices that require a register address specified before a write (eg EEPROM devices)}
{I2C: The I2C device to write to}
{Address: The slave address to write to (I2C_ADDRESS_INVALID to use the current address)}
{Initial: Pointer to the initial buffer to transmit}
{Len: The size of the initial buffer}
{Data: Pointer to a buffer of data to transmit}
{Size: The size of the data buffer}
{Count: The number of bytes of data written on return}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=I2CDeviceWriteWrite(i2c,address,initial,len,data,size,count);
end;

{==============================================================================}

function i2c_device_get_rate(i2c: PI2C_DEVICE): uint32_t; stdcall;
{Get the clock rate of the specified I2C device}
{I2C: The I2C device to get the clock rate from}
{Return: The clock rate in Hz or 0 on failure}
begin
 {}
 Result:=I2CDeviceGetRate(i2c);
end;

{==============================================================================}

function i2c_device_set_rate(i2c: PI2C_DEVICE; rate: uint32_t): uint32_t; stdcall;
{Set the clock rate for the specified I2C device}
{I2C: The I2C device to set the clock rate for}
{Rate: The clock rate to set in Hz}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=I2CDeviceSetRate(i2c,rate);
end;

{==============================================================================}

function i2c_device_get_address(i2c: PI2C_DEVICE): uint16_t; stdcall;
{Get the slave address for the specified I2C device}
{I2C: The I2C device to get the slave address from}
{Return: The slave address or I2C_ADDRESS_INVALID on failure}
begin
 {}
 Result:=I2CDeviceGetAddress(i2c);
end;

{==============================================================================}

function i2c_device_set_address(i2c: PI2C_DEVICE; address: uint16_t): uint32_t; stdcall;
{Set the slave address for the specified I2C device}
{I2C: The I2C device to set the slave address for}
{Address: The slave address to set}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=I2CDeviceSetAddress(i2c,address);
end;

{==============================================================================}

function i2c_device_properties(i2c: PI2C_DEVICE; properties: PI2C_PROPERTIES): uint32_t; stdcall;
{Get the properties for the specified I2C device}
{I2C: The I2C device to get properties from}
{Properties: Pointer to a TI2CProperties structure to fill in}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Replaced by I2CDeviceGetProperties for consistency}
begin
 {}
 Result:=I2CDeviceProperties(i2c,properties);
end;

{==============================================================================}

function i2c_device_get_properties(i2c: PI2C_DEVICE; properties: PI2C_PROPERTIES): uint32_t; stdcall;
{Get the properties for the specified I2C device}
{I2C: The I2C device to get properties from}
{Properties: Pointer to a TI2CProperties structure to fill in}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=I2CDeviceGetProperties(i2c,properties);
end;

{==============================================================================}

function i2c_device_create: PI2C_DEVICE; stdcall;
{Create a new I2C entry}
{Return: Pointer to new I2C entry or nil if I2C could not be created}
begin
 {}
 Result:=I2CDeviceCreate;
end;

{==============================================================================}

function i2c_device_create_ex(size: uint32_t): PI2C_DEVICE; stdcall;
{Create a new I2C entry}
{Size: Size in bytes to allocate for new I2C (Including the I2C entry)}
{Return: Pointer to new I2C entry or nil if I2C could not be created}
begin
 {}
 Result:=I2CDeviceCreateEx(size);
end;

{==============================================================================}

function i2c_device_destroy(i2c: PI2C_DEVICE): uint32_t; stdcall;
{Destroy an existing I2C entry}
{I2C: The I2C device to destroy}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=I2CDeviceDestroy(i2c);
end;

{==============================================================================}

function i2c_device_register(i2c: PI2C_DEVICE): uint32_t; stdcall;
{Register a new I2C in the I2C table}
{I2C: The I2C device to register}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=I2CDeviceRegister(i2c);
end;

{==============================================================================}

function i2c_device_deregister(i2c: PI2C_DEVICE): uint32_t; stdcall;
{Deregister an I2C from the I2C table}
{I2C: The I2C device to deregister}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=I2CDeviceDeregister(i2c);
end;

{==============================================================================}

function i2c_device_find(i2cid: uint32_t): PI2C_DEVICE; stdcall;
{Find an I2C device by ID in the I2C table}
{I2CId: The ID number of the I2C device to find}
{Return: Pointer to I2C device entry or nil if not found}
begin
 {}
 Result:=I2CDeviceFind(i2cid);
end;

{==============================================================================}

function i2c_device_find_by_name(const name: PCHAR): PI2C_DEVICE; stdcall;
{Find an I2C device by name in the device table}
{Name: The name of the I2C device to find (eg I2C0)}
{Return: Pointer to I2C device entry or nil if not found}
begin
 {}
 Result:=I2CDeviceFindByName(String(name));
end;

{==============================================================================}

function i2c_device_find_by_description(const description: PCHAR): PI2C_DEVICE; stdcall;
{Find an I2C device by description in the device table}
{Description: The description of the I2C to find (eg BCM2837 BSC1 Master I2C)}
{Return: Pointer to I2C device entry or nil if not found}
begin
 {}
 Result:=I2CDeviceFindByDescription(String(description));
end;

{==============================================================================}

function i2c_device_enumerate(callback: i2c_enumerate_cb; data: PVOID): uint32_t; stdcall;
{Enumerate all I2C devices in the I2C table}
{Callback: The callback function to call for each I2C device in the table}
{Data: A private data pointer to pass to callback for each I2C device in the table}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=I2CDeviceEnumerate(callback,data);
end;

{==============================================================================}

function i2c_device_notification(i2c: PI2C_DEVICE; callback: i2c_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall;
{Register a notification for I2C device changes}
{Device: The I2C device to notify changes for (Optional, pass nil for all I2C devices)}
{Callback: The function to call when a notification event occurs}
{Data: A private data pointer to pass to callback when a notification event occurs}
{Notification: The events to register for notification of (eg DEVICE_NOTIFICATION_REGISTER)}
{Flags: The flags to control the notification (eg NOTIFIER_FLAG_WORKER)}
begin
 {}
 Result:=I2CDeviceNotification(i2c,callback,data,notification,flags);
end;

{==============================================================================}
{I2C Slave Functions}
function i2c_slave_start(i2c: PI2C_DEVICE): uint32_t; stdcall;
{Start the specified I2C slave ready for reading and writing}
{I2C: The I2C slave to start}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=I2CSlaveStart(i2c);
end;

{==============================================================================}

function i2c_slave_stop(i2c: PI2C_DEVICE): uint32_t; stdcall;
{Stop the specified I2C slave and terminate reading and writing}
{I2C: The I2C slave to stop}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=I2CSlaveStop(i2c);
end;

{==============================================================================}

function i2c_slave_read(i2c: PI2C_DEVICE; buffer: PVOID; size: uint32_t; var count: uint32_t): uint32_t; stdcall;
{Read data from the specified I2C slave}
{I2C: The I2C slave to read from}
{Buffer: Pointer to a buffer to receive the data}
{Size: The size of the buffer}
{Count: The number of bytes read on return}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=I2CSlaveRead(i2c,buffer,size,count);
end;

{==============================================================================}

function i2c_slave_write(i2c: PI2C_DEVICE; buffer: PVOID; size: uint32_t; var count: uint32_t): uint32_t; stdcall;
{Write data to the specified I2C slave}
{I2C: The I2C slave to write to}
{Buffer: Pointer to a buffer of data to transmit}
{Size: The size of the buffer}
{Count: The number of bytes written on return}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=I2CSlaveWrite(i2c,buffer,size,count);
end;

{==============================================================================}

function i2c_slave_get_address(i2c: PI2C_DEVICE): uint16_t; stdcall;
{Get the address for the specified I2C slave}
{I2C: The I2C slave to get the address from}
{Return: The address or I2C_ADDRESS_INVALID on failure}
begin
 {}
 Result:=I2CSlaveGetAddress(i2c);
end;

{==============================================================================}

function i2c_slave_set_address(i2c: PI2C_DEVICE; address: uint16_t): uint32_t; stdcall;
{Set the address for the specified I2C slave}
{I2C: The I2C slave to set the address for}
{Address: The address to set}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=I2CSlaveSetAddress(i2c,address);
end;

{==============================================================================}

function i2c_slave_get_properties(i2c: PI2C_DEVICE; properties: PI2C_PROPERTIES): uint32_t; stdcall;
{Get the properties for the specified I2C slave}
{I2C: The I2C slave to get properties from}
{Properties: Pointer to a TI2CProperties structure to fill in}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=I2CSlaveGetProperties(i2c,properties);
end;

{==============================================================================}

function i2c_slave_create: PI2C_DEVICE; stdcall;
{Create a new I2C slave entry}
{Return: Pointer to new I2C slave entry or nil if I2C could not be created}
begin
 {}
 Result:=I2CSlaveCreate;
end;

{==============================================================================}

function i2c_slave_create_ex(size: uint32_t): PI2C_DEVICE; stdcall;
{Create a new I2C slave entry}
{Size: Size in bytes to allocate for new I2C (Including the I2C slave entry)}
{Return: Pointer to new I2C slave entry or nil if I2C could not be created}
begin
 {}
 Result:=I2CSlaveCreateEx(size);
end;

{==============================================================================}

function i2c_slave_destroy(i2c: PI2C_DEVICE): uint32_t; stdcall;
{Destroy an existing I2C slave entry}
{I2C: The I2C slave to destroy}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=I2CSlaveDestroy(i2c);
end;

{==============================================================================}

function i2c_slave_register(i2c: PI2C_DEVICE): uint32_t; stdcall;
{Register a new I2C slave in the I2C table}
{I2C: The I2C slave to register}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=I2CSlaveRegister(i2c);
end;

{==============================================================================}

function i2c_slave_deregister(i2c: PI2C_DEVICE): uint32_t; stdcall;
{Deregister an I2C slave from the I2C table}
{I2C: The I2C slave to deregister}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=I2CSlaveDeregister(i2c);
end;

{==============================================================================}

function i2c_slave_find(i2cid: uint32_t): PI2C_DEVICE; stdcall;
{Find an I2C slave by ID in the I2C table}
{I2CId: The ID number of the I2C slave to find}
{Return: Pointer to I2C slave entry or nil if not found}
begin
 {}
 Result:=I2CSlaveFind(i2cid);
end;

{==============================================================================}

function i2c_slave_find_by_name(const name: PCHAR): PI2C_DEVICE; stdcall;
{Find an I2C slave by name in the device table}
{Name: The name of the I2C slave to find (eg I2CSlave0)}
{Return: Pointer to I2C slave entry or nil if not found}
begin
 {}
 Result:=I2CSlaveFindByName(String(name));
end;

{==============================================================================}

function i2c_slave_find_by_description(const description: PCHAR): PI2C_DEVICE; stdcall;
{Find an I2C slave by description in the device table}
{Description: The description of the I2C slave to find (eg BCM2837 I2C Slave)}
{Return: Pointer to I2C slave entry or nil if not found}
begin
 {}
 Result:=I2CSlaveFindByDescription(String(description));
end;

{==============================================================================}
{I2C Helper Functions}
function i2c_get_count: uint32_t; stdcall;
{Get the current I2C count}
begin
 {}
 Result:=I2CGetCount;
end;

{==============================================================================}

function i2c_device_get_default: PI2C_DEVICE; stdcall;
{Get the current default I2C device}
begin
 {}
 Result:=I2CDeviceGetDefault;
end;

{==============================================================================}

function i2c_device_set_default(i2c: PI2C_DEVICE): uint32_t; stdcall;
{Set the current default I2C device}
begin
 {}
 Result:=I2CDeviceSetDefault(i2c);
end;

{==============================================================================}

function i2c_device_check(i2c: PI2C_DEVICE): PI2C_DEVICE; stdcall;
{Check if the supplied I2C is in the I2C table}
begin
 {}
 Result:=I2CDeviceCheck(i2c);
end;

{==============================================================================}

function i2c_device_is_slave(i2c: PI2C_DEVICE): BOOL; stdcall;
{Check if the supplied I2C is a slave device}
begin
 {}
 Result:=I2CDeviceIsSlave(i2c);
end;

{==============================================================================}

function i2c_type_to_string(i2ctype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Convert an I2C type value to a string}
begin
 {}
 Result:=APIStringToPCharBuffer(I2CTypeToString(i2ctype),_string,len);
end;

{==============================================================================}

function i2c_state_to_string(i2cstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Convert an I2C state value to a string}
begin
 {}
 Result:=APIStringToPCharBuffer(I2CStateToString(i2cstate),_string,len);
end;

{==============================================================================}

function i2c_is7bit_address(address: uint16_t): BOOL; stdcall;
{Determine if the supplied address is a 7bit address}
begin
 {}
 Result:=I2CIs7BitAddress(address);
end;

{==============================================================================}

function i2c_is10bit_address(address: uint16_t): BOOL; stdcall;
{Determine if the supplied address is a 10bit address}
begin
 {}
 Result:=I2CIs10BitAddress(address);
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{PWM Functions}
{$IFDEF API_EXPORT_PWM}
function pwm_device_start(pwm: PPWM_DEVICE): uint32_t; stdcall;
{Start the specified PWM device}
{PWM: The PWM device to start}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=PWMDeviceStart(pwm);
end;

{==============================================================================}

function pwm_device_stop(pwm: PPWM_DEVICE): uint32_t; stdcall;
{Stop the specified PWM device}
{PWM: The PWM device to stop}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=PWMDeviceStop(pwm);
end;

{==============================================================================}

function pwm_device_write(pwm: PPWM_DEVICE; value: uint32_t): uint32_t; stdcall;
{Write a value to the specified PWM device}
{PWM: The PWM device to write to}
{Value: The value to write}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: The exact meaning of value may depend on the device and other configured options,
       in many cases the value will represent the "on" time of each pulse with regard to
       the duty cycle of the waveform output by the device}
begin
 {}
 Result:=PWMDeviceWrite(pwm,value);
end;

{==============================================================================}

function pwm_device_get_gpio(pwm: PPWM_DEVICE): uint32_t; stdcall;
{Get the GPIO pin used by the specified PWM device}
{PWM: The PWM device to get the GPIO pin from}
{Return: The current GPIO pin or GPIO_PIN_UNKNOWN on failure}
begin
 {}
 Result:=PWMDeviceGetGPIO(pwm);
end;

{==============================================================================}

function pwm_device_set_gpio(pwm: PPWM_DEVICE; gpio: uint32_t): uint32_t; stdcall;
{Set the GPIO pin used by the specified PWM device}
{PWM: The PWM device to set the GPIO pin for}
{GPIO: The GPIO pin to set (eg GPIO_PIN_12)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=PWMDeviceSetGPIO(pwm,gpio);
end;

{==============================================================================}

function pwm_device_get_mode(pwm: PPWM_DEVICE): uint32_t; stdcall;
{Get the current mode of the specified PWM device}
{PWM: The PWM device to get the mode from}
{Return: The current mode or a default value of PWM_MODE_MARKSPACE}
begin
 {}
 Result:=PWMDeviceGetMode(pwm);
end;

{==============================================================================}

function pwm_device_set_mode(pwm: PPWM_DEVICE; mode: uint32_t): uint32_t; stdcall;
{Set the current mode for the specified PWM device}
{PWM: The PWM device to set the mode for}
{Mode: The mode value to set (eg PWM_MODE_MARKSPACE)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=PWMDeviceSetMode(pwm,mode);
end;

{==============================================================================}

function pwm_device_get_range(pwm: PPWM_DEVICE): uint32_t; stdcall;
{Get the current range of the specified PWM device}
{PWM: The PWM device to get the range from}
{Return: The current range or 0 on failure}
begin
 {}
 Result:=PWMDeviceGetRange(pwm);
end;

{==============================================================================}

function pwm_device_set_range(pwm: PPWM_DEVICE; range: uint32_t): uint32_t; stdcall;
{Set the current range for the specified PWM device}
{PWM: The PWM device to set the clock rate for}
{Range: The range value to set}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: The exact meaning of range may depend on the device and other configured options,
       in many cases the range will represent the period of one full cycle of the
       waveform output by the device}
begin
 {}
 Result:=PWMDeviceSetRange(pwm,range);
end;

{==============================================================================}

function pwm_device_get_frequency(pwm: PPWM_DEVICE): uint32_t; stdcall;
{Get the clock frequency of the specified PWM device}
{PWM: The PWM device to get the clock frequency from}
{Return: The clock frequency in Hz or 0 on failure}
begin
 {}
 Result:=PWMDeviceGetFrequency(pwm);
end;

{==============================================================================}

function pwm_device_set_frequency(pwm: PPWM_DEVICE; frequency: uint32_t): uint32_t; stdcall;
{Set the clock frequency for the specified PWM device}
{PWM: The PWM device to set the clock frequency for}
{Frequency: The clock frequency to set in Hz}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=PWMDeviceSetFrequency(pwm,frequency);
end;

{==============================================================================}

function pwm_device_get_polarity(pwm: PPWM_DEVICE): uint32_t; stdcall;
{Get the current polarity of the specified PWM device}
{PWM: The PWM device to get the polarity from}
{Return: The current polarity or a default value of PWM_POLARITY_NORMAL}
begin
 {}
 Result:=PWMDeviceGetPolarity(pwm);
end;

{==============================================================================}

function pwm_device_set_polarity(pwm: PPWM_DEVICE; polarity: uint32_t): uint32_t; stdcall;
{Set the current polarity for the specified PWM device}
{PWM: The PWM device to set the polarity for}
{Polarity: The polarity value to set (eg PWM_POLARITY_NORMAL)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=PWMDeviceSetPolarity(pwm,polarity);
end;

{==============================================================================}

function pwm_device_configure(pwm: PPWM_DEVICE; dutyns, periodns: uint32_t): uint32_t; stdcall;
{Set the configuration of the specified PWM device}
{PWM: The PWM device to set the configuration for}
{DutyNS: The "on" time part of the cycle (Nanoseconds)}
{PeriodNS: The duration of one full cycle (Nanoseconds)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=PWMDeviceConfigure(pwm,dutyns,periodns);
end;

{==============================================================================}

function pwm_device_properties(pwm: PPWM_DEVICE; properties: PPWM_PROPERTIES): uint32_t; stdcall;
{Get the properties for the specified PWM device}
{PWM: The PWM device to get properties from}
{Properties: Pointer to a TPWMProperties structure to fill in}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Replaced by PWMDeviceGetProperties for consistency}
begin
 {}
 Result:=PWMDeviceProperties(pwm,properties);
end;

{==============================================================================}

function pwm_device_get_properties(pwm: PPWM_DEVICE; properties: PPWM_PROPERTIES): uint32_t; stdcall;
{Get the properties for the specified PWM device}
{PWM: The PWM device to get properties from}
{Properties: Pointer to a TPWMProperties structure to fill in}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=PWMDeviceGetProperties(pwm,properties);
end;

{==============================================================================}

function pwm_device_create: PPWM_DEVICE; stdcall;
{Create a new PWM entry}
{Return: Pointer to new PWM entry or nil if PWM could not be created}
begin
 {}
 Result:=PWMDeviceCreate;
end;

{==============================================================================}

function pwm_device_create_ex(size: uint32_t): PPWM_DEVICE; stdcall;
{Create a new PWM entry}
{Size: Size in bytes to allocate for new PWM (Including the PWM entry)}
{Return: Pointer to new PWM entry or nil if PWM could not be created}
begin
 {}
 Result:=PWMDeviceCreateEx(size);
end;

{==============================================================================}

function pwm_device_destroy(pwm: PPWM_DEVICE): uint32_t; stdcall;
{Destroy an existing PWM entry}
begin
 {}
 Result:=PWMDeviceDestroy(pwm);
end;

{==============================================================================}

function pwm_device_register(pwm: PPWM_DEVICE): uint32_t; stdcall;
{Register a new PWM in the PWM table}
begin
 {}
 Result:=PWMDeviceRegister(pwm);
end;

{==============================================================================}

function pwm_device_deregister(pwm: PPWM_DEVICE): uint32_t; stdcall;
{Deregister a PWM from the PWM table}
begin
 {}
 Result:=PWMDeviceDeregister(pwm);
end;

{==============================================================================}

function pwm_device_find(pwmid: uint32_t): PPWM_DEVICE; stdcall;
begin
 {}
 Result:=PWMDeviceFind(pwmid);
end;

{==============================================================================}

function pwm_device_find_by_name(const name: PCHAR): PPWM_DEVICE; stdcall;
begin
 {}
 Result:=PWMDeviceFindByName(String(name));
end;

{==============================================================================}

function pwm_device_find_by_description(const description: PCHAR): PPWM_DEVICE; stdcall;
begin
 {}
 Result:=PWMDeviceFindByDescription(String(description));
end;

{==============================================================================}

function pwm_device_enumerate(callback: pwm_enumerate_cb; data: PVOID): uint32_t; stdcall;
begin
 {}
 Result:=PWMDeviceEnumerate(callback,data);
end;

{==============================================================================}

function pwm_device_notification(pwm: PPWM_DEVICE; callback: pwm_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=PWMDeviceNotification(pwm,callback,data,notification,flags);
end;

{==============================================================================}
{PWM Helper Functions}
function pwm_get_count: uint32_t; stdcall;
{Get the current PWM count}
begin
 {}
 Result:=PWMGetCount;
end;

{==============================================================================}

function pwm_device_get_default: PPWM_DEVICE; stdcall;
{Get the current default PWM device}
begin
 {}
 Result:=PWMDeviceGetDefault;
end;

{==============================================================================}

function pwm_device_set_default(pwm: PPWM_DEVICE): uint32_t; stdcall;
{Set the current default PWM device}
begin
 {}
 Result:=PWMDeviceSetDefault(pwm);
end;

{==============================================================================}

function pwm_device_check(pwm: PPWM_DEVICE): PPWM_DEVICE; stdcall;
{Check if the supplied PWM is in the PWM table}
begin
 {}
 Result:=PWMDeviceCheck(pwm);
end;

{==============================================================================}

function pwm_type_to_string(pwmtype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Convert a PWM type value to a string}
begin
 {}
 Result:=APIStringToPCharBuffer(PWMTypeToString(pwmtype),_string,len);
end;

{==============================================================================}

function pwm_state_to_string(pwmstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Convert a PWM state value to a string}
begin
 {}
 Result:=APIStringToPCharBuffer(PWMStateToString(pwmstate),_string,len);
end;

{==============================================================================}

function pwm_mode_to_string(pwmmode: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Convert a PWM mode value to a string}
begin
 {}
 Result:=APIStringToPCharBuffer(PWMModeToString(pwmmode),_string,len);
end;

{==============================================================================}

function pwm_polarity_to_string(pwmpolarity: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Convert a PWM polarity value to a string}
begin
 {}
 Result:=APIStringToPCharBuffer(PWMPolarityToString(pwmpolarity),_string,len);
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{PCM (I2S) Functions}
{$IFDEF API_EXPORT_PCM}
//To Do
{==============================================================================}
{PCM (I2S) Helper Functions}
//To Do
{$ENDIF}
{==============================================================================}
{==============================================================================}
{GPIO Functions}
{$IFDEF API_EXPORT_GPIO}
function gpio_device_start(gpio: PGPIO_DEVICE): uint32_t; stdcall;
{Start the specified GPIO device and enable access}
{GPIO: The GPIO device to start}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=GPIODeviceStart(gpio);
end;

{==============================================================================}

function gpio_device_stop(gpio: PGPIO_DEVICE): uint32_t; stdcall;
{Stop the specified GPIO device and disable access}
{GPIO: The GPIO device to stop}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=GPIODeviceStop(gpio);
end;

{==============================================================================}

function gpio_device_read(gpio: PGPIO_DEVICE; reg: uint32_t): uint32_t; stdcall;
{Perform a direct read from a register of the specified GPIO device}
{GPIO: The GPIO device to read from}
{Reg: The memory register to read from}
{Return: The value of the memory register}
begin
 {}
 Result:=GPIODeviceRead(gpio,reg);
end;

{==============================================================================}

procedure gpio_device_write(gpio: PGPIO_DEVICE; reg, value: uint32_t); stdcall;
{Perform a direct write to a register of the specified GPIO device}
{GPIO: The GPIO device to write to}
{Reg: The memory register to write to}
{Value: The value to write to the register}
begin
 {}
 GPIODeviceWrite(gpio,reg,value);
end;

{==============================================================================}

function gpio_device_input_get(gpio: PGPIO_DEVICE; pin: uint32_t): uint32_t; stdcall;
{Get the current state of an input pin on the specified GPIO device}
{GPIO: The GPIO device to get from}
{Pin: The pin to get the state for (eg GPIO_PIN_1)}
{Return: The current state (eg GPIO_LEVEL_HIGH) or GPIO_LEVEL_UNKNOWN on failure}
begin
 {}
 Result:=GPIODeviceInputGet(gpio,pin);
end;

{==============================================================================}

function gpio_device_input_wait(gpio: PGPIO_DEVICE; pin, trigger, timeout: uint32_t): uint32_t; stdcall;
{Wait for the state of a input pin to change on the specified GPIO device}
{GPIO: The GPIO device to wait for}
{Pin: The pin to wait for the state to change (eg GPIO_PIN_1)}
{Trigger: The trigger event to wait for (eg GPIO_TRIGGER_HIGH)}
{Timeout: Number of milliseconds to wait for the change (INFINITE to wait forever)}
{Return: The state after the change (eg GPIO_LEVEL_HIGH) or GPIO_LEVEL_UNKNOWN on failure or timeout}
begin
 {}
 Result:=GPIODeviceInputWait(gpio,pin,trigger,timeout);
end;

{==============================================================================}

function gpio_device_input_event(gpio: PGPIO_DEVICE; pin, trigger, flags, timeout: uint32_t; callback: gpio_event_cb; data: PVOID): uint32_t; stdcall;
{Schedule a function to be called when the state of a input pin changes on the specified GPIO device}
{GPIO: The GPIO device to schedule the callback for}
{Pin: The pin to schedule the state change for (eg GPIO_PIN_1)}
{Trigger: The trigger event which will cause the function to be called (eg GPIO_TRIGGER_HIGH)}
{Flags: The flags to control the event (eg GPIO_EVENT_FLAG_REPEAT)}
{Timeout: The number of milliseconds before the scheduled trigger expires (INFINITE to never expire)}
{Callback: The function to be called when the trigger occurs}
{Data: A pointer to be pass to the function when the trigger occurs (Optional)}
{Return: ERROR_SUCCESS if the trigger was scheduled successfully or another error code on failure}
{Note: The pin and trigger that caused the event will be passed to the callback function}
begin
 {}
 Result:=GPIODeviceInputEvent(gpio,pin,trigger,flags,timeout,callback,data);
end;

{==============================================================================}

function gpio_device_input_cancel(gpio: PGPIO_DEVICE; pin: uint32_t): uint32_t; stdcall;
{Cancel a previously scheduled event callback function for an input pin on the specified GPIO device}
{GPIO: The GPIO device to cancel the callback for}
{Pin: The pin to cancel the state change for (eg GPIO_PIN_1)}
{Return: ERROR_SUCCESS if the callback was cancelled successfully or another error code on failure}
begin
 {}
 Result:=GPIODeviceInputCancel(gpio,pin);
end;

{==============================================================================}

function gpio_device_output_set(gpio: PGPIO_DEVICE; pin, level: uint32_t): uint32_t; stdcall;
{Set the state of a output pin on the specified GPIO device}
{GPIO: The GPIO device to set for}
{Pin: The pin to set the state for (eg GPIO_PIN_1)}
{Level: The state to set the pin to (eg GPIO_LEVEL_HIGH)}
{Return: ERROR_SUCCESS if completed successfully or another error code on failure}
begin
 {}
 Result:=GPIODeviceOutputSet(gpio,pin,level);
end;

{==============================================================================}

function gpio_device_level_get(gpio: PGPIO_DEVICE; pin: uint32_t): uint32_t; stdcall;
{Get the current level (state) of a pin on the specified GPIO device}
{GPIO: The GPIO device to get from}
{Pin: The pin to get the level for (eg GPIO_PIN_1)}
{Return: The current level (eg GPIO_LEVEL_HIGH) or GPIO_LEVEL_UNKNOWN on failure}
{Note: This function is a synonym for GPIODeviceInputGet as in many cases the
       level can be read from a pin regardless of input or output mode. This
       may help to make code clearer or easier to understand in some cases}
begin
 {}
 Result:=GPIODeviceLevelGet(gpio,pin);
end;

{==============================================================================}

function gpio_device_level_set(gpio: PGPIO_DEVICE; pin, level: uint32_t): uint32_t; stdcall;
{Set the level (state) of a pin on the specified GPIO device}
{GPIO: The GPIO device to set for}
{Pin: The pin to set the level for (eg GPIO_PIN_1)}
{Level: The level to set the pin to (eg GPIO_LEVEL_HIGH)}
{Return: ERROR_SUCCESS if completed successfully or another error code on failure}
{Note: This function is a synonym for GPIODeviceOutputSet as in many cases the
       level can be set for a pin regardless of input or output mode. This
       may help to make code clearer or easier to understand in some cases}
begin
 {}
 Result:=GPIODeviceLevelSet(gpio,pin,level);
end;

{==============================================================================}

function gpio_device_pull_get(gpio: PGPIO_DEVICE; pin: uint32_t): uint32_t; stdcall;
{Get the current pull state of a pin on the specified GPIO device}
{GPIO: The GPIO device to get from}
{Pin: The pin to get the pull state for (eg GPIO_PIN_1)}
{Return: The current pull state of the pin (eg GPIO_PULL_UP) or GPIO_PULL_UNKNOWN on failure}
begin
 {}
 Result:=GPIODevicePullGet(gpio,pin);
end;

{==============================================================================}

function gpio_device_pull_select(gpio: PGPIO_DEVICE; pin, mode: uint32_t): uint32_t; stdcall;
{Change the pull state of a pin on the specified GPIO device}
{GPIO: The GPIO device to set for}
{Pin: The pin to change the pull state for (eg GPIO_PIN_1)}
{Mode: The pull state to set for the pin (eg GPIO_PULL_UP)}
{Return: ERROR_SUCCESS if completed successfully or another error code on failure}
begin
 {}
 Result:=GPIODevicePullSelect(gpio,pin,mode);
end;

{==============================================================================}

function gpio_device_function_get(gpio: PGPIO_DEVICE; pin: uint32_t): uint32_t; stdcall;
{Get the current function of a pin on the specified GPIO device}
{GPIO: The GPIO device to get from}
{Pin: The pin to get the function for (eg GPIO_PIN_1)}
{Return: The current function of the pin (eg GPIO_FUNCTION_IN) or GPIO_FUNCTION_UNKNOWN on failure}
begin
 {}
 Result:=GPIODeviceFunctionGet(gpio,pin);
end;

{==============================================================================}

function gpio_device_function_select(gpio: PGPIO_DEVICE; pin, mode: uint32_t): uint32_t; stdcall;
{Change the function of a pin on the specified GPIO device}
{GPIO: The GPIO device to set for}
{Pin: The pin to change the function for (eg GPIO_PIN_1)}
{Mode: The function to set for the pin (eg GPIO_FUNCTION_OUT)}
{Return: ERROR_SUCCESS if completed successfully or another error code on failure}
begin
 {}
 Result:=GPIODeviceFunctionSelect(gpio,pin,mode);
end;

{==============================================================================}

function gpio_device_properties(gpio: PGPIO_DEVICE; properties: PGPIO_PROPERTIES): uint32_t; stdcall;
{Get the properties for the specified GPIO device}
{GPIO: The GPIO device to get properties from}
{Properties: Pointer to a TGPIOProperties structure to fill in}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Replaced by GPIODeviceGetProperties for consistency}
begin
 {}
 Result:=GPIODeviceProperties(gpio,properties);
end;

{==============================================================================}

function gpio_device_get_properties(gpio: PGPIO_DEVICE; properties: PGPIO_PROPERTIES): uint32_t; stdcall;
{Get the properties for the specified GPIO device}
{GPIO: The GPIO device to get properties from}
{Properties: Pointer to a TGPIOProperties structure to fill in}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=GPIODeviceGetProperties(gpio,properties);
end;

{==============================================================================}

function gpio_device_create: PGPIO_DEVICE; stdcall;
{Create a new GPIO entry}
{Return: Pointer to new GPIO entry or nil if GPIO could not be created}
begin
 {}
 Result:=GPIODeviceCreate;
end;

{==============================================================================}

function gpio_device_create_ex(size: uint32_t): PGPIO_DEVICE; stdcall;
{Create a new GPIO entry}
{Size: Size in bytes to allocate for new GPIO (Including the GPIO entry)}
{Return: Pointer to new GPIO entry or nil if GPIO could not be created}
begin
 {}
 Result:=GPIODeviceCreateEx(size);
end;

{==============================================================================}

function gpio_device_destroy(gpio: PGPIO_DEVICE): uint32_t; stdcall;
{Destroy an existing GPIO entry}
{GPIO: The GPIO device to destroy}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=GPIODeviceDestroy(gpio);
end;

{==============================================================================}

function gpio_device_register(gpio: PGPIO_DEVICE): uint32_t; stdcall;
{Register a new GPIO in the GPIO table}
{GPIO: The GPIO device to register}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=GPIODeviceRegister(gpio);
end;

{==============================================================================}

function gpio_device_deregister(gpio: PGPIO_DEVICE): uint32_t; stdcall;
{Deregister a GPIO from the GPIO table}
{GPIO: The GPIO device to deregister}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=GPIODeviceDeregister(gpio);
end;

{==============================================================================}

function gpio_device_find(gpioid: uint32_t): PGPIO_DEVICE; stdcall;
{Find a GPIO device by ID in the GPIO table}
{GPIOId: The ID number of the GPIO device to find}
{Return: Pointer to GPIO device entry or nil if not found}
begin
 {}
 Result:=GPIODeviceFind(gpioid);
end;

{==============================================================================}

function gpio_device_find_by_name(const name: PCHAR): PGPIO_DEVICE; stdcall;
{Find a GPIO device by name in the GPIO table}
{Name: The name of the GPIO to find (eg GPIO0)}
{Return: Pointer to GPIO device entry or nil if not found}
begin
 {}
 Result:=GPIODeviceFindByName(String(name));
end;

{==============================================================================}

function gpio_device_find_by_description(const description: PCHAR): PGPIO_DEVICE; stdcall;
{Find a GPIO device by description in the GPIO table}
{Description: The description of the GPIO to find (eg BCM2836 GPIO)}
{Return: Pointer to GPIO device entry or nil if not found}
begin
 {}
 Result:=GPIODeviceFindByDescription(String(description));
end;

{==============================================================================}

function gpio_device_enumerate(callback: gpio_enumerate_cb; data: PVOID): uint32_t; stdcall;
{Enumerate all GPIO devices in the GPIO table}
{Callback: The callback function to call for each GPIO in the table}
{Data: A private data pointer to pass to callback for each GPIO in the table}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=GPIODeviceEnumerate(callback,data);
end;

{==============================================================================}

function gpio_device_notification(gpio: PGPIO_DEVICE; callback: gpio_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall;
{Register a notification for GPIO device changes}
{GPIO: The GPIO device to notify changes for (Optional, pass nil for all GPIO devices)}
{Callback: The function to call when a notification event occurs}
{Data: A private data pointer to pass to callback when a notification event occurs}
{Notification: The events to register for notification of (eg DEVICE_NOTIFICATION_REGISTER)}
{Flags: The flags to control the notification (eg NOTIFIER_FLAG_WORKER)}
begin
 {}
 Result:=GPIODeviceNotification(gpio,callback,data,notification,flags);
end;

{==============================================================================}
{GPIO Helper Functions}
function gpio_get_count: uint32_t; stdcall;
{Get the current GPIO count}
begin
 {}
 Result:=GPIOGetCount;
end;

{==============================================================================}

function gpio_device_get_default: PGPIO_DEVICE; stdcall;
{Get the current default GPIO device}
begin
 {}
 Result:=GPIODeviceGetDefault;
end;

{==============================================================================}

function gpio_device_set_default(gpio: PGPIO_DEVICE): uint32_t; stdcall;
{Set the current default GPIO device}
begin
 {}
 Result:=GPIODeviceSetDefault(gpio);
end;

{==============================================================================}

function gpio_device_check(gpio: PGPIO_DEVICE): PGPIO_DEVICE; stdcall;
{Check if the supplied GPIO is in the GPIO table}
begin
 {}
 Result:=GPIODeviceCheck(gpio);
end;

{==============================================================================}

function gpio_type_to_string(gpiotype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Convert a GPIO type value to a string}
begin
 {}
 Result:=APIStringToPCharBuffer(GPIOTypeToString(gpiotype),_string,len);
end;

{==============================================================================}

function gpio_state_to_string(gpiostate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Convert a GPIO state value to a string}
begin
 {}
 Result:=APIStringToPCharBuffer(GPIOStateToString(gpiostate),_string,len);
end;

{==============================================================================}

function gpio_device_create_event(gpio: PGPIO_DEVICE; pin: PGPIO_PIN; callback: gpio_event_cb; data: PVOID; timeout: uint32_t): PGPIO_EVENT; stdcall;
{Create a new event using the supplied parameters}
{Note: Event must be registered by calling GPIODeviceRegisterEvent}
{Note: Caller must hold the GPIO device lock}
begin
 {}
 Result:=GPIODeviceCreateEvent(gpio,pin,callback,data,timeout);
end;

{==============================================================================}

function gpio_device_destroy_event(gpio: PGPIO_DEVICE; event: PGPIO_EVENT): uint32_t; stdcall;
{Destroy an existing event}
{Note: Event must be deregistered first by calling GPIODeviceDeregisterEvent}
{Note: Caller must hold the GPIO device lock}
begin
 {}
 Result:=GPIODeviceDestroyEvent(gpio,event);
end;

{==============================================================================}

function gpio_device_register_event(gpio: PGPIO_DEVICE; pin: PGPIO_PIN; event: PGPIO_EVENT): uint32_t; stdcall;
{Register an event in the event list of the supplied Pin}
{Note: Event must be created by calling GPIODeviceCreateEvent}
{Note: Caller must hold the GPIO device lock}
begin
 {}
 Result:=GPIODeviceRegisterEvent(gpio,pin,event);
end;

{==============================================================================}

function gpio_device_deregister_event(gpio: PGPIO_DEVICE; pin: PGPIO_PIN; event: PGPIO_EVENT): uint32_t; stdcall;
{Deregister an event from the event list of the supplied Pin}
{Note: Event must be destroyed by calling GPIODeviceDestroyEvent}
{Note: Caller must hold the GPIO device lock}
begin
 {}
 Result:=GPIODeviceDeregisterEvent(gpio,pin,event);
end;

{==============================================================================}

function gpio_pin_to_string(pin: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(GPIOPinToString(pin),_string,len);
end;

{==============================================================================}

function gpio_level_to_string(level: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(GPIOLevelToString(level),_string,len);
end;

{==============================================================================}

function gpio_trigger_to_string(trigger: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(GPIOTriggerToString(trigger),_string,len);
end;

{==============================================================================}

function gpio_pull_to_string(value: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(GPIOPullToString(value),_string,len);
end;

{==============================================================================}

function gpio_function_to_string(value: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(GPIOFunctionToString(value),_string,len);
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{UART Functions}
{$IFDEF API_EXPORT_UART}
function uart_device_open(uart: PUART_DEVICE; baudrate, databits, stopbits, parity, flowcontrol: uint32_t): uint32_t; stdcall;
{Open a UART device ready for sending and receiving}
{UART: The UART device to open}
{BaudRate: Baud rate for the connection (eg 9600, 57600, 115200 etc}
{DataBits: Size of the data (eg SERIAL_DATA_8BIT)}
{StopBits: Number of stop bits (eg SERIAL_STOP_1BIT)}
{Parity: Parity type for the data (eg SERIAL_PARITY_NONE)}
{FlowControl: Flow control for the connection (eg SERIAL_FLOW_NONE)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=UARTDeviceOpen(uart,baudrate,databits,stopbits,parity,flowcontrol);
end;

{==============================================================================}

function uart_device_close(uart: PUART_DEVICE): uint32_t; stdcall;
{Close a UART device and terminate sending and receiving}
{UART: The UART device to close}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=UARTDeviceClose(uart);
end;

{==============================================================================}

function uart_device_read(uart: PUART_DEVICE; buffer: PVOID; size, flags: uint32_t; var count: uint32_t): uint32_t; stdcall;
{Read data from a UART device}
{UART: The UART device to read from}
{Buffer: Pointer to a buffer to receive the data}
{Size: The size of the buffer}
{Flags: The flags to control reading (eg UART_READ_NON_BLOCK)}
{Count: The number of bytes read on return}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=UARTDeviceRead(uart,buffer,size,flags,count);
end;

{==============================================================================}

function uart_device_write(uart: PUART_DEVICE; buffer: PVOID; size, flags: uint32_t; var count: uint32_t): uint32_t; stdcall;
{Write data to a UART device}
{UART: The UART device to write to}
{Buffer: Pointer to a buffer of data to transmit}
{Size: The size of the buffer}
{Flags: The flags to control writing (eg UART_WRITE_NON_BLOCK)}
{Count: The number of bytes written on return}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=UARTDeviceWrite(uart,buffer,size,flags,count);
end;

{==============================================================================}

function uart_device_wait(uart: PUART_DEVICE; direction, timeout: uint32_t): uint32_t; stdcall;
{Wait for data to be available in the receive or transmit FIFO of a UART device}
{UART: The UART device to wait for}
{Direction: The direction of data to wait for (eg UART_WAIT_RECEIVE)}
{Timeout: The number of milliseconds to wait for data (INFINITE to wait forever)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=UARTDeviceWait(uart,direction,timeout);
end;

{==============================================================================}

function uart_device_status(uart: PUART_DEVICE): uint32_t; stdcall;
{Get the current line status of a UART device}
{UART: The UART device to get the status from}
{Return: A set of flags containing the device status (eg UART_STATUS_RTS)}
{Note: Replaced by UARTDeviceGetStatus for consistency}
begin
 {}
 Result:=UARTDeviceStatus(uart);
end;

{==============================================================================}

function uart_device_get_status(uart: PUART_DEVICE): uint32_t; stdcall;
{Get the current line status of a UART device}
{UART: The UART device to get the status from}
{Return: A set of flags containing the device status (eg UART_STATUS_RTS)}
begin
 {}
 Result:=UARTDeviceGetStatus(uart);
end;

{==============================================================================}

function uart_device_set_status(uart: PUART_DEVICE; status: uint32_t): uint32_t; stdcall;
{Set the current line status of a UART device}
{UART: The UART device to set the status for}
{Status: The device status flags to be set (eg UART_STATUS_RTS)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Not all UART_STATUS_* flags can be set, the device may ignore invalid values}
{Note: Not all UART devices support set status, returns ERROR_CALL_NOT_IMPLEMENTED if not supported}
begin
 {}
 Result:=UARTDeviceSetStatus(uart,status);
end;

{==============================================================================}

function uart_device_properties(uart: PUART_DEVICE; properties: PUART_PROPERTIES): uint32_t; stdcall;
{Get the properties for the specified UART device}
{UART: The UART device to get properties from}
{Properties: Pointer to a PUARTProperties structure to fill in}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Replaced by UARTDeviceGetProperties for consistency}
begin
 {}
 Result:=UARTDeviceProperties(uart,properties);
end;

{==============================================================================}

function uart_device_get_properties(uart: PUART_DEVICE; properties: PUART_PROPERTIES): uint32_t; stdcall;
{Get the properties for the specified UART device}
{UART: The UART device to get properties from}
{Properties: Pointer to a PUARTProperties structure to fill in}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=UARTDeviceGetProperties(uart,properties);
end;

{==============================================================================}

function uart_device_set_properties(uart: PUART_DEVICE; properties: PUART_PROPERTIES): uint32_t; stdcall;
{Set the properties for the specified UART device}
{UART: The UART device to set properties for}
{Properties: Pointer to a PUARTProperties structure to use}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=UARTDeviceSetProperties(uart,properties);
end;

{==============================================================================}

function uart_device_create: PUART_DEVICE; stdcall;
{Create a new UART entry}
{Return: Pointer to new UART entry or nil if UART could not be created}
begin
 {}
 Result:=UARTDeviceCreate;
end;

{==============================================================================}

function uart_device_create_ex(size: uint32_t): PUART_DEVICE; stdcall;
{Create a new UART entry}
{Size: Size in bytes to allocate for new UART (Including the UART entry)}
{Return: Pointer to new UART entry or nil if UART could not be created}
begin
 {}
 Result:=UARTDeviceCreateEx(size);
end;

{==============================================================================}

function uart_device_destroy(uart: PUART_DEVICE): uint32_t; stdcall;
{Destroy an existing UART entry}
{UART: The UART device to destroy}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=UARTDeviceDestroy(uart);
end;

{==============================================================================}

function uart_device_register(uart: PUART_DEVICE): uint32_t; stdcall;
{Register a new UART in the UART table}
{UART: The UART device to register}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=UARTDeviceRegister(uart);
end;

{==============================================================================}

function uart_device_deregister(uart: PUART_DEVICE): uint32_t; stdcall;
{Deregister a UART from the UART table}
{UART: The UART device to deregister}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=UARTDeviceDeregister(uart);
end;

{==============================================================================}

function uart_device_find(uartid: uint32_t): PUART_DEVICE; stdcall;
{Find a UART device by ID in the UART table}
{UARTId: The ID number of the UART to find}
{Return: Pointer to UART device entry or nil if not found}
begin
 {}
 Result:=UARTDeviceFind(uartid);
end;

{==============================================================================}

function uart_device_find_by_name(const name: PCHAR): PUART_DEVICE; stdcall;
{Find a UART device by name in the UART table}
{Name: The name of the UART to find (eg UART0)}
{Return: Pointer to UART device entry or nil if not found}
begin
 {}
 Result:=UARTDeviceFindByName(String(name));
end;

{==============================================================================}

function uart_device_find_by_description(const description: PCHAR): PUART_DEVICE; stdcall;
{Find a UART device by description in the UART table}
{Description: The description of the UART to find (eg BCM2836 PL011 UART)}
{Return: Pointer to UART device entry or nil if not found}
begin
 {}
 Result:=UARTDeviceFindByDescription(String(description));
end;

{==============================================================================}

function uart_device_enumerate(callback: uart_enumerate_cb; data: PVOID): uint32_t; stdcall;
{Enumerate all UART devices in the UART table}
{Callback: The callback function to call for each UART in the table}
{Data: A private data pointer to pass to callback for each UART in the table}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=UARTDeviceEnumerate(callback,data);
end;

{==============================================================================}

function uart_device_notification(uart: PUART_DEVICE; callback: uart_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall;
{Register a notification for UART device changes}
{UART: The UART device to notify changes for (Optional, pass nil for all UART devices)}
{Callback: The function to call when a notification event occurs}
{Data: A private data pointer to pass to callback when a notification event occurs}
{Notification: The events to register for notification of (eg DEVICE_NOTIFICATION_REGISTER)}
{Flags: The flags to control the notification (eg NOTIFIER_FLAG_WORKER)}
begin
 {}
 Result:=UARTDeviceNotification(uart,callback,data,notification,flags);
end;

{==============================================================================}
{UART Helper Functions}
function uart_get_count: uint32_t; stdcall;
{Get the current UART count}
begin
 {}
 Result:=UARTGetCount;
end;

{==============================================================================}

function uart_device_get_default: PUART_DEVICE; stdcall;
{Get the current default UART device}
begin
 {}
 Result:=UARTDeviceGetDefault;
end;

{==============================================================================}

function uart_device_set_default(uart: PUART_DEVICE): uint32_t; stdcall;
{Set the current default UART device}
begin
 {}
 Result:=UARTDeviceSetDefault(uart);
end;

{==============================================================================}

function uart_device_check(uart: PUART_DEVICE): PUART_DEVICE; stdcall;
{Check if the supplied UART is in the UART table}
begin
 {}
 Result:=UARTDeviceCheck(uart);
end;

{==============================================================================}

function uart_type_to_string(uarttype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Convert a UART type value to a string}
begin
 {}
 Result:=APIStringToPCharBuffer(UARTTypeToString(uarttype),_string,len);
end;

{==============================================================================}

function uart_mode_to_string(uartmode: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Convert a UART mode to a string}
begin
 {}
 Result:=APIStringToPCharBuffer(UARTModeToString(uartmode),_string,len);
end;

{==============================================================================}

function uart_state_to_string(uartstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Convert a UART state value to a string}
begin
 {}
 Result:=APIStringToPCharBuffer(UARTStateToString(uartstate),_string,len);
end;

{==============================================================================}
{UART Serial Helper Functions}
function uart_serial_device_receive(uart: PUART_DEVICE): uint32_t; stdcall;
{Read data from a UART device into the receive buffer of the associated Serial device}
{Note: Not intended to be called directly by applications}
{Note: Caller must hold the lock on the serial device which owns the UART}
begin
 {}
 Result:=UARTSerialDeviceReceive(uart);
end;

{==============================================================================}

function uart_serial_device_transmit(uart: PUART_DEVICE): uint32_t; stdcall;
{Write data to a UART device from the transmit buffer of the associated Serial device}
{Note: Not intended to be called directly by applications}
{Note: Caller must hold the lock on the serial device which owns the UART}
begin
 {}
 Result:=UARTSerialDeviceTransmit(uart);
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{Serial Functions}
{$IFDEF API_EXPORT_SERIAL}
function serial_device_open(serial: PSERIAL_DEVICE; baudrate, databits, stopbits, parity, flowcontrol, receivedepth, transmitdepth: uint32_t): uint32_t; stdcall;
{Open a Serial device ready for sending and receiving}
{Serial: The Serial device to open}
{BaudRate: Baud rate for the connection (eg 9600, 57600, 115200 etc}
{DataBits: Size of the data (eg SERIAL_DATA_8BIT)}
{StopBits: Number of stop bits (eg SERIAL_STOP_1BIT)}
{Parity: Parity type for the data (eg SERIAL_PARITY_NONE)}
{FlowControl: Flow control for the connection (eg SERIAL_FLOW_NONE)}
{ReceiveDepth: Size of the receive buffer (0 = Default size)}
{TransmitDepth: Size of the transmit buffer (0 = Default size)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SerialDeviceOpen(serial,baudrate,databits,stopbits,parity,flowcontrol,receivedepth,transmitdepth);
end;

{==============================================================================}

function serial_device_close(serial: PSERIAL_DEVICE): uint32_t; stdcall;
{Close a Serial device and terminate sending and receiving}
{Serial: The Serial device to close}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SerialDeviceClose(serial);
end;

{==============================================================================}

function serial_device_read(serial: PSERIAL_DEVICE; buffer: PVOID; size, flags: uint32_t; var count: uint32_t): uint32_t; stdcall;
{Read data from a Serial device}
{Serial: The Serial device to read from}
{Buffer: Pointer to a buffer to receive the data}
{Size: The size of the buffer}
{Flags: The flags to control reading (eg SERIAL_READ_NON_BLOCK)}
{Count: The number of bytes read on return}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SerialDeviceRead(serial,buffer,size,flags,count);
end;

{==============================================================================}

function serial_device_write(serial: PSERIAL_DEVICE; buffer: PVOID; size, flags: uint32_t; var count: uint32_t): uint32_t; stdcall;
{Write data to a Serial device}
{Serial: The Serial device to write to}
{Buffer: Pointer to a buffer of data to transmit}
{Size: The size of the buffer}
{Flags: The flags to control writing (eg SERIAL_WRITE_NON_BLOCK)}
{Count: The number of bytes written on return}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SerialDeviceWrite(serial,buffer,size,flags,count);
end;

{==============================================================================}

function serial_device_wait(serial: PSERIAL_DEVICE; direction, timeout: uint32_t; var count: uint32_t): uint32_t; stdcall;
{Wait for data to be available in the receive or transmit buffers of a Serial device}
{Serial: The Serial device to wait for}
{Direction: The direction of data to wait for (eg SERIAL_WAIT_RECEIVE)}
{Timeout: The number of milliseconds to wait for data (INFINITE to wait forever)}
{Count: The number of bytes available on return}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SerialDeviceWait(serial,direction,timeout,count);
end;

{==============================================================================}

function serial_device_flush(serial: PSERIAL_DEVICE; flags: uint32_t): uint32_t; stdcall;
{Discard the contents of the receive and/or transmit buffers of a Serial device}
{Serial: The Serial device to flush}
{Flags: The flags to indicate what to flush (eg SERIAL_FLUSH_RECEIVE)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SerialDeviceFlush(serial,flags);
end;

{==============================================================================}

function serial_device_status(serial: PSERIAL_DEVICE): uint32_t; stdcall;
{Get the current line status of a Serial device}
{Serial: The Serial device to get the status from}
{Return: A set of flags containing the device status (eg SERIAL_STATUS_RTS)}
{Note: Replaced by SerialDeviceGetStatus for consistency}
begin
 {}
 Result:=SerialDeviceStatus(serial);
end;

{==============================================================================}

function serial_device_get_status(serial: PSERIAL_DEVICE): uint32_t; stdcall;
{Get the current line status of a Serial device}
{Serial: The Serial device to get the status from}
{Return: A set of flags containing the device status (eg SERIAL_STATUS_RTS)}
begin
 {}
 Result:=SerialDeviceGetStatus(serial);
end;

{==============================================================================}

function serial_device_set_status(serial: PSERIAL_DEVICE; status: uint32_t): uint32_t; stdcall;
{Set the current line status of a Serial device}
{Serial: The Serial device to set the status for}
{Status: The device status flags to be set (eg SERIAL_STATUS_RTS)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Not all SERIAL_STATUS_* flags can be set, the device may ignore invalid values}
{Note: Not all serial devices support set status, returns ERROR_CALL_NOT_IMPLEMENTED if not supported}
begin
 {}
 Result:=SerialDeviceSetStatus(serial,status);
end;

{==============================================================================}

function serial_device_properties(serial: PSERIAL_DEVICE; properties: PSERIAL_PROPERTIES): uint32_t; stdcall;
{Get the properties for the specified Serial device}
{Serial: The Serial device to get properties from}
{Properties: Pointer to a PSerialProperties structure to fill in}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Replaced by SerialDeviceGetProperties for consistency}
begin
 {}
 Result:=SerialDeviceProperties(serial,properties);
end;

{==============================================================================}

function serial_device_get_properties(serial: PSERIAL_DEVICE; properties: PSERIAL_PROPERTIES): uint32_t; stdcall;
{Get the properties for the specified Serial device}
{Serial: The Serial device to get properties from}
{Properties: Pointer to a PSerialProperties structure to fill in}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SerialDeviceGetProperties(serial,properties);
end;

{==============================================================================}

function serial_device_set_properties(serial: PSERIAL_DEVICE; properties: PSERIAL_PROPERTIES): uint32_t; stdcall;
{Set the properties for the specified Serial device}
{Serial: The Serial device to set properties for}
{Properties: Pointer to a PSerialProperties structure to use}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SerialDeviceSetProperties(serial,properties);
end;

{==============================================================================}

function serial_device_create: PSERIAL_DEVICE; stdcall;
{Create a new Serial entry}
{Return: Pointer to new Serial entry or nil if Serial could not be created}
begin
 {}
 Result:=SerialDeviceCreate;
end;

{==============================================================================}

function serial_device_create_ex(size: uint32_t): PSERIAL_DEVICE; stdcall;
{Create a new Serial entry}
{Size: Size in bytes to allocate for new Serial (Including the Serial entry)}
{Return: Pointer to new Serial entry or nil if Serial could not be created}
begin
 {}
 Result:=SerialDeviceCreateEx(size);
end;

{==============================================================================}

function serial_device_destroy(serial: PSERIAL_DEVICE): uint32_t; stdcall;
{Destroy an existing Serial entry}
{Serial: The serial device to destroy}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SerialDeviceDestroy(serial);
end;

{==============================================================================}

function serial_device_register(serial: PSERIAL_DEVICE): uint32_t; stdcall;
{Register a new Serial in the Serial table}
{Serial: The serial device to register}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SerialDeviceRegister(serial);
end;

{==============================================================================}

function serial_device_deregister(serial: PSERIAL_DEVICE): uint32_t; stdcall;
{Deregister a Serial from the Serial table}
{Serial: The serial device to deregister}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SerialDeviceDeregister(serial);
end;

{==============================================================================}

function serial_device_find(serialid: uint32_t): PSERIAL_DEVICE; stdcall;
{Find a serial device by ID in the serial table}
{SerialId: The ID number of the serial to find}
{Return: Pointer to serial device entry or nil if not found}
begin
 {}
 Result:=SerialDeviceFind(serialid);
end;

{==============================================================================}

function serial_device_find_by_name(const name: PCHAR): PSERIAL_DEVICE; stdcall;
{Find a serial device by name in the serial table}
{Name: The name of the serial to find (eg Serial0)}
{Return: Pointer to serial device entry or nil if not found}
begin
 {}
 Result:=SerialDeviceFindByName(String(name));
end;

{==============================================================================}

function serial_device_find_by_description(const description: PCHAR): PSERIAL_DEVICE; stdcall;
{Find a serial device by description in the serial table}
{Description: The description of the serial to find (eg BCM2836 PL011 UART)}
{Return: Pointer to serial device entry or nil if not found}
begin
 {}
 Result:=SerialDeviceFindByDescription(String(description));
end;

{==============================================================================}

function serial_device_enumerate(callback: serial_enumerate_cb; data: PVOID): uint32_t; stdcall;
{Enumerate all serial devices in the serial table}
{Callback: The callback function to call for each serial in the table}
{Data: A private data pointer to pass to callback for each serial in the table}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=SerialDeviceEnumerate(callback,data);
end;

{==============================================================================}

function serial_device_notification(serial: PSERIAL_DEVICE; callback: serial_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall;
{Register a notification for serial device changes}
{Serial: The serial device to notify changes for (Optional, pass nil for all serial devices)}
{Callback: The function to call when a notification event occurs}
{Data: A private data pointer to pass to callback when a notification event occurs}
{Notification: The events to register for notification of (eg DEVICE_NOTIFICATION_REGISTER)}
{Flags: The flags to control the notification (eg NOTIFIER_FLAG_WORKER)}
begin
 {}
 Result:=SerialDeviceNotification(serial,callback,data,notification,flags);
end;

{==============================================================================}
{Serial Helper Functions}
function serial_get_count: uint32_t; stdcall;
{Get the current Serial count}
begin
 {}
 Result:=SerialGetCount;
end;

{==============================================================================}

function serial_device_get_default: PSERIAL_DEVICE; stdcall;
{Get the current default Serial device}
begin
 {}
 Result:=SerialDeviceGetDefault;
end;

{==============================================================================}

function serial_device_set_default(serial: PSERIAL_DEVICE): uint32_t; stdcall;
{Set the current default Serial device}
begin
 {}
 Result:=SerialDeviceSetDefault(serial);
end;

{==============================================================================}

function serial_device_check(serial: PSERIAL_DEVICE): PSERIAL_DEVICE; stdcall;
{Check if the supplied Serial is in the Serial table}
begin
 {}
 Result:=SerialDeviceCheck(serial);
end;

{==============================================================================}

function serial_type_to_string(serialtype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Convert a Serial type value to a string}
begin
 {}
 Result:=APIStringToPCharBuffer(SerialTypeToString(serialtype),_string,len);
end;

{==============================================================================}

function serial_state_to_string(serialstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Convert a Serial state value to a string}
begin
 {}
 Result:=APIStringToPCharBuffer(SerialStateToString(serialstate),_string,len);
end;

{==============================================================================}

function serial_device_redirect_input(serial: PSERIAL_DEVICE): BOOL; stdcall;
{Redirect standard input to the serial device specified by Serial}
{Serial: The serial device to redirect input to (or nil to stop redirection)}
{Return: True if completed successfully or False if an error occurred}
{Note: Redirects the input of the text file Input which also
       redirects the input of Read, ReadLn and the standard C library}
begin
 {}
 Result:=SerialDeviceRedirectInput(serial);
end;

{==============================================================================}

function serial_device_redirect_output(serial: PSERIAL_DEVICE): BOOL; stdcall;
{Redirect standard output to the serial device specified by Serial}
{Serial: The serial device to redirect output to (or nil to stop redirection)}
{Return: True if completed successfully or False if an error occurred}
{Note: Redirects the output of the text files Output, ErrOutput, StdOut and StdErr
       which also redirects the output of Write, WriteLn and the standard C library}
begin
 {}
 Result:=SerialDeviceRedirectOutput(serial);
end;

{==============================================================================}

function serial_buffer_read_start(buffer: PSERIAL_BUFFER; var available: uint32_t): PVOID; stdcall;
{Return a pointer to the next read from the buffer and the number of bytes that can be read}
{Note: Caller must hold the lock on the serial device which owns the buffer}
begin
 {}
 Result:=SerialBufferReadStart(buffer,available);
end;

{==============================================================================}

function serial_buffer_read_complete(buffer: PSERIAL_BUFFER; removed: uint32_t): BOOL; stdcall;
{Update the buffer to reflect the number of bytes removed when reading}
{Note: Caller must hold the lock on the serial device which owns the buffer}
begin
 {}
 Result:=SerialBufferReadComplete(buffer,removed);
end;

{==============================================================================}

function serial_buffer_write_start(buffer: PSERIAL_BUFFER; var available: uint32_t): PVOID; stdcall;
{Return a pointer to the next write to the buffer and the number of bytes that can be written}
{Note: Caller must hold the lock on the serial device which owns the buffer}
begin
 {}
 Result:=SerialBufferWriteStart(buffer,available);
end;

{==============================================================================}

function serial_buffer_write_complete(buffer: PSERIAL_BUFFER; added: uint32_t): BOOL; stdcall;
{Update the buffer to reflect the number of bytes added when writing}
{Note: Caller must hold the lock on the serial device which owns the buffer}
begin
 {}
 Result:=SerialBufferWriteComplete(buffer,added);
end;

{==============================================================================}

function serial_data_bits_to_string(bits: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(SerialDataBitsToString(bits),_string,len);
end;

{==============================================================================}

function serial_stop_bits_to_string(bits: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(SerialStopBitsToString(bits),_string,len);
end;

{==============================================================================}

function serial_parity_to_string(parity: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(SerialParityToString(parity),_string,len);
end;

{==============================================================================}

function serial_flow_control_to_string(flow: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(SerialFlowControlToString(flow),_string,len);
end;

{==============================================================================}
{Serial Logging Helper Functions}
function serial_logging_device_add(serial: PSERIAL_DEVICE): uint32_t; stdcall;
{Add a new serial logging device on receipt of a device register notification}
begin
 {}
 Result:=SerialLoggingDeviceAdd(serial);
end;

{==============================================================================}

function serial_logging_device_remove(serial: PSERIAL_DEVICE): uint32_t; stdcall;
{Remove a serial logging device on receipt of a device deregister notification}
begin
 {}
 Result:=SerialLoggingDeviceRemove(serial);
end;

{==============================================================================}

function serial_logging_device_parameters(serial: PSERIAL_DEVICE; const parameters: PCHAR; var baudrate, parity, databits, stopbits: uint32_t): uint32_t; stdcall;
{Break down the serial parameters value into component parts of baud rate, parity, data bits and stop bits}
{The parameters must be in the form 'BaudRate,Parity,DataBits,StopBits' (eg '115200,N,8,1')}
begin
 {}
 Result:=SerialLoggingDeviceParameters(serial,String(parameters),baudrate,parity,databits,stopbits);
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{RTC Functions}
{$IFDEF API_EXPORT_RTC}
function rtc_device_start(rtc: PRTC_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=RTCDeviceStart(rtc);
end;

{==============================================================================}

function rtc_device_stop(rtc: PRTC_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=RTCDeviceStop(rtc);
end;

{==============================================================================}

function rtc_device_get_time(rtc: PRTC_DEVICE): int64_t; stdcall;
begin
 {}
 Result:=RTCDeviceGetTime(rtc);
end;

{==============================================================================}

function rtc_device_set_time(rtc: PRTC_DEVICE; const time: int64_t): int64_t; stdcall;
begin
 {}
 Result:=RTCDeviceSetTime(rtc,time);
end;

{==============================================================================}

function rtc_device_properties(rtc: PRTC_DEVICE; properties: PRTC_PROPERTIES): uint32_t; stdcall;
{Get the properties for the specified RTC device}
{RTC: The RTC device to get properties from}
{Properties: Pointer to a PRTCProperties structure to fill in}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Replaced by RTCDeviceGetProperties for consistency}
begin
 {}
 Result:=RTCDeviceProperties(rtc,properties);
end;

{==============================================================================}

function rtc_device_get_properties(rtc: PRTC_DEVICE; properties: PRTC_PROPERTIES): uint32_t; stdcall;
{Get the properties for the specified RTC device}
{RTC: The RTC device to get properties from}
{Properties: Pointer to a PRTCProperties structure to fill in}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=RTCDeviceGetProperties(rtc,properties);
end;

{==============================================================================}

function rtc_device_create: PRTC_DEVICE; stdcall;
{Create a new RTC entry}
{Return: Pointer to new RTC entry or nil if RTC could not be created}
begin
 {}
 Result:=RTCDeviceCreate;
end;

{==============================================================================}

function rtc_device_create_ex(size: uint32_t): PRTC_DEVICE; stdcall;
{Create a new RTC entry}
{Size: Size in bytes to allocate for new RTC (Including the RTC entry)}
{Return: Pointer to new RTC entry or nil if RTC could not be created}
begin
 {}
 Result:=RTCDeviceCreateEx(size);
end;

{==============================================================================}

function rtc_device_destroy(rtc: PRTC_DEVICE): uint32_t; stdcall;
{Destroy an existing RTC entry}
begin
 {}
 Result:=RTCDeviceDestroy(rtc);
end;

{==============================================================================}

function rtc_device_register(rtc: PRTC_DEVICE): uint32_t; stdcall;
{Register a new RTC in the RTC table}
begin
 {}
 Result:=RTCDeviceRegister(rtc);
end;

{==============================================================================}

function rtc_device_deregister(rtc: PRTC_DEVICE): uint32_t; stdcall;
{Deregister a RTC from the RTC table}
begin
 {}
 Result:=RTCDeviceDeregister(rtc);
end;

{==============================================================================}

function rtc_device_find(rtcid: uint32_t): PRTC_DEVICE; stdcall;
begin
 {}
 Result:=RTCDeviceFind(rtcid);
end;

{==============================================================================}

function rtc_device_find_by_name(const name: PCHAR): PRTC_DEVICE; stdcall;
begin
 {}
 Result:=RTCDeviceFindByName(String(name));
end;

{==============================================================================}

function rtc_device_find_by_description(const description: PCHAR): PRTC_DEVICE; stdcall;
begin
 {}
 Result:=RTCDeviceFindByDescription(String(description));
end;

{==============================================================================}

function rtc_device_enumerate(callback: rtc_enumerate_cb; data: PVOID): uint32_t; stdcall;
begin
 {}
 Result:=RTCDeviceEnumerate(callback,data);
end;

{==============================================================================}

function rtc_device_notification(rtc: PRTC_DEVICE; callback: rtc_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=RTCDeviceNotification(rtc,callback,data,notification,flags);
end;

{==============================================================================}
{RTC Helper Functions}
function rtc_get_count: uint32_t; stdcall;
{Get the current RTC count}
begin
 {}
 Result:=RTCGetCount;
end;

{==============================================================================}

function rtc_device_get_default: PRTC_DEVICE; stdcall;
{Get the current default RTC device}
begin
 {}
 Result:=RTCDeviceGetDefault;
end;

{==============================================================================}

function rtc_device_set_default(rtc: PRTC_DEVICE): uint32_t; stdcall;
{Set the current default RTC device}
begin
 {}
 Result:=RTCDeviceSetDefault(rtc);
end;

{==============================================================================}

function rtc_device_check(rtc: PRTC_DEVICE): PRTC_DEVICE; stdcall;
{Check if the supplied RTC is in the RTC table}
begin
 {}
 Result:=RTCDeviceCheck(rtc);
end;

{==============================================================================}

function rtc_device_type_to_string(rtctype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(RTCDeviceTypeToString(rtctype),_string,len);
end;

{==============================================================================}

function rtc_device_state_to_string(rtcstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(RTCDeviceStateToString(rtcstate),_string,len);
end;

{==============================================================================}

function rtc_time_is_valid(const time: SYSTEMTIME): BOOL; stdcall;
begin
 {}
 Result:=RTCTimeIsValid(time);
end;

{==============================================================================}

function rtc_systemtime_to_filetime(const systemtime: SYSTEMTIME; var filetime: int64_t): BOOL; stdcall;
{System time is assumed to be UTC and returned file time is UTC}
begin
 {}
 Result:=RTCSystemTimeToFileTime(systemtime,filetime);
end;

{==============================================================================}

function rtc_filetime_to_systemtime(const filetime: int64_t; var systemtime: SYSTEMTIME): BOOL; stdcall;
{File time is assumed to be UTC and returned system time is UTC}
begin
 {}
 Result:=RTCFileTimeToSystemTime(filetime,systemtime);
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{Font Functions}
{$IFDEF API_EXPORT_FONT}
function font_load(header: PFONT_HEADER; data: PFONT_DATA; size: uint32_t): FONT_HANDLE; stdcall;
{Load a Font from a font data block and add to the Font table}
{Header: Pointer to the font header}
{Data: Pointer to the font data}
{Size: Size of the font data}
begin
 {}
 Result:=FontLoad(header,data,size);
end;

{==============================================================================}

function font_load_ex(header: PFONT_HEADER; data: PFONT_DATA; unicode: PFONT_UNICODE; size: uint32_t; properties: PFONT_PROPERTIES): FONT_HANDLE; stdcall;
{Load a Font from a font data block and add to the Font table}
{Header: Pointer to the font header}
{Data: Pointer to the font data}
{Unicode: Pointer to the unicode translation table (Optional)}
{Size: Size of the font data}
{Properties: Pointer to a font properties record to use instead of the header (Optional)}
begin
 {}
 Result:=FontLoadEx(header,data,unicode,size,properties);
end;

{==============================================================================}

function font_unload(handle: FONT_HANDLE): uint32_t; stdcall;
begin
 {}
 Result:=FontUnload(handle);
end;

{==============================================================================}

function font_get_name(handle: FONT_HANDLE; name: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(FontGetName(handle),name,len);
end;

{==============================================================================}

function font_get_description(handle: FONT_HANDLE; description: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(FontGetDescription(handle),description,len);
end;

{==============================================================================}

function font_get_width(handle: FONT_HANDLE): uint32_t; stdcall;
begin
 {}
 Result:=FontGetWidth(handle);
end;

{==============================================================================}

function font_get_height(handle: FONT_HANDLE): uint32_t; stdcall;
begin
 {}
 Result:=FontGetHeight(handle);
end;

{==============================================================================}

function font_get_properties(handle: FONT_HANDLE; properties: PFONT_PROPERTIES): uint32_t; stdcall;
begin
 {}
 Result:=FontGetProperties(handle,properties);
end;

{==============================================================================}

function font_char_width(handle: FONT_HANDLE; character: uint16_t): uint32_t; stdcall;
begin
 {}
 Result:=FontCharWidth(handle,character);
end;

{==============================================================================}

function font_char_height(handle: FONT_HANDLE; character: uint16_t): uint32_t; stdcall;
begin
 {}
 Result:=FontCharHeight(handle,character);
end;

{==============================================================================}

function font_text_width(handle: FONT_HANDLE; const text: PCHAR): uint32_t; stdcall;
begin
 {}
 Result:=FontTextWidth(handle,String(text));
end;

{==============================================================================}

function font_text_height(handle: FONT_HANDLE; const text: PCHAR): uint32_t; stdcall;
begin
 {}
 Result:=FontTextHeight(handle,String(text));
end;

{==============================================================================}

function font_find_by_name(const name: PCHAR): FONT_HANDLE; stdcall;
begin
 {}
 Result:=FontFindByName(String(name));
end;

{==============================================================================}

function font_find_by_description(const description: PCHAR): FONT_HANDLE; stdcall;
begin
 {}
 Result:=FontFindByDescription(String(description));
end;

{==============================================================================}

function font_enumerate(callback: font_enumerate_cb; data: PVOID): uint32_t; stdcall;
begin
 {}
 Result:=FontEnumerate(callback,data);
end;

{==============================================================================}
{PSF Font Functions}
function psf_font_load(const filename: PCHAR): FONT_HANDLE; stdcall;
begin
 {}
 Result:=PSFFontLoad(String(filename));
end;

{==============================================================================}

function psf_font_load_ex(data: PVOID; size: uint32_t): FONT_HANDLE; stdcall;
begin
 {}
 Result:=PSFFontLoadEx(data,size);
end;

{==============================================================================}
{Font Helper Functions}
function font_get_count: uint32_t; stdcall;
{Get the current font count}
begin
 {}
 Result:=FontGetCount;
end;

{==============================================================================}

function font_get_default: FONT_HANDLE; stdcall;
{Get the current default font}
begin
 {}
 Result:=FontGetDefault;
end;

{==============================================================================}

function font_set_default(handle: FONT_HANDLE): uint32_t; stdcall;
{Set the current default font}
begin
 {}
 Result:=FontSetDefault(handle);
end;

{==============================================================================}

function font_check(font: PFONT_ENTRY): PFONT_ENTRY; stdcall;
{Check if the supplied Font is in the Font table}
begin
 {}
 Result:=FontCheck(font);
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{Framebuffer Functions}
{$IFDEF API_EXPORT_FRAMEBUFFER}
function framebuffer_device_allocate(framebuffer: PFRAMEBUFFER_DEVICE; properties: PFRAMEBUFFER_PROPERTIES): uint32_t; stdcall;
{Allocate and enable a framebuffer device using supplied properties or defaults}
{Framebuffer: The framebuffer device to allocate}
{Properties: The framebuffer properties (Width/Height/Depth etc) to use for allocation (Optional)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=FramebufferDeviceAllocate(framebuffer,properties);
end;

{==============================================================================}

function framebuffer_device_release(framebuffer: PFRAMEBUFFER_DEVICE): uint32_t; stdcall;
{Disable and release a framebuffer device}
{Framebuffer: The framebuffer device to release}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=FramebufferDeviceRelease(framebuffer);
end;

{==============================================================================}

function framebuffer_device_blank(framebuffer: PFRAMEBUFFER_DEVICE; blank: BOOL): uint32_t; stdcall;
{Blank (Turn off) the display of a framebuffer device}
{Framebuffer: The framebuffer device to blank}
{Blank: Turn off the display if True / Turn on the display if False}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Not all framebuffer devices support blank, returns ERROR_CALL_NOT_IMPLEMENTED if not supported}
{      Devices that support blank should set the flag FRAMEBUFFER_FLAG_BLANK}
begin
 {}
 Result:=FramebufferDeviceBlank(framebuffer,blank);
end;

{==============================================================================}

function framebuffer_device_read(framebuffer: PFRAMEBUFFER_DEVICE; x, y: uint32_t; buffer: PVOID; len, flags: uint32_t): uint32_t; stdcall;
{Read one or more pixels from framebuffer device memory to a supplied buffer}
{Framebuffer: The framebuffer device to read from}
{X: The column to start reading from}
{Y: The row to start reading from}
{Buffer: Pointer to a buffer to receive the read pixels}
{Len: The number of pixels to read starting at X,Y}
{Flags: The flags for the transfer (eg FRAMEBUFFER_TRANSFER_DMA)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Pixel data will be returned in the color format of the framebuffer}
{Note: X and Y are relative to the physical screen and will be translated to the virtual buffer (Where applicable)}
{Note: The default method assumes that framebuffer memory is DMA coherent and does not require cache cleaning before a DMA read}
begin
 {}
 Result:=FramebufferDeviceRead(framebuffer,x,y,buffer,len,flags);
end;

{==============================================================================}

function framebuffer_device_write(framebuffer: PFRAMEBUFFER_DEVICE; x, y: uint32_t; buffer: PVOID; len, flags: uint32_t): uint32_t; stdcall;
{Write one or more pixels to framebuffer device memory from a supplied buffer}
{Framebuffer: The framebuffer device to write to}
{X: The column to start writing from}
{Y: The row to start writing from}
{Buffer: Pointer to a buffer containing the pixels to write}
{Len: The number of pixels to write starting at X,Y}
{Flags: The flags for the transfer (eg FRAMEBUFFER_TRANSFER_DMA)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Caller must ensure pixel data is in the correct color format for the framebuffer}
{Note: X and Y are relative to the physical screen and will be translated to the virtual buffer (Where applicable)}
{Note: The default method assumes that framebuffer memory is DMA coherent and does not require cache invalidation after a DMA write}
begin
 {}
 Result:=FramebufferDeviceWrite(framebuffer,x,y,buffer,len,flags);
end;

{==============================================================================}

function framebuffer_device_mark(framebuffer: PFRAMEBUFFER_DEVICE; x, y, width, height, flags: uint32_t): uint32_t; stdcall;
{Mark a region written to the framebuffer and signal the device to take any necessary actions}
{Framebuffer: The framebuffer device to mark}
{X: The starting column of the mark}
{Y: The starting row of the mark}
{Width: The number of columns to mark}
{Height: The number of rows to mark}
{Flags: The flags used for the transfer (eg FRAMEBUFFER_TRANSFER_DMA)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: X and Y are relative to the physical screen and will be translated to the virtual buffer (Where applicable)}
{Note: Not all framebuffer devices support mark, returns ERROR_CALL_NOT_IMPLEMENTED if not supported}
{      Devices that support and require mark should set the flag FRAMEBUFFER_FLAG_MARK}
begin
 {}
 Result:=FramebufferDeviceMark(framebuffer,x,y,width,height,flags);
end;

{==============================================================================}

function framebuffer_device_commit(framebuffer: PFRAMEBUFFER_DEVICE; address: SIZE_T; size, flags: uint32_t): uint32_t; stdcall;
{Commit a region written to the framebuffer and signal the device to take any necessary actions}
{Framebuffer: The framebuffer device to commit}
{Address: The starting address of the commit}
{Size: The size in bytes of the commit}
{Flags: The flags used for the transfer (eg FRAMEBUFFER_TRANSFER_DMA)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Not all framebuffer devices support commit, returns ERROR_CALL_NOT_IMPLEMENTED if not supported}
{      Devices that support and require commit should set the flag FRAMEBUFFER_FLAG_COMMIT}
begin
 {}
 Result:=FramebufferDeviceCommit(framebuffer,address,size,flags);
end;

{==============================================================================}

function framebuffer_device_get_rect(framebuffer: PFRAMEBUFFER_DEVICE; x, y: uint32_t; buffer: PVOID; width, height, skip, flags: uint32_t): uint32_t; stdcall;
{Get a rectangular area of pixels from framebuffer memory to a supplied buffer}
{Framebuffer: The framebuffer device to get from}
{X: The starting column of the get}
{Y: The starting row of the get}
{Buffer: Pointer to a block of memory large enough to hold the pixels in a contiguous block of rows}
{Width: The number of columns to get}
{Height: The number of rows to get}
{Skip: The number of pixels to skip in the buffer after each row (Optional)}
{Flags: The flags for the transfer (eg FRAMEBUFFER_TRANSFER_DMA)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Pixel data will be returned in the color format of the framebuffer}
{Note: X and Y are relative to the physical screen and will be translated to the virtual buffer (Where applicable)}
{Note: The default method assumes that framebuffer memory is DMA coherent and does not require cache cleaning before a DMA read}
begin
 {}
 Result:=FramebufferDeviceGetRect(framebuffer,x,y,buffer,width,height,skip,flags);
end;

{==============================================================================}

function framebuffer_device_put_rect(framebuffer: PFRAMEBUFFER_DEVICE; x, y: uint32_t; buffer: PVOID; width, height, skip, flags: uint32_t): uint32_t; stdcall;
{Put a rectangular area of pixels from a supplied buffer to framebuffer memory}
{Framebuffer: The framebuffer device to put to}
{X: The starting column of the put}
{Y: The starting row of the put}
{Buffer: Pointer to a block of memory containing the pixels in a contiguous block of rows}
{Width: The number of columns to put}
{Height: The number of rows to put}
{Skip: The number of pixels to skip in the buffer after each row (Optional)}
{Flags: The flags for the transfer (eg FRAMEBUFFER_TRANSFER_DMA)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Caller must ensure pixel data is in the correct color format for the framebuffer}
{Note: X and Y are relative to the physical screen and will be translated to the virtual buffer (Where applicable)}
{Note: The default method assumes that framebuffer memory is DMA coherent and does not require cache invalidation after a DMA write}
begin
 {}
 Result:=FramebufferDevicePutRect(framebuffer,x,y,buffer,width,height,skip,flags);
end;

{==============================================================================}

function framebuffer_device_copy_rect(framebuffer: PFRAMEBUFFER_DEVICE; x1, y1, x2, y2, width, height, flags: uint32_t): uint32_t; stdcall;
{Copy a rectangular area of pixels within framebuffer memory}
{Framebuffer: The framebuffer device to copy on}
{X1: The starting column to copy from}
{Y1: The starting row to copy from}
{X2: The starting column to copy to}
{Y2: The starting row to copy to}
{Width: The number of columns to copy}
{Height: The number of rows to copy}
{Flags: The flags for the transfer (eg FRAMEBUFFER_TRANSFER_DMA)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: X1, Y1, X2 and Y2 are relative to the physical screen and will be translated to the virtual buffer (Where applicable)}
{Note: The default method assumes that framebuffer memory is DMA coherent and does not require cache clean/invalidate before or after a DMA read/write}
begin
 {}
 Result:=FramebufferDeviceCopyRect(framebuffer,x1,y1,x2,y2,width,height,flags);
end;

{==============================================================================}

function framebuffer_device_fill_rect(framebuffer: PFRAMEBUFFER_DEVICE; x, y, width, height, color, flags: uint32_t): uint32_t; stdcall;
{Fill a rectangular area of pixels within framebuffer memory}
{Framebuffer: The framebuffer device to fill on}
{X: The starting column of the fill}
{Y: The starting row of the fill}
{Width: The number of columns to fill}
{Height: The number of rows to fill}
{Color: The color to use for the fill}
{Flags: The flags for the transfer (eg FRAMEBUFFER_TRANSFER_DMA)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Color must be specified in the correct format for the framebuffer}
{Note: X and Y are relative to the physical screen and will be translated to the virtual buffer (Where applicable)}
{Note: The default method assumes that framebuffer memory is DMA coherent and does not require cache invalidation after a DMA write}
begin
 {}
 Result:=FramebufferDeviceFillRect(framebuffer,x,y,width,height,color,flags);
end;

{==============================================================================}

function framebuffer_device_get_line(framebuffer: PFRAMEBUFFER_DEVICE; y: uint32_t): PVOID; stdcall;
{Get the address of the start of a row in framebuffer memory}
{Framebuffer: The framebuffer device to get the start address from}
{Y: The row to get the start address of}
{Return: Pointer to the start address of the row or nil on failure}
{Note: Y is relative to the physical screen and will be translated to the virtual buffer (Where applicable)}
begin
 {}
 Result:=FramebufferDeviceGetLine(framebuffer,y);
end;

{==============================================================================}

function framebuffer_device_get_point(framebuffer: PFRAMEBUFFER_DEVICE; x, y: uint32_t): PVOID; stdcall;
{Get the address of the specified row and column in framebuffer memory}
{Framebuffer: The framebuffer device to get the address from}
{X: The column to get the start address of}
{Y: The row to get the start address of}
{Return: Pointer to the address of the row and column or nil on failure}
{Note: X and Y are relative to the physical screen and will be translated to the virtual buffer (Where applicable)}
begin
 {}
 Result:=FramebufferDeviceGetPoint(framebuffer,x,y);
end;

{==============================================================================}

function framebuffer_device_wait_sync(framebuffer: PFRAMEBUFFER_DEVICE): uint32_t; stdcall;
{Wait for the next vertical sync signal from the display hardware}
{Framebuffer: The framebuffer device to wait for}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Not all framebuffer devices support wait sync, returns ERROR_CALL_NOT_IMPLEMENTED if not supported}
{      Devices that support wait sync should set the flag FRAMEBUFFER_FLAG_SYNC}
begin
 {}
 Result:=FramebufferDeviceWaitSync(framebuffer);
end;

{==============================================================================}

function framebuffer_device_get_offset(framebuffer: PFRAMEBUFFER_DEVICE; var x, y: uint32_t): uint32_t; stdcall;
{Get the virtual offset X and Y from a framebuffer device}
{Framebuffer: The framebuffer device to get the offset from}
{X: The X (Column) offset value in pixels returned from the device if successful}
{Y: The Y (Row) offset value in pixels returned from the device if successful}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: X and Y are relative to the virtual buffer and NOT the physical screen (Where applicable)}
{Note: Not all framebuffer devices support X and/or Y offset}
{      Devices that support offset X should set the flag FRAMEBUFFER_FLAG_OFFSETX}
{      Devices that support offset Y should set the flag FRAMEBUFFER_FLAG_OFFSETY}
begin
 {}
 Result:=FramebufferDeviceGetOffset(framebuffer,x,y);
end;

{==============================================================================}

function framebuffer_device_set_offset(framebuffer: PFRAMEBUFFER_DEVICE; x, y: uint32_t; pan: BOOL): uint32_t; stdcall;
{Set the virtual offset X and Y of a framebuffer device}
{Framebuffer: The framebuffer device to set the offset for}
{X: The X (Column) offset value in pixels to set}
{Y: The Y (Row) offset value in pixels to set}
{Pan: If True then pan the display without updating the Offset X and/or Y}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: X and Y are relative to the virtual buffer and NOT the physical screen (Where applicable)}
{Note: Not all framebuffer devices support X and/or Y offset, returns ERROR_CALL_NOT_IMPLEMENTED if not supported}
{      Devices that support offset X should set the flag FRAMEBUFFER_FLAG_OFFSETX}
{      Devices that support offset Y should set the flag FRAMEBUFFER_FLAG_OFFSETY}
begin
 {}
 Result:=FramebufferDeviceSetOffset(framebuffer,x,y,pan);
end;

{==============================================================================}

function framebuffer_device_set_offset_ex(framebuffer: PFRAMEBUFFER_DEVICE; x, y: uint32_t; pan, switch: BOOL): uint32_t; stdcall;
{Set the virtual offset X and Y of a framebuffer device}
{Framebuffer: The framebuffer device to set the offset for}
{X: The X (Column) offset value in pixels to set}
{Y: The Y (Row) offset value in pixels to set}
{Pan: If True then pan the display without updating the Offset X and/or Y}
{Switch: If False then update the Offset X and/or Y without moving the display}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: X and Y are relative to the virtual buffer and NOT the physical screen (Where applicable)}
{Note: Not all framebuffer devices support X and/or Y offset, returns ERROR_CALL_NOT_IMPLEMENTED if not supported}
{      Devices that support offset X should set the flag FRAMEBUFFER_FLAG_OFFSETX}
{      Devices that support offset Y should set the flag FRAMEBUFFER_FLAG_OFFSETY}
begin
 {}
 Result:=FramebufferDeviceSetOffsetEx(framebuffer,x,y,pan,switch);
end;

{==============================================================================}

function framebuffer_device_get_palette(framebuffer: PFRAMEBUFFER_DEVICE; palette: PFRAMEBUFFER_PALETTE): uint32_t; stdcall;
{Get the 8 bit color palette from a framebuffer device}
{Framebuffer: The framebuffer device to get the palette from}
{Palette: Pointer to a TFramebufferPalette structure for the palette data}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Not all framebuffer devices support 8 bit palette, returns ERROR_CALL_NOT_IMPLEMENTED if not supported}
begin
 {}
 Result:=FramebufferDeviceGetPalette(framebuffer,palette);
end;

{==============================================================================}

function framebuffer_device_set_palette(framebuffer: PFRAMEBUFFER_DEVICE; palette: PFRAMEBUFFER_PALETTE): uint32_t; stdcall;
{Set the 8 bit color palette of a framebuffer device}
{Framebuffer: The framebuffer device to set the palette for}
{Palette: Pointer to a TFramebufferPalette structure for the palette data}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Not all framebuffer devices support 8 bit palette, returns ERROR_CALL_NOT_IMPLEMENTED if not supported}
begin
 {}
 Result:=FramebufferDeviceSetPalette(framebuffer,palette);
end;

{==============================================================================}

function framebuffer_device_set_backlight(framebuffer: PFRAMEBUFFER_DEVICE; brightness: uint32_t): uint32_t; stdcall;
{Set the brightness of the backlight of a framebuffer device}
{Framebuffer: The framebuffer device to set the backlight}
{Brightness: The brightness value to set (Normally 0 to 100)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Not all framebuffer devices support set backlight, returns ERROR_CALL_NOT_IMPLEMENTED if not supported}
{      Devices that support set backlight should set the flag FRAMEBUFFER_FLAG_BACKLIGHT}
begin
 {}
 Result:=FramebufferDeviceSetBacklight(framebuffer,brightness);
end;

{==============================================================================}

function framebuffer_device_set_cursor(framebuffer: PFRAMEBUFFER_DEVICE; width, height, hotspotx, hotspoty: uint32_t; image: PVOID; len: uint32_t): uint32_t; stdcall;
{Set the mouse cursor image and properties of a framebuffer device}
{Framebuffer: The framebuffer device to set the cursor}
{Width: The width of the cursor image in pixels}
{Height: The height of the cursor image in pixels}
{HotspotX: The X hotspot of the cursor image, where the cursor X location will be (Normally 0)}
{HotspotY: The Y hotspot of the cursor image, where the cursor Y location will be (Normally 0)}
{Image: A buffer containing the cursor image pixels in COLOR_FORMAT_DEFAULT format}
{Len: The length of the image buffer in bytes}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For devices that don't support hardware mouse cursor a software cursor will be implemented
       If image is nil then the default cursor image will be used}
begin
 {}
 Result:=FramebufferDeviceSetCursor(framebuffer,width,height,hotspotx,hotspoty,image,len);
end;

{==============================================================================}

function framebuffer_device_update_cursor(framebuffer: PFRAMEBUFFER_DEVICE; enabled: BOOL; x, y: int32_t; relative: BOOL): uint32_t; stdcall;
{Update the position and state for the mouse cursor of a framebuffer device}
{Framebuffer: The framebuffer device to update the cursor}
{Enabled: If true then show the cursor else hide it}
{X: The cursor X location in pixels}
{Y: The cursor Y location in pixels}
{Relative: If true then X and Y are considered relative to the current position}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For devices that don't support hardware mouse cursor a software cursor will be implemented}
begin
 {}
 Result:=FramebufferDeviceUpdateCursor(framebuffer,enabled,x,y,relative);
end;

{==============================================================================}

function framebuffer_device_get_properties(framebuffer: PFRAMEBUFFER_DEVICE; properties: PFRAMEBUFFER_PROPERTIES): uint32_t; stdcall;
{Get the current properties from a framebuffer device}
{Framebuffer: The framebuffer device to get properties from}
{Properties: Pointer to a TFramebufferProperties structure to return}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=FramebufferDeviceGetProperties(framebuffer,properties);
end;

{==============================================================================}

function framebuffer_device_set_properties(framebuffer: PFRAMEBUFFER_DEVICE; properties: PFRAMEBUFFER_PROPERTIES): uint32_t; stdcall;
{Set the current properties for a framebuffer device}
{Framebuffer: The framebuffer device to set properties for}
{Properties: Pointer to a TFramebufferProperties structure containing the properties}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Changing certain properties may cause the framebuffer to be reallocated}
begin
 {}
 Result:=FramebufferDeviceSetProperties(framebuffer,properties);
end;

{==============================================================================}

function framebuffer_device_check_flag(framebuffer: PFRAMEBUFFER_DEVICE; flag: uint32_t): BOOL; stdcall;
{Check if a framebuffer device supports a flag value}
{Framebuffer: The framebuffer device to check}
{Flag: The framebuffer flag to check (eg FRAMEBUFFER_FLAG_BACKLIGHT)}
{Return: True if flag is supported, False if not or on error}
begin
 {}
 Result:=FramebufferDeviceCheckFlag(framebuffer,flag);
end;

{==============================================================================}

function framebuffer_device_get_format(framebuffer: PFRAMEBUFFER_DEVICE): uint32_t; stdcall;
{Get the color format of a framebuffer device}
{Framebuffer: The framebuffer device to get from}
{Return: The color format of the framebuffer (eg COLOR_FORMAT_RGB24)}
begin
 {}
 Result:=FramebufferDeviceGetFormat(framebuffer);
end;

{==============================================================================}

function framebuffer_device_create: PFRAMEBUFFER_DEVICE; stdcall;
{Create a new Framebuffer entry}
{Return: Pointer to new Framebuffer entry or nil if Framebuffer could not be created}
begin
 {}
 Result:=FramebufferDeviceCreate;
end;

{==============================================================================}

function framebuffer_device_create_ex(size: uint32_t): PFRAMEBUFFER_DEVICE; stdcall;
{Create a new Framebuffer entry}
{Size: Size in bytes to allocate for new Framebuffer (Including the Framebuffer entry)}
{Return: Pointer to new Framebuffer entry or nil if Framebuffer could not be created}
begin
 {}
 Result:=FramebufferDeviceCreateEx(size);
end;

{==============================================================================}

function framebuffer_device_destroy(framebuffer: PFRAMEBUFFER_DEVICE): uint32_t; stdcall;
{Destroy an existing Framebuffer entry}
{Framebuffer: The framebuffer device to destroy}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=FramebufferDeviceDestroy(framebuffer);
end;

{==============================================================================}

function framebuffer_device_register(framebuffer: PFRAMEBUFFER_DEVICE): uint32_t; stdcall;
{Register a new Framebuffer in the Framebuffer table}
{Framebuffer: The framebuffer device to register}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=FramebufferDeviceRegister(framebuffer);
end;

{==============================================================================}

function framebuffer_device_deregister(framebuffer: PFRAMEBUFFER_DEVICE): uint32_t; stdcall;
{Deregister a Framebuffer from the Framebuffer table}
{Framebuffer: The framebuffer device to deregister}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=FramebufferDeviceDeregister(framebuffer);
end;

{==============================================================================}

function framebuffer_device_find(framebufferid: uint32_t): PFRAMEBUFFER_DEVICE; stdcall;
{Find a framebuffer device by ID in the framebuffer table}
{FramebufferId: The ID number of the framebuffer to find}
{Return: Pointer to framebuffer device entry or nil if not found}
begin
 {}
 Result:=FramebufferDeviceFind(framebufferid);
end;

{==============================================================================}

function framebuffer_device_find_by_name(const name: PCHAR): PFRAMEBUFFER_DEVICE; stdcall;
{Find a framebuffer device by name in the framebuffer table}
{Name: The name of the framebuffer to find (eg Framebuffer0)}
{Return: Pointer to framebuffer device entry or nil if not found}
begin
 {}
 Result:=FramebufferDeviceFindByName(String(name));
end;

{==============================================================================}

function framebuffer_device_find_by_description(const description: PCHAR): PFRAMEBUFFER_DEVICE; stdcall;
{Find a framebuffer device by description in the framebuffer table}
{Description: The description of the framebuffer to find (eg BCM2836 Framebuffer)}
{Return: Pointer to framebuffer device entry or nil if not found}
begin
 {}
 Result:=FramebufferDeviceFindByDescription(String(description));
end;

{==============================================================================}

function framebuffer_device_enumerate(callback: framebuffer_enumerate_cb; data: PVOID): uint32_t; stdcall;
{Enumerate all framebuffer devices in the framebuffer table}
{Callback: The callback function to call for each framebuffer in the table}
{Data: A private data pointer to pass to callback for each framebuffer in the table}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=FramebufferDeviceEnumerate(callback,data);
end;

{==============================================================================}

function framebuffer_device_notification(framebuffer: PFRAMEBUFFER_DEVICE; callback: framebuffer_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall;
{Register a notification for framebuffer device changes}
{Framebuffer: The framebuffer device to notify changes for (Optional, pass nil for all framebuffer devices)}
{Callback: The function to call when a notification event occurs}
{Data: A private data pointer to pass to callback when a notification event occurs}
{Notification: The events to register for notification of (eg DEVICE_NOTIFICATION_REGISTER)}
{Flags: The flags to control the notification (eg NOTIFIER_FLAG_WORKER)}
begin
 {}
 Result:=FramebufferDeviceNotification(framebuffer,callback,data,notification,flags);
end;

{==============================================================================}
{Framebuffer Helper Functions}
function framebuffer_device_get_count: uint32_t; stdcall;
{Get the current framebuffer device count}
begin
 {}
 Result:=FramebufferDeviceGetCount;
end;

{==============================================================================}

function framebuffer_device_get_default: PFRAMEBUFFER_DEVICE; stdcall;
{Get the current default framebuffer device}
begin
 {}
 Result:=FramebufferDeviceGetDefault;
end;

{==============================================================================}

function framebuffer_device_set_default(framebuffer: PFRAMEBUFFER_DEVICE): uint32_t; stdcall;
{Set the current default framebuffer device}
begin
 {}
 Result:=FramebufferDeviceSetDefault(framebuffer);
end;

{==============================================================================}

function framebuffer_device_check(framebuffer: PFRAMEBUFFER_DEVICE): PFRAMEBUFFER_DEVICE; stdcall;
{Check if the supplied Framebuffer device is in the Framebuffer table}
begin
 {}
 Result:=FramebufferDeviceCheck(framebuffer);
end;

{==============================================================================}

function framebuffer_device_swap(value: uint32_t): uint32_t; stdcall;
{No longer required (See ColorDefaultToFormat and ColorFormatToDefault)}
begin
 {}
 Result:=FramebufferDeviceSwap(value);
end;

{==============================================================================}

function framebuffer_type_to_string(framebuffertype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Convert a Framebuffer type value to a string}
begin
 {}
 Result:=APIStringToPCharBuffer(FramebufferTypeToString(framebuffertype),_string,len);
end;

{==============================================================================}

function framebuffer_state_to_string(framebufferstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Convert a Framebuffer state value to a string}
begin
 {}
 Result:=APIStringToPCharBuffer(FramebufferStateToString(framebufferstate),_string,len);
end;

{==============================================================================}

procedure framebuffer_device_hide_cursor(framebuffer: PFRAMEBUFFER_DEVICE); stdcall;
{Restore the framebuffer area under the cursor from the cursor buffer}
{Note: Caller must hold the framebuffer lock}
{Note: Driver support function only, not intended for direct use by applications}
begin
 {}
 FramebufferDeviceHideCursor(framebuffer);
end;

{==============================================================================}

procedure framebuffer_device_show_cursor(framebuffer: PFRAMEBUFFER_DEVICE); stdcall;
{Save the framebuffer area under the cursor to the cursor buffer and merge the
 cursor input with it to create the cursor output. Put the output to the framebuffer}
{Note: Caller must hold the framebuffer lock}
{Note: Driver support function only, not intended for direct use by applications}
begin
 {}
 FramebufferDeviceShowCursor(framebuffer);
end;

{==============================================================================}

function framebuffer_cursor_to_string(state: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(FramebufferCursorToString(state),_string,len);
end;

{==============================================================================}

function framebuffer_depth_to_string(depth: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(FramebufferDepthToString(depth),_string,len);
end;

{==============================================================================}

function framebuffer_order_to_string(order: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(FramebufferOrderToString(order),_string,len);
end;

{==============================================================================}

function framebuffer_mode_to_string(mode: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(FramebufferModeToString(mode),_string,len);
end;

{==============================================================================}

function framebuffer_rotation_to_string(rotation: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(FramebufferRotationToString(rotation),_string,len);
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{Graphics Console Functions}
{$IFDEF API_EXPORT_GRAPHICSCONSOLE}
function graphics_window_create(console: PCONSOLE_DEVICE; position: uint32_t): WINDOW_HANDLE; stdcall;
{Create a new Graphics window}
{Console: The console device to create the new window on}
{Position: The console position to create the new window at (eg CONSOLE_POSITION_FULL)}
{Return: Handle to new Graphics window or INVALID_HANDLE_VALUE if the window could not be created}
begin
 {}
 Result:=GraphicsWindowCreate(console,position);
end;

{==============================================================================}

function graphics_window_create_ex(console: PCONSOLE_DEVICE; font: FONT_HANDLE; size, state, mode, position: uint32_t): WINDOW_HANDLE; stdcall;
{Create a new Graphics window}
{Console: The console device to create the new window on}
{Font: The handle of the default font for the new console window}
{Size: The size in bytes to allocate for the new window entry (Defaults to SizeOf(TGraphicsWindow))}
{State: The state of the new console window (WINDOW_STATE_VISIBLE or WINDOW_STATE_INVISIBLE)}
{Mode: The mode of the new console window (Normally WINDOW_MODE_GRAPHICS)}
{Position: The console position to create the new window at (eg CONSOLE_POSITION_FULL)}
{Return: Handle to new Graphics window or INVALID_HANDLE_VALUE if the window could not be created}
begin
 {}
 Result:=GraphicsWindowCreateEx(console,font,size,state,mode,position);
end;

{==============================================================================}

function graphics_window_destroy(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Close and Destroy an existing console window}
{Handle: The handle of the window to destroy}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=GraphicsWindowDestroy(handle);
end;

{==============================================================================}

function graphics_window_show(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Make an existing console window visible and show it on screen}
{Handle: The handle of the window to show}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=GraphicsWindowShow(handle);
end;

{==============================================================================}

function graphics_window_hide(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Make an existing console window invisible and hide it on screen}
{Handle: The handle of the window to hide}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=GraphicsWindowHide(handle);
end;

{==============================================================================}

function graphics_window_activate(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Make an existing console window the active window}
{Handle: The handle of the window to activate}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=GraphicsWindowActivate(handle);
end;

{==============================================================================}

function graphics_window_deactivate(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Make an existing console window inactive}
{Handle: The handle of the window to deactivate}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: On success there will be no active window set}
begin
 {}
 Result:=GraphicsWindowDeactivate(handle);
end;

{==============================================================================}

function graphics_window_next(console: PCONSOLE_DEVICE; visible: BOOL): WINDOW_HANDLE; stdcall;
{Get the next console window starting with the active window}
{Console: The console device to change the active window on}
{Visible: If true only return windows that are visible}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=GraphicsWindowNext(console,visible);
end;

{==============================================================================}

function graphics_window_previous(console: PCONSOLE_DEVICE; visible: BOOL): WINDOW_HANDLE; stdcall;
{Get the previous console window starting with the active window}
{Console: The console device to change the active window on}
{Visible: If true only return windows that are visible}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=GraphicsWindowPrevious(console,visible);
end;

{==============================================================================}

function graphics_window_at(console: PCONSOLE_DEVICE; x, y: uint32_t; visible: BOOL): WINDOW_HANDLE; stdcall;
{Find the console window that X and Y coordinates are within}
{Console: The console device to find the window on}
{X: The X coordinate to find the window for}
{Y: The Y coordinate to find the window for}
{Visible: If true only return windows that are visible}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For Graphics Console functions, X and Y are based on screen pixels not characters}
begin
 {}
 Result:=GraphicsWindowAt(console,x,y,visible);
end;

{==============================================================================}

function graphics_window_find(console: PCONSOLE_DEVICE; position: uint32_t): WINDOW_HANDLE; stdcall;
{Find an existing console window in the position specified}
{Console: The console device to find the window on}
{Position: The window position to find (eg CONSOLE_POSITION_FULL)}
{Return: The handle of the existing window or INVALID_HANDLE_VALUE if not found}
begin
 {}
 Result:=GraphicsWindowFind(console,position);
end;

{==============================================================================}

function graphics_window_enumerate(console: PCONSOLE_DEVICE; callback: graphics_window_enumerate_cb; data: PVOID): uint32_t; stdcall;
{Enumerate existing console windows on the specified console device}
{Console: The console device to enumerate windows for}
{Callback: The function to call for each window enumerated}
{Data: A pointer to private data to be passed to the callback (Optional)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=GraphicsWindowEnumerate(console,callback,data);
end;

{==============================================================================}

function graphics_window_check_flag(handle: WINDOW_HANDLE; flag: uint32_t): BOOL; stdcall;
{Check an existing console window to determine if a flag is set or not}
{Handle: The handle of the window to check}
{Flag: The window flag to check for (eg WINDOW_FLAG_LINE_WRAP)}
{Return: True if the flag is set, False if not set}
begin
 {}
 Result:=GraphicsWindowCheckFlag(handle,flag);
end;

{==============================================================================}

function graphics_window_update_flag(handle: WINDOW_HANDLE; flag: uint32_t; clear: BOOL): uint32_t; stdcall;
{Set or clear a flag on an existing console window}
{Handle: The handle of the window to set or clear the flag on}
{Flag: The window flag to set or clear (eg WINDOW_FLAG_LINE_WRAP)}
{Clear: If true clear the flag, else set it}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=GraphicsWindowUpdateFlag(handle,flag,clear);
end;

{==============================================================================}

function graphics_window_get_mode(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Get the window mode of an existing console window}
{Handle: The handle of the window to get the mode for}
{Return: The window mode (eg WINDOW_MODE_GRAPHICS)}
begin
 {}
 Result:=GraphicsWindowGetMode(handle);
end;

{==============================================================================}

function graphics_window_get_state(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Get the window state of an existing console window}
{Handle: The handle of the window to get the state for}
{Return: The window state (eg WINDOW_STATE_INVISIBLE)}
begin
 {}
 Result:=GraphicsWindowGetState(handle);
end;

{==============================================================================}

function graphics_window_get_position(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Get the position of an existing console window}
{Handle: The handle of the window to get the position for}
{Return: The window position (eg CONSOLE_POSITION_FULL)}
begin
 {}
 Result:=GraphicsWindowGetPosition(handle);
end;

{==============================================================================}

function graphics_window_set_position(handle: WINDOW_HANDLE; position: uint32_t): uint32_t; stdcall;
{Set the position of an existing console window}
{Handle: The handle of the window to set the position for}
{Position: The new window position to set}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: The function will return ERROR_INVALID_PARAMETER if another window exists at the position}
begin
 {}
 Result:=GraphicsWindowSetPosition(handle,position);
end;

{==============================================================================}

function graphics_window_get_properties(handle: WINDOW_HANDLE; properties: PWINDOW_PROPERTIES): uint32_t; stdcall;
{Get the properties for the specified console window}
{Handle: The handle of the window to get the properties from}
{Properties: Pointer to a TWindowProperties structure to fill in}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=GraphicsWindowGetProperties(handle,properties);
end;

{==============================================================================}

function graphics_window_get_min_x(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Get the current minimum X of the window viewport for an existing console window}
{Handle: The handle of the window to get MinX for}
{Return: The minimum X value for the current window viewport}
{Note: For Graphics Console functions, X is based on screen pixels not characters}
begin
 {}
 Result:=GraphicsWindowGetMinX(handle);
end;

{==============================================================================}

function graphics_window_get_min_y(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Get the current minimum Y of the window viewport for an existing console window}
{Handle: The handle of the window to get MinY for}
{Return: The minimum Y value for the current window viewport}
{Note: For Graphics Console functions, Y is based on screen pixels not characters}
begin
 {}
 Result:=GraphicsWindowGetMinY(handle);
end;

{==============================================================================}

function graphics_window_get_max_x(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Get the current maximum X of the window viewport for an existing console window}
{Handle: The handle of the window to get MaxX for}
{Return: The maximum X value for the current window viewport}
{Note: For Graphics Console functions, X is based on screen pixels not characters}
begin
 {}
 Result:=GraphicsWindowGetMaxX(handle);
end;

{==============================================================================}

function graphics_window_get_max_y(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Get the current maximum Y of the window viewport for an existing console window}
{Handle: The handle of the window to get MaxY for}
{Return: The maximum Y value for the current window viewport}
{Note: For Graphics Console functions, Y is based on screen pixels not characters}
begin
 {}
 Result:=GraphicsWindowGetMaxY(handle);
end;

{==============================================================================}

function graphics_window_get_rect(handle: WINDOW_HANDLE): TCONSOLE_RECT; stdcall;
{Get the rectangle X1,Y1,X2,Y2 of the window viewport for an existing console window}
{Handle: The handle of the window to get the rectangle for}
{Return: The rectangle of the current window viewport}
{Note: For Graphics Console functions, Rect is based on screen pixels not characters}
begin
 {}
 Result:=GraphicsWindowGetRect(handle);
end;

{==============================================================================}

function graphics_window_set_rect(handle: WINDOW_HANDLE; const rect: TCONSOLE_RECT): uint32_t; stdcall;
{Set the rectangle X1,Y1,X2,Y2 of the window viewport for an existing console window}
{Handle: The handle of the window to set the rectangle for}
{Rect: The rectangle to set for the window viewport}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For Graphics Console functions, Rect is based on screen pixels not characters}
begin
 {}
 Result:=GraphicsWindowSetRect(handle,rect);
end;

{==============================================================================}

function graphics_window_reset_rect(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Reset the window viewport for an existing console window to the maximum size}
{Handle: The handle of the window to reset the viewport for}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=GraphicsWindowResetRect(handle);
end;

{==============================================================================}

function graphics_window_get_viewport(handle: WINDOW_HANDLE; var x1, y1, x2, y2: uint32_t): uint32_t; stdcall;
{Get the X1,Y1,X2,Y2 of the window viewport for an existing console window}
{Handle: The handle of the window to get the viewport for}
{X1: The left edge of the current viewport}
{Y1: The top edge of the current viewport}
{X2: The right edge of the current viewport}
{Y2: The bottom edge of the current viewport}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For Graphics Console functions, Viewport is based on screen pixels not characters}
begin
 {}
 Result:=GraphicsWindowGetViewport(handle,x1,y1,x2,y2);
end;

{==============================================================================}

function graphics_window_set_viewport(handle: WINDOW_HANDLE; x1, y1, x2, y2: uint32_t): uint32_t; stdcall;
{Set the X1,Y1,X2,Y2 of the window viewport for an existing console window}
{Handle: The handle of the window to get the viewport for}
{X1: The left edge of the window viewport}
{Y1: The top edge of the window viewport}
{X2: The right edge of the window viewport}
{Y2: The bottom edge of the window viewport}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For Graphics Console functions, Viewport is based on screen pixels not characters}
begin
 {}
 Result:=GraphicsWindowSetViewport(handle,x1,y1,x2,y2);
end;

{==============================================================================}

function graphics_window_reset_viewport(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Reset the window viewport for an existing console window to the maximum size}
{Handle: The handle of the window to reset the viewport for}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=GraphicsWindowResetViewport(handle);
end;

{==============================================================================}

function graphics_window_get_cols(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Get the current columns of the window viewport for an existing console window}
{Handle: The handle of the window to get columns for}
{Return: The columns value for the current window viewport}
{Note: For Graphics Console functions, Columns is based on screen pixels not characters}
begin
 {}
 Result:=GraphicsWindowGetCols(handle);
end;

{==============================================================================}

function graphics_window_get_rows(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Get the current rows of the window viewport for an existing console window}
{Handle: The handle of the window to get rows for}
{Return: The rows value for the current window viewport}
{Note: For Graphics Console functions, Rows is based on screen pixels not characters}
begin
 {}
 Result:=GraphicsWindowGetRows(handle);
end;

{==============================================================================}

function graphics_window_get_width(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Get the absolute width of an existing console window}
{Handle: The handle of the window to get the width for}
{Return: The absolute width of the window}
{Note: For Graphics Console functions, Width is based on screen pixels not characters}
begin
 {}
 Result:=GraphicsWindowGetWidth(handle);
end;

{==============================================================================}

function graphics_window_get_height(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Get the absolute height of an existing console window}
{Handle: The handle of the window to get the height for}
{Return: The absolute height of the window}
{Note: For Graphics Console functions, Height is based on screen pixels not characters}
begin
 {}
 Result:=GraphicsWindowGetHeight(handle);
end;

{==============================================================================}

function graphics_window_get_format(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Get the color format of an existing console window}
{Handle: The handle of the window to get the format for}
{Return: The color format of the window (eg COLOR_FORMAT_ARGB32)}
begin
 {}
 Result:=GraphicsWindowGetFormat(handle);
end;

{==============================================================================}

function graphics_window_get_forecolor(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Get the current foreground color of an existing console window}
{Handle: The handle of the window to get the foreground color for}
{Return: The foreground color of the window (eg COLOR_WHITE)}
begin
 {}
 Result:=GraphicsWindowGetForecolor(handle);
end;

{==============================================================================}

function graphics_window_set_forecolor(handle: WINDOW_HANDLE; color: uint32_t): uint32_t; stdcall;
{Set the current foreground color of an existing console window}
{Handle: The handle of the window to set the foreground color for}
{Color: The foreground color to set (eg COLOR_WHITE)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=GraphicsWindowSetForecolor(handle,color);
end;

{==============================================================================}

function graphics_window_get_backcolor(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Get the current background color of an existing console window}
{Handle: The handle of the window to get the background color for}
{Return: The background color of the window (eg COLOR_BLACK)}
begin
 {}
 Result:=GraphicsWindowGetBackcolor(handle);
end;

{==============================================================================}

function graphics_window_set_backcolor(handle: WINDOW_HANDLE; color: uint32_t): uint32_t; stdcall;
{Set the current background color of an existing console window}
{Handle: The handle of the window to set the background color for}
{Color: The background color to set (eg COLOR_BLACK)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=GraphicsWindowSetBackcolor(handle,color);
end;

{==============================================================================}

function graphics_window_get_font(handle: WINDOW_HANDLE): FONT_HANDLE; stdcall;
{Get the default font of an existing console window}
{Handle: The handle of the window to get the default font for}
{Return: The font handle of the default font or INVALID_HANDLE_VALUE on error}
begin
 {}
 Result:=GraphicsWindowGetFont(handle);
end;

{==============================================================================}

function graphics_window_set_font(handle: WINDOW_HANDLE; font: FONT_HANDLE): uint32_t; stdcall;
{Set the default font of an existing console window}
{Handle: The handle of the window to set the default font for}
{Font: The font handle of the default font to set}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=GraphicsWindowSetFont(handle,font);
end;

{==============================================================================}

function graphics_window_get_cursor_xy(handle: WINDOW_HANDLE; var x, y: uint32_t): uint32_t; stdcall;
{Get the current cursor X and Y positions of an existing console window}
{Handle: The handle of the window to get cursor X and Y for}
{X: The returned cursor X value}
{Y: The returned cursor Y value}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For Graphics Console functions, cursor X and Y are based on screen pixels not characters}
begin
 {}
 Result:=GraphicsWindowGetCursorXY(handle,x,y);
end;

{==============================================================================}

function graphics_window_set_cursor_xy(handle: WINDOW_HANDLE; x, y: uint32_t): uint32_t; stdcall;
{Set the current cursor X and Y positions of an existing console window}
{Handle: The handle of the window to set cursor X and Y for}
{X: The new cursor X value}
{Y: The new cursor Y value}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For Graphics Console functions, cursor X and Y are based on screen pixels not characters}
begin
 {}
 Result:=GraphicsWindowSetCursorXY(handle,x,y);
end;

{==============================================================================}

function graphics_window_get_cursor_mode(handle: WINDOW_HANDLE): CURSOR_MODE; stdcall;
{Get the current cursor mode of an existing console window}
{Handle: The handle of the window to get the mode for}
{Return: The current cursor mode (eg CURSOR_MODE_INSERT)}
begin
 {}
 Result:=GraphicsWindowGetCursorMode(handle);
end;

{==============================================================================}

function graphics_window_set_cursor_mode(handle: WINDOW_HANDLE; cursormode: CURSOR_MODE): uint32_t; stdcall;
{Set the current cursor mode of an existing console window}
{Handle: The handle of the window to set the mode for}
{CursorMode: The cursor mode to set (eg CURSOR_MODE_INSERT)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=GraphicsWindowSetCursorMode(handle,cursormode);
end;

{==============================================================================}

function graphics_window_get_cursor_blink(handle: WINDOW_HANDLE): BOOL; stdcall;
{Get the current cursor blink state of an existing console window}
{Handle: The handle of the window to get blink state for}
{Return: True if blink is enabled, False if not or on error}
begin
 {}
 Result:=GraphicsWindowGetCursorBlink(handle);
end;

{==============================================================================}

function graphics_window_set_cursor_blink(handle: WINDOW_HANDLE; cursorblink: BOOL): uint32_t; stdcall;
{Set the current cursor blink state of an existing console window}
{Handle: The handle of the window to set the blink state for}
{CursorBlink: True to enable blink, False to disable}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=GraphicsWindowSetCursorBlink(handle,cursorblink);
end;

{==============================================================================}

function graphics_window_get_cursor_state(handle: WINDOW_HANDLE): CURSOR_STATE; stdcall;
{Get the current cursor state of an existing console window}
{Handle: The handle of the window to get the state for}
{Return: The current cursor state (eg CURSOR_STATE_ON)}
begin
 {}
 Result:=GraphicsWindowGetCursorState(handle);
end;

{==============================================================================}

function graphics_window_set_cursor_state(handle: WINDOW_HANDLE; cursorstate: CURSOR_STATE): uint32_t; stdcall;
{Set the current cursor state of an existing console window}
{Handle: The handle of the window to set the state for}
{CursorState: The cursor state to set (eg CURSOR_STATE_ON)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=GraphicsWindowSetCursorState(handle,cursorstate);
end;

{==============================================================================}

function graphics_window_get_cursor_shape(handle: WINDOW_HANDLE): CURSOR_SHAPE; stdcall;
{Get the current cursor shape of an existing console window}
{Handle: The handle of the window to get the shape for}
{Return: The current cursor shape (eg CURSORLINE)}
begin
 {}
 Result:=GraphicsWindowGetCursorShape(handle);
end;

{==============================================================================}

function graphics_window_set_cursor_shape(handle: WINDOW_HANDLE; cursorshape: CURSOR_SHAPE): uint32_t; stdcall;
{Set the current cursor shape of an existing console window}
{Handle: The handle of the window to set the shape for}
{CursorShape: The cursor shape to set (eg CURSORLINE)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=GraphicsWindowSetCursorShape(handle,cursorshape);
end;

{==============================================================================}

function graphics_window_cursor_on(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Enable the cursor on an existing console window}
{Handle: The handle of the window to enable the cursor for}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=GraphicsWindowCursorOn(handle);
end;

{==============================================================================}

function graphics_window_cursor_off(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Disable the cursor on an existing console window}
{Handle: The handle of the window to disable the cursor for}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=GraphicsWindowCursorOff(handle);
end;

{==============================================================================}

function graphics_window_cursor_line(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Change the cursor to a vertical line on an existing console window}
{Handle: The handle of the window to change the cursor for}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=GraphicsWindowCursorLine(handle);
end;

{==============================================================================}

function graphics_window_cursor_bar(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Change the cursor to a horizontal bar on an existing console window}
{Handle: The handle of the window to change the cursor for}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=GraphicsWindowCursorBar(handle);
end;

{==============================================================================}

function graphics_window_cursor_block(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Change the cursor to a solid block on an existing console window}
{Handle: The handle of the window to change the cursor for}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=GraphicsWindowCursorBlock(handle);
end;

{==============================================================================}

function graphics_window_cursor_move(handle: WINDOW_HANDLE; x, y: uint32_t): uint32_t; stdcall;
{Move the cursor on an existing console window}
{Handle: The handle of the window to move the cursor for}
{X: The column to move the cursor to}
{Y: The row to move the cursor to}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For Graphics Console functions, X and Y are based on screen pixels not characters}
begin
 {}
 Result:=GraphicsWindowCursorMove(handle,x,y);
end;

{==============================================================================}

function graphics_window_cursor_blink(handle: WINDOW_HANDLE; enabled: BOOL): uint32_t; stdcall;
{Set the blink state of the cursor on an existing console window}
{Handle: The handle of the window to set the blink state for}
{Enabled: True if the cursor is blinking, False if not}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=GraphicsWindowCursorBlink(handle,enabled);
end;

{==============================================================================}

function graphics_window_clear(handle: WINDOW_HANDLE): uint32_t; stdcall;
{Clear the current viewport of an existing console window}
{Handle: The handle of the window to clear}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=GraphicsWindowClear(handle);
end;

{==============================================================================}

function graphics_window_clear_ex(handle: WINDOW_HANDLE; x1, y1, x2, y2, color: uint32_t): uint32_t; stdcall;
{Clear part of the the current viewport of an existing console window}
{Handle: The handle of the window to clear}
{X1: The left edge of the area to clear (relative to current viewport)}
{Y1: The top edge of the area to clear (relative to current viewport)}
{X2: The right edge of the area to clear (relative to current viewport)}
{Y2: The bottom edge of the area to clear (relative to current viewport)}
{Color: The fill color for the area to clear (eg COLOR_WHITE)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For Graphics Console functions, Viewport is based on screen pixels not characters}
begin
 {}
 Result:=GraphicsWindowClearEx(handle,x1,y1,x2,y2,color);
end;

{==============================================================================}

function graphics_window_draw_box(handle: WINDOW_HANDLE; x1, y1, x2, y2, color, width: uint32_t): uint32_t; stdcall;
{Draw a rectangular box outline on an existing console window}
{Handle: The handle of the window to draw on}
{X1: The left edge of the box (relative to current viewport)}
{Y1: The top edge of the box (relative to current viewport)}
{X2: The right edge of the box (relative to current viewport)}
{Y2: The bottom edge of the box (relative to current viewport)}
{Color: The color to draw with (eg COLOR_WHITE)}
{Width: The width of the box outline}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For Graphics Console functions, Viewport is based on screen pixels not characters}
begin
 {}
 Result:=GraphicsWindowDrawBox(handle,x1,y1,x2,y2,color,width);
end;

{==============================================================================}

function graphics_window_draw_line(handle: WINDOW_HANDLE; x1, y1, x2, y2, color, width: uint32_t): uint32_t; stdcall;
{Draw a line on an existing console window}
{Handle: The handle of the window to draw on}
{X1: The left starting point of the line (relative to current viewport)}
{Y1: The top starting point of the line (relative to current viewport)}
{X2: The right ending point of the line (relative to current viewport)}
{Y2: The bottom ending point of the line (relative to current viewport)}
{Color: The color to draw with (eg COLOR_WHITE)}
{Width: The width of the line}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For Graphics Console functions, Viewport is based on screen pixels not characters}
begin
 {}
 Result:=GraphicsWindowDrawLine(handle,x1,y1,x2,y2,color,width);
end;

{==============================================================================}

function graphics_window_draw_block(handle: WINDOW_HANDLE; x1, y1, x2, y2, color: uint32_t): uint32_t; stdcall;
{Draw a rectangular filled block on an existing console window}
{Handle: The handle of the window to draw on}
{X1: The left edge of the block (relative to current viewport)}
{Y1: The top edge of the block (relative to current viewport)}
{X2: The right edge of the block (relative to current viewport)}
{Y2: The bottom edge of the block (relative to current viewport)}
{Color: The color to draw with (eg COLOR_WHITE)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For Graphics Console functions, Viewport is based on screen pixels not characters}
begin
 {}
 Result:=GraphicsWindowDrawBlock(handle,x1,y1,x2,y2,color);
end;

{==============================================================================}

function graphics_window_draw_circle(handle: WINDOW_HANDLE; x, y, color, width, radius: uint32_t): uint32_t; stdcall;
{Draw a circle on an existing console window}
{Handle: The handle of the window to draw on}
{X: The left starting point of the circle (relative to current viewport)}
{Y: The top starting point of the circle (relative to current viewport)}
{Color: The color to draw with (eg COLOR_WHITE)}
{Width: The width of the circle outline}
{Radius: The radius of the circle}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For Graphics Console functions, Viewport is based on screen pixels not characters}
begin
 {}
 Result:=GraphicsWindowDrawCircle(handle,x,y,color,width,radius);
end;

{==============================================================================}

function graphics_window_draw_char(handle: WINDOW_HANDLE; ch: CHAR; x, y: uint32_t): uint32_t; stdcall;
{Draw a character on an existing console window}
{Handle: The handle of the window to draw on}
{Ch: The character to draw}
{X: The left starting point of the character (relative to current viewport)}
{Y: The top starting point of the character (relative to current viewport)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For Graphics Console functions, Viewport is based on screen pixels not characters}
begin
 {}
 Result:=GraphicsWindowDrawChar(handle,ch,x,y);
end;

{==============================================================================}

function graphics_window_draw_char_ex(handle: WINDOW_HANDLE; font: FONT_HANDLE; ch: CHAR; x, y, forecolor, backcolor: uint32_t): uint32_t; stdcall;
{Draw a character on an existing console window}
{Handle: The handle of the window to draw on}
{Font: The handle of the font to draw the character with}
{Ch: The character to draw}
{X: The left starting point of the character (relative to current viewport)}
{Y: The top starting point of the character (relative to current viewport)}
{Forecolor: The foreground color for the character (eg COLOR_WHITE)}
{Backcolor: The background color for the character (eg COLOR_BLACK)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For Graphics Console functions, Viewport is based on screen pixels not characters}
begin
 {}
 Result:=GraphicsWindowDrawCharEx(handle,font,ch,x,y,forecolor,backcolor);
end;

{==============================================================================}

function graphics_window_draw_text(handle: WINDOW_HANDLE; const text: PCHAR; x, y: uint32_t): uint32_t; stdcall;
{Draw a text string on an existing console window}
{Handle: The handle of the window to draw on}
{Text: The text to draw}
{X: The left starting point of the text (relative to current viewport)}
{Y: The top starting point of the text (relative to current viewport)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For Graphics Console functions, Viewport is based on screen pixels not characters}
begin
 {}
 Result:=GraphicsWindowDrawText(handle,String(text),x,y);
end;

{==============================================================================}

function graphics_window_draw_text_ex(handle: WINDOW_HANDLE; font: FONT_HANDLE; const text: PCHAR; x, y, forecolor, backcolor: uint32_t): uint32_t; stdcall;
{Draw a text string on an existing console window}
{Handle: The handle of the window to draw on}
{Font: The handle of the font to draw the text with}
{Text: The text to draw}
{X: The left starting point of the text (relative to current viewport)}
{Y: The top starting point of the text (relative to current viewport)}
{Forecolor: The foreground color for the text (eg COLOR_WHITE)}
{Backcolor: The background color for the text (eg COLOR_BLACK)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For Graphics Console functions, Viewport is based on screen pixels not characters}
begin
 {}
 Result:=GraphicsWindowDrawTextEx(handle,font,String(text),x,y,forecolor,backcolor);
end;

{==============================================================================}

function graphics_window_draw_pixel(handle: WINDOW_HANDLE; x, y, color: uint32_t): uint32_t; stdcall;
{Draw a single pixel on an existing console window}
{Handle: The handle of the window to draw on}
{X: The column for the pixel (relative to current viewport)}
{Y: The row for the pixel (relative to current viewport)}
{Color: The color for the pixel (eg COLOR_WHITE)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For Graphics Console functions, Viewport is based on screen pixels not characters}
begin
 {}
 Result:=GraphicsWindowDrawPixel(handle,x,y,color);
end;

{==============================================================================}

function graphics_window_draw_image(handle: WINDOW_HANDLE; x, y: uint32_t; image: PVOID; width, height, format: uint32_t): uint32_t; stdcall;
{Draw an image on an existing console window}
{Handle: The handle of the window to draw on}
{X: The left starting point of the image (relative to current viewport)}
{Y: The top starting point of the image (relative to current viewport)}
{Image: Pointer to the image data in a contiguous block of pixel rows}
{Width: The width in pixels of a row in the image data}
{Height: The height in pixels of all rows in the image data}
{Format: The color format of the image data (eg COLOR_FORMAT_ARGB32) Pass COLOR_FORMAT_UNKNOWN to use the window format}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For Graphics Console functions, Viewport is based on screen pixels not characters}
begin
 {}
 Result:=GraphicsWindowDrawImage(handle,x,y,image,width,height,format);
end;

{==============================================================================}

function graphics_window_get_pixel(handle: WINDOW_HANDLE; x, y: uint32_t): uint32_t; stdcall;
{Get a single pixel from an existing console window}
{Handle: The handle of the window to get from}
{X: The column of the pixel (relative to current viewport)}
{Y: The row of the pixel (relative to current viewport)}
{Return: The color of the pixel at X,Y (eg COLOR_WHITE)}
{Note: For Graphics Console functions, Viewport is based on screen pixels not characters}
begin
 {}
 Result:=GraphicsWindowGetPixel(handle,x,y);
end;

{==============================================================================}

function graphics_window_get_image(handle: WINDOW_HANDLE; x, y: uint32_t; image: PVOID; width, height, format: uint32_t): uint32_t; stdcall;
{Get an image from an existing console window}
{Handle: The handle of the window to get from}
{X: The left starting point of the image (relative to current viewport)}
{Y: The top starting point of the image (relative to current viewport)}
{Image: Pointer to a block of memory large enough to hold the image in a contiguous block of pixel rows}
{Width: The width in pixels of a row of the image}
{Height: The height in pixels of all rows of the image}
{Format: The color format to store in the image data (eg COLOR_FORMAT_ARGB32) Pass COLOR_FORMAT_UNKNOWN to use the window format}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For Graphics Console functions, Viewport is based on screen pixels not characters}
begin
 {}
 Result:=GraphicsWindowGetImage(handle,x,y,image,width,height,format);
end;

{==============================================================================}

function graphics_window_copy_image(handle: WINDOW_HANDLE; const source, dest: TCONSOLE_POINT; width, height: uint32_t): uint32_t; stdcall;
{Copy an image from one place to another in an existing console window}
{Handle: The handle of the window to copy from and to}
{Source: The starting point (X,Y) to copy the image from}
{Dest: The starting point (X,Y) to copy the image to}
{Width: The width in pixels of each row of the image}
{Height: The height in pixels of all rows of the image}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For Graphics Console functions, Viewport is based on screen pixels not characters}
begin
 {}
 Result:=GraphicsWindowCopyImage(handle,source,dest,width,height);
end;

{==============================================================================}

function graphics_window_move_image(handle: WINDOW_HANDLE; const source, dest: TCONSOLE_POINT; width, height, fillcolor: uint32_t): uint32_t; stdcall;
{Move an image from one place to another in an existing console window}
{Handle: The handle of the window to copy from and to}
{Source: The starting point (X,Y) to copy the image from}
{Dest: The starting point (X,Y) to copy the image to}
{Width: The width in pixels of each row of the image}
{Height: The height in pixels of all rows of the image}
{Fillcolor: The color to fill the area where the image was moved from (COLOR_NONE for no fill, same as copy)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: For Graphics Console functions, Viewport is based on screen pixels not characters}
begin
 {}
 Result:=GraphicsWindowMoveImage(handle,source,dest,width,height,fillcolor);
end;

{==============================================================================}

function graphics_window_image_size(handle: WINDOW_HANDLE; width, height, format, stride: uint32_t): uint32_t; stdcall;
{Calculate the size in bytes of an image that is Width by Height in the color format specified}
{Handle: The handle of the window for the image}
{Width: The width of the image in pixels}
{Height: The height of the image in pixels}
{Format: The color format to use for the calculation (eg COLOR_FORMAT_ARGB32) Pass COLOR_FORMAT_UNKNOWN to use the window format}
{Stride: The distance in bytes between each row of pixels (Optional)}
{Return: The size in bytes for an image of the specified size and format or 0 on error}
begin
 {}
 Result:=GraphicsWindowImageSize(handle,width,height,format,stride);
end;

{==============================================================================}
{Graphics Console Helper Functions}
function graphics_window_get_count(console: PCONSOLE_DEVICE): uint32_t; stdcall;
{Get the current console window count}
{Console: The console device to get the window count for}
{Return: The current number of console windows on the specified console device}
begin
 {}
 Result:=GraphicsWindowGetCount(console);
end;

{==============================================================================}

function graphics_window_get_active(console: PCONSOLE_DEVICE): WINDOW_HANDLE; stdcall;
{Get the current console active window}
{Console: The console device to get the active window for}
{Return: The window handle of the current active window or INVALID_HANDLE_VALUE on failure}
begin
 {}
 Result:=GraphicsWindowGetActive(console);
end;

{==============================================================================}

function graphics_window_check(console: PCONSOLE_DEVICE; window: PGRAPHICS_WINDOW): PGRAPHICS_WINDOW; stdcall;
{Check if a console window entry is valid}
{Console: The console device to search for the window}
{Window: The window entry to check for validity}
{Return: The supplied window if successful or nil on failure}
begin
 {}
 Result:=GraphicsWindowCheck(console,window);
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{HID Functions}
{$IFDEF API_EXPORT_HID}
function hid_parser_parse_collections(device: PHID_DEVICE; var collections: PHID_COLLECTIONS; var count: uint32_t): uint32_t; stdcall;
{Parse the HID report descriptor of the provided device and populate the collections, reports and usages}
{Device: The HID device to parse collections for}
{Collections: A pointer to the top level collections array to be populated}
{Count: A variable to return the number of top level collections}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=HIDParserParseCollections(device,collections,count);
end;

{==============================================================================}

function hid_parser_free_collections(collections: PHID_COLLECTIONS; count: uint32_t): uint32_t; stdcall;
{Free the collections, reports and usages parsed from a HID report descriptor}
{Collections: A pointer to the top level collections array to be freed}
{Count: The number of top level collections in the array}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=HIDParserFreeCollections(collections,count);
end;

{==============================================================================}

function hid_parser_count_collections(device: PHID_DEVICE; parent: PHID_COLLECTION): uint32_t; stdcall;
{Count the number of collections found in the HID report descriptor of the provided device}
{Device: The HID device to count collections for}
{Parent: The parent HID collection, if supplied count child collections else count top level collections}
{Return: The number of collections found, 0 if none for or on error}
begin
 {}
 Result:=HIDParserCountCollections(device,parent);
end;

{==============================================================================}

function hid_parser_count_reports(device: PHID_DEVICE; collection: PHID_COLLECTION): uint32_t; stdcall;
{Count the number of reports found in the HID report descriptor of the supplied device and collection}
{Device: The HID device to count reports for}
{Collection: The HID collection to count reports for}
{Return: The number of reports found, 0 if none for or on error}
begin
 {}
 Result:=HIDParserCountReports(device,collection);
end;

{==============================================================================}

function hid_parser_count_usages(device: PHID_DEVICE; report: PHID_REPORT): uint32_t; stdcall;
{Count the number of usages found in the HID report descriptor for the supplied device and report}
{Device: The HID device to count usages for}
{Report: The HID report to count usages for}
{Return: The number of usages found, 0 if none for or on error}
begin
 {}
 Result:=HIDParserCountUsages(device,report);
end;

{==============================================================================}

function hid_parser_allocate_collection(device: PHID_DEVICE; parent: PHID_COLLECTION; state: PHID_STATE; flags, start: uint32_t): PHID_COLLECTION; stdcall;
{Allocate a HID collection to contain a set of reports and usages from a HID report descriptor}
{Device: The HID device containing the collection}
{Parent: The HID collection containing the collection (or nil for a top level collection)}
{State: The current HID parser state}
{Flags: The flags for the collection from the HID report descriptor}
{Start: The starting byte offset of the collection in the HID report descriptor}
{Return: A pointer to the HID collection or nil on error}
begin
 {}
 Result:=HIDParserAllocateCollection(device,parent,state,flags,start);
end;

{==============================================================================}

function hid_parser_allocate_report(device: PHID_DEVICE; collection: PHID_COLLECTION; state: PHID_STATE; kind: uint8_t; flags, index, sequence: uint32_t): PHID_REPORT; stdcall;
{Allocate a HID report to contain a set of usages from a HID report descriptor}
{Device: The HID device containing the report}
{Collection: The HID collection containing the report}
{State: The current HID parser state}
{Kind: The report kind (eg HID_REPORT_INPUT)}
{Flags: The flags for the report from the HID report descriptor}
{Index: The index of this report in the collection (First report is 0)}
{Sequence: The sequence of this report in all collections (First report is 0)}
{Return: A pointer to the HID report or nil on error}
begin
 {}
 Result:=HIDParserAllocateReport(device,collection,state,kind,flags,index,sequence);
end;

{==============================================================================}

function hid_parser_allocate_usage(device: PHID_DEVICE; report: PHID_REPORT; state: PHID_STATE; index: uint32_t): PHID_USAGE; stdcall;
{Allocate a HID usage from a HID report descriptor}
{Device: The HID device containing the usage}
{Report: The HID report containing the usage}
{State: The current HID parser state}
{Index: The index of this usage in the report (First usage is 0)}
{Return: A pointer to the HID usage or nil on error}
begin
 {}
 Result:=HIDParserAllocateUsage(device,report,state,index);
end;

{==============================================================================}

function hid_parser_update_usage(device: PHID_DEVICE; report: PHID_REPORT; state: PHID_STATE; usage: PHID_USAGE): BOOL; stdcall;
{Update a HID usage from a HID report descriptor}
{Device: The HID device containing the usage}
{Report: The HID report containing the usage}
{State: The current HID parser state}
{Usage: The HID usage to update}
{Return: True if completed or False on error}
{Note: As usages must precede the main item they relate to in the HID report descriptor they need to be allocated}
{      before all the required information is known, this function updates the usage after the main item is found}
begin
 {}
 Result:=HIDParserUpdateUsage(device,report,state,usage);
end;

{==============================================================================}

function hid_parser_free_usage(device: PHID_DEVICE; usage: PHID_USAGE): BOOL; stdcall;
{Free a HID usage and any associated usage aliases}
{Device: The HID device containing the usage}
{Usage: The HID usage to free}
{Return: True if completed or False on error}
begin
 {}
 Result:=HIDParserFreeUsage(device,usage);
end;

{==============================================================================}

function hid_parser_pop_stack(var stack: PHID_STACK; var state: PHID_STATE): uint32_t; stdcall;
{Replace the current HID parser state with the top item from the parser stack}
{Stack: The HID parser stack}
{State: The HID parser state to replace}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=HIDParserPopStack(stack,state);
end;

{==============================================================================}

function hid_parser_push_stack(stack: PHID_STACK): uint32_t; stdcall;
{Place a copy of the current HID parser state on top of the parser stack}
{Stack: The HID parser stack}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=HIDParserPushStack(stack);
end;

{==============================================================================}

function hid_parser_free_stack(stack: PHID_STACK): uint32_t; stdcall;
{Free the HID parser stack and state}
{Stack: The HID parser stack}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=HIDParserFreeStack(stack);
end;

{==============================================================================}

function hid_parser_reset_state(state: PHID_STATE): uint32_t; stdcall;
{Clear the Local and Global HID parser state}
{State: The HID parser state to reset}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=HIDParserResetState(state);
end;

{==============================================================================}

function hid_parser_clean_state(state: PHID_STATE): uint32_t; stdcall;
{Clear the Local HID parser state}
{State: The HID parser state to clean}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=HIDParserCleanState(state);
end;

{==============================================================================}

function hid_find_collection(device: PHID_DEVICE; page, usage: uint16_t): PHID_COLLECTION; stdcall;
{Find the first HID collection matching the specified page and usage}
{Device: The HID device to find collections from}
{Page: The HID Usage Page to match (eg HID_PAGE_GENERIC_DESKTOP)}
{Usage: The HID Usage to match (eg HID_DESKTOP_MOUSE)}
{Return: A pointer to the first matching collection or nil if not matched}
begin
 {}
 Result:=HIDFindCollection(device,page,usage);
end;

{==============================================================================}

function hid_find_report_ids(device: PHID_DEVICE; collection: PHID_COLLECTION; var minid, maxid: uint8_t): uint32_t; stdcall;
{Find the minimum and maximum report ids contained in the specified HID collection or all collections}
{Device: The HID device to find report ids from}
{Collection: The HID collection to find report ids from (or nil to find from all collections)}
{MinId: A variable to receive the minimum report id number}
{MaxId: A variable to receive the maximum report id number}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=HIDFindReportIds(device,collection,minid,maxid);
end;

{==============================================================================}

function hid_find_report_sizes(device: PHID_DEVICE; collection: PHID_COLLECTION; kind: uint8_t; var minsize, maxsize: uint32_t): uint32_t; stdcall;
{Find the minimum and maximum report sizes contained in the specified HID collection or all collections}
{Device: The HID device to find report sizes from}
{Collection: The HID collection to find report sizes from (or nil to find from all collections)}
{Kind: The report kind to find sizes for (eg HID_REPORT_INPUT)}
{MinSize: A variable to receive the minimum report size}
{MaxSize: A variable to receive the maximum report size}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=HIDFindReportSizes(device,collection,kind,minsize,maxsize);
end;

{==============================================================================}

function hid_count_reports(device: PHID_DEVICE; collection: PHID_COLLECTION; kind, id: uint8_t; var count: uint32_t): uint32_t; stdcall;
{Count the number of HID reports of the specified type and id in the specified collection}
{Device: The HID device to get the report count from}
{Collection: The HID collection to get the report count from}
{Kind: The report kind to count reports for (eg HID_REPORT_INPUT)}
{Id: The report id to count reports for (must be less than or equal to the maximum report id)}
{Count: A variable to return the number of reports}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=HIDCountReports(device,collection,kind,id,count);
end;

{==============================================================================}

function hid_find_reports(device: PHID_DEVICE; collection: PHID_COLLECTION; kind, id: uint8_t; reports: PHID_REPORTS; count: uint32_t): uint32_t; stdcall;
{Find all HID reports of the specified type and id in the specified collection}
{Device: The HID device to get the reports from}
{Collection: The HID collection to get the reports from}
{Kind: The report kind to get reports for (eg HID_REPORT_INPUT)}
{Id: The report id to get reports for (must be less than or equal to the maximum report id)}
{Reports: A pointer to an array to return the list of reports}
{Count: The number of reports able to be returned in the reports array}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: The caller is responsible for allocating the reports array which must be large enough}
{      to hold a pointer to every report in the returned list}
{      When finished the array should be freed by the caller but not the reports themselves}
{      Call HIDCountReports first to obtain the correct size to be allocated for the array}
begin
 {}
 Result:=HIDFindReports(device,collection,kind,id,reports,count);
end;

{==============================================================================}

function hid_allocate_definition(device: PHID_DEVICE; collection: PHID_COLLECTION; kind, id: uint8_t): PHID_DEFINITION; stdcall;
{Allocate a HID definition to describe an input, output or feature report contained in the specified collection}
{Device: The HID device to create the report definition from}
{Collection: The HID collection to create the report definition from}
{Kind: The report kind to create a definition for (eg HID_REPORT_INPUT)}
{Id: The report id to create a definition for (must be less than or equal to the maximum report id)}
{Return: A pointer to the allocated definition or nil on error}
begin
 {}
 Result:=HIDAllocateDefinition(device,collection,kind,id);
end;

{==============================================================================}

function hid_free_definition(definition: PHID_DEFINITION): uint32_t; stdcall;
{Free a HID definition describing an input, output or feature report}
{Definition: The HID definition to be freed}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=HIDFreeDefinition(definition);
end;

{==============================================================================}

function hid_insert_bit_field(field: PHID_FIELD; buffer: PVOID; size: uint32_t; value: BOOL): uint32_t; stdcall;
{Insert a bit field value into a report buffer}
{Field: The field to insert into the report}
{Buffer: A pointer to the report buffer}
{Size: The size in bytes of the report buffer}
{Value: The value to insert into the buffer}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=HIDInsertBitField(field,buffer,size,value);
end;

{==============================================================================}

function hid_insert_signed_field(field: PHID_FIELD; buffer: PVOID; size: uint32_t; value: int32_t): uint32_t; stdcall;
{Insert a signed field value into a report buffer}
{Field: The field to insert into the report}
{Buffer: A pointer to the report buffer}
{Size: The size in bytes of the report buffer}
{Value: The value to insert into the buffer}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=HIDInsertSignedField(field,buffer,size,value);
end;

{==============================================================================}

function hid_insert_unsigned_field(field: PHID_FIELD; buffer: PVOID; size, value: uint32_t): uint32_t; stdcall;
{Insert an unsigned field value into a report buffer}
{Field: The field to insert into the report}
{Buffer: A pointer to the report buffer}
{Size: The size in bytes of the report buffer}
{Value: The value to insert into the buffer}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=HIDInsertUnsignedField(field,buffer,size,value);
end;

{==============================================================================}

function hid_extract_bit_field(field: PHID_FIELD; buffer: PVOID; size: uint32_t; var value: BOOL): uint32_t; stdcall;
{Extract a bit field value from a report buffer}
{Field: The field to extract from the report}
{Buffer: A pointer to the report buffer}
{Size: The size in bytes of the report buffer}
{Value: A variable to receive the extracted value}
{Return: ERROR_SUCCESS if completed or another error code on failure}
var
 WorkBool:Boolean;
begin
 {}
 Result:=HIDExtractBitField(field,buffer,size,WorkBool);
 
 {Return Value}
 value:=WorkBool;
end;

{==============================================================================}

function hid_extract_signed_field(field: PHID_FIELD; buffer: PVOID; size: uint32_t; var value: int32_t): uint32_t; stdcall;
{Extract a signed field value from a report buffer}
{Field: The field to extract from the report}
{Buffer: A pointer to the report buffer}
{Size: The size in bytes of the report buffer}
{Value: A variable to receive the extracted value}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=HIDExtractSignedField(field,buffer,size,value);
end;

{==============================================================================}

function hid_extract_unsigned_field(field: PHID_FIELD; buffer: PVOID; size: uint32_t; var value: uint32_t): uint32_t; stdcall;
{Extract an unsigned field value from a report buffer}
{Field: The field to extract from the report}
{Buffer: A pointer to the report buffer}
{Size: The size in bytes of the report buffer}
{Value: A variable to receive the extracted value}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=HIDExtractUnsignedField(field,buffer,size,value);
end;

{==============================================================================}
{HID Device Functions}
function hid_device_set_state(device: PHID_DEVICE; state: uint32_t): uint32_t; stdcall;
{Set the state of the specified HID device and send a notification}
{Device: The HID device to set the state for}
{State: The new state to set and notify (eg HID_STATE_ATTACHED)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=HIDDeviceSetState(device,state);
end;

{==============================================================================}

function hid_device_get_idle(device: PHID_DEVICE; var duration: uint16_t; reportid: uint8_t): uint32_t; stdcall;
{Get the idle rate from a HID device for the specified report id}
{Device: The HID device to get the idle rate from}
{Duration: A variable to receive the idle rate (in Milliseconds)}
{ReportId: The report id to get the idle rate from}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=HIDDeviceGetIdle(device,duration,reportid);
end;

{==============================================================================}

function hid_device_set_idle(device: PHID_DEVICE; duration: uint16_t; reportid: uint8_t): uint32_t; stdcall;
{Set the idle rate on a HID device for the specified report id}
{Device: The HID device to set the idle rate for}
{Duration: The idle rate to set (in Milliseconds)}
{ReportId: The report id to set the idle rate for}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=HIDDeviceSetIdle(device,duration,reportid);
end;

{==============================================================================}

function hid_device_get_report(device: PHID_DEVICE; reporttype, reportid: uint8_t; reportdata: PVOID; reportsize: uint32_t): uint32_t; stdcall;
{Read a report by type and id from a HID device}
{Device: The HID device to read the report from}
{ReportType: The report type to read (eg HID_REPORT_INPUT)}
{ReportId: The report id to read (eg HID_REPORTID_NONE)}
{ReportData: A pointer to a buffer to receive the report data}
{ReportSize: The size in bytes of the buffer pointed to by report data}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=HIDDeviceGetReport(device,reporttype,reportid,reportdata,reportsize);
end;

{==============================================================================}

function hid_device_set_report(device: PHID_DEVICE; reporttype, reportid: uint8_t; reportdata: PVOID; reportsize: uint32_t): uint32_t; stdcall;
{Write a report by type and id to a HID device}
{Device: The HID device to write the report to}
{ReportType: The report type to write (eg HID_REPORT_OUTPUT)}
{ReportId: The report id to write (eg HID_REPORTID_NONE)}
{ReportData: A pointer to a buffer containing the report data}
{ReportSize: The size in bytes of the buffer pointed to by report data}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=HIDDeviceSetReport(device,reporttype,reportid,reportdata,reportsize);
end;

{==============================================================================}

function hid_device_allocate_report(device: PHID_DEVICE; collection: PHID_COLLECTION; reportid: uint8_t; reportsize: uint32_t): uint32_t; stdcall;
{Allocate and initialize an input report by id on a HID device}
{Device: The HID device to allocate the report on}
{Collection: The HID collection this request corresponds to}
{ReportId: The report id to allocate (eg HID_REPORTID_NONE)}
{ReportSize: The size in bytes to allocate for the report (Provider will handle alignment and other requirements)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: An allocated report must be submitted before reports will be received from the device}
begin
 {}
 Result:=HIDDeviceAllocateReport(device,collection,reportid,reportsize);
end;

{==============================================================================}

function hid_device_release_report(device: PHID_DEVICE; reportid: uint8_t): uint32_t; stdcall;
{Release an input report by id from a HID device}
{Device: The HID device to release the report from}
{ReportId: The report id to allocate (eg HID_REPORTID_NONE)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: If the report has been submitted it must be cancelled before being released}
begin
 {}
 Result:=HIDDeviceReleaseReport(device,reportid);
end;

{==============================================================================}

function hid_device_submit_report(device: PHID_DEVICE; reportid: uint8_t): uint32_t; stdcall;
{Submit an input report by id on a HID device}
{Device: The HID device to submit the report on}
{ReportId: The report id to submit (eg HID_REPORTID_NONE)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: The report must be allocated then submitted before reports will be received from the device}
begin
 {}
 Result:=HIDDeviceSubmitReport(device,reportid);
end;

{==============================================================================}

function hid_device_cancel_report(device: PHID_DEVICE; reportid: uint8_t): uint32_t; stdcall;
{Cancel an input report by id on a HID device}
{Device: The HID device to cancel the report on}
{ReportId: The report id to cancel (eg HID_REPORTID_NONE)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: The report should be cancelled then released to stop receiving reports from the device}
begin
 {}
 Result:=HIDDeviceCancelReport(device,reportid);
end;

{==============================================================================}

function hid_device_get_protocol(device: PHID_DEVICE; var protocol: uint8_t): uint32_t; stdcall;
{Get the report protocol from a HID device}
{Device: The HID device to get the report protocol from}
{Protocol: A variable to receive the report protocol (eg HID_PROTOCOL_REPORT)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=HIDDeviceGetProtocol(device,protocol);
end;

{==============================================================================}

function hid_device_set_protocol(device: PHID_DEVICE; protocol: uint8_t): uint32_t; stdcall;
{Set the report protocol for a HID device}
{Device: The HID device to set the report protocol for}
{Protocol: The report protocol to set (eg HID_PROTOCOL_REPORT)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=HIDDeviceSetProtocol(device,protocol);
end;

{==============================================================================}

function hid_device_get_interval(device: PHID_DEVICE; var interval: uint32_t): uint32_t; stdcall;
{Get the polling interval from a HID device}
{Device: The HID device to get the polling interval from}
{Interval: A variable to receive the polling interval (in Milliseconds)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=HIDDeviceGetInterval(device,interval);
end;

{==============================================================================}

function hid_device_set_interval(device: PHID_DEVICE; interval: uint32_t): uint32_t; stdcall;
{Set the polling interval for a HID device}
{Device: The HID device to set the polling interval for}
{Interval: The polling interval to set (in Milliseconds)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=HIDDeviceSetInterval(device,interval);
end;

{==============================================================================}

function hid_device_get_report_descriptor(device: PHID_DEVICE; descriptor: PHID_REPORT_DESCRIPTOR; size: uint32_t): uint32_t; stdcall;
{Get the Report Descriptor for a HID device}
{Device: The HID device to get the descriptor for}
{Descriptor: Pointer to a buffer to return the HID Report Descriptor}
{Size: The size in bytes of the buffer pointed to by Descriptor}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=HIDDeviceGetReportDescriptor(device,descriptor,size);
end;

{==============================================================================}

function hid_device_get_physical_descriptor_set0(device: PHID_DEVICE; descriptor: PHID_PHYSICAL_DESCRIPTOR_SET0): uint32_t; stdcall;
{Get the HID Physical Descriptor Set 0 for a HID device}
{Device: The HID device to get the descriptor for}
{Descriptor: Pointer to a HID Physical Descriptor Set 0 structure for the returned data}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=HIDDeviceGetPhysicalDescriptorSet0(device,descriptor);
end;

{==============================================================================}

function hid_device_get_physical_descriptor_set(device: PHID_DEVICE; descriptor: PHID_PHYSICAL_DESCRIPTOR_SET; index: uint8_t; size: uint32_t): uint32_t; stdcall;
{Get a HID Physical Descriptor Set for a HID device}
{Device: The HID device to get the descriptor for}
{Descriptor: Pointer to a HID Physical Descriptor Set structure for the returned data}
{Index: The index of the physical descriptor set to return}
{Size: The size in bytes of the buffer pointed to by Descriptor}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=HIDDeviceGetPhysicalDescriptorSet(device,descriptor,index,size);
end;

{==============================================================================}

function hid_device_bind_device(device: PHID_DEVICE): uint32_t; stdcall;
{Attempt to bind a HID device to one of the registered consumers}
{Device: The HID device to attempt to bind a consumer to}
{Return: ERROR_SUCCESS if completed, ERROR_NOT_SUPPORTED if unsupported or another error code on failure}
begin
 {}
 Result:=HIDDeviceBindDevice(device);
end;

{==============================================================================}

function hid_device_unbind_device(device: PHID_DEVICE; consumer: PHID_CONSUMER): uint32_t; stdcall;
{Unbind a HID device from a consumer}
{Device: The HID device to unbind a consumer from}
{Consumer: The consumer to unbind the device from (nil to unbind from current consumer)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=HIDDeviceUnbindDevice(device,consumer);
end;

{==============================================================================}

function hid_device_bind_collections(device: PHID_DEVICE): uint32_t; stdcall;
{Attempt to bind the HID collections in the specified device to one of the registered consumers}
{Device: The HID device containing the collections to attempt to bind a consumer to}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=HIDDeviceBindCollections(device);
end;

{==============================================================================}

function hid_device_unbind_collections(device: PHID_DEVICE; consumer: PHID_CONSUMER): uint32_t; stdcall;
{Unbind the HID collections in the specified device from a consumer}
{Device: The HID device containing the collections to unbind a consumer from}
{Consumer: The consumer to unbind the collections from (nil to unbind from current consumer)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=HIDDeviceUnbindCollections(device,consumer);
end;

{==============================================================================}

function hid_device_create: PHID_DEVICE; stdcall;
{Create a new HID device entry}
{Return: Pointer to new HID device entry or nil if HID device could not be created}
begin
 {}
 Result:=HIDDeviceCreate;
end;

{==============================================================================}

function hid_device_create_ex(size: uint32_t): PHID_DEVICE; stdcall;
{Create a new HID device entry}
{Size: Size in bytes to allocate for new HID device (Including the HID device entry)}
{Return: Pointer to new HID device entry or nil if HID device could not be created}
begin
 {}
 Result:=HIDDeviceCreateEx(size);
end;

{==============================================================================}

function hid_device_destroy(device: PHID_DEVICE): uint32_t; stdcall;
{Destroy an existing HID device entry}
{Device: The HID device to destroy}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=HIDDeviceDestroy(device);
end;

{==============================================================================}

function hid_device_register(device: PHID_DEVICE): uint32_t; stdcall;
{Register a new HID device in the HID device table}
{Device: The HID device to register}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=HIDDeviceRegister(device);
end;

{==============================================================================}

function hid_device_deregister(device: PHID_DEVICE): uint32_t; stdcall;
{Deregister a HID device from the HID device table}
{Device: The HID device to deregister}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=HIDDeviceDeregister(device);
end;

{==============================================================================}

function hid_device_find(hidid: uint32_t): PHID_DEVICE; stdcall;
{Find a HID device by ID in the HID device table}
{HIDId: The ID number of the HID device to find}
{Return: Pointer to HID device entry or nil if not found}
begin
 {}
 Result:=HIDDeviceFind(hidid);
end;

{==============================================================================}

function hid_device_find_by_name(const name: PCHAR): PHID_DEVICE; stdcall;
{Find a HID device by name in the device table}
{Name: The name of the HID device to find (eg HID0)}
{Return: Pointer to HID device entry or nil if not found}
begin
 {}
 Result:=HIDDeviceFindByName(String(name));
end;

{==============================================================================}

function hid_device_find_by_description(const description: PCHAR): PHID_DEVICE; stdcall;
{Find a HID device by description in the device table}
{Description: The description of the HID to find (eg Optical USB Mouse)}
{Return: Pointer to HID device entry or nil if not found}
begin
 {}
 Result:=HIDDeviceFindByDescription(String(description));
end;

{==============================================================================}

function hid_device_enumerate(callback: hid_device_enumerate_cb; data: PVOID): uint32_t; stdcall;
{Enumerate all HID devices in the HID device table}
{Callback: The callback function to call for each HID device in the table}
{Data: A private data pointer to pass to callback for each HID device in the table}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=HIDDeviceEnumerate(callback,data);
end;

{==============================================================================}

function hid_device_notification(device: PHID_DEVICE; callback: hid_device_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall;
{Register a notification for HID device changes}
{Device: The HID device to notify changes for (Optional, pass nil for all HID devices)}
{Callback: The function to call when a notification event occurs}
{Data: A private data pointer to pass to callback when a notification event occurs}
{Notification: The events to register for notification of (eg DEVICE_NOTIFICATION_REGISTER)}
{Flags: The flags to control the notification (eg NOTIFIER_FLAG_WORKER)}
begin
 {}
 Result:=HIDDeviceNotification(device,callback,data,notification,flags);
end;

{==============================================================================}
{HID Consumer Functions}
function hid_consumer_create: PHID_CONSUMER; stdcall;
{Create a new HID Consumer entry}
{Return: Pointer to new Consumer entry or nil if consumer could not be created}
begin
 {}
 Result:=HIDConsumerCreate;
end;

{==============================================================================}

function hid_consumer_create_ex(size: uint32_t): PHID_CONSUMER; stdcall;
{Create a new HID Consumer entry}
{Size: Size in bytes to allocate for new consumer (Including the consumer entry)}
{Return: Pointer to new Consumer entry or nil if consumer could not be created}
begin
 {}
 Result:=HIDConsumerCreateEx(size);
end;

{==============================================================================}

function hid_consumer_destroy(consumer: PHID_CONSUMER): uint32_t; stdcall;
{Destroy an existing HID Consumer entry}
begin
 {}
 Result:=HIDConsumerDestroy(consumer);
end;

{==============================================================================}

function hid_consumer_register(consumer: PHID_CONSUMER): uint32_t; stdcall;
{Register a new Consumer in the HID Consumer table}
begin
 {}
 Result:=HIDConsumerRegister(consumer);
end;

{==============================================================================}

function hid_consumer_deregister(consumer: PHID_CONSUMER): uint32_t; stdcall;
{Deregister a Consumer from the HID Consumer table}
begin
 {}
 Result:=HIDConsumerDeregister(consumer);
end;

{==============================================================================}

function hid_consumer_find(consumerid: uint32_t): PHID_CONSUMER; stdcall;
{Find a consumer by Id in the HID Consumer table}
begin
 {}
 Result:=HIDConsumerFind(consumerid);
end;

{==============================================================================}

function hid_consumer_find_by_name(const name: PCHAR): PHID_CONSUMER; stdcall;
{Find a consumer by name in the Driver table}
begin
 {}
 Result:=HIDConsumerFindByName(String(name));
end;

{==============================================================================}

function hid_consumer_enumerate(callback: hid_consumer_enumerate_cb; data: PVOID): uint32_t; stdcall;
{Enumerate all consumers in the HID Consumer table}
begin
 {}
 Result:=HIDConsumerEnumerate(callback,data);
end;

{==============================================================================}
{HID Helper Functions}
function hid_is_bit_field(field: PHID_FIELD): BOOL; stdcall;
{Return True if the supplied field contains a 1 bit value}
begin
 {}
 Result:=HIDIsBitField(field);
end;

{==============================================================================}

function hid_is_byte_field(field: PHID_FIELD): BOOL; stdcall;
{Return True if the supplied HID field contains a 1 byte value}
begin
 {}
 Result:=HIDIsByteField(field);
end;

{==============================================================================}

function hid_is_word_field(field: PHID_FIELD): BOOL; stdcall;
{Return True if the supplied HID field contains a 2 byte value}
begin
 {}
 Result:=HIDIsWordField(field);
end;

{==============================================================================}

function hid_is_long_field(field: PHID_FIELD): BOOL; stdcall;
{Return True if the supplied HID field contains a 3 or 4 byte value}
begin
 {}
 Result:=HIDIsLongField(field);
end;

{==============================================================================}

function hid_is_signed_field(field: PHID_FIELD): BOOL; stdcall;
{Return True if the supplied HID field contains a signed value}
begin
 {}
 Result:=HIDIsSignedField(field);
end;

{==============================================================================}

function hid_page_to_string(page: uint16_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Return a string describing a HID usage page}
begin
 {}
 Result:=APIStringToPCharBuffer(HIDPageToString(page),_string,len);
end;

{==============================================================================}

function hid_usage_to_string(page, usage, count: uint16_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Return a string describing a HID usage within the given page}
begin
 {}
 Result:=APIStringToPCharBuffer(HIDUsageToString(page,usage,count),_string,len);
end;

{==============================================================================}

function hid_unit_type_to_string(unittype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Return a string describing a HID unit type}
begin
 {}
 Result:=APIStringToPCharBuffer(HIDUnitTypeToString(unittype),_string,len);
end;

{==============================================================================}

function hid_report_kind_to_string(kind: uint8_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Return a string describing a HID report type}
begin
 {}
 Result:=APIStringToPCharBuffer(HIDReportKindToString(kind),_string,len);
end;

{==============================================================================}

function hid_report_flags_to_string(flags: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Return a string describing the flags of a HID report}
begin
 {}
 Result:=APIStringToPCharBuffer(HIDReportFlagsToString(flags),_string,len);
end;

{==============================================================================}

function hid_collection_flags_to_string(flags: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Return a string describing the flags of a HID collection}
begin
 {}
 Result:=APIStringToPCharBuffer(HIDCollectionFlagsToString(flags),_string,len);
end;

{==============================================================================}
{HID Device Helper Functions}
function hid_device_get_count: uint32_t; stdcall;
{Get the current HID Device count}
begin
 {}
 Result:=HIDDeviceGetCount;
end;

{==============================================================================}

function hid_device_check(device: PHID_DEVICE): PHID_DEVICE; stdcall;
{Check if the supplied HID Device is in the device table}
begin
 {}
 Result:=HIDDeviceCheck(device);
end;

{==============================================================================}

function hid_device_type_to_string(hidtype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Return a string describing the HID device type (eg HID_TYPE_USB)}
begin
 {}
 Result:=APIStringToPCharBuffer(HIDDeviceTypeToString(hidtype),_string,len);
end;

{==============================================================================}

function hid_device_state_to_string(hidstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Return a string describing the HID device state (eg HID_STATE_ATTACHED)}
begin
 {}
 Result:=APIStringToPCharBuffer(HIDDeviceStateToString(hidstate),_string,len);
end;

{==============================================================================}

function hid_device_state_to_notification(state: uint32_t): uint32_t; stdcall;
{Convert a Device state value into the notification code for device notifications}
begin
 {}
 Result:=HIDDeviceStateToNotification(state);
end;

{==============================================================================}
{HID Consumer Helper Functions}
function hid_consumer_get_count: uint32_t; stdcall;
{Get the current HID Consumer count}
begin
 {}
 Result:=HIDConsumerGetCount;
end;

{==============================================================================}

function hid_consumer_check(consumer: PHID_CONSUMER): PHID_CONSUMER; stdcall;
{Check if the supplied HID Consumer is in the consumer table}
begin
 {}
 Result:=HIDConsumerCheck(consumer);
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{Keymap Functions}
{$IFDEF API_EXPORT_KEYMAP}
function keymap_load(header: PKEYMAP_HEADER; data: PKEYMAP_DATA; size: uint32_t): KEYMAP_HANDLE; stdcall;
{Load a Keymap from a keymap data block and add to the Keymap table}
{Header: Pointer to the keymap header}
{Data: Pointer to the keymap data}
{Size: Size of the keymap data}
{Return: Handle of the newly loaded keymap or INVALID_HANDLE_VALUE on failure}
begin
 {}
 Result:=KeymapLoad(header,data,size);
end;

{==============================================================================}

function keymap_load_ex(header: PKEYMAP_HEADER; data: PKEYMAP_DATA; capskeys: PKEYMAP_CAPSKEYS; deadkeys: PKEYMAP_DEADKEYS; size: uint32_t; properties: PKEYMAP_PROPERTIES): KEYMAP_HANDLE; stdcall;
{Load a Keymap from a keymap data block and add to the Keymap table}
{Header: Pointer to the keymap header (See TKeymapHeader)}
{Data: Pointer to the keymap data (See TKeymapData)}
{Capskeys: Pointer to the capskeys table (Optional)}
{Deadkeys: Pointer to the deadkeys table (Optional)}
{Size: Size of the keymap data}
{Properties: Pointer to a keymap properties record to use instead of the header (Optional)}
{Return: Handle of the newly loaded keymap or INVALID_HANDLE_VALUE on failure}
begin
 {}
 Result:=KeymapLoadEx(header,data,capskeys,deadkeys,size,properties);
end;

{==============================================================================}

function keymap_unload(handle: KEYMAP_HANDLE): uint32_t; stdcall;
{Unload an existing keymap and remove from the Keymap table}
{Handle: The handle of the keymap to unload}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=KeymapUnload(handle);
end;

{==============================================================================}

function keymap_get_name(handle: KEYMAP_HANDLE; name: PCHAR; len: uint32_t): uint32_t; stdcall;
{Get the name of the specified keymap}
{Handle: The handle of the keymap to get the name for}
{Return: The name of the keymap (eg US)}
begin
 {}
 Result:=APIStringToPCharBuffer(KeymapGetName(handle),name,len);
end;

{==============================================================================}

function keymap_get_description(handle: KEYMAP_HANDLE; description: PCHAR; len: uint32_t): uint32_t; stdcall;
{Get the description of the specified keymap}
{Handle: The handle of the keymap to get the description for}
{Return: The description of the keymap (eg US English)}
begin
 {}
 Result:=APIStringToPCharBuffer(KeymapGetDescription(handle),description,len);
end;

{==============================================================================}

function keymap_check_flag(handle: KEYMAP_HANDLE; flag: uint32_t): BOOL; stdcall;
{Check if a specified keymap has a particular flag set or not}
{Handle: The handle of the keymap to check the flag for}
{Flag: The flag value to check (eg KEYMAP_FLAG_CAPS_ASCII)}
{Return: True if the flag is set and False if not set}
begin
 {}
 Result:=KeymapCheckFlag(handle,flag);
end;

{==============================================================================}

function keymap_get_key_code(handle: KEYMAP_HANDLE; scancode: uint16_t; index: uint8_t): uint16_t; stdcall;
{Resolve a scan code and index value to a key code using the specified keymap}
{Handle: The handle of the keymap to use for translation}
{ScanCode: The keyboard scan code value to resolve (eg SCAN_CODE_A)}
{Index: The keymap index to use for the translation (eg KEYMAP_INDEX_SHIFT)}
{Return: The translated key code value (eg KEY_CODE_A) or KEY_CODE_NONE on failure}
begin
 {}
 Result:=KeymapGetKeyCode(handle,scancode,index);
end;

{==============================================================================}

function keymap_get_char_code(handle: KEYMAP_HANDLE; keycode: uint16_t): CHAR; stdcall;
{Resolve a key code value to an ANSI character code using the specified keymap}
{Handle: The handle of the keymap to use for translation}
{KeyCode: The key code value to resolve (eg KEY_CODE_A)}
{Return: The ANSI character value for the keycode or 0 on failure}
begin
 {}
 Result:=KeymapGetCharCode(handle,keycode);
end;

{==============================================================================}

function keymap_get_char_unicode(handle: KEYMAP_HANDLE; keycode: uint16_t): WCHAR; stdcall;
{Resolve a key code value to a Unicode character code using the specified keymap}
{Handle: The handle of the keymap to use for translation}
{KeyCode: The key code value to resolve (eg KEY_CODE_A)}
{Return: The Unicode character value for the keycode or 0 on failure}
begin
 {}
 Result:=KeymapGetCharUnicode(handle,keycode);
end;

{==============================================================================}

function keymap_check_capskey(handle: KEYMAP_HANDLE; scancode: uint16_t): BOOL; stdcall;
{Check if a scan code is affected by the Caps Lock key in the specified keymap}
{Handle: The handle of the keymap to check}
{ScanCode: The scan code value to check (eg SCAN_CODE_A)}
{Return: True if affected by Caps Lock, False if not}
begin
 {}
 Result:=KeymapCheckCapskey(handle,scancode);
end;

{==============================================================================}

function keymap_check_deadkey(handle: KEYMAP_HANDLE; scancode: uint16_t; index: uint8_t): BOOL; stdcall;
{Check if a scan code represents a Dead Key in the specified keymap}
{Handle: The handle of the keymap to check}
{ScanCode: The scan code value to check (eg SCAN_CODE_A)}
{Index: The keymap index to check (eg KEYMAP_INDEX_SHIFT)}
{Return: True if the scan key is a Dead Key, False if not}
begin
 {}
 Result:=KeymapCheckDeadkey(handle,scancode,index);
end;

{==============================================================================}

function keymap_resolve_deadkey(handle: KEYMAP_HANDLE; deadcode, scancode: uint16_t; deadindex, scanindex: uint8_t; var keycode: uint16_t): BOOL; stdcall;
{Resolve a Dead Key and the next scan code to a key code value}
{Handle: The handle of the keymap to use for resolution}
{DeadCode: The scan code value of the dead key (eg SCAN_CODE_GRAVE)}
{ScanCode: The scan code value of the next key (eg (SCAN_CODE_A)}
{DeadIndex: The keymap index of the dead key (eg KEYMAP_INDEX_SHIFT)}
{ScanIndex: The keymap index of the next key (eg KEYMAP_INDEX_SHIFT)}
{KeyCode: Return value for the key code represented by the dead key / next key combination (or KEY_CODE_NONE)}
{Return: True if the dead key / next key combination resolves to a key code or False if not}
begin
 {}
 Result:=KeymapResolveDeadkey(handle,deadcode,scancode,deadindex,scanindex,keycode);
end;

{==============================================================================}

function keymap_get_properties(handle: KEYMAP_HANDLE; properties: PKEYMAP_PROPERTIES): uint32_t; stdcall;
{Get the properties of the specified keymap}
{Handle: The handle of the keymap to get the properties for}
{Properties: Pointer to a keymap properties structure to return the properties}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=KeymapGetProperties(handle,properties);
end;

{==============================================================================}

function keymap_find_by_name(const name: PCHAR): KEYMAP_HANDLE; stdcall;
{Find a keymap by name}
{Name: The name of the keymap to find (eg US)}
{Return: The handle of the matching keymap or INVALID_HANDLE_VALUE if not found}
begin
 {}
 Result:=KeymapFindByName(String(name));
end;

{==============================================================================}

function keymap_find_by_description(const description: PCHAR): KEYMAP_HANDLE; stdcall;
{Find a keymap by description}
{Description: The description of the keymap to find (eg US English)}
{Return: The handle of the matching keymap or INVALID_HANDLE_VALUE if not found}
begin
 {}
 Result:=KeymapFindByDescription(String(description));
end;

{==============================================================================}

function keymap_enumerate(callback: keymap_enumerate_cb; data: PVOID): uint32_t; stdcall;
{Enumerate all loaded keymaps}
{Callback: The function to call for each loaded keymap}
{Data: A private data pointer to pass to callback for each loaded keymap}
begin
 {}
 Result:=KeymapEnumerate(callback,data);
end;

{==============================================================================}
{Keymap Helper Functions}
function keymap_get_count: uint32_t; stdcall;
{Get the current keymap count}
begin
 {}
 Result:=KeymapGetCount;
end;

{==============================================================================}

function keymap_get_default: KEYMAP_HANDLE; stdcall;
{Get the current default keymap}
begin
 {}
 Result:=KeymapGetDefault;
end;

{==============================================================================}

function keymap_set_default(handle: KEYMAP_HANDLE): uint32_t; stdcall;
{Set the current default keymap}
begin
 {}
 Result:=KeymapSetDefault(handle);
end;

{==============================================================================}

function keymap_check(keymap: PKEYMAP_ENTRY): PKEYMAP_ENTRY; stdcall;
{Check if the supplied Keymap is in the Keymap table}
begin
 {}
 Result:=KeymapCheck(keymap);
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{Keyboard Functions}
{$IFDEF API_EXPORT_KEYBOARD}
function keyboard_get(var keycode: uint16_t): uint32_t; stdcall;
{Get the first key code from the global keyboard buffer}
{KeyCode: The returned key code read from the buffer (eg KEY_CODE_A)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Key code is the value translated from the scan code using the current keymap
       it may not be a character code and it may include non printable characters.

       To translate a key code to a character call KeymapGetCharCode()}
begin
 {}
 Result:=KeyboardGet(keycode);
end;

{==============================================================================}

function keyboard_peek: uint32_t; stdcall;
{Peek at the global keyboard buffer to see if any data packets are ready}
{Return: ERROR_SUCCESS if packets are ready, ERROR_NO_MORE_ITEMS if not or another error code on failure}
begin
 {}
 Result:=KeyboardPeek;
end;

{==============================================================================}

function keyboard_read(buffer: PVOID; size: uint32_t; var count: uint32_t): uint32_t; stdcall;
{Read keyboard data packets from the global keyboard buffer}
{Buffer: Pointer to a buffer to copy the keyboard data packets to}
{Size: The size of the buffer in bytes (Must be at least TKeyboardData or greater)}
{Count: The number of keyboard data packets copied to the buffer}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=KeyboardRead(buffer,size,count);
end;

{==============================================================================}

function keyboard_read_ex(buffer: PVOID; size, flags: uint32_t; var count: uint32_t): uint32_t; stdcall;
{Read keyboard data packets from the global keyboard buffer}
{Buffer: Pointer to a buffer to copy the keyboard data packets to}
{Size: The size of the buffer in bytes (Must be at least TKeyboardData or greater)}
{Flags: The flags to use for the read (eg KEYBOARD_FLAG_NON_BLOCK)}
{Count: The number of keyboard data packets copied to the buffer}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=KeyboardReadEx(buffer,size,flags,count);
end;

{==============================================================================}

function keyboard_put(scancode, keycode: uint16_t; modifiers: uint32_t): uint32_t; stdcall;
{Put a scan code and key code in the global keyboard buffer}
{ScanCode: The scan code to write to the buffer (eg SCAN_CODE_A)}
{KeyCode: The key code to write to the buffer (eg KEY_CODE_A)}
{Modifiers: The modifier keys to write to the buffer (eg KEYBOARD_LEFT_CTRL)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=KeyboardPut(scancode,keycode,modifiers);
end;

{==============================================================================}

function keyboard_write(buffer: PVOID; size, count: uint32_t): uint32_t; stdcall;
{Write keyboard data packets to the global keyboard buffer}
{Buffer: Pointer to a buffer to copy the keyboard data packets from}
{Size: The size of the buffer in bytes (Must be at least TKeyboardData or greater)}
{Count: The number of keyboard data packets to copy from the buffer}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=KeyboardWrite(buffer,size,count);
end;

{==============================================================================}

function keyboard_flush: uint32_t; stdcall;
{Flush the contents of the global keyboard buffer}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=KeyboardFlush;
end;

{==============================================================================}

function keyboard_device_get(keyboard: PKEYBOARD_DEVICE; var keycode: uint16_t): uint32_t; stdcall;
{Get the first key code from the buffer of the specified keyboard}
{Keyboard: The keyboard device to get from}
{KeyCode: The returned key code read from the buffer (eg KEY_CODE_A)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Key code is the value translated from the scan code using the current keymap
       it may not be a character code and it may include non printable characters.

       To translate a key code to a character call KeymapGetCharCode()}
begin
 {}
 Result:=KeyboardDeviceGet(keyboard,keycode);
end;

{==============================================================================}

function keyboard_device_read(keyboard: PKEYBOARD_DEVICE; buffer: PVOID; size: uint32_t; var count: uint32_t): uint32_t; stdcall;
{Read keyboard data packets from the buffer of the specified keyboard}
{Keyboard: The keyboard device to read from}
{Buffer: Pointer to a buffer to copy the keyboard data packets to}
{Size: The size of the buffer in bytes (Must be at least TKeyboardData or greater)}
{Count: The number of keyboard data packets copied to the buffer}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=KeyboardDeviceRead(keyboard,buffer,size,count);
end;

{==============================================================================}

function keyboard_device_control(keyboard: PKEYBOARD_DEVICE; request: int; argument1: SIZE_T; var argument2: SIZE_T): uint32_t; stdcall;
{Perform a control request on the specified keyboard device}
{Keyboard: The keyboard device to control}
{Request: The request code for the operation (eg KEYBOARD_CONTROL_GET_FLAG)}
{Argument1: The first argument for the operation (Dependent on request code)}
{Argument2: The second argument for the operation (Dependent on request code)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=KeyboardDeviceControl(keyboard,request,argument1,argument2);
end;

{==============================================================================}

function keyboard_device_set_state(keyboard: PKEYBOARD_DEVICE; state: uint32_t): uint32_t; stdcall;
{Set the state of the specified keyboard and send a notification}
{Keyboard: The keyboard to set the state for}
{State: The new state to set and notify}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=KeyboardDeviceSetState(keyboard,state);
end;

{==============================================================================}

function keyboard_device_create: PKEYBOARD_DEVICE; stdcall;
{Create a new Keyboard device entry}
{Return: Pointer to new Keyboard device entry or nil if keyboard could not be created}
begin
 {}
 Result:=KeyboardDeviceCreate;
end;

{==============================================================================}

function keyboard_device_create_ex(size: uint32_t): PKEYBOARD_DEVICE; stdcall;
{Create a new Keyboard device entry}
{Size: Size in bytes to allocate for new keyboard (Including the keyboard device entry)}
{Return: Pointer to new Keyboard device entry or nil if keyboard could not be created}
begin
 {}
 Result:=KeyboardDeviceCreateEx(size);
end;

{==============================================================================}

function keyboard_device_destroy(keyboard: PKEYBOARD_DEVICE): uint32_t; stdcall;
{Destroy an existing Keyboard device entry}
{Keyboard: The keyboard device to destroy}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=KeyboardDeviceDestroy(keyboard);
end;

{==============================================================================}

function keyboard_device_register(keyboard: PKEYBOARD_DEVICE): uint32_t; stdcall;
{Register a new Keyboard device in the Keyboard table}
{Keyboard: The keyboard device to register}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=KeyboardDeviceRegister(keyboard);
end;

{==============================================================================}

function keyboard_device_deregister(keyboard: PKEYBOARD_DEVICE): uint32_t; stdcall;
{Deregister a Keyboard device from the Keyboard table}
{Keyboard: The keyboard device to deregister}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=KeyboardDeviceDeregister(keyboard);
end;

{==============================================================================}

function keyboard_device_find(keyboardid: uint32_t): PKEYBOARD_DEVICE; stdcall;
{Find a keyboard device by ID in the keyboard table}
{KeyboardId: The ID number of the keyboard to find}
{Return: Pointer to keyboard device entry or nil if not found}
begin
 {}
 Result:=KeyboardDeviceFind(keyboardid);
end;

{==============================================================================}

function keyboard_device_find_by_name(const name: PCHAR): PKEYBOARD_DEVICE; stdcall;
{Find a keyboard device by name in the keyboard table}
{Name: The name of the keyboard to find (eg Keyboard0)}
{Return: Pointer to keyboard device entry or nil if not found}
begin
 {}
 Result:=KeyboardDeviceFindByName(String(name));
end;

{==============================================================================}

function keyboard_device_find_by_description(const description: PCHAR): PKEYBOARD_DEVICE; stdcall;
{Find a keyboard device by description in the keyboard table}
{Description: The description of the keyboard to find (eg USB HID Keyboard)}
{Return: Pointer to keyboard device entry or nil if not found}
begin
 {}
 Result:=KeyboardDeviceFindByDescription(String(description));
end;

{==============================================================================}

function keyboard_device_enumerate(callback: keyboard_enumerate_cb; data: PVOID): uint32_t; stdcall;
{Enumerate all keyboard devices in the keyboard table}
{Callback: The callback function to call for each keyboard in the table}
{Data: A private data pointer to pass to callback for each keyboard in the table}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=KeyboardDeviceEnumerate(callback,data);
end;

{==============================================================================}

function keyboard_device_notification(keyboard: PKEYBOARD_DEVICE; callback: keyboard_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall;
{Register a notification for keyboard device changes}
{Keyboard: The keyboard device to notify changes for (Optional, pass nil for all keyboards)}
{Callback: The function to call when a notification event occurs}
{Data: A private data pointer to pass to callback when a notification event occurs}
{Notification: The events to register for notification of (eg DEVICE_NOTIFICATION_REGISTER)}
{Flags: The flags to control the notification (eg NOTIFIER_FLAG_WORKER)}
begin
 {}
 Result:=KeyboardDeviceNotification(keyboard,callback,data,notification,flags);
end;

{==============================================================================}
{Keyboard Helper Functions}
function keyboard_get_count: uint32_t; stdcall;
{Get the current keyboard count}
begin
 {}
 Result:=KeyboardGetCount;
end;

{==============================================================================}

function keyboard_device_check(keyboard: PKEYBOARD_DEVICE): PKEYBOARD_DEVICE; stdcall;
{Check if the supplied Keyboard is in the keyboard table}
begin
 {}
 Result:=KeyboardDeviceCheck(keyboard);
end;

{==============================================================================}

function keyboard_device_type_to_string(keyboardtype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(KeyboardDeviceTypeToString(keyboardtype),_string,len);
end;

{==============================================================================}

function keyboard_device_state_to_string(keyboardstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(KeyboardDeviceStateToString(keyboardstate),_string,len);
end;

{==============================================================================}

function keyboard_device_state_to_notification(state: uint32_t): uint32_t; stdcall;
{Convert a Keyboard state value into the notification code for device notifications}
begin
 {}
 Result:=KeyboardDeviceStateToNotification(state);
end;

{==============================================================================}

function keyboard_remap_ctrl_code(keycode, charcode: uint16_t): uint16_t; stdcall;
{Remap Ctrl-<Key> combinations to ASCII control codes}
{Note: Caller must check for Left-Ctrl or Right-Ctrl modifiers}
begin
 {}
 Result:=KeyboardRemapCtrlCode(keycode,charcode);
end;

{==============================================================================}

function keyboard_remap_key_code(scancode, keycode: uint16_t; var charcode: uint8_t; modifiers: uint32_t): BOOL; stdcall;
{Remap the SCAN_CODE_* and KEY_CODE_* values to DOS compatible scan codes}
{Returns True is the key was remapped, False if it was not}
{See: http://www.freepascal.org/docs-html/rtl/keyboard/kbdscancode.html}
{See also: \source\packages\rtl-console\src\inc\keyscan.inc}
{Note: See below for a version that uses SCAN_CODE_* values instead of translated KEY_CODE_* values}
begin
 {}
 Result:=KeyboardRemapKeyCode(scancode,keycode,charcode,modifiers);
end;

{==============================================================================}

function keyboard_remap_scan_code(scancode, keycode: uint16_t; var charcode: uint8_t; modifiers: uint32_t): BOOL; stdcall;
{Remap the SCAN_CODE_* and KEY_CODE_* values to DOS compatible scan codes}
{Returns True is the key was remapped, False if it was not}
{See: http://www.freepascal.org/docs-html/rtl/keyboard/kbdscancode.html}
{See also: \source\packages\rtl-console\src\inc\keyscan.inc}
{Note: Same as above except using SCAN_CODE_* values instead of translated KEY_CODE_* values}
begin
 {}
 Result:=KeyboardRemapScanCode(scancode,keycode,charcode,modifiers);
end;

{==============================================================================}

function keyboard_insert_data(keyboard: PKEYBOARD_DEVICE; data: PKEYBOARD_DATA; signal: BOOL): uint32_t; stdcall;
{Insert a TKeyboardData entry into the keyboard buffer (Direct or Global)}
{Keyboard: The keyboard device to insert data for}
{Data: The TKeyboardData entry to insert}
{Signal: If True then signal that new data is available in the buffer}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Caller must hold the keyboard lock}
begin
 {}
 Result:=KeyboardInsertData(keyboard,data,signal);
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{Mouse Functions}
{$IFDEF API_EXPORT_MOUSE}
function mouse_peek: uint32_t; stdcall;
{Peek at the global mouse buffer to see if any data packets are ready}
{Return: ERROR_SUCCESS if packets are ready, ERROR_NO_MORE_ITEMS if not or another error code on failure}
begin
 {}
 Result:=MousePeek;
end;

{==============================================================================}

function mouse_read(buffer: PVOID; size: uint32_t; var count: uint32_t): uint32_t; stdcall;
{Read mouse data packets from the global mouse buffer}
{Buffer: Pointer to a buffer to copy the mouse data packets to}
{Size: The size of the buffer in bytes (Must be at least TMouseData or greater)}
{Count: The number of mouse data packets copied to the buffer}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=MouseRead(buffer,size,count);
end;

{==============================================================================}

function mouse_read_ex(buffer: PVOID; size, flags: uint32_t; var count: uint32_t): uint32_t; stdcall;
{Read mouse data packets from the global mouse buffer}
{Buffer: Pointer to a buffer to copy the mouse data packets to}
{Size: The size of the buffer in bytes (Must be at least TMouseData or greater)}
{Flags: The flags for the behaviour of the read (eg MOUSE_FLAG_NON_BLOCK)}
{Count: The number of mouse data packets copied to the buffer}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=MouseReadEx(buffer,size,flags,count);
end;

{==============================================================================}

function mouse_write(buffer: PVOID; size, count: uint32_t): uint32_t; stdcall;
{Write mouse data packets to the global mouse buffer}
{Buffer: Pointer to a buffer to copy the mouse data packets from}
{Size: The size of the buffer in bytes (Must be at least TMouseData or greater)}
{Count: The number of mouse data packets to copy from the buffer}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=MouseWrite(buffer,size,count);
end;

{==============================================================================}

function mouse_flush: uint32_t; stdcall;
{Flush the contents of the global mouse buffer}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=MouseFlush;
end;

{==============================================================================}

function mouse_device_read(mouse: PMOUSE_DEVICE; buffer: PVOID; size: uint32_t; var count: uint32_t): uint32_t; stdcall;
{Read mouse data packets from the buffer of the specified mouse}
{Mouse: The mouse device to read from}
{Buffer: Pointer to a buffer to copy the mouse data packets to}
{Size: The size of the buffer in bytes (Must be at least TMouseData or greater)}
{Count: The number of mouse data packets copied to the buffer}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=MouseDeviceRead(mouse,buffer,size,count);
end;

{==============================================================================}

function mouse_device_update(mouse: PMOUSE_DEVICE): uint32_t; stdcall;
{Request the specified mouse device to update the current configuration}
{Mouse: The mouse device to update}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Items updated can include rotation, maximum X, Y and wheel and flags (If supported)}
begin
 {}
 Result:=MouseDeviceUpdate(mouse);
end;

{==============================================================================}

function mouse_device_control(mouse: PMOUSE_DEVICE; request: int; argument1: SIZE_T; var argument2: SIZE_T): uint32_t; stdcall;
{Perform a control request on the specified mouse device}
{Mouse: The mouse device to control}
{Request: The request code for the operation (eg MOUSE_CONTROL_GET_FLAG)}
{Argument1: The first argument for the operation (Dependent on request code)}
{Argument2: The second argument for the operation (Dependent on request code)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=MouseDeviceControl(mouse,request,argument1,argument2);
end;

{==============================================================================}

function mouse_device_get_properties(mouse: PMOUSE_DEVICE; properties: PMOUSE_PROPERTIES): uint32_t; stdcall;
{Get the properties for the specified mouse device}
{Mouse: The mouse device to get properties from}
{Properties: Pointer to a TMouseProperties structure to fill in}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=MouseDeviceGetProperties(mouse,properties);
end;

{==============================================================================}

function mouse_device_set_state(mouse: PMOUSE_DEVICE; state: uint32_t): uint32_t; stdcall;
{Set the state of the specified mouse and send a notification}
{Mouse: The mouse to set the state for}
{State: The new state to set and notify}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=MouseDeviceSetState(mouse,state);
end;

{==============================================================================}

function mouse_device_create: PMOUSE_DEVICE; stdcall;
{Create a new Mouse device entry}
{Return: Pointer to new Mouse device entry or nil if mouse could not be created}
begin
 {}
 Result:=MouseDeviceCreate;
end;

{==============================================================================}

function mouse_device_create_ex(size: uint32_t): PMOUSE_DEVICE; stdcall;
{Create a new Mouse device entry}
{Size: Size in bytes to allocate for new mouse (Including the mouse device entry)}
{Return: Pointer to new Mouse device entry or nil if mouse could not be created}
begin
 {}
 Result:=MouseDeviceCreateEx(size);
end;

{==============================================================================}

function mouse_device_destroy(mouse: PMOUSE_DEVICE): uint32_t; stdcall;
{Destroy an existing Mouse device entry}
{Mouse: The mouse device to destroy}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=MouseDeviceDestroy(mouse);
end;

{==============================================================================}

function mouse_device_register(mouse: PMOUSE_DEVICE): uint32_t; stdcall;
{Register a new Mouse device in the Mouse table}
{Mouse: The mouse device to register}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=MouseDeviceRegister(mouse);
end;

{==============================================================================}

function mouse_device_deregister(mouse: PMOUSE_DEVICE): uint32_t; stdcall;
{Deregister a Mouse device from the Mouse table}
{Mouse: The mouse device to deregister}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=MouseDeviceDeregister(mouse);
end;

{==============================================================================}

function mouse_device_find(mouseid: uint32_t): PMOUSE_DEVICE; stdcall;
{Find a mouse device by ID in the mouse table}
{MouseId: The ID number of the mouse to find}
{Return: Pointer to mouse device entry or nil if not found}
begin
 {}
 Result:=MouseDeviceFind(mouseid);
end;

{==============================================================================}

function mouse_device_find_by_name(const name: PCHAR): PMOUSE_DEVICE; stdcall;
{Find a mouse device by name in the mouse table}
{Name: The name of the mouse to find (eg Mouse0)}
{Return: Pointer to mouse device entry or nil if not found}
begin
 {}
 Result:=MouseDeviceFindByName(String(name));
end;

{==============================================================================}

function mouse_device_find_by_description(const description: PCHAR): PMOUSE_DEVICE; stdcall;
{Find a mouse device by description in the mouse table}
{Description: The description of the mouse to find (eg USB HID Mouse)}
{Return: Pointer to mouse device entry or nil if not found}
begin
 {}
 Result:=MouseDeviceFindByDescription(String(description));
end;

{==============================================================================}

function mouse_device_enumerate(callback: mouse_enumerate_cb; data: PVOID): uint32_t; stdcall;
{Enumerate all mouse devices in the mouse table}
{Callback: The callback function to call for each mouse in the table}
{Data: A private data pointer to pass to callback for each mouse in the table}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=MouseDeviceEnumerate(callback,data);
end;

{==============================================================================}

function mouse_device_notification(mouse: PMOUSE_DEVICE; callback: mouse_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall;
{Register a notification for mouse device changes}
{Mouse: The mouse device to notify changes for (Optional, pass nil for all mice)}
{Callback: The function to call when a notification event occurs}
{Data: A private data pointer to pass to callback when a notification event occurs}
{Notification: The events to register for notification of (eg DEVICE_NOTIFICATION_REGISTER)}
{Flags: The flags to control the notification (eg NOTIFIER_FLAG_WORKER)}
begin
 {}
 Result:=MouseDeviceNotification(mouse,callback,data,notification,flags);
end;

{==============================================================================}
{Mouse Helper Functions}
function mouse_get_count: uint32_t; stdcall;
{Get the current mouse count}
begin
 {}
 Result:=MouseGetCount;
end;

{==============================================================================}

function mouse_device_check(mouse: PMOUSE_DEVICE): PMOUSE_DEVICE; stdcall;
{Check if the supplied Mouse is in the mouse table}
begin
 {}
 Result:=MouseDeviceCheck(mouse);
end;

{==============================================================================}

function mouse_device_type_to_string(mousetype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(MouseDeviceTypeToString(mousetype),_string,len);
end;

{==============================================================================}

function mouse_device_state_to_string(mousestate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(MouseDeviceStateToString(mousestate),_string,len);
end;

{==============================================================================}

function mouse_device_rotation_to_string(rotation: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Return a string describing the supplied mouse rotation value}
begin
 {}
 Result:=APIStringToPCharBuffer(MouseDeviceRotationToString(rotation),_string,len);
end;

{==============================================================================}

function mouse_device_state_to_notification(state: uint32_t): uint32_t; stdcall;
{Convert a Mouse state value into the notification code for device notifications}
begin
 {}
 Result:=MouseDeviceStateToNotification(state);
end;

{==============================================================================}

function mouse_device_resolve_rotation(rotation: uint32_t): uint32_t; stdcall;
{Resolve a value of 0, 90, 180 or 270 to a mouse rotation constant (eg MOUSE_ROTATION_180)}
{Note: Also accepts passing the mouse rotation constant values directly}
begin
 {}
 Result:=MouseDeviceResolveRotation(rotation);
end;

{==============================================================================}

function mouse_insert_data(mouse: PMOUSE_DEVICE; data: PMOUSE_DATA; signal: BOOL): uint32_t; stdcall;
{Insert a TMouseData entry into the mouse buffer (Direct or Global)}
{Mouse: The mouse device to insert data for}
{Data: The TMouseData entry to insert}
{Signal: If True then signal that new data is available in the buffer}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Caller must hold the mouse lock}
begin
 {}
 Result:=MouseInsertData(mouse,data,signal);
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{Touch Functions}
{$IFDEF API_EXPORT_TOUCH}
function touch_device_start(touch: PTOUCH_DEVICE): uint32_t; stdcall;
{Start the specified Touch device ready for receiving events}
{Touch: The Touch device to start}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=TouchDeviceStart(touch);
end;

{==============================================================================}

function touch_device_stop(touch: PTOUCH_DEVICE): uint32_t; stdcall;
{Stop the specified Touch device and terminate receiving events}
{Touch: The Touch device to stop}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=TouchDeviceStop(touch);
end;

{==============================================================================}

function touch_device_peek(touch: PTOUCH_DEVICE): uint32_t; stdcall;
{Peek at the buffer of the specified touch device to see if any data packets are ready}
{Touch: The Touch device to peek at}
{Return: ERROR_SUCCESS if packets are ready, ERROR_NO_MORE_ITEMS if not or another error code on failure}
begin
 {}
 Result:=TouchDevicePeek(touch);
end;

{==============================================================================}

function touch_device_read(touch: PTOUCH_DEVICE; buffer: PVOID; size, flags: uint32_t; var count: uint32_t): uint32_t; stdcall;
{Read touch data packets from the buffer of the specified touch device}
{Touch: The Touch device to read from}
{Buffer: Pointer to a buffer to copy the touch data packets to}
{Size: The size of the buffer in bytes (Must be at least TTouchData or greater)}
{Flags: The flags for the behaviour of the read (eg TOUCH_FLAG_NON_BLOCK)}
{Count: The number of touch data packets copied to the buffer}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=TouchDeviceRead(touch,buffer,size,flags,count);
end;

{==============================================================================}

function touch_device_write(touch: PTOUCH_DEVICE; buffer: PVOID; size, count: uint32_t): uint32_t; stdcall;
{Write touch data packets to the buffer of the specified touch device}
{Touch: The Touch device to write to}
{Buffer: Pointer to a buffer to copy the touch data packets from}
{Size: The size of the buffer in bytes (Must be at least TTouchData or greater)}
{Count: The number of touch data packets to copy from the buffer}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=TouchDeviceWrite(touch,buffer,size,count);
end;

{==============================================================================}

function touch_device_flush(touch: PTOUCH_DEVICE): uint32_t; stdcall;
{Flush the contents of the buffer of the specified touch device}
{Touch: The Touch device to flush}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=TouchDeviceFlush(touch);
end;

{==============================================================================}

function touch_device_update(touch: PTOUCH_DEVICE): uint32_t; stdcall;
{Request the specified touch device to update the current configuration}
{Touch: The Touch device to update}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Items updated can include rotation, maximum X and Y and flags (If supported)}
begin
 {}
 Result:=TouchDeviceUpdate(touch);
end;

{==============================================================================}

function touch_device_control(touch: PTOUCH_DEVICE; request: int; argument1: SIZE_T; var argument2: SIZE_T): uint32_t; stdcall;
{Perform a control request on the specified touch device}
{Touch: The Touch device to control}
{Request: The request code for the operation (eg TOUCH_CONTROL_GET_FLAG)}
{Argument1: The first argument for the operation (Dependent on request code)}
{Argument2: The second argument for the operation (Dependent on request code)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=TouchDeviceControl(touch,request,argument1,argument2);
end;

{==============================================================================}

function touch_device_properties(touch: PTOUCH_DEVICE; properties: PTOUCH_PROPERTIES): uint32_t; stdcall;
{Get the properties for the specified Touch device}
{Touch: The Touch device to get properties from}
{Properties: Pointer to a TTouchProperties structure to fill in}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Replaced by TouchDeviceGetProperties for consistency}
begin
 {}
 Result:=TouchDeviceProperties(touch,properties);
end;

{==============================================================================}

function touch_device_get_properties(touch: PTOUCH_DEVICE; properties: PTOUCH_PROPERTIES): uint32_t; stdcall;
{Get the properties for the specified Touch device}
{Touch: The Touch device to get properties from}
{Properties: Pointer to a TTouchProperties structure to fill in}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=TouchDeviceGetProperties(touch,properties);
end;

{==============================================================================}

function touch_device_create: PTOUCH_DEVICE; stdcall;
{Create a new Touch device entry}
{Return: Pointer to new Touch device entry or nil if Touch device could not be created}
begin
 {}
 Result:=TouchDeviceCreate;
end;

{==============================================================================}

function touch_device_create_ex(size: uint32_t): PTOUCH_DEVICE; stdcall;
{Create a new Touch device entry}
{Size: Size in bytes to allocate for new Touch device (Including the Touch device entry)}
{Return: Pointer to new Touch device entry or nil if Touch device could not be created}
begin
 {}
 Result:=TouchDeviceCreateEx(size);
end;

{==============================================================================}

function touch_device_destroy(touch: PTOUCH_DEVICE): uint32_t; stdcall;
{Destroy an existing Touch device entry}
{Touch: The Touch device to destroy}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=TouchDeviceDestroy(touch);
end;

{==============================================================================}

function touch_device_register(touch: PTOUCH_DEVICE): uint32_t; stdcall;
{Register a new Touch device in the Touch device table}
{Touch: The Touch device to register}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=TouchDeviceRegister(touch);
end;

{==============================================================================}

function touch_device_deregister(touch: PTOUCH_DEVICE): uint32_t; stdcall;
{Deregister a Touch device from the Touch device table}
{Touch: The Touch device to deregister}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=TouchDeviceDeregister(touch);
end;

{==============================================================================}

function touch_device_find(touchid: uint32_t): PTOUCH_DEVICE; stdcall;
{Find a Touch device by ID in the Touch device table}
{TouchId: The ID number of the Touch device to find}
{Return: Pointer to Touch device entry or nil if not found}
begin
 {}
 Result:=TouchDeviceFind(touchid);
end;

{==============================================================================}

function touch_device_find_by_name(const name: PCHAR): PTOUCH_DEVICE; stdcall;
{Find a Touch device by name in the device table}
{Name: The name of the Touch device to find (eg Touch0)}
{Return: Pointer to Touch device entry or nil if not found}
begin
 {}
 Result:=TouchDeviceFindByName(String(name));
end;

{==============================================================================}

function touch_device_find_by_description(const description: PCHAR): PTOUCH_DEVICE; stdcall;
{Find a Touch device by description in the device table}
{Description: The description of the Touch to find (eg USB Touchscreen)}
{Return: Pointer to Touch device entry or nil if not found}
begin
 {}
 Result:=TouchDeviceFindByDescription(String(description));
end;

{==============================================================================}

function touch_device_enumerate(callback: touch_enumerate_cb; data: PVOID): uint32_t; stdcall;
{Enumerate all Touch devices in the Touch device table}
{Callback: The callback function to call for each Touch device in the table}
{Data: A private data pointer to pass to callback for each Touch device in the table}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=TouchDeviceEnumerate(callback,data);
end;

{==============================================================================}

function touch_device_notification(touch: PTOUCH_DEVICE; callback: touch_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall;
{Register a notification for Touch device changes}
{Touch: The Touch device to notify changes for (Optional, pass nil for all Touch devices)}
{Callback: The function to call when a notification event occurs}
{Data: A private data pointer to pass to callback when a notification event occurs}
{Notification: The events to register for notification of (eg DEVICE_NOTIFICATION_REGISTER)}
{Flags: The flags to control the notification (eg NOTIFIER_FLAG_WORKER)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=TouchDeviceNotification(touch,callback,data,notification,flags);
end;

{==============================================================================}
{Touch Helper Functions}
function touch_get_count: uint32_t; stdcall;
{Get the current Touch device count}
{Return: The number of Touch devices}
begin
 {}
 Result:=TouchGetCount;
end;

{==============================================================================}

function touch_device_get_default: PTOUCH_DEVICE; stdcall;
{Get the current default Touch device}
{Return: Pointer to default Touch device entry}
begin
 {}
 Result:=TouchDeviceGetDefault;
end;

{==============================================================================}

function touch_device_set_default(touch: PTOUCH_DEVICE): uint32_t; stdcall;
{Set the current default Touch device}
{Touch: The Touch device to set as default}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=TouchDeviceSetDefault(touch);
end;

{==============================================================================}

function touch_device_check(touch: PTOUCH_DEVICE): PTOUCH_DEVICE; stdcall;
{Check if the supplied Touch device is in the Touch device table}
{Touch: The Touch device to check}
{Return: Pointer to Touch device entry or nil if not found}
begin
 {}
 Result:=TouchDeviceCheck(touch);
end;

{==============================================================================}

function touch_device_type_to_string(touchtype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Return a string describing the Touch device type (eg TOUCH_TYPE_CAPACITIVE)}
begin
 {}
 Result:=APIStringToPCharBuffer(TouchDeviceTypeToString(touchtype),_string,len);
end;

{==============================================================================}

function touch_device_state_to_string(touchstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Return a string describing the Touch device state (eg TOUCH_STATE_ENABLED)}
begin
 {}
 Result:=APIStringToPCharBuffer(TouchDeviceStateToString(touchstate),_string,len);
end;

{==============================================================================}

function touch_device_rotation_to_string(rotation: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Return a string describing the supplied touch rotation value}
begin
 {}
 Result:=APIStringToPCharBuffer(TouchDeviceRotationToString(rotation),_string,len);
end;

{==============================================================================}

function touch_device_resolve_rotation(rotation: uint32_t): uint32_t; stdcall;
{Resolve a value of 0, 90, 180 or 270 to a touch rotation constant (eg TOUCH_ROTATION_180)}
{Note: Also accepts passing the touch rotation constant values directly}
begin
 {}
 Result:=TouchDeviceResolveRotation(rotation);
end;

{==============================================================================}

function touch_device_set_callback(touch: PTOUCH_DEVICE; event: touch_event_cb; parameter: PVOID): uint32_t; stdcall;
{Set the event callback function for the specified touch device}
{Touch: The touch device to set the event callback for}
{Event: The event callback function to be called when touch data is received}
{Parameter: A pointer to private data to be passed to the callback with each event}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: This function also clears the TOUCH_FLAG_MOUSE_DATA flag because the event}
{      callback is not compatible with receiving touch events as mouse data}
begin
 {}
 Result:=TouchDeviceSetCallback(touch,event,parameter);
end;

{==============================================================================}

function touch_insert_data(touch: PTOUCH_DEVICE; data: PTOUCH_DATA; signal: BOOL): uint32_t; stdcall;
{Insert a TTouchData entry into the touch device buffer}
{Touch: The touch device to insert data for}
{Data: The TTouchData entry to insert}
{Signal: If True then signal that new data is available in the buffer}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Caller must hold the touch device lock}
begin
 {}
 Result:=TouchInsertData(touch,data,signal);
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{Joystick Functions}
{$IFDEF API_EXPORT_JOYSTICK}
function joystick_device_start(joystick: PJOYSTICK_DEVICE): uint32_t; stdcall;
{Start the specified Joystick device ready for receiving events}
{Joystick: The Joystick device to start}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=JoystickDeviceStart(joystick);
end;

{==============================================================================}

function joystick_device_stop(joystick: PJOYSTICK_DEVICE): uint32_t; stdcall;
{Stop the specified Joystick device and terminate receiving events}
{Joystick: The Joystick device to stop}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=JoystickDeviceStop(joystick);
end;

{==============================================================================}

function joystick_device_peek(joystick: PJOYSTICK_DEVICE): uint32_t; stdcall;
{Peek at the buffer of the specified joystick device to see if any data packets are ready}
{Joystick: The Joystick device to peek at}
{Return: ERROR_SUCCESS if packets are ready, ERROR_NO_MORE_ITEMS if not or another error code on failure}
begin
 {}
 Result:=JoystickDevicePeek(joystick);
end;

{==============================================================================}

function joystick_device_read(joystick: PJOYSTICK_DEVICE; buffer: PVOID; size, flags: uint32_t; var count: uint32_t): uint32_t; stdcall;
{Read joystick data packets from the buffer of the specified joystick device}
{Joystick: The Joystick device to read from}
{Buffer: Pointer to a buffer to copy the joystick data packets to}
{Size: The size of the buffer in bytes (Must be at least TJoystickData or greater)}
{Flags: The flags for the behaviour of the read (eg JOYSTICK_FLAG_NON_BLOCK)}
{Count: The number of joystick data packets copied to the buffer}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=JoystickDeviceRead(joystick,buffer,size,flags,count);
end;

{==============================================================================}

function joystick_device_write(joystick: PJOYSTICK_DEVICE; buffer: PVOID; size, count: uint32_t): uint32_t; stdcall;
{Write joystick data packets to the buffer of the specified joystick device}
{Joystick: The Joystick device to write to}
{Buffer: Pointer to a buffer to copy the joystick data packets from}
{Size: The size of the buffer in bytes (Must be at least TJoystickData or greater)}
{Count: The number of joystick data packets to copy from the buffer}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=JoystickDeviceWrite(joystick,buffer,size,count);
end;

{==============================================================================}

function joystick_device_flush(joystick: PJOYSTICK_DEVICE): uint32_t; stdcall;
{Flush the contents of the buffer of the specified joystick device}
{Joystick: The Joystick device to flush}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=JoystickDeviceFlush(joystick);
end;

{==============================================================================}

function joystick_device_update(joystick: PJOYSTICK_DEVICE): uint32_t; stdcall;
{Request the specified Joystick device to update the current configuration}
{Joystick: The Joystick device to update}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Items updated can include rotation, maximum X and Y and flags (If supported)}
begin
 {}
 Result:=JoystickDeviceUpdate(joystick);
end;

{==============================================================================}

function joystick_device_control(joystick: PJOYSTICK_DEVICE; request: int; argument1: SIZE_T; var argument2: SIZE_T): uint32_t; stdcall;
{Perform a control request on the specified Joystick device}
{Joystick: The Joystick device to control}
{Request: The request code for the operation (eg JOYSTICK_CONTROL_GET_FLAG)}
{Argument1: The first argument for the operation (Dependent on request code)}
{Argument2: The second argument for the operation (Dependent on request code)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=JoystickDeviceControl(joystick,request,argument1,argument2);
end;

{==============================================================================}

function joystick_device_get_properties(joystick: PJOYSTICK_DEVICE; properties: PJOYSTICK_PROPERTIES): uint32_t; stdcall;
{Get the properties for the specified Joystick device}
{Joystick: The Joystick device to get properties from}
{Properties: Pointer to a TJoystickProperties structure to fill in}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=JoystickDeviceGetProperties(joystick,properties);
end;

{==============================================================================}

function joystick_device_set_state(joystick: PJOYSTICK_DEVICE; state: uint32_t): uint32_t; stdcall;
{Set the state of the specified joystick and send a notification}
{Joystick: The joystick to set the state for}
{State: The new state to set and notify}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=JoystickDeviceSetState(joystick,state);
end;

{==============================================================================}

function joystick_device_create: PJOYSTICK_DEVICE; stdcall;
{Create a new Joystick device entry}
{Return: Pointer to new Joystick device entry or nil if Joystick device could not be created}
begin
 {}
 Result:=JoystickDeviceCreate;
end;

{==============================================================================}

function joystick_device_create_ex(size: uint32_t): PJOYSTICK_DEVICE; stdcall;
{Create a new Joystick device entry}
{Size: Size in bytes to allocate for new Joystick device (Including the Joystick device entry)}
{Return: Pointer to new Joystick device entry or nil if Joystick device could not be created}
begin
 {}
 Result:=JoystickDeviceCreateEx(size);
end;

{==============================================================================}

function joystick_device_destroy(joystick: PJOYSTICK_DEVICE): uint32_t; stdcall;
{Destroy an existing Joystick device entry}
{Joystick: The Joystick device to destroy}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=JoystickDeviceDestroy(joystick);
end;

{==============================================================================}

function joystick_device_register(joystick: PJOYSTICK_DEVICE): uint32_t; stdcall;
{Register a new Joystick device in the Joystick device table}
{Joystick: The Joystick device to register}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=JoystickDeviceRegister(joystick);
end;

{==============================================================================}

function joystick_device_deregister(joystick: PJOYSTICK_DEVICE): uint32_t; stdcall;
{Deregister a Joystick device from the Joystick device table}
{Joystick: The Joystick device to deregister}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=JoystickDeviceDeregister(joystick);
end;

{==============================================================================}

function joystick_device_find(joystickid: uint32_t): PJOYSTICK_DEVICE; stdcall;
{Find a Joystick device by ID in the Joystick device table}
{JoystickId: The ID number of the Joystick device to find}
{Return: Pointer to Joystick device entry or nil if not found}
begin
 {}
 Result:=JoystickDeviceFind(joystickid);
end;

{==============================================================================}

function joystick_device_find_by_name(const name: PCHAR): PJOYSTICK_DEVICE; stdcall;
{Find a Joystick device by name in the device table}
{Name: The name of the Joystick device to find (eg Joystick0)}
{Return: Pointer to Joystick device entry or nil if not found}
begin
 {}
 Result:=JoystickDeviceFindByName(String(name));
end;

{==============================================================================}

function joystick_device_find_by_description(const description: PCHAR): PJOYSTICK_DEVICE; stdcall;
{Find a Joystick device by description in the device table}
{Description: The description of the Joystick to find (eg USB Gamepad)}
{Return: Pointer to Joystick device entry or nil if not found}
begin
 {}
 Result:=JoystickDeviceFindByDescription(String(description));
end;

{==============================================================================}

function joystick_device_enumerate(callback: joystick_enumerate_cb; data: PVOID): uint32_t; stdcall;
{Enumerate all Joystick devices in the Joystick device table}
{Callback: The callback function to call for each Joystick device in the table}
{Data: A private data pointer to pass to callback for each Joystick device in the table}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=JoystickDeviceEnumerate(callback,data);
end;

{==============================================================================}

function joystick_device_notification(joystick: PJOYSTICK_DEVICE; callback: joystick_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall;
{Register a notification for Joystick device changes}
{Joystick: The Joystick device to notify changes for (Optional, pass nil for all Joystick devices)}
{Callback: The function to call when a notification event occurs}
{Data: A private data pointer to pass to callback when a notification event occurs}
{Notification: The events to register for notification of (eg DEVICE_NOTIFICATION_REGISTER)}
{Flags: The flags to control the notification (eg NOTIFIER_FLAG_WORKER)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=JoystickDeviceNotification(joystick,callback,data,notification,flags);
end;

{==============================================================================}
{Joystick Helper Functions}
function joystick_get_count: uint32_t; stdcall;
{Get the current Joystick device count}
{Return: The number of Joystick devices}
begin
 {}
 Result:=JoystickGetCount;
end;

{==============================================================================}

function joystick_device_get_default: PJOYSTICK_DEVICE; stdcall;
{Get the current default Joystick device}
{Return: Pointer to default Joystick device entry}
begin
 {}
 Result:=JoystickDeviceGetDefault;
end;

{==============================================================================}

function joystick_device_set_default(joystick: PJOYSTICK_DEVICE): uint32_t; stdcall;
{Set the current default Joystick device}
{Joystick: The Joystick device to set as default}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=JoystickDeviceSetDefault(joystick);
end;

{==============================================================================}

function joystick_device_check(joystick: PJOYSTICK_DEVICE): PJOYSTICK_DEVICE; stdcall;
{Check if the supplied Joystick device is in the Joystick device table}
{Joystick: The Joystick device to check}
{Return: Pointer to Joystick device entry or nil if not found}
begin
 {}
 Result:=JoystickDeviceCheck(joystick);
end;

{==============================================================================}

function joystick_device_axis_to_string(name: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Return a string describing a Joystick or Gamepad Axis (eg JOYSTICK_AXIS_X)}
begin
 {}
 Result:=APIStringToPCharBuffer(JoystickDeviceAxisToString(name),_string,len);
end;

{==============================================================================}

function joystick_device_hat_to_string(name: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Return a string describing a Joystick or Gamepad Hat (eg JOYSTICK_HAT_POV)}
begin
 {}
 Result:=APIStringToPCharBuffer(JoystickDeviceHatToString(name),_string,len);
end;

{==============================================================================}

function joystick_device_button_to_string(name: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Return a string describing a Joystick or Gamepad Button (eg GAMEPAD_BUTTON_UP)}
begin
 {}
 Result:=APIStringToPCharBuffer(JoystickDeviceButtonToString(name),_string,len);
end;

{==============================================================================}

function joystick_device_type_to_string(joysticktype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Return a string describing the Joystick device type (eg JOYSTICK_TYPE_JOYSTICK)}
begin
 {}
 Result:=APIStringToPCharBuffer(JoystickDeviceTypeToString(joysticktype),_string,len);
end;

{==============================================================================}

function joystick_device_state_to_string(joystickstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{Return a string describing the Joystick device state (eg JOYSTICK_STATE_ENABLED)}
begin
 {}
 Result:=APIStringToPCharBuffer(JoystickDeviceStateToString(joystickstate),_string,len);
end;

{==============================================================================}

function joystick_device_state_to_notification(state: uint32_t): uint32_t; stdcall;
{Convert a Joystick state value into the notification code for device notifications}
begin
 {}
 Result:=JoystickDeviceStateToNotification(state);
end;

{==============================================================================}

function joystick_device_get_axis(joystick: PJOYSTICK_DEVICE; index: uint32_t): uint32_t; stdcall;
{Get the name (identifier) of an Axis on the specified Joystick}
{Joystick: The Joystick device to get the name from}
{Index: The index of the Axis in the Joystick properties (First Axis is 0)}
{Return: The current name of the Axis (eg GAMEPAD_AXIS_LEFT_X)}
begin
 {}
 Result:=JoystickDeviceGetAxis(joystick,index);
end;

{==============================================================================}

function joystick_device_set_axis(joystick: PJOYSTICK_DEVICE; index, name: uint32_t): uint32_t; stdcall;
{Set the name (identifier) of an Axis on the specified Joystick}
{Joystick: The Joystick device to set the name for}
{Index: The index of the Axis in the Joystick properties (First Axis is 0)}
{Name: The name (identifier) to set for the Axis (eg JOYSTICK_AXIS_X}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=JoystickDeviceSetAxis(joystick,index,name);
end;

{==============================================================================}

function joystick_device_get_hat(joystick: PJOYSTICK_DEVICE; index: uint32_t): uint32_t; stdcall;
{Get the name (identifier) of a Hat on the specified Joystick}
{Joystick: The Joystick device to get the name from}
{Index: The index of the Hat in the Joystick properties (First Hat is 0)}
{Return: The current name of the Hat (eg GAMEPAD_HAT_POV)}
begin
 {}
 Result:=JoystickDeviceGetHat(joystick,index);
end;

{==============================================================================}

function joystick_device_set_hat(joystick: PJOYSTICK_DEVICE; index, name: uint32_t): uint32_t; stdcall;
{Set the name (identifier) of a Hat on the specified Joystick}
{Joystick: The Joystick device to set the name for}
{Index: The index of the Hat in the Joystick properties (First Hat is 0)}
{Name: The name (identifier) to set for the Hat (eg JOYSTICK_HAT_POV)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=JoystickDeviceSetHat(joystick,index,name);
end;

{==============================================================================}

function joystick_device_get_button(joystick: PJOYSTICK_DEVICE; index: uint32_t): uint32_t; stdcall;
{Get the name (identifier) of a Button on the specified Joystick}
{Joystick: The Joystick device to get the name from}
{Index: The index of the Button in the Joystick properties (First Button is 0)}
{Return: The current name of the Button (eg GAMEPAD_BUTTON_B)}
begin
 {}
 Result:=JoystickDeviceGetButton(joystick,index);
end;

{==============================================================================}

function joystick_device_set_button(joystick: PJOYSTICK_DEVICE; index, name: uint32_t): uint32_t; stdcall;
{Set the name (identifier) of a Button on the specified Joystick}
{Joystick: The Joystick device to set the name for}
{Index: The index of the Button in the Joystick properties (First Button is 0)}
{Name: The name (identifier) to set for the Button (eg GAMEPAD_BUTTON_LT)}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=JoystickDeviceSetButton(joystick,index,name);
end;

{==============================================================================}

function joystick_device_set_callback(joystick: PJOYSTICK_DEVICE; event: joystick_event_cb; parameter: PVOID): uint32_t; stdcall;
{Set the event callback function for the specified Joystick}
{Joystick: The Joystick device to set the event callback for}
{Event: The event callback function to be called when Joystick data is received}
{Parameter: A pointer to private data to be passed to the callback with each event}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=JoystickDeviceSetCallback(joystick,event,parameter);
end;

{==============================================================================}

function joystick_insert_data(joystick: PJOYSTICK_DEVICE; data: PJOYSTICK_DATA; signal: BOOL): uint32_t; stdcall;
{Insert a TJoystickData entry into the joystick device buffer}
{Joystick: The joystick device to insert data for}
{Data: The TJoystickData entry to insert}
{Signal: If True then signal that new data is available in the buffer}
{Return: ERROR_SUCCESS if completed or another error code on failure}
{Note: Caller must hold the joystick device lock}
begin
 {}
 Result:=JoystickInsertData(joystick,data,signal);
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{Storage Functions}
{$IFDEF API_EXPORT_STORAGE}
function storage_device_read(storage: PSTORAGE_DEVICE; const start, count: int64_t; buffer: PVOID): uint32_t; stdcall;
begin
 {}
 Result:=StorageDeviceRead(storage,start,count,buffer);
end;

{==============================================================================}

function storage_device_write(storage: PSTORAGE_DEVICE; const start, count: int64_t; buffer: PVOID): uint32_t; stdcall;
begin
 {}
 Result:=StorageDeviceWrite(storage,start,count,buffer);
end;

{==============================================================================}

function storage_device_erase(storage: PSTORAGE_DEVICE; const start, count: int64_t): uint32_t; stdcall;
begin
 {}
 Result:=StorageDeviceErase(storage,start,count);
end;

{==============================================================================}

function storage_device_control(storage: PSTORAGE_DEVICE; request: int; argument1: SIZE_T; var argument2: SIZE_T): uint32_t; stdcall;
begin
 {}
 Result:=StorageDeviceControl(storage,request,argument1,argument2);
end;

{==============================================================================}

function storage_device_set_state(storage: PSTORAGE_DEVICE; state: uint32_t): uint32_t; stdcall;
{Set the state of the specified storage and send a notification}
{Storage: The storage to set the state for}
{State: The new state to set and notify}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=StorageDeviceSetState(storage,state);
end;

{==============================================================================}

function storage_device_start_status(storage: PSTORAGE_DEVICE; interval: uint32_t): uint32_t; stdcall;
{Start status monitoring on the specified storage for insert/eject notifications}
{Storage: The storage to start status monitoring for}
{Interval: The status monitoring interval in milliseconds}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=StorageDeviceStartStatus(storage,interval);
end;

{==============================================================================}

function storage_device_stop_status(storage: PSTORAGE_DEVICE): uint32_t; stdcall;
{Stop status monitoring on the specified storage for insert/eject notifications}
{Storage: The storage to stop status monitoring for}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=StorageDeviceStopStatus(storage);
end;

{==============================================================================}

function storage_device_create: PSTORAGE_DEVICE; stdcall;
{Create a new Storage entry}
{Return: Pointer to new Storage entry or nil if storage could not be created}
begin
 {}
 Result:=StorageDeviceCreate;
end;

{==============================================================================}

function storage_device_create_ex(size: uint32_t): PSTORAGE_DEVICE; stdcall;
{Create a new Storage entry}
{Size: Size in bytes to allocate for new storage (Including the storage entry)}
{Return: Pointer to new Storage entry or nil if storage could not be created}
begin
 {}
 Result:=StorageDeviceCreateEx(size);
end;

{==============================================================================}

function storage_device_destroy(storage: PSTORAGE_DEVICE): uint32_t; stdcall;
{Destroy an existing Storage entry}
begin
 {}
 Result:=StorageDeviceDestroy(storage);
end;

{==============================================================================}

function storage_device_register(storage: PSTORAGE_DEVICE): uint32_t; stdcall;
{Register a new Storage in the Storage table}
begin
 {}
 Result:=StorageDeviceRegister(storage);
end;

{==============================================================================}

function storage_device_deregister(storage: PSTORAGE_DEVICE): uint32_t; stdcall;
{Deregister a Storage from the Storage table}
begin
 {}
 Result:=StorageDeviceDeregister(storage);
end;

{==============================================================================}

function storage_device_find(storageid: uint32_t): PSTORAGE_DEVICE; stdcall;
begin
 {}
 Result:=StorageDeviceFind(storageid);
end;

{==============================================================================}

function storage_device_find_by_device(device: PDEVICE): PSTORAGE_DEVICE; stdcall;
{Find a Storage device by the matching DeviceData property}
{Device: The device entry to match with the DeviceData value}
{Return: The Storage device matched or nil if none found}
begin
 {}
 Result:=StorageDeviceFindByDevice(device);
end;

{==============================================================================}

function storage_device_find_by_name(const name: PCHAR): PSTORAGE_DEVICE; stdcall;
begin
 {}
 Result:=StorageDeviceFindByName(String(name));
end;

{==============================================================================}

function storage_device_find_by_description(const description: PCHAR): PSTORAGE_DEVICE; stdcall;
begin
 {}
 Result:=StorageDeviceFindByDescription(String(description));
end;

{==============================================================================}

function storage_device_enumerate(callback: storage_enumerate_cb; data: PVOID): uint32_t; stdcall;
begin
 {}
 Result:=StorageDeviceEnumerate(callback,data);
end;

{==============================================================================}

function storage_device_notification(storage: PSTORAGE_DEVICE; callback: storage_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=StorageDeviceNotification(storage,callback,data,notification,flags);
end;

{==============================================================================}
{Storage Helper Functions}
function storage_get_count: uint32_t; stdcall;
{Get the current storage count}
begin
 {}
 Result:=StorageGetCount;
end;

{==============================================================================}

function storage_device_check(storage: PSTORAGE_DEVICE): PSTORAGE_DEVICE; stdcall;
{Check if the supplied Storage is in the storage table}
begin
 {}
 Result:=StorageDeviceCheck(storage);
end;

{==============================================================================}

function storage_device_type_to_string(storagetype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(StorageDeviceTypeToString(storagetype),_string,len);
end;

{==============================================================================}

function storage_device_state_to_string(storagestate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(StorageDeviceStateToString(storagestate),_string,len);
end;

{==============================================================================}

function storage_device_state_to_notification(state: uint32_t): uint32_t; stdcall;
{Convert a Storage state value into the notification code for device notifications}
begin
 {}
 Result:=StorageDeviceStateToNotification(state);
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{Network Functions}
{$IFDEF API_EXPORT_NETWORK}
function network_start: uint32_t; stdcall;
begin
 {}
 Result:=NetworkStart;
end;

{==============================================================================}

function network_stop: uint32_t; stdcall;
begin
 {}
 Result:=NetworkStop;
end;

{==============================================================================}

function network_start_completed: BOOL; stdcall;
{Returns True if the network sub system has been started}
begin
 {}
 Result:=NetworkStartCompleted;
end;

{==============================================================================}

function network_device_open(network: PNETWORK_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=NetworkDeviceOpen(network);
end;

{==============================================================================}

function network_device_close(network: PNETWORK_DEVICE): uint32_t; stdcall;
begin
 {}
 Result:=NetworkDeviceClose(network);
end;

{==============================================================================}

function network_device_read(network: PNETWORK_DEVICE; buffer: PVOID; size: uint32_t; var length: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=NetworkDeviceRead(network,buffer,size,length);
end;

{==============================================================================}

function network_device_write(network: PNETWORK_DEVICE; buffer: PVOID; size: uint32_t; var length: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=NetworkDeviceWrite(network,buffer,size,length);
end;

{==============================================================================}

function network_device_control(network: PNETWORK_DEVICE; request: int; argument1: SIZE_T; var argument2: SIZE_T): uint32_t; stdcall;
begin
 {}
 Result:=NetworkDeviceControl(network,request,argument1,argument2);
end;

{==============================================================================}

function network_buffer_allocate(network: PNETWORK_DEVICE; var entry: PNETWORK_ENTRY): uint32_t; stdcall;
{Allocate a transmit buffer from the specified network device, the returned entry will
 include a buffer for writing data to as well as an offset value to allow the driver
 data to be written to the start of the buffer.

 When the data has been copied to the buffer, pass the entry to NetworkBufferTransmit}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=NetworkBufferAllocate(network,entry);
end;

{==============================================================================}

function network_buffer_release(network: PNETWORK_DEVICE; entry: PNETWORK_ENTRY): uint32_t; stdcall;
{Release a receive buffer to the specified network device, the entry must have been
 returned from NetworkBufferReceive}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=NetworkBufferRelease(network,entry);
end;

{==============================================================================}

function network_buffer_receive(network: PNETWORK_DEVICE; var entry: PNETWORK_ENTRY): uint32_t; stdcall;
{Receive a completed receive buffer from the specified network device. The returned
 entry will contain a one or more packets of data to read from.

 When the data has been processed pass the returned buffer to NetworkBufferRelease}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=NetworkBufferReceive(network,entry);
end;

{==============================================================================}

function network_buffer_transmit(network: PNETWORK_DEVICE; entry: PNETWORK_ENTRY): uint32_t; stdcall;
{Transmit a completed transmit buffer to the specified network device. The entry
 must have been allocated using NetworkBufferAllocate}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=NetworkBufferTransmit(network,entry);
end;

{==============================================================================}

function network_device_set_state(network: PNETWORK_DEVICE; state: uint32_t): uint32_t; stdcall;
{Set the state of the specified network and send a notification}
{Network: The network to set the state for}
{State: The new state to set and notify}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=NetworkDeviceSetState(network,state);
end;

{==============================================================================}

function network_device_set_status(network: PNETWORK_DEVICE; status: uint32_t): uint32_t; stdcall;
{Set the status of the specified network and send a notification}
{Network: The network to set the status for}
{Status: The new status to set and notify}
{Return: ERROR_SUCCESS if completed or another error code on failure}
begin
 {}
 Result:=NetworkDeviceSetStatus(network,status);
end;

{==============================================================================}

function network_device_create: PNETWORK_DEVICE; stdcall;
{Create a new Network entry}
{Return: Pointer to new Network entry or nil if network could not be created}
begin
 {}
 Result:=NetworkDeviceCreate;
end;

{==============================================================================}

function network_device_create_ex(size: uint32_t): PNETWORK_DEVICE; stdcall;
{Create a new Network entry}
{Size: Size in bytes to allocate for new network (Including the network entry)}
{Return: Pointer to new Network entry or nil if network could not be created}
begin
 {}
 Result:=NetworkDeviceCreateEx(size);
end;

{==============================================================================}

function network_device_destroy(network: PNETWORK_DEVICE): uint32_t; stdcall;
{Destroy an existing Network entry}
begin
 {}
 Result:=NetworkDeviceDestroy(network);
end;

{==============================================================================}

function network_device_register(network: PNETWORK_DEVICE): uint32_t; stdcall;
{Register a new Network in the Network table}
begin
 {}
 Result:=NetworkDeviceRegister(network);
end;

{==============================================================================}

function network_device_deregister(network: PNETWORK_DEVICE): uint32_t; stdcall;
{Deregister a Network from the Network table}
begin
 {}
 Result:=NetworkDeviceDeregister(network);
end;

{==============================================================================}

function network_device_find(networkid: uint32_t): PNETWORK_DEVICE; stdcall;
begin
 {}
 Result:=NetworkDeviceFind(networkid);
end;

{==============================================================================}

function network_device_find_by_name(const name: PCHAR): PNETWORK_DEVICE; stdcall;
begin
 {}
 Result:=NetworkDeviceFindByName(String(name));
end;

{==============================================================================}

function network_device_find_by_description(const description: PCHAR): PNETWORK_DEVICE; stdcall;
begin
 {}
 Result:=NetworkDeviceFindByDescription(String(description));
end;

{==============================================================================}

function network_device_enumerate(callback: network_enumerate_cb; data: PVOID): uint32_t; stdcall;
begin
 {}
 Result:=NetworkDeviceEnumerate(callback,data);
end;

{==============================================================================}

function network_device_notification(network: PNETWORK_DEVICE; callback: network_notification_cb; data: PVOID; notification, flags: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=NetworkDeviceNotification(network,callback,data,notification,flags);
end;

{==============================================================================}

function network_event_allocate(callback: network_event_callback_cb; data: PVOID; event: uint32_t): PNETWORK_EVENT; stdcall;
{Create and Register a new Event entry in the Event table}
begin
 {}
 Result:=NetworkEventAllocate(callback,data,event);
end;

{==============================================================================}

function network_event_release(event: PNETWORK_EVENT): uint32_t; stdcall;
{Deregister and Destroy an Event from the Event table}
begin
 {}
 Result:=NetworkEventRelease(event);
end;

{==============================================================================}

function network_event_register(callback: network_event_callback_cb; data: PVOID; event: uint32_t): THANDLE; stdcall;
{Register a callback for one or more network events}
begin
 {}
 Result:=NetworkEventRegister(callback,data,event);
end;

{==============================================================================}

function network_event_deregister(handle: THANDLE): uint32_t; stdcall;
{Deregister a network event callback}
begin
 {}
 Result:=NetworkEventDeregister(handle);
end;
{==============================================================================}

function network_event_notify(event: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=NetworkEventNotify(event);
end;

{==============================================================================}
{Network Helper Functions}
function network_get_last_error: int32_t; stdcall;
{Get the last network error value for the current Thread}
{Return: Last Network Error or ERROR_SUCCESS if no error}
begin
 {}
 Result:=NetworkGetLastError;
end;

{==============================================================================}

procedure network_set_last_error(error: int32_t); stdcall;
{Set the last network error value for the current Thread}
begin
 {}
 NetworkSetLastError(error);
end;

{==============================================================================}

function network_get_count: uint32_t; stdcall;
{Get the current network count}
begin
 {}
 Result:=NetworkGetCount;
end;

{==============================================================================}

function network_device_check(network: PNETWORK_DEVICE): PNETWORK_DEVICE; stdcall;
{Check if the supplied Network is in the network table}
begin
 {}
 Result:=NetworkDeviceCheck(network);
end;

{==============================================================================}

function network_device_type_to_string(networktype: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(NetworkDeviceTypeToString(networktype),_string,len);
end;

{==============================================================================}

function network_device_state_to_string(networkstate: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(NetworkDeviceStateToString(networkstate),_string,len);
end;

{==============================================================================}

function network_device_status_to_string(networkstatus: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(NetworkDeviceStatusToString(networkstatus),_string,len);
end;

{==============================================================================}

function network_device_state_to_notification(state: uint32_t): uint32_t; stdcall;
{Convert a Network state value into the notification code for device notifications}
begin
 {}
 Result:=NetworkDeviceStateToNotification(state);
end;

{==============================================================================}

function network_device_status_to_notification(status: uint32_t): uint32_t; stdcall;
{Convert a Network status value into the notification code for device notifications}
begin
 {}
 Result:=NetworkDeviceStatusToNotification(status);
end;

{==============================================================================}

function network_event_check(event: PNETWORK_EVENT): PNETWORK_EVENT; stdcall;
{Check if the supplied Event is in the event table}
begin
 {}
 Result:=NetworkEventCheck(event);
end;

{==============================================================================}

function hardware_address_to_string(const address: THARDWARE_ADDRESS; separator: PCHAR; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(HardwareAddressToString(address,String(separator)),_string,len);
end;

{==============================================================================}

procedure string_to_hardware_address(_string: PCHAR; var address: THARDWARE_ADDRESS); stdcall;
begin
 {}
 address:=StringToHardwareAddress(String(_string));
end;

{==============================================================================}

function valid_hardware_address(const address: THARDWARE_ADDRESS): BOOL; stdcall;
begin
 {}
 Result:=ValidHardwareAddress(address);
end;

{==============================================================================}

procedure random_hardware_addres(var addresss: THARDWARE_ADDRESS); stdcall;
begin
 {}
 addresss:=RandomHardwareAddress;
end;

{==============================================================================}

function compare_hardware_address(const address1, address2: THARDWARE_ADDRESS): BOOL; stdcall;
begin
 {}
 Result:=CompareHardwareAddress(address1,address2);
end;

{==============================================================================}

function compare_hardware_default(const address: THARDWARE_ADDRESS): BOOL; stdcall;
begin
 {}
 Result:=CompareHardwareDefault(address);
end;

{==============================================================================}

function compare_hardware_broadcast(const address: THARDWARE_ADDRESS): BOOL; stdcall;
begin
 {}
 Result:=CompareHardwareBroadcast(address);
end;

{==============================================================================}

function compare_hardware_multicast(const address: THARDWARE_ADDRESS): BOOL; stdcall;
begin
 {}
 Result:=CompareHardwareMulticast(address);
end;

{==============================================================================}

function adapter_type_to_string(_type: uint16_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(AdapterTypeToString(_type),_string,len);
end;

{==============================================================================}

function adapter_mode_to_string(mode: uint16_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(AdapterModeToString(mode),_string,len);
end;

{==============================================================================}

function adapter_config_to_string(config: uint16_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(AdapterConfigToString(config),_string,len);
end;

{==============================================================================}

function adapter_state_to_string(state: int; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(AdapterStateToString(state),_string,len);
end;

{==============================================================================}

function adapter_status_to_string(status: int; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(AdapterStatusToString(status),_string,len);
end;

{==============================================================================}

function frame_type_to_string(_type: uint16_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(FrameTypeToString(_type),_string,len);
end;

{==============================================================================}

function network_media_type_to_string(_type: uint16_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(Network.MediaTypeToString(_type),_string,len);
end;

{==============================================================================}

function packet_type_to_string(_type: uint16_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(PacketTypeToString(_type),_string,len);
end;

{==============================================================================}

function config_type_to_string(_type: uint16_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(ConfigTypeToString(_type),_string,len);
end;

{==============================================================================}

function config_command_to_string(command: uint16_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(ConfigCommandToString(command),_string,len);
end;

{==============================================================================}

function auth_type_to_string(_type: uint16_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(AuthTypeToString(_type),_string,len);
end;

{==============================================================================}

function auth_command_to_string(command: uint16_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(AuthCommandToString(command),_string,len);
end;

{==============================================================================}

function phy_interface_mode_to_string(mode: uint16_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(PhyInterfaceModeToString(mode),_string,len);
end;

{==============================================================================}

function phy_link_speed_to_string(speed: uint16_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(PhyLinkSpeedToString(speed),_string,len);
end;

{==============================================================================}

function phy_duplex_mode_to_string(mode: uint16_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(PhyDuplexModeToString(mode),_string,len);
end;

{==============================================================================}

function match_string_to_phy_interface_mode(mode: PCHAR): uint16_t; stdcall;
begin
 {}
 Result:=MatchStringToPhyInterfaceMode(String(mode));
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{Timezone Functions}
{$IFDEF API_EXPORT_TIMEZONE}
function timezone_add(data: PTIMEZONE_DATA; default: BOOL): uint32_t; stdcall;
{Add a Timezone from a timezone data block and to the Timezone table}
begin
 {}
 Result:=TimezoneAdd(data,default);
end;

{==============================================================================}

function timezone_delete(timezone: PTIMEZONE_ENTRY): uint32_t; stdcall;
begin
 {}
 Result:=TimezoneDelete(timezone);
end;

{==============================================================================}

function timezone_get_name(timezone: PTIMEZONE_ENTRY; name: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(TimezoneGetName(timezone),name,len);
end;

{==============================================================================}

function timezone_get_description(timezone: PTIMEZONE_ENTRY; description: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(TimezoneGetDescription(timezone),description,len);
end;

{==============================================================================}

function timezone_get_bias(timezone: PTIMEZONE_ENTRY): int32_t; stdcall;
begin
 {}
 Result:=TimezoneGetBias(timezone);
end;

{==============================================================================}

function timezone_get_state(timezone: PTIMEZONE_ENTRY): uint32_t; stdcall;
{Get the state of the supplied Timezone at the current date and time}
{Timezone: The timezone entry to get the state for}
{Return: The TIME_ZONE_ID_* constant representing the standard / daylight state of the timezone}
begin
 {}
 Result:=TimezoneGetState(timezone);
end;

{==============================================================================}

function timezone_get_state_ex(timezone: PTIMEZONE_ENTRY; const datetime: double_t): uint32_t; stdcall;
{Get the state of the supplied Timezone at the specified date and time}
{Timezone: The timezone entry to get the state for}
{DateTime: The date and time to get the state of the timezone at}
{Return: The TIME_ZONE_ID_* constant representing the standard / daylight state of the timezone}
begin
 {}
 Result:=TimezoneGetStateEx(timezone,datetime);
end;

{==============================================================================}

function timezone_get_active_bias(timezone: PTIMEZONE_ENTRY): int32_t; stdcall;
{Get the bias (offset between UTC and Local) of the supplied Timezone at the current date and time}
{Timezone: The timezone entry to get the bias for}
{Return: The bias in minutes offset between UTC and Local including any daylight bias if active}
begin
 {}
 Result:=TimezoneGetActiveBias(timezone);
end;

{==============================================================================}

function timezone_get_active_bias_ex(timezone: PTIMEZONE_ENTRY; const datetime: double_t): int32_t; stdcall;
{Get the bias (offset between UTC and Local) of the supplied Timezone at the specified date and time}
{Timezone: The timezone entry to get the bias for}
{DateTime: The date and time to get the bias of the timezone at}
{Return: The bias in minutes offset between UTC and Local}
begin
 {}
 Result:=TimezoneGetActiveBiasEx(timezone,datetime);
end;

{==============================================================================}

function timezone_get_standard_name(timezone: PTIMEZONE_ENTRY; name: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(TimezoneGetStandardName(timezone),name,len);
end;

{==============================================================================}

function timezone_get_standard_bias(timezone: PTIMEZONE_ENTRY): int32_t; stdcall;
begin
 {}
 Result:=TimezoneGetStandardBias(timezone);
end;

{==============================================================================}

function timezone_get_standard_date(timezone: PTIMEZONE_ENTRY; next: BOOL): double_t; stdcall;
begin
 {}
 Result:=TimezoneGetStandardDate(timezone,next);
end;

{==============================================================================}

function timezone_get_standard_start(timezone: PTIMEZONE_ENTRY): SYSTEMTIME; stdcall;
begin
 {}
 Result:=TimezoneGetStandardStart(timezone);
end;

{==============================================================================}

function timezone_get_daylight_name(timezone: PTIMEZONE_ENTRY; name: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(TimezoneGetDaylightName(timezone),name,len);
end;

{==============================================================================}

function timezone_get_daylight_bias(timezone: PTIMEZONE_ENTRY): int32_t; stdcall;
begin
 {}
 Result:=TimezoneGetDaylightBias(timezone);
end;

{==============================================================================}

function timezone_get_daylight_date(timezone: PTIMEZONE_ENTRY; next: BOOL): double_t; stdcall;
begin
 {}
 Result:=TimezoneGetDaylightDate(timezone,next);
end;

{==============================================================================}

function timezone_get_daylight_start(timezone: PTIMEZONE_ENTRY): SYSTEMTIME; stdcall;
begin
 {}
 Result:=TimezoneGetDaylightStart(timezone);
end;

{==============================================================================}

function timezone_find(const name: PCHAR): PTIMEZONE_ENTRY; stdcall;
begin
 {}
 Result:=TimezoneFind(String(name));
end;

{==============================================================================}

function timezone_find_by_standard(const standardname: PCHAR): PTIMEZONE_ENTRY; stdcall;
begin
 {}
 Result:=TimezoneFindByStandard(String(standardname));
end;

{==============================================================================}

function timezone_find_by_daylight(const daylightname: PCHAR): PTIMEZONE_ENTRY; stdcall;
begin
 {}
 Result:=TimezoneFindByDaylight(String(daylightname));
end;

{==============================================================================}

function timezone_enumerate(callback: timezone_enumerate_cb; data: PVOID): uint32_t; stdcall;
begin
 {}
 Result:=TimezoneEnumerate(callback,data);
end;

{==============================================================================}
{Timezone Helper Functions}
function timezone_get_count: uint32_t; stdcall;
{Get the current timezone count}
begin
 {}
 Result:=TimezoneGetCount;
end;

{==============================================================================}

function timezone_get_default: PTIMEZONE_ENTRY; stdcall;
{Get the current default timezone}
begin
 {}
 Result:=TimezoneGetDefault;
end;

{==============================================================================}

function timezone_set_default(timezone: PTIMEZONE_ENTRY): uint32_t; stdcall;
{Set the current default timezone}
begin
 {}
 Result:=TimezoneSetDefault(timezone);
end;

{==============================================================================}

function timezone_check(timezone: PTIMEZONE_ENTRY): PTIMEZONE_ENTRY; stdcall;
{Check if the supplied Timezone is in the Timezone table}
begin
 {}
 Result:=TimezoneCheck(timezone);
end;

{==============================================================================}

function timezone_update_offset: uint32_t; stdcall;
begin
 {}
 Result:=TimezoneUpdateOffset;
end;

{==============================================================================}

function timezone_start_to_date_time(const start: SYSTEMTIME; year: uint16_t): double_t; stdcall;
{Calculate the start date and time from the start date of a timezone}
begin
 {}
 Result:=TimezoneStartToDateTime(start,year);
end;

{==============================================================================}

function timezone_start_to_description(const start: SYSTEMTIME; description: PCHAR; len: uint32_t): uint32_t; stdcall;
{Get the description of the start date of a timezone}
begin
 {}
 Result:=APIStringToPCharBuffer(TimezoneStartToDescription(start),description,len);
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{Locale Functions}
{$IFDEF API_EXPORT_LOCALE}
function IsValidCodePage(codepage: UINT): BOOL; stdcall;
begin
 {}
 Result:=Locale.IsValidCodePage(codepage);
end;

{==============================================================================}

function GetACP: UINT; stdcall;
begin
 {}
 Result:=Locale.GetACP;
end;

{==============================================================================}

function GetOEMCP: UINT; stdcall;
begin
 {}
 Result:=Locale.GetOEMCP;
end;

{==============================================================================}

function SetACP(codepage: UINT): BOOL; stdcall;
begin
 {}
 Result:=Locale.SetACP(codepage);
end;

{==============================================================================}

function SetOEMCP(codepage: UINT): BOOL; stdcall;
begin
 {}
 Result:=Locale.SetOEMCP(codepage);
end;

{==============================================================================}

function GetConsoleCP: UINT; stdcall;
begin
 {}
 Result:=Locale.GetConsoleCP;
end;

{==============================================================================}

function SetConsoleCP(wcodepageid: UINT): BOOL; stdcall;
begin
 {}
 Result:=Locale.SetConsoleCP(wcodepageid);
end;

{==============================================================================}

function GetConsoleOutputCP: UINT; stdcall;
begin
 {}
 Result:=Locale.GetConsoleOutputCP;
end;

{==============================================================================}

function SetConsoleOutputCP(wcodepageid: UINT): BOOL; stdcall;
begin
 {}
 Result:=Locale.SetConsoleOutputCP(wcodepageid);
end;

{==============================================================================}

function GetCPInfo(codepage: UINT; var lpcpinfo: CPINFO): BOOL; stdcall;
begin
 {}
 Result:=Locale.GetCPInfo(codepage,lpcpinfo);
end;

{==============================================================================}

function GetCPInfoEx(codepage: UINT; dwflags: uint32_t; var lpcpinfoex: CPINFOEXA): BOOL; stdcall;
begin
 {}
 Result:=Locale.GetCPInfoEx(codepage,dwflags,lpcpinfoex);
end;

{==============================================================================}

function GetCPInfoExA(codepage: UINT; dwflags: uint32_t; var lpcpinfoex: CPINFOEXA): BOOL; stdcall;
begin
 {}
 Result:=Locale.GetCPInfoExA(codepage,dwflags,lpcpinfoex);
end;

{==============================================================================}

function GetCPInfoExW(codepage: UINT; dwflags: uint32_t; var lpcpinfoex: CPINFOEXW): BOOL; stdcall;
begin
 {}
 Result:=Locale.GetCPInfoExW(codepage,dwflags,lpcpinfoex);
end;

{==============================================================================}

function IsValidLocale(_locale: LCID; dwflags: uint32_t): BOOL; stdcall;
begin
 {}
 Result:=Locale.IsValidLocale(_locale,dwflags);
end;

{==============================================================================}

function GetSystemDefaultLCID: LCID; stdcall;
begin
 {}
 Result:=Locale.GetSystemDefaultLCID;
end;

{==============================================================================}

function GetUserDefaultLCID: LCID; stdcall;
begin
 {}
 Result:=Locale.GetUserDefaultLCID;
end;

{==============================================================================}

function SetSystemDefaultLCID(_locale: LCID): BOOL; stdcall;
begin
 {}
 Result:=Locale.SetSystemDefaultLCID(_locale);
end;

{==============================================================================}

function GetSystemDefaultLangID: LANGID; stdcall;
{Get the System Default Language Identifier (Combined Primary and Sub language Identifiers)}
{Note: System and User values are the same for Ultibo}
begin
 {}
 Result:=Locale.GetSystemDefaultLangID;
end;

{==============================================================================}

function GetUserDefaultLangID: LANGID; stdcall;
{Get the System Default Language Identifier (Combined Primary and Sub language Identifiers)}
{Note: System and User values are the same for Ultibo}
begin
 {}
 Result:=Locale.GetUserDefaultLangID;
end;

{==============================================================================}
{Locale Helper Functions}
function map_page(codepage: UINT): uint16_t; stdcall;
{Map a default code page to the actual current page}
begin
 {}
 Result:=MapPage(codepage);
end;

{==============================================================================}

function get_page(pageid: uint16_t): PCODE_PAGE; stdcall;
{Find the requested page in the linked list}
begin
 {}
 Result:=GetPage(pageid);
end;

{==============================================================================}

function check_page(page: PCODE_PAGE): BOOL; stdcall;
{Check that the Page supplied is part of the Linked list}
begin
 {}
 Result:=CheckPage(page);
end;

{==============================================================================}

function link_page(page: PCODE_PAGE): BOOL; stdcall;
{Link Page to Prev,Next Siblings and Adjust First/Last}
begin
 {}
 Result:=LinkPage(page);
end;

{==============================================================================}

function unlink_page(page: PCODE_PAGE): BOOL; stdcall;
{Unlink Page from Prev,Next Siblings and Adjust First/Last}
begin
 {}
 Result:=UnlinkPage(page);
end;

{==============================================================================}

function load_page(pageid: uint16_t; table: PCODE_TABLE; lower: PLOWER_TABLE; upper: PUPPER_TABLE): BOOL; stdcall;
{Load a code table and allocate memory to create a code page}
begin
 {}
 Result:=LoadPage(pageid,table,lower,upper);
end;

{==============================================================================}

function unload_page(pageid: uint16_t; page: PCODE_PAGE): BOOL; stdcall;
{Unload a code page and release allocated memory}
begin
 {}
 Result:=UnloadPage(pageid,page);
end;

{==============================================================================}

function default_trans(pageid, transid: uint16_t): BOOL; stdcall;
begin
 {}
 Result:=DefaultTrans(pageid,transid);
end;

{==============================================================================}

function install_trans(pageid: uint16_t; table: PTRANS_TABLE): BOOL; stdcall;
begin
 {}
 Result:=InstallTrans(pageid,table);
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{Unicode Functions}
{$IFDEF API_EXPORT_UNICODE}
function MultiByteToWideChar(codepage: UINT; dwflags: uint32_t; lpmultibytestr: LPCSTR; cbmultibyte: int; lpwidecharstr: LPWSTR; cchwidechar: int): int; stdcall;
{SBCS/DBCS OEM or ANSI string to Unicode string}
{Note: cchWideChar is the size of lpWideCharStr in WideChars (not Bytes)}
{Note: Currently ignores the Flags parameter}
{Note: Currently only supports SBCS}
begin
 {}
 Result:=Unicode.MultiByteToWideChar(codepage,dwflags,lpmultibytestr,cbmultibyte,lpwidecharstr,cchwidechar);
end;

{==============================================================================}

function WideCharToMultiByte(codepage: UINT; dwflags: uint32_t; lpwidecharstr: LPCWSTR; cchwidechar: int; lpmultibytestr: LPSTR; cbmultibyte: int; lpdefaultchar: LPCSTR; lpuseddefaultchar: LPBOOL): int; stdcall;
{Unicode string to SBCS/DBCS OEM or ANSI string}
{Note: cchWideChar is the size of lpWideCharStr in WideChars (not Bytes)}
{Note: Currently ignores the Flags and DefaultChar parameters}
{Note: Currently only supports SBCS}
begin
 {}
 Result:=Unicode.WideCharToMultiByte(codepage,dwflags,lpwidecharstr,cchwidechar,lpmultibytestr,cbmultibyte,lpdefaultchar,lpuseddefaultchar);
end;

{==============================================================================}

function CompareString(locale: LCID; dwcmpflags: uint32_t; lpstring1: LPCSTR; cchcount1: int; lpstring2: LPCSTR; cchcount2: int): int; stdcall;
begin
 {}
 Result:=Unicode.CompareString(locale,dwcmpflags,lpstring1,cchcount1,lpstring2,cchcount2);
end;

{==============================================================================}

function CompareStringA(locale: LCID; dwcmpflags: uint32_t; lpstring1: LPCSTR; cchcount1: int; lpstring2: LPCSTR; cchcount2: int): int; stdcall;
{ANSI compare of two strings for equivalence. If both strings are equal returns CSTR_EQUAL, if string 1 is less than string 2
 returns CSTR_LESS_THAN and if string 1 is greater than string 2 returns CSTR_GREATER_THAN, on error returns 0}
{Note: Currently the Locale value is ignored and the ANSI code page is used for comparison}
{Note: Currently only supports SBCS}
begin
 {}
 Result:=Unicode.CompareStringA(locale,dwcmpflags,lpstring1,cchcount1,lpstring2,cchcount2);
end;

{==============================================================================}

function CompareStringW(locale: LCID; dwcmpflags: uint32_t; lpstring1: LPCWSTR; cchcount1: int; lpstring2: LPCWSTR; cchcount2: int): int; stdcall;
{Unicode compare of two strings for equivalence. If both strings are equal returns CSTR_EQUAL, if string 1 is less than string 2
 returns CSTR_LESS_THAN and if string 1 is greater than string 2 returns CSTR_GREATER_THAN, on error returns 0}
{Note: Currently the Locale value is ignored}
begin
 {}
 Result:=Unicode.CompareStringW(locale,dwcmpflags,lpstring1,cchcount1,lpstring2,cchcount2);
end;

{==============================================================================}

function CharUpper(lpsz: LPSTR): LPSTR; stdcall;
begin
 {}
 Result:=Unicode.CharUpper(lpsz);
end;

{==============================================================================}

function CharUpperA(lpsz: LPSTR): LPSTR; stdcall;
{Lower to Upper case conversion in ANSI code page (Char)}
{Note: Unlike Windows this function does not differentiate a single character by
 the high order word of the passed pointer. To convert a single character call
 CharUpperBuffA instead with the length as 1.}
{Note: Currently only supports SBCS}
begin
 {}
 Result:=Unicode.CharUpperA(lpsz);
end;

{==============================================================================}

function CharUpperW(lpsz: LPWSTR): LPWSTR; stdcall;
{Lower to Upper case conversion in Unicode (WideChar)}
{Note: Unlike Windows this function does not differentiate a single character by
 the high order word of the passed pointer. To convert a single character call
 CharUpperBuffW instead with the length as 1.}
begin
 {}
 Result:=Unicode.CharUpperW(lpsz);
end;

{==============================================================================}

function CharUpperBuff(lpsz: LPSTR; cchlength: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Unicode.CharUpperBuff(lpsz,cchlength);
end;

{==============================================================================}

function CharUpperBuffA(lpsz: LPSTR; cchlength: uint32_t): uint32_t; stdcall;
{Lower to Upper case conversion in ANSI code page (Char)}
{Note: Currently only supports SBCS}
begin
 {}
 Result:=Unicode.CharUpperBuffA(lpsz,cchlength);
end;

{==============================================================================}

function CharUpperBuffW(lpsz: LPWSTR; cchlength: uint32_t): uint32_t; stdcall;
{Lower to Upper case conversion in Unicode (WideChar)}
begin
 {}
 Result:=Unicode.CharUpperBuffW(lpsz,cchlength);
end;

{==============================================================================}

function CharLower(lpsz: LPSTR): LPSTR; stdcall;
begin
 {}
 Result:=Unicode.CharLower(lpsz);
end;

{==============================================================================}

function CharLowerA(lpsz: LPSTR): LPSTR; stdcall;
{Upper to Lower case conversion in ANSI code page (Char)}
{Note: Unlike Windows this function does not differentiate a single character by
 the high order word of the passed pointer. To convert a single character call
 CharLowerBuffA instead with the length as 1.}
{Note: Currently only supports SBCS}
begin
 {}
 Result:=Unicode.CharLowerA(lpsz);
end;

{==============================================================================}

function CharLowerW(lpsz: LPWSTR): LPWSTR; stdcall;
{Upper to Lower case conversion in Unicode (WideChar)}
{Note: Unlike Windows this function does not differentiate a single character by
 the high order word of the passed pointer. To convert a single character call
 CharLowerBuffW instead with the length as 1.}
begin
 {}
 Result:=Unicode.CharLowerW(lpsz);
end;

{==============================================================================}

function CharLowerBuff(lpsz: LPSTR; cchlength: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Unicode.CharLowerBuff(lpsz,cchlength);
end;

{==============================================================================}

function CharLowerBuffA(lpsz: LPSTR; cchlength: uint32_t): uint32_t; stdcall;
{Upper to Lower case conversion in ANSI code page (Char)}
{Note: Currently only supports SBCS}
begin
 {}
 Result:=Unicode.CharLowerBuffA(lpsz,cchlength);
end;

{==============================================================================}

function CharLowerBuffW(lpsz: LPWSTR; cchlength: uint32_t): uint32_t; stdcall;
{Upper to Lower case conversion in Unicode (WideChar)}
begin
 {}
 Result:=Unicode.CharLowerBuffW(lpsz,cchlength);
end;

{==============================================================================}

function AnsiToOem(lpszsrc: LPCSTR; lpszdst: LPSTR): BOOL; stdcall;
begin
 {}
 Result:=Unicode.AnsiToOem(lpszsrc,lpszdst);
end;

{==============================================================================}

function AnsiToOemBuff(lpszsrc: LPCSTR; lpszdst: LPSTR; cchdstlength: uint32_t): BOOL; stdcall;
begin
 {}
 Result:=Unicode.AnsiToOemBuff(lpszsrc,lpszdst,cchdstlength);
end;

{==============================================================================}

function OemToAnsi(lpszsrc: LPCSTR; lpszdst: LPSTR): BOOL; stdcall;
begin
 {}
 Result:=Unicode.OemToAnsi(lpszsrc,lpszdst);
end;

{==============================================================================}

function OemToAnsiBuff(lpszsrc: LPCSTR; lpszdst: LPSTR; cchdstlength: uint32_t): BOOL; stdcall;
begin
 {}
 Result:=Unicode.OemToAnsiBuff(lpszsrc,lpszdst,cchdstlength);
end;

{==============================================================================}

function CharToOem(lpszsrc: LPCSTR; lpszdst: LPSTR): BOOL; stdcall;
begin
 {}
 Result:=Unicode.CharToOem(lpszsrc,lpszdst);
end;

{==============================================================================}

function CharToOemA(lpszsrc: LPCSTR; lpszdst: LPSTR): BOOL; stdcall;
{ANSI to OEM conversion (Char to Char)}
{Note: Currently only supports SBCS}
begin
 {}
 Result:=Unicode.CharToOemA(lpszsrc,lpszdst);
end;

{==============================================================================}

function CharToOemW(lpszsrc: LPCWSTR; lpszdst: LPSTR): BOOL; stdcall;
{Unicode to OEM conversion (WideChar to Char)}
{Note: Currently only supports SBCS}
begin
 {}
 Result:=Unicode.CharToOemW(lpszsrc,lpszdst);
end;

{==============================================================================}

function OemToChar(lpszsrc: LPCSTR; lpszdst: LPSTR): BOOL; stdcall;
begin
 {}
 Result:=Unicode.OemToChar(lpszsrc,lpszdst);
end;

{==============================================================================}

function OemToCharA(lpszsrc: LPCSTR; lpszdst: LPSTR): BOOL; stdcall;
{OEM to ANSI conversion (Char to Char)}
{Note: Currently only supports SBCS}
begin
 {}
 Result:=Unicode.OemToCharA(lpszsrc,lpszdst);
end;

{==============================================================================}

function OemToCharW(lpszsrc: LPCSTR; lpszdst: LPWSTR): BOOL; stdcall;
{OEM to Unicode conversion (Char to WideChar)}
{Note: Currently only supports SBCS}
begin
 {}
 Result:=Unicode.OemToCharW(lpszsrc,lpszdst);
end;

{==============================================================================}

function CharToOemBuff(lpszsrc: LPCSTR; lpszdst: LPSTR; cchdstlength: uint32_t): BOOL; stdcall;
begin
 {}
 Result:=Unicode.CharToOemBuff(lpszsrc,lpszdst,cchdstlength);
end;

{==============================================================================}

function CharToOemBuffA(lpszsrc: LPCSTR; lpszdst: LPSTR; cchdstlength: uint32_t): BOOL; stdcall;
{ANSI to OEM conversion (Char to Char)}
{Note: Currently only supports SBCS}
begin
 {}
 Result:=Unicode.CharToOemBuffA(lpszsrc,lpszdst,cchdstlength);
end;

{==============================================================================}

function CharToOemBuffW(lpszsrc: LPCWSTR; lpszdst: LPSTR; cchdstlength: uint32_t): BOOL; stdcall;
{Unicode to OEM conversion (WideChar to Char)}
{Note: Currently only supports SBCS}
begin
 {}
 Result:=Unicode.CharToOemBuffW(lpszsrc,lpszdst,cchdstlength);
end;

{==============================================================================}

function OemToCharBuff(lpszsrc: LPCSTR; lpszdst: LPSTR; cchdstlength: uint32_t): BOOL; stdcall;
begin
 {}
 Result:=Unicode.OemToCharBuff(lpszsrc,lpszdst,cchdstlength);
end;

{==============================================================================}

function OemToCharBuffA(lpszsrc: LPCSTR; lpszdst: LPSTR; cchdstlength: uint32_t): BOOL; stdcall;
{OEM to ANSI conversion (Char to Char)}
{Note: Currently only supports SBCS}
begin
 {}
 Result:=Unicode.OemToCharBuffA(lpszsrc,lpszdst,cchdstlength);
end;

{==============================================================================}

function OemToCharBuffW(lpszsrc: LPCSTR; lpszdst: LPWSTR; cchdstlength: uint32_t): BOOL; stdcall;
{OEM to Unicode conversion (Char to WideChar)}
{Note: Currently only supports SBCS}
begin
 {}
 Result:=Unicode.OemToCharBuffW(lpszsrc,lpszdst,cchdstlength);
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{TFTFramebuffer Functions}
{$IFDEF API_EXPORT_TFTFRAMEBUFFER}
function tft_framebuffer_allocate(framebuffer: PFRAMEBUFFER_DEVICE; properties: PFRAMEBUFFER_PROPERTIES): uint32_t; stdcall;
{Implementation of FramebufferDeviceAllocate API for TFT Framebuffer}
{Note: Not intended to be called directly by applications, use FramebufferDeviceAllocate instead}
begin
 {}
 Result:=TFTFramebufferAllocate(framebuffer,properties);
end;

{==============================================================================}

function tft_framebuffer_release(framebuffer: PFRAMEBUFFER_DEVICE): uint32_t; stdcall;
{Implementation of FramebufferDeviceRelease API for TFT Framebuffer}
{Note: Not intended to be called directly by applications, use FramebufferDeviceRelease instead}
begin
 {}
 Result:=TFTFramebufferRelease(framebuffer);
end;

{==============================================================================}

function tft_framebuffer_mark(framebuffer: PFRAMEBUFFER_DEVICE; x, y, width, height, flags: uint32_t): uint32_t; stdcall;
{Implementation of FramebufferDeviceMark API for TFT Framebuffer}
{Note: Not intended to be called directly by applications, use FramebufferDeviceMark instead}
{Note: Marks full lines only, X and Width are ignored for TFT Framebuffer}
begin
 {}
 Result:=TFTFramebufferMark(framebuffer,x,y,width,height,flags);
end;

{==============================================================================}

function tft_framebuffer_commit(framebuffer: PFRAMEBUFFER_DEVICE; address: SIZE_T; size, flags: uint32_t): uint32_t; stdcall;
{Implementation of FramebufferDeviceCommit API for TFT Framebuffer}
{Note: Not intended to be called directly by applications, use FramebufferDeviceCommit instead}
begin
 {}
 Result:=TFTFramebufferCommit(framebuffer,address,size,flags);
end;

{==============================================================================}

procedure tft_framebuffer_update_display(framebuffer: PTFT_FRAMEBUFFER); stdcall;
{Timer function for display dirty region redraw}
{Note: Not intended to be called directly by applications}
begin
 {}
 TFTFramebufferUpdateDisplay(framebuffer);
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{FileSystem Functions (Ultibo)}
{$IFDEF API_EXPORT_FILESYSTEM}
function file_sys_start: uint32_t; stdcall;
begin
 {}
 Result:=FileSystem.FileSysStart;
end;

{==============================================================================}

function file_sys_stop: uint32_t; stdcall;
begin
 {}
 Result:=FileSystem.FileSysStop;
end;

{==============================================================================}

function file_sys_start_completed: BOOL; stdcall;
{Returns True if the filesystem has been started}
begin
 {}
 Result:=FileSystem.FileSysStartCompleted;
end;

{==============================================================================}

procedure file_sys_async_start(data: PVOID); stdcall;
begin
 {}
 FileSystem.FileSysAsyncStart(data);
end;

{==============================================================================}
{Drive Functions}

{==============================================================================}
{File Functions}
function FileOpen(const filename: PCHAR; mode: int): THANDLE; stdcall;
begin
 {}
 Result:=FileSystem.FSFileOpen(String(filename),mode);
end;

{==============================================================================}

function FileCreate(const filename: PCHAR): THANDLE; stdcall;
begin
 {}
 Result:=FileSystem.FSFileCreate(String(filename));
end;

{==============================================================================}

procedure FileClose(handle: THANDLE); stdcall;
begin
 {}
 FileSystem.FSFileClose(handle);
end;

{==============================================================================}

function RenameFile(const oldname, newname: PCHAR): BOOL; stdcall;
begin
 {}
 Result:=FileSystem.FSRenameFile(String(oldname),String(newname));
end;

{==============================================================================}

function FileSeek(handle: THANDLE; offset, origin: int32_t): int32_t; stdcall;
begin
 {}
 Result:=FileSystem.FSFileSeek(handle,offset,origin);
end;

{==============================================================================}

function FileFlush(handle: THANDLE): BOOL; stdcall;
begin
 {}
 Result:=FileSystem.FSFileFlush(handle);
end;

{==============================================================================}

function FileTruncate(handle: THANDLE): BOOL; stdcall;
begin
 {}
 Result:=FileSystem.FSFileTruncate(handle);
end;

{==============================================================================}

function EndOfFile(handle: THANDLE): BOOL; stdcall;
begin
 {}
 Result:=FileSystem.FSEndOfFile(handle);
end;

{==============================================================================}

function FilePos(handle: THANDLE): int32_t; stdcall;
begin
 {}
 Result:=FileSystem.FSFilePos(handle);
end;

{==============================================================================}

function FileSize(handle: THANDLE): int32_t; stdcall;
begin
 {}
 Result:=FileSystem.FSFileSize(handle);
end;

{==============================================================================}

function FileAge(const filename: PCHAR): int; stdcall;
begin
 {}
 Result:=FileSystem.FSFileAge(String(filename));
end;

{==============================================================================}

function FileExists(const filename: PCHAR): BOOL; stdcall;
begin
 {}
 Result:=FileSystem.FSFileExists(String(filename));
end;

{==============================================================================}

function FileGetAttr(const filename: PCHAR): int; stdcall;
begin
 {}
 Result:=FileSystem.FSFileGetAttr(String(filename));
end;

{==============================================================================}

function FileGetDate(handle: THANDLE): int; stdcall;
begin
 {}
 Result:=FileSystem.FSFileGetDate(handle);
end;

{==============================================================================}

function FileSetAttr(const filename: PCHAR; attr: int): int; stdcall;
begin
 {}
 Result:=FileSystem.FSFileSetAttr(String(filename),attr);
end;

{==============================================================================}

function FileSetDate(handle: THANDLE; age: int): int; stdcall;
begin
 {}
 Result:=FileSystem.FSFileSetDate(handle,age);
end;

{==============================================================================}

function FileRead(handle: THANDLE; buffer: PVOID; count: int32_t): int32_t; stdcall;
begin
 {}
 Result:=FileSystem.FSFileRead(handle,buffer^,count);
end;

{==============================================================================}

function FileWrite(handle: THANDLE; buffer: PVOID; count: int32_t): int32_t; stdcall;
begin
 {}
 Result:=FileSystem.FSFileWrite(handle,buffer^,count);
end;

{==============================================================================}
{Directory Functions}
function CreateDir(const dirname: PCHAR): BOOL; stdcall;
begin
 {}
 Result:=FileSystem.FSCreateDir(String(dirname));
end;

{==============================================================================}

function RemoveDir(const dirname: PCHAR): BOOL; stdcall;
begin
 {}
 Result:=FileSystem.FSRemoveDir(String(dirname));
end;

{==============================================================================}

function RenameDir(const oldname, newname: PCHAR): BOOL; stdcall;
begin
 {}
 Result:=FileSystem.FSRenameDir(String(oldname),String(newname));
end;

{==============================================================================}

function GetCurrentDir(dirname: PCHAR; len: uint32_t): uint32_t; stdcall;
{No Volume Support}
begin
 {}
 Result:=APIStringToPCharBuffer(FileSystem.FSGetCurrentDir,dirname,len);
end;

{==============================================================================}

function SetCurrentDir(const dirname: PCHAR): BOOL; stdcall;
begin
 {}
 Result:=FileSystem.FSSetCurrentDir(String(dirname));
end;

{==============================================================================}

function DirectoryExists(const dirname: PCHAR): BOOL; stdcall;
begin
 {}
 Result:=FileSystem.FSDirectoryExists(String(dirname));
end;

{==============================================================================}

procedure ForceDirectories(dirname: PCHAR); stdcall;
begin
 {}
 FileSystem.FSForceDirectories(String(dirname));
end;

{==============================================================================}

procedure DeleteTree(const dirname: PCHAR); stdcall;
begin
 {}
 FileSystem.FSDeleteTree(String(dirname));
end;

{==============================================================================}
{Search Functions}

{==============================================================================}
{Additional Functions}
function FileCopy(const sourcefile, destfile: PCHAR; failifexists: BOOL): BOOL; stdcall;
begin
 {}
 Result:=FileSystem.FSFileCopy(String(sourcefile),String(destfile),failifexists);
end;

{==============================================================================}

function FileCopyEx(const sourcefile, destfile: PCHAR; failifexists: BOOL; usesourcedate: BOOL; destdate: int; usesourceattr: BOOL; destattr: int): BOOL; stdcall;
begin
 {}
 Result:=FileSystem.FSFileCopyEx(String(sourcefile),String(destfile),failifexists,usesourcedate,destdate,usesourceattr,destattr);
end;

{==============================================================================}

function GetShortName(const filename: PCHAR; shortname: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(FileSystem.FSGetShortName(String(filename)),shortname,len);
end;

{==============================================================================}

function GetLongName(const filename: PCHAR; longname: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(FileSystem.FSGetLongName(String(filename)),longname,len);
end;

{==============================================================================}

function GetTrueName(const filename: PCHAR; truename: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(FileSystem.FSGetTrueName(String(filename)),truename,len);
end;

{==============================================================================}
{Extended Functions}
function FileSeekEx(handle: THANDLE; const offset: int64_t; origin: int32_t): int64_t; stdcall;
begin
 {}
 Result:=FileSystem.FSFileSeekEx(handle,offset,origin);
end;

{==============================================================================}

function EndOfFileEx(handle: THANDLE): BOOL; stdcall;
begin
 {}
 Result:=FileSystem.FSEndOfFileEx(handle);
end;

{==============================================================================}

function FilePosEx(handle: THANDLE): int64_t; stdcall;
begin
 {}
 Result:=FileSystem.FSFilePosEx(handle);
end;

{==============================================================================}

function FileSizeEx(handle: THANDLE): int64_t; stdcall;
begin
 {}
 Result:=FileSystem.FSFileSizeEx(handle);
end;

{==============================================================================}

function FileAgeEx(const filename: PCHAR): FILETIME; stdcall;
begin
 {}
 Result:=FileSystem.FSFileAgeEx(String(filename));
end;

{==============================================================================}

function FileGetAttrEx(handle: THANDLE): int; stdcall;
begin
 {}
 Result:=FileSystem.FSFileGetAttrEx(handle);
end;

{==============================================================================}

function FileGetDateEx(handle: THANDLE): FILETIME; stdcall;
begin
 {}
 Result:=FileSystem.FSFileGetDateEx(handle);
end;

{==============================================================================}

function FileSetDateEx(handle: THANDLE; age: FILETIME): int; stdcall;
begin
 {}
 Result:=FileSystem.FSFileSetDateEx(handle,age);
end;

{==============================================================================}

function FindFirstEx(const path: PCHAR; var searchrec: TFileSearchRec): int; stdcall;
begin
 {}
 Result:=FileSystem.FSFindFirstEx(String(path),searchrec);
end;

{==============================================================================}

function FindNextEx(var searchrec: TFileSearchRec): int; stdcall;
begin
 {}
 Result:=FileSystem.FSFindNextEx(searchrec);
end;

{==============================================================================}

procedure FindCloseEx(var searchrec: TFileSearchRec); stdcall;
begin
 {}
 FileSystem.FSFindCloseEx(searchrec);
end;

{==============================================================================}
{FileSystem Functions (Win32 Compatibility)}
{Drive Functions}

{==============================================================================}
{File Functions}

{==============================================================================}
{Directory Functions}

{==============================================================================}
{FileSystem Helper Functions}
function file_sys_redirect_input(handle: THANDLE): BOOL; stdcall;
{Redirect standard input to the file specified by Handle}
{Handle: The file handle to redirect input to (or INVALID_HANDLE_VALUE to stop redirection)}
{Return: True if completed successfully or False if an error occurred}
{Note: Redirects the input of the text file Input which also
       redirects the input of Read, ReadLn and the standard C library}
begin
 {}
 Result:=FileSystem.FileSysRedirectInput(handle);
end;

{==============================================================================}

function file_sys_redirect_output(handle: THANDLE): BOOL; stdcall;
{Redirect standard output to the file specified by Handle}
{Handle: The file handle to redirect output to (or INVALID_HANDLE_VALUE to stop redirection)}
{Return: True if completed successfully or False if an error occurred}
{Note: Redirects the output of the text files Output, ErrOutput, StdOut and StdErr
       which also redirects the output of Write, WriteLn and the standard C library}
begin
 {}
 Result:=FileSystem.FileSysRedirectOutput(handle);
end;

{==============================================================================}

function compare_partitions(partition1, partition2: PVOID): int; stdcall;
{Sort partitions in order of start sector}
begin
 {}
 Result:=FileSystem.ComparePartitions(partition1,partition2);
end;

{==============================================================================}

function disk_media_type_to_string(_type: TMEDIA_TYPE; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(FileSystem.MediaTypeToString(_type),_string,len);
end;

{==============================================================================}

function floppy_type_to_string(_type: TFLOPPY_TYPE; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(FileSystem.FloppyTypeToString(_type),_string,len);
end;

{==============================================================================}

function image_type_to_string(_type: TIMAGE_TYPE; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(FileSystem.ImageTypeToString(_type),_string,len);
end;

{==============================================================================}

function drive_type_to_string(_type: TDRIVE_TYPE; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(FileSystem.DriveTypeToString(_type),_string,len);
end;

{==============================================================================}

function file_sys_type_to_string(_type: TFILE_SYS_TYPE; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(FileSystem.FileSysTypeToString(_type),_string,len);
end;

{==============================================================================}

function string_to_file_sys_type(filesystype: PCHAR): TFILE_SYS_TYPE; stdcall;
begin
 {}
 Result:=FileSystem.StringToFileSysType(String(filesystype));
end;

{==============================================================================}

function partition_id_to_string(id: uint8_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(FileSystem.PartitionIdToString(id),_string,len);
end;

{==============================================================================}

function string_to_partition_id(partitionid: PCHAR): uint8_t; stdcall;
begin
 {}
 Result:=FileSystem.StringToPartitionId(String(partitionid));
end;

{==============================================================================}

function cache_mode_to_string(cachemode: TCACHE_MODE; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(FileSystem.CacheModeToString(cachemode),_string,len);
end;

{==============================================================================}

function cache_state_to_string(cachestate: TCACHE_STATE; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(FileSystem.CacheStateToString(cachestate),_string,len);
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{Winsock Functions}
{$IFDEF API_EXPORT_WINSOCK}
function WSStart: BOOL; stdcall;
begin
 {}
 Result:=Winsock.WSStart;
end;

{==============================================================================}

function WSStop: BOOL; stdcall;
begin
 {}
 Result:=Winsock.WSStop;
end;

{==============================================================================}

procedure WSAsyncStart(data: PVOID); stdcall;
begin
 {}
 Winsock.WSAsyncStart(data);
end;

{==============================================================================}

function accept(s: TSOCKET; addr: PSockAddr; addrlen: ptOS_INT): TSOCKET; stdcall;
begin
 {}
 Result:=Winsock.accept(s,addr,addrlen);
end;

{==============================================================================}

function bind(s: TSOCKET; addr: PSockaddr; namelen: tOS_INT): tOS_INT; stdcall;
begin
 {}
 Result:=Winsock.bind(s,addr^,namelen);
end;

{==============================================================================}

function closesocket(s: TSOCKET): tOS_INT; stdcall;
begin
 {}
 Result:=Winsock.closesocket(s);
end;

{==============================================================================}

function connect(s: TSOCKET; name: PSockAddr; namelen: tOS_INT): tOS_INT; stdcall;
begin
 {}
 Result:=Winsock.connect(s,name^,namelen);
end;

{==============================================================================}

function ioctlsocket(s: TSOCKET; cmd: int32_t; arg: pu_long): tOS_INT; stdcall;
begin
 {}
 Result:=Winsock.ioctlsocket(s,cmd,arg^);
end;

{==============================================================================}

function getpeername(s: TSOCKET; name: PSockaddr; namelen: ptOS_INT): tOS_INT; stdcall;
begin
 {}
 Result:=Winsock.getpeername(s,name^,namelen^);
end;

{==============================================================================}

function getsockname(s: TSOCKET; name: PSockaddr; namelen: ptOS_INT): tOS_INT; stdcall;
begin
 {}
 Result:=Winsock.getsockname(s,name^,namelen^);
end;

{==============================================================================}

function getsockopt(s: TSOCKET; level: tOS_INT; optname: tOS_INT; optval: PCHAR; optlen: ptOS_INT): tOS_INT; stdcall;
begin
 {}
 Result:=Winsock.getsockopt(s,level,optname,optval,optlen^);
end;

{==============================================================================}

function htonl(hostlong: u_long): u_long; stdcall;
begin
 {}
 Result:=Winsock.htonl(hostlong);
end;

{==============================================================================}

function htons(hostshort: u_short): u_short; stdcall;
begin
 {}
 Result:=Winsock.htons(hostshort);
end;

{==============================================================================}

function inet_addr(const cp: PCHAR): u_long; stdcall; // PInAddr;
begin
 {}
 Result:=Winsock.inet_addr(cp);
end;

{==============================================================================}

function inet_ntoa(inaddr: TInAddr): PCHAR; stdcall;
{As per the Winsock specification, the buffer returned by this function is only
 guaranteed to be valid until the next Winsock function call is made within the
 same thread. Therefore, the data should be copied before another Winsock call}
begin
 {}
 Result:=Winsock.inet_ntoa(inaddr);
end;

{==============================================================================}

function listen(s: TSOCKET; backlog: tOS_INT): tOS_INT; stdcall;
begin
 {}
 Result:=Winsock.listen(s,backlog);
end;

{==============================================================================}

function ntohl(netlong: u_long): u_long; stdcall;
begin
 {}
 Result:=Winsock.ntohl(netlong);
end;

{==============================================================================}

function ntohs(netshort: u_short): u_short; stdcall;
begin
 {}
 Result:=Winsock.ntohs(netshort);
end;

{==============================================================================}

function recv(s: TSOCKET; buf: PCHAR; len: tOS_INT; flags: tOS_INT): tOS_INT; stdcall;
begin
 {}
 Result:=Winsock.recv(s,buf^,len,flags);
end;

{==============================================================================}

function recvfrom(s: TSOCKET; buf: PCHAR; len: tOS_INT; flags: tOS_INT; from: PSockAddr; fromlen: ptOS_INT): tOS_INT; stdcall;
begin
 {}
 Result:=Winsock.recvfrom(s,buf^,len,flags,from^,fromlen^);
end;

{==============================================================================}

function select(nfds: tOS_INT; readfds, writefds, exceptfds: PFDSet; timeout: PTimeVal): tOS_INT; stdcall;
{Note: All sockets contained by the FDSet must be of the same type}
begin
 {}
 Result:=Winsock.select(nfds,readfds,writefds,exceptfds,timeout);
end;

{==============================================================================}

function send(s: TSOCKET; const buf: PCHAR; len: tOS_INT; flags: tOS_INT): tOS_INT; stdcall;
begin
 {}
 Result:=Winsock.send(s,buf^,len,flags);
end;

{==============================================================================}

function sendto(s: TSOCKET; const buf: PCHAR; len: tOS_INT; flags: tOS_INT; toaddr: PSockAddr; tolen: tOS_INT): tOS_INT; stdcall;
begin
 {}
 Result:=Winsock.sendto(s,buf^,len,flags,toaddr^,tolen);
end;

{==============================================================================}

function setsockopt(s: TSOCKET; level: tOS_INT; optname: tOS_INT; const optval: PCHAR; optlen: tOS_INT): tOS_INT; stdcall;
begin
 {}
 Result:=Winsock.setsockopt(s,level,optname,optval,optlen);
end;

{==============================================================================}

function shutdown(s: TSOCKET; how: tOS_INT): tOS_INT; stdcall;
begin
 {}
 Result:=Winsock.shutdown(s,how);
end;

{==============================================================================}

function socket(af: tOS_INT; struct: tOS_INT; protocol: tOS_INT): TSOCKET; stdcall;
begin
 {}
 Result:=Winsock.socket(af,struct,protocol);
end;

{==============================================================================}

function gethostbyaddr(const addr: PCHAR; len: tOS_INT; family: tOS_INT): PHostEnt; stdcall;
begin
 {}
 Result:=Winsock.gethostbyaddr(addr,len,family);
end;

{==============================================================================}

function gethostbyname(const name: PCHAR): PHostEnt; stdcall;
begin
 {}
 Result:=Winsock.gethostbyname(name);
end;

{==============================================================================}

function gethostname(name: PCHAR; namelen: tOS_INT): tOS_INT; stdcall;
begin
 {}
 Result:=Winsock.gethostname(name,namelen);
end;

{==============================================================================}

function getservbyport(port: tOS_INT; const proto: PCHAR): PServEnt; stdcall;
begin
 {}
 Result:=Winsock.getservbyport(port,proto);
end;

{==============================================================================}

function getservbyname(const name, proto: PCHAR): PServEnt; stdcall;
begin
 {}
 Result:=Winsock.getservbyname(name,proto);
end;

{==============================================================================}

function getprotobynumber(proto: tOS_INT): PProtoEnt; stdcall;
begin
 {}
 Result:=Winsock.getprotobynumber(proto);
end;

{==============================================================================}

function getprotobyname(const name: PCHAR): PProtoEnt; stdcall;
begin
 {}
 Result:=Winsock.getprotobyname(name);
end;

{==============================================================================}

function WSAStartup(wversionrequired: uint16_t; var wsadata: TWSADATA): tOS_INT; stdcall;
begin
 {}
 Result:=Winsock.WSAStartup(wversionrequired,wsadata);
end;

{==============================================================================}

function WSACleanup: tOS_INT; stdcall;
begin
 {}
 Result:=Winsock.WSACleanup;
end;

{==============================================================================}

procedure WSASetLastError(ierror: tOS_INT); stdcall;
begin
 {}
 Winsock.WSASetLastError(ierror);
end;

{==============================================================================}

function WSAGetLastError: tOS_INT; stdcall;
begin
 {}
 Result:=Winsock.WSAGetLastError;
end;

{==============================================================================}

function WSAIsBlocking: BOOL; stdcall;
begin
 {}
 Result:=Winsock.WSAIsBlocking;
end;

{==============================================================================}

function WSAUnhookBlockingHook: tOS_INT; stdcall;
begin
 {}
 Result:=Winsock.WSAUnhookBlockingHook;
end;

{==============================================================================}

function WSASetBlockingHook(lpblockfunc: TFarProc): TFarProc; stdcall;
begin
 {}
 Result:=Winsock.WSASetBlockingHook(lpblockfunc);
end;

{==============================================================================}

function WSACancelBlockingCall: tOS_INT; stdcall;
begin
 {}
 Result:=Winsock.WSACancelBlockingCall;
end;

{==============================================================================}

function WSAAsyncGetServByName(hwnd: HWND; wmsg: u_int; const name: PCHAR; const proto: PCHAR; buf: PCHAR; buflen: tOS_INT): THANDLE; stdcall;
begin
 {}
 Result:=Winsock.WSAAsyncGetServByName(hwnd,wmsg,name,proto,buf,buflen);
end;

{==============================================================================}

function WSAAsyncGetServByPort(hwnd: HWND; wmsg: u_int; port: tOS_INT; proto: PCHAR; buf: PCHAR; buflen: tOS_INT): THANDLE; stdcall;
begin
 {}
 Result:=Winsock.WSAAsyncGetServByPort(hwnd,wmsg,port,proto,buf,buflen);
end;

{==============================================================================}

function WSAAsyncGetProtoByName(hwnd: HWND; wmsg: u_int; const name: PCHAR; buf: PCHAR; buflen: tOS_INT): THANDLE; stdcall;
begin
 {}
 Result:=Winsock.WSAAsyncGetProtoByName(hwnd,wmsg,name,buf,buflen);
end;

{==============================================================================}

function WSAAsyncGetProtoByNumber(hwnd: HWND; wmsg: u_int; number: tOS_INT; buf: PCHAR; buflen: tOS_INT): THANDLE; stdcall;
begin
 {}
 Result:=Winsock.WSAAsyncGetProtoByNumber(hwnd,wmsg,number,buf,buflen);
end;

{==============================================================================}

function WSAAsyncGetHostByName(hwnd: HWND; wmsg: u_int; const name: PCHAR; buf: PCHAR; buflen: tOS_INT): THANDLE; stdcall;
begin
 {}
 Result:=Winsock.WSAAsyncGetHostByName(hwnd,wmsg,name,buf,buflen);
end;

{==============================================================================}

function WSAAsyncGetHostByAddr(hwnd: HWND; wmsg: u_int; const addr: PCHAR; len: tOS_INT; family: tOS_INT; buf: PCHAR; buflen: tOS_INT): THANDLE; stdcall;
begin
 {}
 Result:=Winsock.WSAAsyncGetHostByAddr(hwnd,wmsg,addr,len,family,buf,buflen);
end;

{==============================================================================}

function WSACancelAsyncRequest(hasynctaskhandle: THANDLE): tOS_INT; stdcall;
begin
 {}
 Result:=Winsock.WSACancelAsyncRequest(hasynctaskhandle);
end;

{==============================================================================}

function WSAAsyncSelect(s: TSOCKET; hwnd: HWND; wmsg: u_int; levent: int32_t): tOS_INT; stdcall; //  really a c-long
begin
 {}
 Result:=Winsock.WSAAsyncSelect(s,hwnd,wmsg,levent);
end;

{==============================================================================}

function WSARecvEx(s: TSOCKET; buf: PVOID; len: tOS_INT; flags: ptOS_INT): tOS_INT; stdcall;
begin
 {}
 Result:=Winsock.WSARecvEx(s,buf,len,flags);
end;

{==============================================================================}

function __WSAFDIsSet(s: TSOCKET; var fdset: TFDSet): BOOL; stdcall;
begin
 {}
 Result:=Winsock.__WSAFDIsSet(s,fdset);
end;

{==============================================================================}

function __WSAFDIsSet_(s: TSOCKET; var fdset: TFDSet): tOS_INT; stdcall;
begin
 {}
 Result:=Winsock.__WSAFDIsSet_(s,fdset);
end;

{==============================================================================}

function TransmitFile(hsocket: TSOCKET; hfile: THANDLE; nnumberofbytestowrite: uint32_t; nnumberofbytespersend: uint32_t; lpoverlapped: POverlapped; lptransmitbuffers: PTransmitFileBuffers; dwreserved: uint32_t): BOOL; stdcall;
begin
 {}
 Result:=Winsock.TransmitFile(hsocket,hfile,nnumberofbytestowrite,nnumberofbytespersend,lpoverlapped,lptransmitbuffers,dwreserved);
end;

{==============================================================================}

function AcceptEx(slistensocket, sacceptsocket: TSOCKET; lpoutputbuffer: PVOID; dwreceivedatalength, dwlocaladdresslength, dwremoteaddresslength: uint32_t; var lpdwbytesreceived: uint32_t; lpoverlapped: POverlapped): BOOL; stdcall;
begin
 {}
 Result:=Winsock.AcceptEx(slistensocket,sacceptsocket,lpoutputbuffer,dwreceivedatalength,dwlocaladdresslength,dwremoteaddresslength,lpdwbytesreceived,lpoverlapped);
end;

{==============================================================================}

procedure GetAcceptExSockaddrs(lpoutputbuffer: PVOID; dwreceivedatalength, dwlocaladdresslength, dwremoteaddresslength: uint32_t; var localsockaddr: PSockAddr; var localsockaddrlength: int; var remotesockaddr: PSockAddr; var remotesockaddrlength: int); stdcall;
begin
 {}
 Winsock.GetAcceptExSockaddrs(lpoutputbuffer,dwreceivedatalength,dwlocaladdresslength,dwremoteaddresslength,localsockaddr,localsockaddrlength,remotesockaddr,remotesockaddrlength);
end;

{==============================================================================}

function WSAMakeSyncReply(buflen, error: uint16_t): uint32_t; stdcall;
begin
 {}
 Result:=Winsock.WSAMakeSyncReply(buflen,error);
end;

{==============================================================================}

function WSAMakeSelectReply(event, error: uint16_t): uint32_t; stdcall;
begin
 {}
 Result:=Winsock.WSAMakeSelectReply(event,error);
end;

{==============================================================================}

function WSAGetAsyncBuflen(param: uint32_t): uint16_t; stdcall;
begin
 {}
 Result:=Winsock.WSAGetAsyncBuflen(param);
end;

{==============================================================================}

function WSAGetAsyncError(param: uint32_t): uint16_t; stdcall;
begin
 {}
 Result:=Winsock.WSAGetAsyncError(param);
end;

{==============================================================================}

function WSAGetSelectEvent(param: uint32_t): uint16_t; stdcall;
begin
 {}
 Result:=Winsock.WSAGetSelectEvent(param);
end;

{==============================================================================}

function WSAGetSelectError(param: uint32_t): uint16_t; stdcall;
begin
 {}
 Result:=Winsock.WSAGetSelectError(param);
end;

{==============================================================================}

procedure FD_CLR(socket: TSOCKET; var fdset: TFDSet); stdcall;
begin
 {}
 Winsock.FD_CLR(socket,fdset);
end;

{==============================================================================}

function FD_ISSET(socket: TSOCKET; var fdset: TFDSet): BOOL; stdcall;
begin
 {}
 Result:=Winsock.FD_ISSET(socket,fdset);
end;

{==============================================================================}

procedure FD_SET(socket: TSOCKET; var fdset: TFDSet); stdcall;
begin
 {}
 Winsock.FD_SET(socket,fdset);
end;

{==============================================================================}

procedure FD_ZERO(var fdset: TFDSet); stdcall;
begin
 {}
 Winsock.FD_ZERO(fdset);
end;

{==============================================================================}
{Winsock Undocumented Functions}
function WsControl(proto: uint32_t; action: uint32_t; prequestinfo: PVOID; var pcbrequestinfolen: uint32_t; presponseinfo: PVOID; var pcbresponseinfolen: uint32_t): int; stdcall;
begin
 {}
 Result:=Winsock.WsControl(proto,action,prequestinfo,pcbrequestinfolen,presponseinfo,pcbresponseinfolen);
end;

{==============================================================================}

function getnetbyaddr(addr: PVOID; len, struct: int): PNetEnt; stdcall;
begin
 {}
 Result:=Winsock.getnetbyaddr(addr,len,struct);
end;

{==============================================================================}

function getnetbyname(const name: PCHAR): PNetEnt; stdcall;
begin
 {}
 Result:=Winsock.getnetbyname(name);
end;

{==============================================================================}
{Winsock Enhanced Functions}
function WsControlEx(proto: uint32_t; action: uint32_t; prequestinfo: PVOID; var pcbrequestinfolen: uint32_t; presponseinfo: PVOID; var pcbresponseinfolen: uint32_t): int; stdcall;
begin
 {}
 Result:=Winsock.WsControlEx(proto,action,prequestinfo,pcbrequestinfolen,presponseinfo,pcbresponseinfolen);
end;

{==============================================================================}
{Winsock Helper Functions}
function WinsockRedirectInput(s: TSOCKET): BOOL; stdcall;
{Redirect standard input to the socket specified by s}
{s: The socket to redirect input to (or INVALID_SOCKET to stop redirection)}
{Return: True if completed successfully or False if an error occurred}
{Note: Redirects the input of the text file Input which also
       redirects the input of Read, ReadLn and the standard C library}
begin
 {}
 Result:=Winsock.WinsockRedirectInput(s);
end;

{==============================================================================}

function WinsockRedirectOutput(s: TSOCKET): BOOL; stdcall;
{Redirect standard output to the socket specified by s}
{s: The socket to redirect output to (or INVALID_SOCKET to stop redirection)}
{Return: True if completed successfully or False if an error occurred}
{Note: Redirects the output of the text files Output, ErrOutput, StdOut and StdErr
       which also redirects the output of Write, WriteLn and the standard C library}
begin
 {}
 Result:=Winsock.WinsockRedirectOutput(s);
end;

{==============================================================================}

function WinsockErrorToString(error: int32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(Winsock.WinsockErrorToString(error),_string,len);
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{Winsock2 Functions}
{$IFDEF API_EXPORT_WINSOCK2}
function WS2Start: BOOL; stdcall;
begin
 {}
 Result:=Winsock2.WS2Start;
end;

{==============================================================================}

function WS2Stop: BOOL; stdcall;
begin
 {}
 Result:=Winsock2.WS2Stop;
end;

{==============================================================================}

procedure WS2AsyncStart(data: PVOID); stdcall;
begin
 {}
 Winsock2.WS2AsyncStart(data);
end;

{==============================================================================}

function accept(s: TSOCKET; addr: PSockAddr; addrlen: Pint32_t): TSOCKET; stdcall;
begin
 {}
 Result:=Winsock2.accept(s,addr,addrlen);
end;

{==============================================================================}

function bind(s: TSOCKET; addr: PSockAddr; namelen: int32_t): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.bind(s,addr^,namelen);
end;

{==============================================================================}

function closesocket(s: TSOCKET): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.closesocket(s);
end;

{==============================================================================}

function connect(s: TSOCKET; name: PSockAddr; namelen: int32_t): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.connect(s,name^,namelen);
end;

{==============================================================================}

function ioctlsocket(s: TSOCKET; cmd: int32_t; arg: pu_long): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.ioctlsocket(s,cmd,arg^);
end;

{==============================================================================}

function getpeername(s: TSOCKET; name: PSockAddr; namelen: Pint32_t): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.getpeername(s,name^,namelen^);
end;

{==============================================================================}

function getsockname(s: TSOCKET; name: PSockAddr; namelen: Pint32_t): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.getsockname(s,name^,namelen^);
end;

{==============================================================================}

function getsockopt(s: TSOCKET; level, optname: int32_t; optval: PCHAR; optlen: Pint32_t): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.getsockopt(s,level,optname,optval,optlen^);
end;

{==============================================================================}

function htonl(hostlong: u_long): u_long; stdcall;
begin
 {}
 Result:=Winsock2.htonl(hostlong);
end;

{==============================================================================}

function htons(hostshort: u_short): u_short; stdcall;
begin
 {}
 Result:=Winsock2.htons(hostshort);
end;

{==============================================================================}

function inet_addr(const cp: PCHAR): u_long; stdcall;
begin
 {}
 Result:=Winsock2.inet_addr(cp);
end;

{==============================================================================}

function inet_ntoa(inaddr: TInAddr): PCHAR; stdcall;
{As per the Winsock specification, the buffer returned by this function is only
 guaranteed to be valid until the next Winsock function call is made within the
 same thread. Therefore, the data should be copied before another Winsock call}
begin
 {}
 Result:=Winsock2.inet_ntoa(inaddr);
end;

{==============================================================================}

function listen(s: TSOCKET; backlog: int32_t): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.listen(s,backlog);
end;

{==============================================================================}

function ntohl(netlong: u_long): u_long; stdcall;
begin
 {}
 Result:=Winsock2.ntohl(netlong);
end;

{==============================================================================}

function ntohs(netshort: u_short): u_short; stdcall;
begin
 {}
 Result:=Winsock2.ntohs(netshort);
end;

{==============================================================================}

function recv(s: TSOCKET; buf: PCHAR; len, flags: int32_t): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.recv(s,buf^,len,flags);
end;

{==============================================================================}

function recvfrom(s: TSOCKET; buf: PCHAR; len, flags: int32_t; from: PSockAddr; fromlen: Pint32_t): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.recvfrom(s,buf^,len,flags,from^,fromlen^);
end;

{==============================================================================}

function select(nfds: int32_t; readfds, writefds, exceptfds: PFDSet; timeout: PTimeVal): int32_t; stdcall;
{Note: All sockets contained by the FDSet must be of the same type}
begin
 {}
 Result:=Winsock2.select(nfds,readfds,writefds,exceptfds,timeout);
end;

{==============================================================================}

function send(s: TSOCKET; const buf: PCHAR; len, flags: int32_t): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.send(s,buf^,len,flags);
end;

{==============================================================================}

function sendto(s: TSOCKET; const buf: PCHAR; len, flags: int32_t; addrto: PSockAddr; tolen: int32_t): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.sendto(s,buf^,len,flags,addrto^,tolen);
end;

{==============================================================================}

function setsockopt(s: TSOCKET; level, optname: int32_t; const optval: PCHAR; optlen: int32_t): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.setsockopt(s,level,optname,optval,optlen);
end;

{==============================================================================}

function shutdown(s: TSOCKET; how: int32_t): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.shutdown(s,how);
end;

{==============================================================================}

function socket(af, struct, protocol: int32_t): TSOCKET; stdcall;
begin
 {}
 Result:=Winsock2.socket(af,struct,protocol);
end;

{==============================================================================}

function gethostbyaddr(addr: PVOID; len, family: int32_t): PHostEnt; stdcall;
begin
 {}
 Result:=Winsock2.gethostbyaddr(addr,len,family);
end;

{==============================================================================}

function gethostbyname(const name: PCHAR): PHostEnt; stdcall;
begin
 {}
 Result:=Winsock2.gethostbyname(name);
end;

{==============================================================================}

function gethostname(name: PCHAR; len: int32_t): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.gethostname(name,len);
end;

{==============================================================================}

function getservbyport(port: int32_t; const proto: PCHAR): PServEnt; stdcall;
begin
 {}
 Result:=Winsock2.getservbyport(port,proto);
end;

{==============================================================================}

function getservbyname(const name, proto: PCHAR): PServEnt; stdcall;
begin
 {}
 Result:=Winsock2.getservbyname(name,proto);
end;

{==============================================================================}

function getprotobynumber(proto: int32_t): PProtoEnt; stdcall;
begin
 {}
 Result:=Winsock2.getprotobynumber(proto);
end;

{==============================================================================}

function getprotobyname(const name: PCHAR): PProtoEnt; stdcall;
begin
 {}
 Result:=Winsock2.getprotobyname(name);
end;

{==============================================================================}

function getaddrinfo(pnodename, pservicename: PCHAR; phints: PAddrInfo; var ppresult: PAddrInfo): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.getaddrinfo(pnodename,pservicename,phints,ppresult);
end;

{==============================================================================}

procedure freeaddrinfo(ai: PAddrInfo); stdcall;
begin
 {}
 Winsock2.freeaddrinfo(ai);
end;

{==============================================================================}

function getnameinfo(sa: PSockAddr; salen: int; host: PCHAR; hostlen: uint32_t; serv: PCHAR; servlen: uint32_t; flags: int): int; stdcall;
begin
 {}
 Result:=Winsock2.getnameinfo(sa,salen,host,hostlen,serv,servlen,flags);
end;

{==============================================================================}

function WSAStartup(wversionrequired: uint16_t; var wsdata: TWSAData): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSAStartup(wversionrequired,wsdata);
end;

{==============================================================================}

function WSACleanup: int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSACleanup;
end;

{==============================================================================}

procedure WSASetLastError(ierror: int32_t); stdcall;
begin
 {}
 Winsock2.WSASetLastError(ierror);
end;

{==============================================================================}

function WSAGetLastError: int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSAGetLastError;
end;

{==============================================================================}

function WSAIsBlocking: BOOL; stdcall;
begin
 {}
 Result:=Winsock2.WSAIsBlocking;
end;

{==============================================================================}

function WSAUnhookBlockingHook: int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSAUnhookBlockingHook;
end;

{==============================================================================}

function WSASetBlockingHook(lpblockfunc: TFarProc): TFarProc; stdcall;
begin
 {}
 Result:=Winsock2.WSASetBlockingHook(lpblockfunc);
end;

{==============================================================================}

function WSACancelBlockingCall: int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSACancelBlockingCall;
end;

{==============================================================================}

function WSAAsyncGetServByName(hwindow: HWND; wmsg: u_int; const name, proto: PCHAR; buf: PCHAR; buflen: int32_t): THANDLE; stdcall;
begin
 {}
 Result:=Winsock2.WSAAsyncGetServByName(hwindow,wmsg,name,proto,buf,buflen);
end;

{==============================================================================}

function WSAAsyncGetServByPort(hwindow: HWND; wmsg, port: u_int; proto, buf: PCHAR; buflen: int32_t): THANDLE; stdcall;
begin
 {}
 Result:=Winsock2.WSAAsyncGetServByPort(hwindow,wmsg,port,proto,buf,buflen);
end;

{==============================================================================}

function WSAAsyncGetProtoByName(hwindow: HWND; wmsg: u_int; const name: PCHAR; buf: PCHAR; buflen: int32_t): THANDLE; stdcall;
begin
 {}
 Result:=Winsock2.WSAAsyncGetProtoByName(hwindow,wmsg,name,buf,buflen);
end;

{==============================================================================}

function WSAAsyncGetProtoByNumber(hwindow: HWND; wmsg: u_int; number: int32_t; buf: PCHAR; buflen: int32_t): THANDLE; stdcall;
begin
 {}
 Result:=Winsock2.WSAAsyncGetProtoByNumber(hwindow,wmsg,number,buf,buflen);
end;

{==============================================================================}

function WSAAsyncGetHostByName(hwindow: HWND; wmsg: u_int; const name: PCHAR; buf: PCHAR; buflen: int32_t): THANDLE; stdcall;
begin
 {}
 Result:=Winsock2.WSAAsyncGetHostByName(hwindow,wmsg,name,buf,buflen);
end;

{==============================================================================}

function WSAAsyncGetHostByAddr(hwindow: HWND; wmsg: u_int; const addr: PCHAR; len, family: int32_t; buf: PCHAR; buflen: int32_t): THANDLE; stdcall;
begin
 {}
 Result:=Winsock2.WSAAsyncGetHostByAddr(hwindow,wmsg,addr,len,family,buf,buflen);
end;

{==============================================================================}

function WSACancelAsyncRequest(hasynctaskhandle: THANDLE): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSACancelAsyncRequest(hasynctaskhandle);
end;

{==============================================================================}

function WSAAsyncSelect(s: TSOCKET; hwindow: HWND; wmsg: u_int; levent: int32_t): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSAAsyncSelect(s,hwindow,wmsg,levent);
end;

{==============================================================================}

function __WSAFDIsSet(s: TSOCKET; var fdset: TFDSet): BOOL; stdcall;
begin
 {}
 Result:=Winsock2.__WSAFDIsSet(s,fdset);
end;

{==============================================================================}

function inet_pton(family: int32_t; pszaddrstring: PCHAR; paddrbuf: PVOID): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.inet_pton(family,pszaddrstring,paddrbuf);
end;

{==============================================================================}

function InetPtonA(family: int32_t; pszaddrstring: PCHAR; paddrbuf: PVOID): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.InetPtonA(family,pszaddrstring,paddrbuf);
end;

{==============================================================================}

function InetPtonW(family: int32_t; pszaddrstring: PWCHAR; paddrbuf: PVOID): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.InetPtonW(family,pszaddrstring,paddrbuf);
end;

{==============================================================================}

function inet_ntop(family: int32_t; paddr: PVOID; pstringbuf: PCHAR; stringbufsize: int32_t): PCHAR; stdcall;
begin
 {}
 Result:=Winsock2.inet_ntop(family,paddr,pstringbuf,stringbufsize);
end;

{==============================================================================}

function InetNtopA(family: int32_t; paddr: PVOID; pstringbuf: PCHAR; stringbufsize: int32_t): PCHAR; stdcall;
begin
 {}
 Result:=Winsock2.InetNtopA(family,paddr,pstringbuf,stringbufsize);
end;

{==============================================================================}

function InetNtopW(family: int32_t; paddr: PVOID; pstringbuf: PWCHAR; stringbufsize: int32_t): PWCHAR; stdcall;
begin
 {}
 Result:=Winsock2.InetNtopW(family,paddr,pstringbuf,stringbufsize);
end;

{==============================================================================}

function WSAAccept(s: TSOCKET; addr: TSockAddr; addrlen: Pint32_t; lpfncondition: LPCONDITIONPROC; dwcallbackdata: uint32_t): TSOCKET; stdcall;
begin
 {}
 Result:=Winsock2.WSAAccept(s,addr,addrlen,lpfncondition,dwcallbackdata);
end;

{==============================================================================}

function WSACloseEvent(hevent: WSAEVENT): WordBool; stdcall;
begin
 {}
 Result:=Winsock2.WSACloseEvent(hevent);
end;

{==============================================================================}

function WSAConnect(s: TSOCKET; name: PSockAddr; namelen: int32_t; lpcallerdata, lpcalleedata: LPWSABUF; lpsqos, lpgqos: LPQOS): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSAConnect(s,name,namelen,lpcallerdata,lpcalleedata,lpsqos,lpgqos);
end;

{==============================================================================}

function WSACreateEvent: WSAEVENT; stdcall;
begin
 {}
 Result:=Winsock2.WSACreateEvent;
end;

{==============================================================================}

function WSADuplicateSocketA(s: TSOCKET; dwprocessid: uint32_t; lpprotocolinfo: LPWSAProtocol_InfoA): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSADuplicateSocketA(s,dwprocessid,lpprotocolinfo);
end;

{==============================================================================}

function WSADuplicateSocketW(s: TSOCKET; dwprocessid: uint32_t; lpprotocolinfo: LPWSAProtocol_InfoW): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSADuplicateSocketW(s,dwprocessid,lpprotocolinfo);
end;

{==============================================================================}

function WSAEnumNetworkEvents(s: TSOCKET; heventobject: WSAEVENT; lpnetworkevents: LPWSANETWORKEVENTS): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSAEnumNetworkEvents(s,heventobject,lpnetworkevents);
end;

{==============================================================================}

function WSAEnumProtocolsA(lpiprotocols: Pint32_t; lpprotocolbuffer: LPWSAProtocol_InfoA; var lpdwbufferlength: uint32_t): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSAEnumProtocolsA(lpiprotocols,lpprotocolbuffer,lpdwbufferlength);
end;

{==============================================================================}

function WSAEnumProtocolsW(lpiprotocols: Pint32_t; lpprotocolbuffer: LPWSAProtocol_InfoW; var lpdwbufferlength: uint32_t): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSAEnumProtocolsW(lpiprotocols,lpprotocolbuffer,lpdwbufferlength);
end;

{==============================================================================}

function WSAEventSelect(s: TSOCKET; heventobject: WSAEVENT; lnetworkevents: int32_t): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSAEventSelect(s,heventobject,lnetworkevents);
end;

{==============================================================================}

function WSAGetOverlappedResult(s: TSOCKET; lpoverlapped: LPWSAOVERLAPPED; lpcbtransfer: LPDWORD; fwait: BOOL; var lpdwflags: uint32_t): WordBool; stdcall;
begin
 {}
 Result:=Winsock2.WSAGetOverlappedResult(s,lpoverlapped,lpcbtransfer,fwait,lpdwflags);
end;

{==============================================================================}

function WSAGetQosByName(s: TSOCKET; lpqosname: LPWSABUF; lpqos: LPQOS): WordBool; stdcall;
begin
 {}
 Result:=Winsock2.WSAGetQosByName(s,lpqosname,lpqos);
end;

{==============================================================================}

function WSAhtonl(s: TSOCKET; hostlong: u_long; var lpnetlong: uint32_t): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSAhtonl(s,hostlong,lpnetlong);
end;

{==============================================================================}

function WSAhtons(s: TSOCKET; hostshort: u_short; var lpnetshort: uint16_t): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSAhtons(s,hostshort,lpnetshort);
end;

{==============================================================================}

function WSAIoctl(s: TSOCKET; dwiocontrolcode: uint32_t; lpvinbuffer: PVOID; cbinbuffer: uint32_t; lpvoutbuffer: PVOID; cboutbuffer: uint32_t; lpcbbytesreturned: LPDWORD; lpoverlapped: LPWSAOVERLAPPED; lpcompletionroutine: LPWSAOVERLAPPED_COMPLETION_ROUTINE): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSAIoctl(s,dwiocontrolcode,lpvinbuffer,cbinbuffer,lpvoutbuffer,cboutbuffer,lpcbbytesreturned,lpoverlapped,lpcompletionroutine);
end;

{==============================================================================}

function WSAJoinLeaf(s: TSOCKET; name: PSockAddr; namelen: int32_t; lpcallerdata, lpcalleedata: LPWSABUF; lpsqos, lpgqos: LPQOS; dwflags: uint32_t): TSOCKET; stdcall;
begin
 {}
 Result:=Winsock2.WSAJoinLeaf(s,name,namelen,lpcallerdata,lpcalleedata,lpsqos,lpgqos,dwflags);
end;

{==============================================================================}

function WSANtohl(s: TSOCKET; netlong: u_long; var lphostlong: uint32_t): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSANtohl(s,netlong,lphostlong);
end;

{==============================================================================}

function WSANtohs(s: TSOCKET; netshort: u_short; var lphostshort: uint16_t): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSANtohs(s,netshort,lphostshort);
end;

{==============================================================================}

function WSARecv(s: TSOCKET; lpbuffers: LPWSABUF; dwbuffercount: uint32_t; var lpnumberofbytesrecvd: uint32_t; var lpflags: uint32_t; lpoverlapped: LPWSAOVERLAPPED; lpcompletionroutine: LPWSAOVERLAPPED_COMPLETION_ROUTINE): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSARecv(s,lpbuffers,dwbuffercount,lpnumberofbytesrecvd,lpflags,lpoverlapped,lpcompletionroutine);
end;

{==============================================================================}

function WSARecvDisconnect(s: TSOCKET; lpinbounddisconnectdata: LPWSABUF): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSARecvDisconnect(s,lpinbounddisconnectdata);
end;

{==============================================================================}

function WSARecvFrom(s: TSOCKET; lpbuffers: LPWSABUF; dwbuffercount: uint32_t; var lpnumberofbytesrecvd: uint32_t; var lpflags: uint32_t; lpfrom: PSockAddr; lpfromlen: Pint32_t; lpoverlapped: LPWSAOVERLAPPED; lpcompletionroutine: LPWSAOVERLAPPED_COMPLETION_ROUTINE): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSARecvFrom(s,lpbuffers,dwbuffercount,lpnumberofbytesrecvd,lpflags,lpfrom,lpfromlen,lpoverlapped,lpcompletionroutine);
end;

{==============================================================================}

function WSARecvMsg(s: TSOCKET; lpmsg: LPWSAMSG; lpdwnumberofbytesrecvd: uint32_t; lpoverlapped: LPWSAOVERLAPPED; lpcompletionroutine: LPWSAOVERLAPPED_COMPLETION_ROUTINE): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSARecvMsg(s,lpmsg,lpdwnumberofbytesrecvd,lpoverlapped,lpcompletionroutine);
end;

{==============================================================================}

function WSAResetEvent(hevent: WSAEVENT): WordBool; stdcall;
begin
 {}
 Result:=Winsock2.WSAResetEvent(hevent);
end;

{==============================================================================}

function WSASend(s: TSOCKET; lpbuffers: LPWSABUF; dwbuffercount: uint32_t; var lpnumberofbytessent: uint32_t; dwflags: uint32_t; lpoverlapped: LPWSAOVERLAPPED; lpcompletionroutine: LPWSAOVERLAPPED_COMPLETION_ROUTINE): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSASend(s,lpbuffers,dwbuffercount,lpnumberofbytessent,dwflags,lpoverlapped,lpcompletionroutine);
end;

{==============================================================================}

function WSASendDisconnect(s: TSOCKET; lpoutbounddisconnectdata: LPWSABUF): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSASendDisconnect(s,lpoutbounddisconnectdata);
end;

{==============================================================================}

function WSASendTo(s: TSOCKET; lpbuffers: LPWSABUF; dwbuffercount: uint32_t; var lpnumberofbytessent: uint32_t; dwflags: uint32_t; lpto: PSockAddr; itolen: int32_t; lpoverlapped: LPWSAOVERLAPPED; lpcompletionroutine: LPWSAOVERLAPPED_COMPLETION_ROUTINE): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSASendTo(s,lpbuffers,dwbuffercount,lpnumberofbytessent,dwflags,lpto,itolen,lpoverlapped,lpcompletionroutine);
end;

{==============================================================================}

function WSASendMsg(s: TSOCKET; lpmsg: LPWSAMSG; dwflags: uint32_t; lpnumberofbytessent: uint32_t; lpoverlapped: LPWSAOVERLAPPED; lpcompletionroutine: LPWSAOVERLAPPED_COMPLETION_ROUTINE): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSASendMsg(s,lpmsg,dwflags,lpnumberofbytessent,lpoverlapped,lpcompletionroutine);
end;

{==============================================================================}

function WSASetEvent(hevent: WSAEVENT): WordBool; stdcall;
begin
 {}
 Result:=Winsock2.WSASetEvent(hevent);
end;

{==============================================================================}

function WSASocketA(af, itype, protocol: int32_t; lpprotocolinfo: LPWSAProtocol_InfoA; g: GROUP; dwflags: uint32_t): TSOCKET; stdcall;
begin
 {}
 Result:=Winsock2.WSASocketA(af,itype,protocol,lpprotocolinfo,g,dwflags);
end;

{==============================================================================}

function WSASocketW(af, itype, protocol: int32_t; lpprotocolinfo: LPWSAProtocol_InfoW; g: GROUP; dwflags: uint32_t): TSOCKET; stdcall;
begin
 {}
 Result:=Winsock2.WSASocketW(af,itype,protocol,lpprotocolinfo,g,dwflags);
end;

{==============================================================================}

function WSAWaitForMultipleEvents(cevents: uint32_t; lphevents: PWSAEVENT; fwaitall: LONGBOOL; dwtimeout: uint32_t; falertable: LONGBOOL): uint32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSAWaitForMultipleEvents(cevents,lphevents,fwaitall,dwtimeout,falertable);
end;

{==============================================================================}

function WSAAddressToStringA(var lpsaaddress: TSockAddr; const dwaddresslength: uint32_t; const lpprotocolinfo: LPWSAProtocol_InfoA; const lpszaddressstring: PCHAR; var lpdwaddressstringlength: uint32_t): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSAAddressToStringA(lpsaaddress,dwaddresslength,lpprotocolinfo,lpszaddressstring,lpdwaddressstringlength);
end;

{==============================================================================}

function WSAAddressToStringW(var lpsaaddress: TSockAddr; const dwaddresslength: uint32_t; const lpprotocolinfo: LPWSAProtocol_InfoW; const lpszaddressstring: PWCHAR; var lpdwaddressstringlength: uint32_t): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSAAddressToStringW(lpsaaddress,dwaddresslength,lpprotocolinfo,lpszaddressstring,lpdwaddressstringlength);
end;

{==============================================================================}

function WSAStringToAddressA(const addressstring: PCHAR; const addressfamily: int32_t; const lpprotocolinfo: LPWSAProtocol_InfoA; var lpaddress: TSockAddr; var lpaddresslength: int32_t): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSAStringToAddressA(addressstring,addressfamily,lpprotocolinfo,lpaddress,lpaddresslength);
end;

{==============================================================================}

function WSAStringToAddressW(const addressstring: PWCHAR; const addressfamily: int32_t; const lpprotocolinfo: LPWSAProtocol_InfoA; var lpaddress: TSockAddr; var lpaddresslength: int32_t): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSAStringToAddressW(addressstring,addressfamily,lpprotocolinfo,lpaddress,lpaddresslength);
end;

{==============================================================================}

function WSALookupServiceBeginA(const lpqsrestrictions: LPWSAQuerySetA; const dwcontrolflags: uint32_t; lphlookup: PHANDLE): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSALookupServiceBeginA(lpqsrestrictions,dwcontrolflags,lphlookup);
end;

{==============================================================================}

function WSALookupServiceBeginW(const lpqsrestrictions: LPWSAQuerySetW; const dwcontrolflags: uint32_t; lphlookup: PHANDLE): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSALookupServiceBeginW(lpqsrestrictions,dwcontrolflags,lphlookup);
end;

{==============================================================================}

function WSALookupServiceNextA(const hlookup: THANDLE; const dwcontrolflags: uint32_t; var lpdwbufferlength: uint32_t; lpqsresults: LPWSAQuerySetA): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSALookupServiceNextA(hlookup,dwcontrolflags,lpdwbufferlength,lpqsresults);
end;

{==============================================================================}

function WSALookupServiceNextW(const hlookup: THANDLE; const dwcontrolflags: uint32_t; var lpdwbufferlength: uint32_t; lpqsresults: LPWSAQuerySetW): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSALookupServiceNextW(hlookup,dwcontrolflags,lpdwbufferlength,lpqsresults);
end;

{==============================================================================}

function WSALookupServiceEnd(const hlookup: THANDLE): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSALookupServiceEnd(hlookup);
end;

{==============================================================================}

function WSAInstallServiceClassA(const lpserviceclassinfo: LPWSAServiceClassInfoA): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSAInstallServiceClassA(lpserviceclassinfo);
end;

{==============================================================================}

function WSAInstallServiceClassW(const lpserviceclassinfo: LPWSAServiceClassInfoW): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSAInstallServiceClassW(lpserviceclassinfo);
end;

{==============================================================================}

function WSARemoveServiceClass(const lpserviceclassid: PGUID): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSARemoveServiceClass(lpserviceclassid);
end;

{==============================================================================}

function WSAGetServiceClassInfoA(const lpproviderid: PGUID; const lpserviceclassid: PGUID; var lpdwbufsize: uint32_t; lpserviceclassinfo: LPWSAServiceClassInfoA): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSAGetServiceClassInfoA(lpproviderid,lpserviceclassid,lpdwbufsize,lpserviceclassinfo);
end;

{==============================================================================}

function WSAGetServiceClassInfoW(const lpproviderid: PGUID; const lpserviceclassid: PGUID; var lpdwbufsize: uint32_t; lpserviceclassinfo: LPWSAServiceClassInfoW): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSAGetServiceClassInfoW(lpproviderid,lpserviceclassid,lpdwbufsize,lpserviceclassinfo);
end;

{==============================================================================}

function WSAEnumNameSpaceProvidersA(var lpdwbufferlength: uint32_t; const lpnspbuffer: LPWSANameSpace_InfoA): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSAEnumNameSpaceProvidersA(lpdwbufferlength,lpnspbuffer);
end;

{==============================================================================}

function WSAEnumNameSpaceProvidersW(var lpdwbufferlength: uint32_t; const lpnspbuffer: LPWSANameSpace_InfoW): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSAEnumNameSpaceProvidersW(lpdwbufferlength,lpnspbuffer);
end;

{==============================================================================}

function WSAGetServiceClassNameByClassIdA(const lpserviceclassid: PGUID; lpszserviceclassname: PCHAR; var lpdwbufferlength: uint32_t): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSAGetServiceClassNameByClassIdA(lpserviceclassid,lpszserviceclassname,lpdwbufferlength);
end;

{==============================================================================}

function WSAGetServiceClassNameByClassIdW(const lpserviceclassid: PGUID; lpszserviceclassname: PWCHAR; var lpdwbufferlength: uint32_t): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSAGetServiceClassNameByClassIdW(lpserviceclassid,lpszserviceclassname,lpdwbufferlength);
end;

{==============================================================================}

function WSASetServiceA(const lpqsreginfo: LPWSAQuerySetA; const essoperation: TWSAeSetServiceOp; const dwcontrolflags: uint32_t): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSASetServiceA(lpqsreginfo,essoperation,dwcontrolflags);
end;

{==============================================================================}

function WSASetServiceW(const lpqsreginfo: LPWSAQuerySetW; const essoperation: TWSAeSetServiceOp; const dwcontrolflags: uint32_t): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSASetServiceW(lpqsreginfo,essoperation,dwcontrolflags);
end;

{==============================================================================}

function WSAMakeSyncReply(buflen, error: uint16_t): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSAMakeSyncReply(buflen,error);
end;

{==============================================================================}

function WSAMakeSelectReply(event, error: uint16_t): int32_t; stdcall;
begin
 {}
 Result:=Winsock2.WSAMakeSelectReply(event,error);
end;

{==============================================================================}

function WSAGetAsyncBuflen(param: int32_t): uint16_t; stdcall;
begin
 {}
 Result:=Winsock2.WSAGetAsyncBuflen(param);
end;

{==============================================================================}

function WSAGetAsyncError(param: int32_t): uint16_t; stdcall;
begin
 {}
 Result:=Winsock2.WSAGetAsyncError(param);
end;

{==============================================================================}

function WSAGetSelectEvent(param: int32_t): uint16_t; stdcall;
begin
 {}
 Result:=Winsock2.WSAGetSelectEvent(param);
end;

{==============================================================================}

function WSAGetSelectError(param: int32_t): uint16_t; stdcall;
begin
 {}
 Result:=Winsock2.WSAGetSelectError(param);
end;

{==============================================================================}

procedure FD_CLR(socket: TSOCKET; var fdset: TFDSet); stdcall;
begin
 {}
 Winsock2.FD_CLR(socket,fdset);
end;

{==============================================================================}

function FD_ISSET(socket: TSOCKET; var fdset: TFDSet): BOOL; stdcall;
begin
 {}
 Result:=Winsock2.FD_ISSET(socket,fdset);
end;

{==============================================================================}

procedure FD_SET(socket: TSOCKET; var fdset: TFDSet); stdcall;
begin
 {}
 Winsock2.FD_SET(socket,fdset);
end;

{==============================================================================}

procedure FD_ZERO(var fdset: TFDSet); stdcall;
begin
 {}
 Winsock2.FD_ZERO(fdset);
end;

{==============================================================================}
{Winsock2 Undocumented Functions}
function WsControl(proto: uint32_t; action: uint32_t; prequestinfo: PVOID; var pcbrequestinfolen: uint32_t; presponseinfo: PVOID; var pcbresponseinfolen: uint32_t): int; stdcall;
begin
 {}
 Result:=Winsock2.WsControl(proto,action,prequestinfo,pcbrequestinfolen,presponseinfo,pcbresponseinfolen);
end;

{==============================================================================}

function getnetbyaddr(addr: PVOID; len, struct: int): PNetEnt; stdcall;
begin
 {}
 Result:=Winsock2.getnetbyaddr(addr,len,struct);
end;

{==============================================================================}

function getnetbyname(const name: PCHAR): PNetEnt; stdcall;
begin
 {}
 Result:=Winsock2.getnetbyname(name);
end;

{==============================================================================}
{Winsock2 Enhanced Functions}
function WsControlEx(proto: uint32_t; action: uint32_t; prequestinfo: PVOID; var pcbrequestinfolen: uint32_t; presponseinfo: PVOID; var pcbresponseinfolen: uint32_t): int; stdcall;
begin
 {}
 Result:=Winsock2.WsControlEx(proto,action,prequestinfo,pcbrequestinfolen,presponseinfo,pcbresponseinfolen);
end;

{==============================================================================}
{Winsock2 Helper Functions}
function Winsock2RedirectInput(s: TSOCKET): BOOL; stdcall;
{Redirect standard input to the socket specified by s}
{s: The socket to redirect input to (or INVALID_SOCKET to stop redirection)}
{Return: True if completed successfully or False if an error occurred}
{Note: Redirects the input of the text file Input which also
       redirects the input of Read, ReadLn and the standard C library}
begin
 {}
 Result:=Winsock2.Winsock2RedirectInput(s);
end;

{==============================================================================}

function Winsock2RedirectOutput(s: TSOCKET): BOOL; stdcall;
{Redirect standard output to the socket specified by s}
{s: The socket to redirect output to (or INVALID_SOCKET to stop redirection)}
{Return: True if completed successfully or False if an error occurred}
{Note: Redirects the output of the text files Output, ErrOutput, StdOut and StdErr
       which also redirects the output of Write, WriteLn and the standard C library}
begin
 {}
 Result:=Winsock2.Winsock2RedirectOutput(s);
end;

{==============================================================================}

function Winsock2ErrorToString(error: int32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(Winsock2.Winsock2ErrorToString(error),_string,len);
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{Iphlpapi Functions}
{$IFDEF API_EXPORT_IPHLPAPI}
function GetNumberOfInterfaces(var pdwnumif: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.GetNumberOfInterfaces(pdwnumif);
end;

{==============================================================================}

function GetIfEntry(pifrow: PMIB_IFROW): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.GetIfEntry(pifrow);
end;

{==============================================================================}

function GetIfTable(piftable: PMIB_IFTABLE; var pdwsize: uint32_t; border: BOOL): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.GetIfTable(piftable,pdwsize,border);
end;

{==============================================================================}

function GetIpAddrTable(pipaddrtable: PMIB_IPADDRTABLE; var pdwsize: uint32_t; border: BOOL): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.GetIpAddrTable(pipaddrtable,pdwsize,border);
end;

{==============================================================================}

function GetIpNetTable(pipnettable: PMIB_IPNETTABLE; var pdwsize: uint32_t; border: BOOL): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.GetIpNetTable(pipnettable,pdwsize,border);
end;

{==============================================================================}

function GetIpForwardTable(pipforwardtable: PMIB_IPFORWARDTABLE; var pdwsize: uint32_t; border: BOOL): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.GetIpForwardTable(pipforwardtable,pdwsize,border);
end;

{==============================================================================}

function GetTcpTable(ptcptable: PMIB_TCPTABLE; var pdwsize: uint32_t; border: BOOL): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.GetTcpTable(ptcptable,pdwsize,border);
end;

{==============================================================================}

function GetUdpTable(pudptable: PMIB_UDPTABLE; var pdwsize: uint32_t; border: BOOL): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.GetUdpTable(pudptable,pdwsize,border);
end;

{==============================================================================}

function GetIpStatistics(var pstats: MIB_IPSTATS): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.GetIpStatistics(pstats);
end;

{==============================================================================}

function GetIcmpStatistics(var pstats: MIB_ICMP): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.GetIcmpStatistics(pstats);
end;

{==============================================================================}

function GetTcpStatistics(var pstats: MIB_TCPSTATS): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.GetTcpStatistics(pstats);
end;

{==============================================================================}

function GetUdpStatistics(var pstats: MIB_UDPSTATS): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.GetUdpStatistics(pstats);
end;

{==============================================================================}

function SetIfEntry(const pifrow: MIB_IFROW): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.SetIfEntry(pifrow);
end;

{==============================================================================}

function CreateIpForwardEntry(const proute: MIB_IPFORWARDROW): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.CreateIpForwardEntry(proute);
end;

{==============================================================================}

function SetIpForwardEntry(const proute: MIB_IPFORWARDROW): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.SetIpForwardEntry(proute);
end;

{==============================================================================}

function DeleteIpForwardEntry(const proute: MIB_IPFORWARDROW): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.DeleteIpForwardEntry(proute);
end;

{==============================================================================}

function SetIpStatistics(const pipstats: MIB_IPSTATS): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.SetIpStatistics(pipstats);
end;

{==============================================================================}

function SetIpTTL(nttl: UINT): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.SetIpTTL(nttl);
end;

{==============================================================================}

function CreateIpNetEntry(const parpentry: MIB_IPNETROW): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.CreateIpNetEntry(parpentry);
end;

{==============================================================================}

function SetIpNetEntry(const parpentry: MIB_IPNETROW): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.SetIpNetEntry(parpentry);
end;

{==============================================================================}

function DeleteIpNetEntry(const parpentry: MIB_IPNETROW): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.DeleteIpNetEntry(parpentry);
end;

{==============================================================================}

function FlushIpNetTable(dwifindex: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.FlushIpNetTable(dwifindex);
end;

{==============================================================================}

function CreateProxyArpEntry(dwaddress, dwmask, dwifindex: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.CreateProxyArpEntry(dwaddress,dwmask,dwifindex);
end;

{==============================================================================}

function DeleteProxyArpEntry(dwaddress, dwmask, dwifindex: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.DeleteProxyArpEntry(dwaddress,dwmask,dwifindex);
end;

{==============================================================================}

function SetTcpEntry(const ptcprow: MIB_TCPROW): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.SetTcpEntry(ptcprow);
end;

{==============================================================================}

function GetInterfaceInfo(piftable: PIP_INTERFACE_INFO; var dwoutbuflen: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.GetInterfaceInfo(piftable,dwoutbuflen);
end;

{==============================================================================}

function GetUniDirectionalAdapterInfo(pipifinfo: PIP_UNIDIRECTIONAL_ADAPTER_ADDRESS; var dwoutbuflen: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.GetUniDirectionalAdapterInfo(pipifinfo,dwoutbuflen);
end;

{==============================================================================}

function GetBestInterface(dwdestaddr: IPAddr; var pdwbestifindex: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.GetBestInterface(dwdestaddr,pdwbestifindex);
end;

{==============================================================================}

function GetBestRoute(dwdestaddr, dwsourceaddr: uint32_t; pbestroute: PMIB_IPFORWARDROW): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.GetBestRoute(dwdestaddr,dwsourceaddr,pbestroute);
end;

{==============================================================================}

function NotifyAddrChange(var handle: THANDLE; overlapped: POVERLAPPED): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.NotifyAddrChange(handle,overlapped);
end;

{==============================================================================}

function NotifyRouteChange(var handle: THANDLE; overlapped: POVERLAPPED): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.NotifyRouteChange(handle,overlapped);
end;

{==============================================================================}

function GetAdapterIndex(adaptername: LPWSTR; var ifindex: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.GetAdapterIndex(adaptername,ifindex);
end;

{==============================================================================}

function AddIPAddress(address: IPAddr; ipmask: IPMask; ifindex: uint32_t; var ntecontext, nteinstance: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.AddIPAddress(address,ipmask,ifindex,ntecontext,nteinstance);
end;

{==============================================================================}

function DeleteIPAddress(ntecontext: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.DeleteIPAddress(ntecontext);
end;

{==============================================================================}

function GetNetworkParams(pfixedinfo: PFIXED_INFO; var poutbuflen: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.GetNetworkParams(pfixedinfo,poutbuflen);
end;

{==============================================================================}

function GetAdaptersInfo(padapterinfo: PIP_ADAPTER_INFO; var poutbuflen: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.GetAdaptersInfo(padapterinfo,poutbuflen);
end;

{==============================================================================}

function GetPerAdapterInfo(ifindex: uint32_t; pperadapterinfo: PIP_PER_ADAPTER_INFO; var poutbuflen: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.GetPerAdapterInfo(ifindex,pperadapterinfo,poutbuflen);
end;

{==============================================================================}

function IpReleaseAddress(const adapterinfo: IP_ADAPTER_INDEX_MAP): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.IpReleaseAddress(adapterinfo);
end;

{==============================================================================}

function IpRenewAddress(const adapterinfo: IP_ADAPTER_INDEX_MAP): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.IpRenewAddress(adapterinfo);
end;

{==============================================================================}

function SendARP(const destip, srcip: IPAddr; pmacaddr: PDWORD; var phyaddrlen: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.SendARP(destip,srcip,pmacaddr,phyaddrlen);
end;

{==============================================================================}

function GetRTTAndHopCount(destipaddress: IPAddr; var hopcount: uint32_t; maxhops: uint32_t; var rtt: uint32_t): BOOL; stdcall;
begin
 {}
 Result:=Iphlpapi.GetRTTAndHopCount(destipaddress,hopcount,maxhops,rtt);
end;

{==============================================================================}

function GetFriendlyIfIndex(ifindex: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.GetFriendlyIfIndex(ifindex);
end;

{==============================================================================}

function EnableRouter(var phandle: THANDLE; poverlapped: POVERLAPPED): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.EnableRouter(phandle,poverlapped);
end;

{==============================================================================}

function UnenableRouter(poverlapped: POVERLAPPED; lpdwenablecount: LPDWORD): uint32_t; stdcall;
begin
 {}
 Result:=Iphlpapi.UnenableRouter(poverlapped,lpdwenablecount);
end;

{==============================================================================}
{IP Helper Helper Functions}
function MIBIFOperStatusToString(value: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(Iphlpapi.MIBIFOperStatusToString(value),_string,len);
end;

{==============================================================================}

function MIBIFTypeToString(value: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(Iphlpapi.MIBIFTypeToString(value),_string,len);
end;

{==============================================================================}

function MIBIFAdminStatusToString(value: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(Iphlpapi.MIBIFAdminStatusToString(value),_string,len);
end;

{==============================================================================}

function MIBTCPRTOToString(value: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(Iphlpapi.MIBTCPRTOToString(value),_string,len);
end;

{==============================================================================}

function MIBTCPStateToString(value: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(Iphlpapi.MIBTCPStateToString(value),_string,len);
end;

{==============================================================================}

function MIBIPForwardingToString(value: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(Iphlpapi.MIBIPForwardingToString(value),_string,len);
end;

{==============================================================================}

function MIBIPRouteTypeToString(value: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(Iphlpapi.MIBIPRouteTypeToString(value),_string,len);
end;

{==============================================================================}

function MIBIPProtoToString(value: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(Iphlpapi.MIBIPProtoToString(value),_string,len);
end;

{==============================================================================}

function MIBIPNetTypeToString(value: uint32_t; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(Iphlpapi.MIBIPNetTypeToString(value),_string,len);
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}
{Ultibo Functions}
{$IFDEF API_EXPORT_ULTIBO}
{General Functions (Compatibility)}
function GetVersion: uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.GetVersion;
end;

{==============================================================================}

function GetVersionEx(lpversioninformation: LPOSVERSIONINFOA): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.GetVersionEx(lpversioninformation);
end;

{==============================================================================}

function GetVersionExA(lpversioninformation: LPOSVERSIONINFOA): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.GetVersionExA(lpversioninformation);
end;

{==============================================================================}

function GetVersionExW(lpversioninformation: LPOSVERSIONINFOW): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.GetVersionExW(lpversioninformation);
end;

{==============================================================================}

procedure GetSystemInfo(var lpsysteminfo: SYSTEM_INFO); stdcall;
begin
 {}
 Ultibo.GetSystemInfo(lpsysteminfo);
end;

{==============================================================================}

procedure GetNativeSystemInfo(lpsysteminfo: LPSYSTEM_INFO); stdcall;
begin
 {}
 Ultibo.GetNativeSystemInfo(lpsysteminfo);
end;

{==============================================================================}

function GetLargePageMinimum: SIZE_T; stdcall;
begin
 {}
 Result:=Ultibo.GetLargePageMinimum;
end;

{==============================================================================}

function GetComputerName(lpbuffer: LPSTR; var nsize: uint32_t): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.GetComputerName(lpbuffer,nsize);
end;

{==============================================================================}

function GetComputerNameA(lpbuffer: LPSTR; var nsize: uint32_t): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.GetComputerNameA(lpbuffer,nsize);
end;

{==============================================================================}

function GetComputerNameW(lpbuffer: LPWSTR; var nsize: uint32_t): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.GetComputerNameW(lpbuffer,nsize);
end;

{==============================================================================}

function SetComputerName(const lpcomputername: LPCSTR): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.SetComputerName(lpcomputername);
end;

{==============================================================================}

function SetComputerNameA(const lpcomputername: LPCSTR): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.SetComputerNameA(lpcomputername);
end;

{==============================================================================}

function SetComputerNameW(const lpcomputername: LPCWSTR): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.SetComputerNameW(lpcomputername);
end;

{==============================================================================}

function GetComputerNameEx(nametype: COMPUTER_NAME_FORMAT; lpbuffer: LPSTR; var nsize: uint32_t): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.GetComputerNameEx(nametype,lpbuffer,nsize);
end;

{==============================================================================}

function GetComputerNameExA(nametype: COMPUTER_NAME_FORMAT; lpbuffer: LPSTR; var nsize: uint32_t): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.GetComputerNameExA(nametype,lpbuffer,nsize);
end;

{==============================================================================}

function GetComputerNameExW(nametype: COMPUTER_NAME_FORMAT; lpbuffer: LPWSTR; var nsize: uint32_t): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.GetComputerNameExW(nametype,lpbuffer,nsize);
end;

{==============================================================================}

function SetComputerNameEx(nametype: COMPUTER_NAME_FORMAT; const lpbuffer: LPCSTR): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.SetComputerNameEx(nametype,lpbuffer);
end;

{==============================================================================}

function SetComputerNameExA(nametype: COMPUTER_NAME_FORMAT; const lpbuffer: LPCSTR): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.SetComputerNameExA(nametype,lpbuffer);
end;

{==============================================================================}

function SetComputerNameExW(nametype: COMPUTER_NAME_FORMAT; const lpbuffer: LPCWSTR): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.SetComputerNameExW(nametype,lpbuffer);
end;

{==============================================================================}

function ExitUltibo(dwreserved: uint32_t; ureserved: UINT): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.ExitUltibo(dwreserved,ureserved);
end;

{==============================================================================}

function ExitUltiboEx(uflags: UINT; dwreserved: uint32_t): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.ExitUltiboEx(uflags,dwreserved);
end;

{==============================================================================}
{General Functions (Ultibo)}
function RestartComputer(delay: uint32_t): BOOL; stdcall;
{Delay: Milliseconds to delay before restart}
begin
 {}
 Result:=Ultibo.RestartComputer(delay);
end;

{==============================================================================}

function ShutdownComputer(delay: uint32_t): BOOL; stdcall;
{Delay: Milliseconds to delay before shutdown}
begin
 {}
 Result:=Ultibo.ShutdownComputer(delay);
end;

{==============================================================================}

function Uptime: FILETIME; stdcall;
{Get the current system up time as a FileTime value}
begin
 {}
 Result:=Ultibo.Uptime;
end;

{==============================================================================}
{Time Functions (Compatibility)}
function GetTickCount: uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.GetTickCount;
end;

{==============================================================================}

function GetTickCount64: ULONGLONG; stdcall;
begin
 {}
 Result:=Ultibo.GetTickCount64;
end;

{==============================================================================}

procedure GetSystemTime(var lpsystemtime: SYSTEMTIME); stdcall;
{Get the current system time in UTC}
begin
 {}
 Ultibo.GetSystemTime(lpsystemtime);
end;

{==============================================================================}

procedure GetSystemTimeAsFileTime(var lpsystemtimeasfiletime: FILETIME); stdcall;
{Get the current system time in UTC as a FileTime value}
begin
 {}
 Ultibo.GetSystemTimeAsFileTime(lpsystemtimeasfiletime);
end;

{==============================================================================}

function SetSystemTime(var lpsystemtime: SYSTEMTIME): BOOL; stdcall;
{Set the current system time in UTC}
begin
 {}
 Result:=Ultibo.SetSystemTime(lpsystemtime);
end;

{==============================================================================}

procedure GetLocalTime(var lpsystemtime: SYSTEMTIME); stdcall;
{Get the current local time}
begin
 {}
 Ultibo.GetLocalTime(lpsystemtime);
end;

{==============================================================================}

function SetLocalTime(var lpsystemtime: SYSTEMTIME): BOOL; stdcall;
{Set the current local time}
begin
 {}
 Result:=Ultibo.SetLocalTime(lpsystemtime);
end;

{==============================================================================}

function SystemTimeToTzSpecificLocalTime(lptimezoneinformation: LPTIME_ZONE_INFORMATION; var lpuniversaltime, lplocaltime: SYSTEMTIME): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.SystemTimeToTzSpecificLocalTime(lptimezoneinformation,lpuniversaltime,lplocaltime);
end;

{==============================================================================}

function TzSpecificLocalTimeToSystemTime(lptimezoneinformation: LPTIME_ZONE_INFORMATION; const lplocaltime: SYSTEMTIME; var lpuniversaltime: SYSTEMTIME): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.TzSpecificLocalTimeToSystemTime(lptimezoneinformation,lplocaltime,lpuniversaltime);
end;

{==============================================================================}

function GetTimeZoneInformation(var lptimezoneinformation: TIME_ZONE_INFORMATION): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.GetTimeZoneInformation(lptimezoneinformation);
end;

{==============================================================================}

function SetTimeZoneInformation(const lptimezoneinformation: TIME_ZONE_INFORMATION): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.SetTimeZoneInformation(lptimezoneinformation);
end;

{==============================================================================}

function SystemTimeToFileTime(const lpsystemtime: SYSTEMTIME; var lpfiletime: FILETIME): BOOL; stdcall;
{Convert a SystemTime value to a FileTime value}
{Note: lpSystemTime is assumed to be UTC / lpFileTime is returned as UTC}
begin
 {}
 Result:=Ultibo.SystemTimeToFileTime(lpsystemtime,lpfiletime);
end;

{==============================================================================}

function FileTimeToSystemTime(const lpfiletime: FILETIME; var lpsystemtime: SYSTEMTIME): BOOL; stdcall;
{Convert a FileTime value to a SystemTime value}
{Note: lpFileTime is assumed to be UTC / lpSystemTime is returned as UTC}
{Note: If lpFileTime is less than 30/12/1899 then SystemTime will be zero}
begin
 {}
 Result:=Ultibo.FileTimeToSystemTime(lpfiletime,lpsystemtime);
end;

{==============================================================================}

function FileTimeToLocalFileTime(const lpfiletime: FILETIME; var lplocalfiletime: FILETIME): BOOL; stdcall;
{Convert a FileTime in UTC to a FileTime in Local time}
{Note: TIMEZONE_TIME_OFFSET is the number of minutes offset from UTC}
begin
 {}
 Result:=Ultibo.FileTimeToLocalFileTime(lpfiletime,lplocalfiletime);
end;

{==============================================================================}

function LocalFileTimeToFileTime(const lplocalfiletime: FILETIME; var lpfiletime: FILETIME): BOOL; stdcall;
{Convert a FileTime in Local time to a FileTime in UTC}
{Note: TIMEZONE_TIME_OFFSET is the number of minutes offset from UTC}
begin
 {}
 Result:=Ultibo.LocalFileTimeToFileTime(lplocalfiletime,lpfiletime);
end;

{==============================================================================}

function CompareFileTime(const lpfiletime1, lpfiletime2: FILETIME): LONG; stdcall;
begin
 {}
 Result:=Ultibo.CompareFileTime(lpfiletime1,lpfiletime2);
end;

{==============================================================================}

function FileTimeToDosDateTime(const lpfiletime: FILETIME; var lpfatdate, lpfattime: uint16_t): BOOL; stdcall;
{Convert a FileTime value to a DOS date and time value}
{Note: FileTime is assumed to be Local / DOS date and time is returned as Local}
{Note: If FileTime is less than 1/1/1980 then DOS date and time will be 1/1/1980}
begin
 {}
 Result:=Ultibo.FileTimeToDosDateTime(lpfiletime,lpfatdate,lpfattime);
end;

{==============================================================================}

function DosDateTimeToFileTime(wfatdate, wfattime: uint16_t; var lpfiletime: FILETIME): BOOL; stdcall;
{Convert a DOS date and time value to a FileTime value}
{Note: DOS date and time is assumed to be Local / FileTime is returned as Local}
{Note: If DOS date and time is less than 1/1/1980 then FileTime will be 1/1/1980}
begin
 {}
 Result:=Ultibo.DosDateTimeToFileTime(wfatdate,wfattime,lpfiletime);
end;

{==============================================================================}

function QueryPerformanceCounter(var lpPerformanceCount: LARGE_INTEGER): BOOL; stdcall;
{Retrieves the current value of the performance counter, which is a high
 resolution (<1us) time stamp that can be used for time-interval measurements}
begin
 {}
 Result:=Ultibo.QueryPerformanceCounter(lpPerformanceCount);
end;

{==============================================================================}

function QueryPerformanceFrequency(var lpFrequency: LARGE_INTEGER): BOOL; stdcall;
{Retrieves the frequency of the performance counter.
 The frequency of the performance counter is fixed at system boot and is
 consistent across all processors. Therefore, the frequency need only be
 queried upon application initialization, and the result can be cached}
begin
 {}
 Result:=Ultibo.QueryPerformanceFrequency(lpFrequency);
end;

{==============================================================================}
{Time Functions (Ultibo)}
function GetCurrentTime: FILETIME; stdcall;
{Get the current system time in UTC as a FileTime value}
begin
 {}
 Result:=Ultibo.GetCurrentTime;
end;

{==============================================================================}

procedure SetCurrentTime(const time: FILETIME); stdcall;
{Set the current system time in UTC from a FileTime value}
begin
 {}
 Ultibo.SetCurrentTime(time);
end;

{==============================================================================}

function GetTimeAdjust: int32_t; stdcall;
{Gets the time adjustment used internally}
begin
 {}
 Result:=Ultibo.GetTimeAdjust;
end;

{==============================================================================}

procedure SetTimeAdjust(adjust: int32_t); stdcall;
{Sets the time adjustment used internally}
begin
 {}
 Ultibo.SetTimeAdjust(adjust);
end;

{==============================================================================}

function GetCurrentTimezone(name: PCHAR; len: uint32_t): uint32_t; stdcall;
{Get the name of the current Timezone}
begin
 {}
 Result:=APIStringToPCharBuffer(Ultibo.GetCurrentTimezone,name,len);
end;

{==============================================================================}

function SetCurrentTimezone(const name: PCHAR): BOOL; stdcall;
{Set the current Timezone by name}
begin
 {}
 Result:=Ultibo.SetCurrentTimezone(String(name));
end;

{==============================================================================}

function GetTimezoneActiveOffset: int32_t; stdcall;
{Gets the Active Offset from the current Timezone}
begin
 {}
 Result:=Ultibo.GetTimezoneActiveOffset;
end;

{==============================================================================}

function GetTimezoneStandardOffset: int32_t; stdcall;
{Gets the Standard Offset from the current Timezone}
begin
 {}
 Result:=Ultibo.GetTimezoneStandardOffset;
end;

{==============================================================================}

procedure SetTimezoneStandardOffset(offset: int32_t); stdcall;
{Sets the Standard Offset for the current Timezone}
begin
 {}
 Ultibo.SetTimezoneStandardOffset(offset);
end;

{==============================================================================}

function GetTimezoneDaylightOffset: int32_t; stdcall;
{Gets the Daylight Offset from the current Timezone}
begin
 {}
 Result:=Ultibo.GetTimezoneDaylightOffset;
end;

{==============================================================================}

procedure SetTimezoneDaylightOffset(offset: int32_t); stdcall;
{Sets the Daylight Offset for the current Timezone}
begin
 {}
 Ultibo.SetTimezoneDaylightOffset(offset);
end;

{==============================================================================}

function GetTimezoneStandardStart(description: PCHAR; len: uint32_t): uint32_t; stdcall;
{Get the description of the standard time start for the current Timezone}
begin
 {}
 Result:=APIStringToPCharBuffer(Ultibo.GetTimezoneStandardStart,description,len);
end;

{==============================================================================}

function GetTimezoneDaylightStart(description: PCHAR; len: uint32_t): uint32_t; stdcall;
{Get the description of the daylight time start for the current Timezone}
begin
 {}
 Result:=APIStringToPCharBuffer(Ultibo.GetTimezoneDaylightStart,description,len);
end;

{==============================================================================}

function GetTimezoneStandardDate: double_t; stdcall;
{Get the next date of the standard time start for the current Timezone}
begin
 {}
 Result:=Ultibo.GetTimezoneStandardDate;
end;

{==============================================================================}

function GetTimezoneDaylightDate: double_t; stdcall;
{Get the next date of the daylight time start for the current Timezone}
begin
 {}
 Result:=Ultibo.GetTimezoneDaylightDate;
end;

{==============================================================================}

function FileTimeToDateTime(const filetime: FILETIME): double_t; stdcall;
{Convert a FileTime value to a DateTime value}
{Note: FileTime is assumed to be UTC / DateTime is returned as Local}
{Note: If FileTime is less than 30/12/1899 then Result will be zero}
begin
 {}
 Result:=Ultibo.FileTimeToDateTime(filetime);
end;

{==============================================================================}

function DateTimeToFileTime(datetime: double_t): FILETIME; stdcall;
{Convert a DateTime value to a FileTime value}
{Note: DateTime is assumed to be Local / FileTime is returned as UTC}
begin
 {}
 Result:=Ultibo.DateTimeToFileTime(datetime);
end;

{==============================================================================}

function LocalFileTimeToDateTime(const filetime: FILETIME): double_t; stdcall;
{Convert a FileTime value to a DateTime value}
{Note: FileTime is assumed to be Local / DateTime is returned as Local}
{Note: If FileTime is less than 30/12/1899 then Result will be zero}
begin
 {}
 Result:=Ultibo.LocalFileTimeToDateTime(filetime);
end;

{==============================================================================}

function DateTimeToLocalFileTime(datetime: double_t): FILETIME; stdcall;
{Convert a DateTime value to a FileTime value}
{Note: DateTime is assumed to be Local / FileTime is returned as Local}
begin
 {}
 Result:=Ultibo.DateTimeToLocalFileTime(datetime);
end;

{==============================================================================}

function SystemFileTimeToDateTime(const filetime: FILETIME): double_t; stdcall;
{Convert a FileTime value to a DateTime value}
{Note: FileTime is assumed to be UTC / DateTime is returned as UTC}
{Note: If FileTime is less than 30/12/1899 then Result will be zero}
{Note: Same as LocalFileTimeToDateTime but renamed for clarity}
begin
 {}
 Result:=Ultibo.SystemFileTimeToDateTime(filetime);
end;

{==============================================================================}

function DateTimeToSystemFileTime(datetime: double_t): FILETIME; stdcall;
{Convert a DateTime value to a FileTime value}
{Note: DateTime is assumed to be UTC / FileTime is returned as UTC}
{Note: Same as DateTimeToLocalFileTime but renamed for clarity}
begin
 {}
 Result:=Ultibo.DateTimeToSystemFileTime(datetime);
end;

{==============================================================================}

function FileTimeToUnixTime(const filetime: FILETIME): time_t; stdcall;
{Convert a FileTime value to a Unix/Linux time value}
{Note: FileTime is assumed to be Local / UnixTime is returned as Local}
{Note: If FileTime is less than 1/1/1970 then Result will be zero}
begin
 {}
 Result:=Ultibo.FileTimeToUnixTime(filetime);
end;

{==============================================================================}

function UnixTimeToFileTime(unixtime: time_t): FILETIME; stdcall;
{Convert a Unix/Linux time value to a FileTime value}
{Note: UnixTime is assumed to be Local / FileTime is returned as Local}
begin
 {}
 Result:=Ultibo.UnixTimeToFileTime(unixtime);
end;

{==============================================================================}

function UnixTimeToDateTime(unixtime: time_t): double_t; stdcall;
{Convert a Unix/Linux time value to a DateTime value}
{Note: UnixTime is assumed to be Local / DateTime is returned as Local}
begin
 {}
 Result:=Ultibo.UnixTimeToDateTime(unixtime);
end;

{==============================================================================}

function DateTimeToUnixTime(datetime: double_t): time_t; stdcall;
{Convert a DateTime value to a Unix/Linux time value}
{Note: DateTime is assumed to be Local / UnixTime is returned as Local}
{Note: If DateTime is less than 1/1/1970 then Result will be zero}
begin
 {}
 Result:=Ultibo.DateTimeToUnixTime(datetime);
end;

{==============================================================================}

function FileTimeToFileDate(const filetime: FILETIME): int; stdcall;
{Convert a FileTime value to a DOS date value}
{Note: FileTime is assumed to be UTC / FileDate is returned as Local}
{Note: If FileTime is less than 1/1/1980 then Result will be zero}
begin
 {}
 Result:=Ultibo.FileTimeToFileDate(filetime);
end;

{==============================================================================}

function FileDateToFileTime(filedate: int): FILETIME; stdcall;
{Convert a DOS date value to a FileTime value}
{Note: FileDate is assumed to be Local / FileTime is returned as UTC}
{Note: If FileDate is less than 1/1/1980 then Result will be zero}
begin
 {}
 Result:=Ultibo.FileDateToFileTime(filedate);
end;

{==============================================================================}

function FileTimeToAdjustedTime(const filetime: FILETIME): FILETIME; stdcall;
{Convert a local FileTime value to a DST adjusted FileTime value}
{Note: TIMEZONE_TIME_ADJUST is the number of minutes difference from TIMEZONE_TIME_OFFSET}
begin
 {}
 Result:=Ultibo.FileTimeToAdjustedTime(filetime);
end;

{==============================================================================}

function AdjustedTimeToFileTime(const filetime: FILETIME): FILETIME; stdcall;
{Convert a DST adjusted FileTime value to a local FileTime value}
{Note: TIMEZONE_TIME_ADJUST is the number of minutes difference from TIMEZONE_TIME_OFFSET}
begin
 {}
 Result:=Ultibo.AdjustedTimeToFileTime(filetime);
end;

{==============================================================================}

function RoundFileTime(const filetime: FILETIME): FILETIME; stdcall;
{Round FileTime to nearest 2 seconds for compatibility with FileDate}
begin
 {}
 Result:=Ultibo.RoundFileTime(filetime);
end;

{==============================================================================}

function ConvertFileTime(const filetime: FILETIME; offset: int; local: BOOL): FILETIME; stdcall;
{Convert a FileTime value to a specified offset (Local or UTC)}
{Note: Offset is the number of minutes to adjust in conversion}
{      Local indicates whether the source time is Local or UTC}
begin
 {}
 Result:=Ultibo.ConvertFileTime(filetime,offset,local);
end;

{==============================================================================}

function ConvertDateTime(datetime: double_t; offset: int; local: BOOL): double_t; stdcall;
{Convert a DateTime value to a specified offset (Local or UTC)}
{Note: Offset is the number of minutes to adjust in conversion}
{      Local indicates whether the source time is Local or UTC}
begin
 {}
 Result:=Ultibo.ConvertDateTime(datetime,offset,local);
end;

{==============================================================================}
{Drive Functions (Compatibility)}
function GetDiskType(const lprootpathname: LPCSTR): UINT; stdcall;
begin
 {}
 Result:=Ultibo.GetDiskType(lprootpathname);
end;

{==============================================================================}

function GetDriveTypeA(const lprootpathname: LPCSTR): UINT; stdcall;
begin
 {}
 Result:=Ultibo.GetDriveTypeA(lprootpathname);
end;

{==============================================================================}

function GetDriveTypeW(const lprootpathname: LPCWSTR): UINT; stdcall;
begin
 {}
 Result:=Ultibo.GetDriveTypeW(lprootpathname);
end;

{==============================================================================}

function GetLogicalDrives: uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.GetLogicalDrives;
end;

{==============================================================================}

function GetLogicalDriveStrings(nbufferlength: uint32_t; lpbuffer: LPSTR): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.GetLogicalDriveStrings(nbufferlength,lpbuffer);
end;

{==============================================================================}

function GetLogicalDriveStringsA(nbufferlength: uint32_t; lpbuffer: LPSTR): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.GetLogicalDriveStringsA(nbufferlength,lpbuffer);
end;

{==============================================================================}

function GetLogicalDriveStringsW(nbufferlength: uint32_t; lpbuffer: LPWSTR): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.GetLogicalDriveStringsW(nbufferlength,lpbuffer);
end;

{==============================================================================}

function DefineDosDevice(dwflags: uint32_t; const lpdevicename, lptargetpath: LPCSTR): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.DefineDosDevice(dwflags,lpdevicename,lptargetpath);
end;

{==============================================================================}

function DefineDosDeviceA(dwflags: uint32_t; const lpdevicename, lptargetpath: LPCSTR): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.DefineDosDeviceA(dwflags,lpdevicename,lptargetpath);
end;

{==============================================================================}

function DefineDosDeviceW(dwflags: uint32_t; const lpdevicename, lptargetpath: LPCWSTR): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.DefineDosDeviceW(dwflags,lpdevicename,lptargetpath);
end;

{==============================================================================}

function QueryDosDevice(const lpdevicename: LPCSTR; lptargetpath: LPSTR; ucchmax: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.QueryDosDevice(lpdevicename,lptargetpath,ucchmax);
end;

{==============================================================================}

function QueryDosDeviceA(const lpdevicename: LPCSTR; lptargetpath: LPSTR; ucchmax: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.QueryDosDeviceA(lpdevicename,lptargetpath,ucchmax);
end;

{==============================================================================}

function QueryDosDeviceW(const lpdevicename: LPCWSTR; lptargetpath: LPWSTR; ucchmax: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.QueryDosDeviceW(lpdevicename,lptargetpath,ucchmax);
end;

{==============================================================================}

function SetVolumeLabel(const lprootpathname, lpvolumename: LPCSTR): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.SetVolumeLabel(lprootpathname,lpvolumename);
end;

{==============================================================================}

function SetVolumeLabelA(const lprootpathname, lpvolumename: LPCSTR): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.SetVolumeLabelA(lprootpathname,lpvolumename);
end;

{==============================================================================}

function SetVolumeLabelW(const lprootpathname, lpvolumename: LPCWSTR): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.SetVolumeLabelW(lprootpathname,lpvolumename);
end;

{==============================================================================}

function GetVolumeInformation(const lprootpathname: LPCSTR; lpvolumenamebuffer: LPSTR; nvolumenamesize: uint32_t; lpvolumeserialnumber: LPDWORD; var lpmaximumcomponentlength, lpfilesystemflags: uint32_t; lpfilesystemnamebuffer: LPSTR; nfilesystemnamesize: uint32_t): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.GetVolumeInformation(lprootpathname,lpvolumenamebuffer,nvolumenamesize,lpvolumeserialnumber,lpmaximumcomponentlength,lpfilesystemflags,lpfilesystemnamebuffer,nfilesystemnamesize);
end;

{==============================================================================}

function GetVolumeInformationA(const lprootpathname: LPCSTR; lpvolumenamebuffer: LPSTR; nvolumenamesize: uint32_t; lpvolumeserialnumber: LPDWORD; var lpmaximumcomponentlength, lpfilesystemflags: uint32_t; lpfilesystemnamebuffer: LPSTR; nfilesystemnamesize: uint32_t): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.GetVolumeInformationA(lprootpathname,lpvolumenamebuffer,nvolumenamesize,lpvolumeserialnumber,lpmaximumcomponentlength,lpfilesystemflags,lpfilesystemnamebuffer,nfilesystemnamesize);
end;

{==============================================================================}

function GetVolumeInformationW(const lprootpathname: LPCWSTR; lpvolumenamebuffer: LPWSTR; nvolumenamesize: uint32_t; lpvolumeserialnumber: LPDWORD; var lpmaximumcomponentlength, lpfilesystemflags: uint32_t; lpfilesystemnamebuffer: LPWSTR; nfilesystemnamesize: uint32_t): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.GetVolumeInformationW(lprootpathname,lpvolumenamebuffer,nvolumenamesize,lpvolumeserialnumber,lpmaximumcomponentlength,lpfilesystemflags,lpfilesystemnamebuffer,nfilesystemnamesize);
end;

{==============================================================================}

function GetDiskFreeSpace(const lprootpathname: LPCSTR; var lpsectorspercluster, lpbytespersector, lpnumberoffreeclusters, lptotalnumberofclusters: uint32_t): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.GetDiskFreeSpace(lprootpathname,lpsectorspercluster,lpbytespersector,lpnumberoffreeclusters,lptotalnumberofclusters);
end;

{==============================================================================}

function GetDiskFreeSpaceA(const lprootpathname: LPCSTR; var lpsectorspercluster, lpbytespersector, lpnumberoffreeclusters, lptotalnumberofclusters: uint32_t): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.GetDiskFreeSpaceA(lprootpathname,lpsectorspercluster,lpbytespersector,lpnumberoffreeclusters,lptotalnumberofclusters);
end;

{==============================================================================}

function GetDiskFreeSpaceW(const lprootpathname: LPCWSTR; var lpsectorspercluster, lpbytespersector, lpnumberoffreeclusters, lptotalnumberofclusters: uint32_t): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.GetDiskFreeSpaceW(lprootpathname,lpsectorspercluster,lpbytespersector,lpnumberoffreeclusters,lptotalnumberofclusters);
end;

{==============================================================================}

function GetDiskFreeSpaceEx(const lpdirectoryname: LPCSTR; var lpfreebytesavailabletocaller, lptotalnumberofbytes: ULARGE_INTEGER; lptotalnumberoffreebytes: PULARGE_INTEGER): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.GetDiskFreeSpaceEx(lpdirectoryname,lpfreebytesavailabletocaller,lptotalnumberofbytes,lptotalnumberoffreebytes);
end;

{==============================================================================}

function GetDiskFreeSpaceExA(const lpdirectoryname: LPCSTR; var lpfreebytesavailabletocaller, lptotalnumberofbytes: ULARGE_INTEGER; lptotalnumberoffreebytes: PULARGE_INTEGER): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.GetDiskFreeSpaceExA(lpdirectoryname,lpfreebytesavailabletocaller,lptotalnumberofbytes,lptotalnumberoffreebytes);
end;

{==============================================================================}

function GetDiskFreeSpaceExW(const lpdirectoryname: LPCWSTR; var lpfreebytesavailabletocaller, lptotalnumberofbytes: ULARGE_INTEGER; lptotalnumberoffreebytes: PULARGE_INTEGER): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.GetDiskFreeSpaceExW(lpdirectoryname,lpfreebytesavailabletocaller,lptotalnumberofbytes,lptotalnumberoffreebytes);
end;

{==============================================================================}
{Drive Functions (Ultibo)}
function GetPathDrive(const path: PCHAR): uint8_t; stdcall;
begin
 {}
 Result:=Ultibo.GetPathDrive(String(path));
end;

{==============================================================================}

function GetDriveType(drive: uint8_t): TDRIVE_TYPE; stdcall;
begin
 {}
 Result:=Ultibo.GetDriveType(drive);
end;

{==============================================================================}

procedure GetDriveData(drive: uint8_t; var data: TDRIVE_DATA); stdcall;
begin
 {}
 data:=Ultibo.GetDriveData(drive);
end;

{==============================================================================}

function GetDriveAttr(drive: uint8_t): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.GetDriveAttr(drive);
end;

{==============================================================================}

function GetDriveLabel(drive: uint8_t; _label: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(Ultibo.GetDriveLabel(drive),_label,len);
end;

{==============================================================================}

function SetDriveLabel(drive: uint8_t; const _label: PCHAR): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.SetDriveLabel(drive,String(_label));
end;

{==============================================================================}

function GetDriveSerial(drive: uint8_t): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.GetDriveSerial(drive);
end;

{==============================================================================}

function SetDriveSerial(drive: uint8_t; serial: uint32_t): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.SetDriveSerial(drive,serial);
end;

{==============================================================================}

function IsDriveValid(drive: uint8_t): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.IsDriveValid(drive);
end;

{==============================================================================}

function GetValidDrives: uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.GetValidDrives;
end;

{==============================================================================}

function GetValidDriveNames(names: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(Ultibo.GetValidDriveNames,names,len);
end;

{==============================================================================}

function GetDriveFreeSpace(drive: uint8_t): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.GetDriveFreeSpace(drive);
end;

{==============================================================================}

function GetDriveFreeSpaceEx(drive: uint8_t): int64_t; stdcall;
begin
 {}
 Result:=Ultibo.GetDriveFreeSpaceEx(drive);
end;

{==============================================================================}

function GetDriveTotalSpace(drive: uint8_t): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.GetDriveTotalSpace(drive);
end;

{==============================================================================}

function GetDriveTotalSpaceEx(drive: uint8_t): int64_t; stdcall;
begin
 {}
 Result:=Ultibo.GetDriveTotalSpaceEx(drive);
end;

{==============================================================================}

function GetDriveInformation(const path: PCHAR; var clustersize: uint32_t; var totalclustercount, freeclustercount: int64_t): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.GetDriveInformation(String(path),clustersize,totalclustercount,freeclustercount);
end;

{==============================================================================}

function GetCurrentDrive: uint8_t; stdcall;
begin
 {}
 Result:=Ultibo.GetCurrentDrive;
end;

{==============================================================================}

function SetCurrentDrive(const drive: PCHAR): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.SetCurrentDrive(String(drive));
end;

{==============================================================================}
{File Functions (Compatibility)}
function AreFileApisANSI: BOOL; stdcall;
begin
 {}
 Result:=Ultibo.AreFileApisANSI;
end;

{==============================================================================}

procedure SetFileApisToOEM; stdcall;
begin
 {}
 Ultibo.SetFileApisToOEM;
end;

{==============================================================================}

procedure SetFileApisToANSI; stdcall;
begin
 {}
 Ultibo.SetFileApisToANSI;
end;

{==============================================================================}

function CreateFile(const lpfilename: LPCSTR; dwdesiredaccess, dwsharemode: uint32_t; lpsecurityattributes: LPSECURITY_ATTRIBUTES; dwcreationdisposition: uint32_t; dwflagsandattributes: uint32_t; htemplatefile: HANDLE): HANDLE; stdcall;
begin
 {}
 Result:=Ultibo.CreateFile(lpfilename,dwdesiredaccess,dwsharemode,lpsecurityattributes,dwcreationdisposition,dwflagsandattributes,htemplatefile);
end;

{==============================================================================}

function CreateFileA(const lpfilename: LPCSTR; dwdesiredaccess, dwsharemode: uint32_t; lpsecurityattributes: LPSECURITY_ATTRIBUTES; dwcreationdisposition: uint32_t; dwflagsandattributes: uint32_t; htemplatefile: HANDLE): HANDLE; stdcall;
{Note: lpSecurityAttributes and hTemplateFile are currently ignored by Ultibo}
begin
 {}
 Result:=Ultibo.CreateFileA(lpfilename,dwdesiredaccess,dwsharemode,lpsecurityattributes,dwcreationdisposition,dwflagsandattributes,htemplatefile);
end;

{==============================================================================}

function CreateFileW(const lpfilename: LPCWSTR; dwdesiredaccess, dwsharemode: uint32_t; lpsecurityattributes: LPSECURITY_ATTRIBUTES; dwcreationdisposition: uint32_t; dwflagsandattributes: uint32_t; htemplatefile: HANDLE): HANDLE; stdcall;
{Note: lpSecurityAttributes and hTemplateFile are currently ignored by Ultibo}
begin
 {}
 Result:=Ultibo.CreateFileW(lpfilename,dwdesiredaccess,dwsharemode,lpsecurityattributes,dwcreationdisposition,dwflagsandattributes,htemplatefile);
end;

{==============================================================================}

function SetFileAttributes(const lpfilename: LPCSTR; dwfileattributes: uint32_t): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.SetFileAttributes(lpfilename,dwfileattributes);
end;

{==============================================================================}

function SetFileAttributesA(const lpfilename: LPCSTR; dwfileattributes: uint32_t): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.SetFileAttributesA(lpfilename,dwfileattributes);
end;

{==============================================================================}

function SetFileAttributesW(const lpfilename: LPCWSTR; dwfileattributes: uint32_t): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.SetFileAttributesW(lpfilename,dwfileattributes);
end;

{==============================================================================}

function GetFileAttributes(const lpfilename: LPCSTR): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.GetFileAttributes(lpfilename);
end;

{==============================================================================}

function GetFileAttributesA(const lpfilename: LPCSTR): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.GetFileAttributesA(lpfilename);
end;

{==============================================================================}

function GetFileAttributesW(const lpfilename: LPCWSTR): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.GetFileAttributesW(lpfilename);
end;

{==============================================================================}

function DeleteFile(const lpfilename: LPCSTR): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.DeleteFile(lpfilename);
end;

{==============================================================================}

function DeleteFileA(const lpfilename: LPCSTR): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.DeleteFileA(lpfilename);
end;

{==============================================================================}

function DeleteFileW(const lpfilename: LPCWSTR): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.DeleteFileW(lpfilename);
end;

{==============================================================================}

function MoveFile(const lpexistingfilename, lpnewfilename: LPCSTR): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.MoveFile(lpexistingfilename,lpnewfilename);
end;

{==============================================================================}

function MoveFileA(const lpexistingfilename, lpnewfilename: LPCSTR): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.MoveFileA(lpexistingfilename,lpnewfilename);
end;

{==============================================================================}

function MoveFileW(const lpexistingfilename, lpnewfilename: LPCWSTR): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.MoveFileW(lpexistingfilename,lpnewfilename);
end;

{==============================================================================}

function FindFirstFile(const lpfilename: LPCSTR; var lpfindfiledata: WIN32_FIND_DATAA): HANDLE; stdcall;
begin
 {}
 Result:=Ultibo.FindFirstFile(lpfilename,lpfindfiledata);
end;

{==============================================================================}

function FindFirstFileA(const lpfilename: LPCSTR; var lpfindfiledata: WIN32_FIND_DATAA): HANDLE; stdcall;
begin
 {}
 Result:=Ultibo.FindFirstFileA(lpfilename,lpfindfiledata);
end;

{==============================================================================}

function FindFirstFileW(const lpfilename: LPCWSTR; var lpfindfiledata: WIN32_FIND_DATAW): HANDLE; stdcall;
begin
 {}
 Result:=Ultibo.FindFirstFileW(lpfilename,lpfindfiledata);
end;

{==============================================================================}

function FindNextFile(hfindfile: HANDLE; var lpfindfiledata: WIN32_FIND_DATAA): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.FindNextFile(hfindfile,lpfindfiledata);
end;

{==============================================================================}

function FindNextFileA(hfindfile: HANDLE; var lpfindfiledata: WIN32_FIND_DATAA): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.FindNextFileA(hfindfile,lpfindfiledata);
end;

{==============================================================================}

function FindNextFileW(hfindfile: HANDLE; var lpfindfiledata: WIN32_FIND_DATAW): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.FindNextFileW(hfindfile,lpfindfiledata);
end;

{==============================================================================}

function FindCloseFile(hfindfile: HANDLE): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.FindCloseFile(hfindfile);
end;

{==============================================================================}

function GetFileSize(hfile: HANDLE; lpfilesizehigh: LPDWORD): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.GetFileSize(hfile,lpfilesizehigh);
end;

{==============================================================================}

function GetFileSizeEx(hfile: HANDLE; var lpfilesize: LARGE_INTEGER): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.GetFileSizeEx(hfile,lpfilesize);
end;

{==============================================================================}

function GetFileTime(hfile: HANDLE; lpcreationtime, lplastaccesstime, lplastwritetime: PFILETIME): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.GetFileTime(hfile,lpcreationtime,lplastaccesstime,lplastwritetime);
end;

{==============================================================================}

function SetFileTime(hfile: HANDLE; lpcreationtime, lplastaccesstime, lplastwritetime: PFILETIME): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.SetFileTime(hfile,lpcreationtime,lplastaccesstime,lplastwritetime);
end;

{==============================================================================}

function ReadFile(hfile: HANDLE; lpbuffer: LPVOID; nnumberofbytestoread: uint32_t; lpnumberofbytesread: LPDWORD; lpoverlapped: LPOVERLAPPED): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.ReadFile(hfile,lpbuffer,nnumberofbytestoread,lpnumberofbytesread,lpoverlapped);
end;

{==============================================================================}

function WriteFile(hfile: HANDLE; lpbuffer: LPCVOID; nnumberofbytestowrite: uint32_t; lpnumberofbyteswritten: LPDWORD; lpoverlapped: LPOVERLAPPED): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.WriteFile(hfile,lpbuffer,nnumberofbytestowrite,lpnumberofbyteswritten,lpoverlapped);
end;

{==============================================================================}

function SetEndOfFile(hfile: HANDLE): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.SetEndOfFile(hfile);
end;

{==============================================================================}

function SetFilePointer(hfile: HANDLE; ldistancetomove: LONG; lpdistancetomovehigh: PLONG; dwmovemethod: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.SetFilePointer(hfile,ldistancetomove,lpdistancetomovehigh,dwmovemethod);
end;

{==============================================================================}

function SetFilePointerEx(hfile: HANDLE; lidistancetomove: LARGE_INTEGER; lpnewfilepointer: PLARGE_INTEGER; dwmovemethod: uint32_t): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.SetFilePointerEx(hfile,lidistancetomove,lpnewfilepointer,dwmovemethod);
end;

{==============================================================================}

function FlushFileBuffers(hfile: HANDLE): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.FlushFileBuffers(hfile);
end;

{==============================================================================}

function CopyFile(const lpexistingfilename, lpnewfilename: LPCSTR; bfailifexists: BOOL): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.CopyFile(lpexistingfilename,lpnewfilename,bfailifexists);
end;

{==============================================================================}

function CopyFileA(const lpexistingfilename, lpnewfilename: LPCSTR; bfailifexists: BOOL): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.CopyFileA(lpexistingfilename,lpnewfilename,bfailifexists);
end;

{==============================================================================}

function CopyFileW(const lpexistingfilename, lpnewfilename: LPCWSTR; bfailifexists: BOOL): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.CopyFileW(lpexistingfilename,lpnewfilename,bfailifexists);
end;

{==============================================================================}

function SetFileShortName(hfile: HANDLE; const lpshortname: LPCSTR): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.SetFileShortName(hfile,lpshortname);
end;

{==============================================================================}

function SetFileShortNameA(hfile: HANDLE; const lpshortname: LPCSTR): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.SetFileShortNameA(hfile,lpshortname);
end;

{==============================================================================}

function SetFileShortNameW(hfile: HANDLE; const lpshortname: LPCWSTR): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.SetFileShortNameW(hfile,lpshortname);
end;

{==============================================================================}

function CreateHardLink(const lpfilename, lpexistingfilename: LPCSTR; lpsecurityattributes: LPSECURITY_ATTRIBUTES): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.CreateHardLink(lpfilename,lpexistingfilename,lpsecurityattributes);
end;

{==============================================================================}

function CreateHardLinkA(const lpfilename, lpexistingfilename: LPCSTR; lpsecurityattributes: LPSECURITY_ATTRIBUTES): BOOL; stdcall;
{Note: lpSecurityAttributes is currently ignored by Ultibo}
begin
 {}
 Result:=Ultibo.CreateHardLinkA(lpfilename,lpexistingfilename,lpsecurityattributes);
end;

{==============================================================================}

function CreateHardLinkW(const lpfilename, lpexistingfilename: LPCWSTR; lpsecurityattributes: LPSECURITY_ATTRIBUTES): BOOL; stdcall;
{Note: lpSecurityAttributes is currently ignored by Ultibo}
begin
 {}
 Result:=Ultibo.CreateHardLinkW(lpfilename,lpexistingfilename,lpsecurityattributes);
end;

{==============================================================================}

function CreateSymbolicLink(const lpsymlinkfilename, lptargetfilename: LPCSTR; dwflags: uint32_t): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.CreateSymbolicLink(lpsymlinkfilename,lptargetfilename,dwflags);
end;

{==============================================================================}

function CreateSymbolicLinkA(const lpsymlinkfilename, lptargetfilename: LPCSTR; dwflags: uint32_t): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.CreateSymbolicLinkA(lpsymlinkfilename,lptargetfilename,dwflags);
end;

{==============================================================================}

function CreateSymbolicLinkW(const lpsymlinkfilename, lptargetfilename: LPCWSTR; dwflags: uint32_t): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.CreateSymbolicLinkW(lpsymlinkfilename,lptargetfilename,dwflags);
end;

{==============================================================================}

function GetFileInformationByHandle(hfile: HANDLE; var lpfileinformation: BY_HANDLE_FILE_INFORMATION): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.GetFileInformationByHandle(hfile,lpfileinformation);
end;

{==============================================================================}

function GetFinalPathNameByHandle(hfile: HANDLE; lpszfilepath: LPSTR; cchfilepath, dwflags: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.GetFinalPathNameByHandle(hfile,lpszfilepath,cchfilepath,dwflags);
end;

{==============================================================================}

function GetFinalPathNameByHandleA(hfile: HANDLE; lpszfilepath: LPSTR; cchfilepath, dwflags: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.GetFinalPathNameByHandleA(hfile,lpszfilepath,cchfilepath,dwflags);
end;

{==============================================================================}

function GetFinalPathNameByHandleW(hfile: HANDLE; lpszfilepath: LPWSTR; cchfilepath, dwflags: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.GetFinalPathNameByHandleW(hfile,lpszfilepath,cchfilepath,dwflags);
end;

{==============================================================================}
{File Functions (Ultibo)}

{==============================================================================}
{Directory Functions (Compatibility)}
function CreateDirectory(const lppathname: LPCSTR; lpsecurityattributes: LPSECURITY_ATTRIBUTES): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.CreateDirectory(lppathname,lpsecurityattributes);
end;

{==============================================================================}

function CreateDirectoryA(const lppathname: LPCSTR; lpsecurityattributes: LPSECURITY_ATTRIBUTES): BOOL; stdcall;
{Note: lpSecurityAttributes is currently ignored by Ultibo}
begin
 {}
 Result:=Ultibo.CreateDirectoryA(lppathname,lpsecurityattributes);
end;

{==============================================================================}

function CreateDirectoryW(const lppathname: LPCWSTR; lpsecurityattributes: LPSECURITY_ATTRIBUTES): BOOL; stdcall;
{Note: lpSecurityAttributes is currently ignored by Ultibo}
begin
 {}
 Result:=Ultibo.CreateDirectoryW(lppathname,lpsecurityattributes);
end;

{==============================================================================}

function RemoveDirectory(const lppathname: LPCSTR): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.RemoveDirectory(lppathname);
end;

{==============================================================================}

function RemoveDirectoryA(const lppathname: LPCSTR): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.RemoveDirectoryA(lppathname);
end;

{==============================================================================}

function RemoveDirectoryW(const lppathname: LPCWSTR): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.RemoveDirectoryW(lppathname);
end;

{==============================================================================}

function SetCurrentDirectory(const lppathname: LPCSTR): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.SetCurrentDirectory(lppathname);
end;

{==============================================================================}

function SetCurrentDirectoryA(const lppathname: LPCSTR): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.SetCurrentDirectoryA(lppathname);
end;

{==============================================================================}

function SetCurrentDirectoryW(const lppathname: LPCWSTR): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.SetCurrentDirectoryW(lppathname);
end;

{==============================================================================}

function GetCurrentDirectory(nbufferlength: uint32_t; lpbuffer: LPSTR): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.GetCurrentDirectory(nbufferlength,lpbuffer);
end;

{==============================================================================}

function GetCurrentDirectoryA(nbufferlength: uint32_t; lpbuffer: LPSTR): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.GetCurrentDirectoryA(nbufferlength,lpbuffer);
end;

{==============================================================================}

function GetCurrentDirectoryW(nbufferlength: uint32_t; lpbuffer: LPWSTR): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.GetCurrentDirectoryW(nbufferlength,lpbuffer);
end;

{==============================================================================}

function GetLongPathName(const lpszshortpath: LPCSTR; lpszlongpath: LPSTR; cchbuffer: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.GetLongPathName(lpszshortpath,lpszlongpath,cchbuffer);
end;

{==============================================================================}

function GetLongPathNameA(const lpszshortpath: LPCSTR; lpszlongpath: LPSTR; cchbuffer: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.GetLongPathNameA(lpszshortpath,lpszlongpath,cchbuffer);
end;

{==============================================================================}

function GetLongPathNameW(const lpszshortpath: LPCWSTR; lpszlongpath: LPWSTR; cchbuffer: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.GetLongPathNameW(lpszshortpath,lpszlongpath,cchbuffer);
end;

{==============================================================================}

function GetShortPathName(const lpszlongpath: LPCSTR; lpszshortpath: LPSTR; cchbuffer: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.GetShortPathName(lpszlongpath,lpszshortpath,cchbuffer);
end;

{==============================================================================}

function GetShortPathNameA(const lpszlongpath: LPCSTR; lpszshortpath: LPSTR; cchbuffer: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.GetShortPathNameA(lpszlongpath,lpszshortpath,cchbuffer);
end;

{==============================================================================}

function GetShortPathNameW(const lpszlongpath: LPCWSTR; lpszshortpath: LPWSTR; cchbuffer: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.GetShortPathNameW(lpszlongpath,lpszshortpath,cchbuffer);
end;

{==============================================================================}

function GetFullPathName(const lpfilename: LPCSTR; nbufferlength: uint32_t; lpbuffer: LPSTR; var lpfilepart: LPSTR): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.GetFullPathName(lpfilename,nbufferlength,lpbuffer,lpfilepart);
end;

{==============================================================================}

function GetFullPathNameA(const lpfilename: LPCSTR; nbufferlength: uint32_t; lpbuffer: LPSTR; var lpfilepart: LPSTR): uint32_t; stdcall;
{Note: lpFilePart is currently ignored by Ultibo}
begin
 {}
 Result:=Ultibo.GetFullPathNameA(lpfilename,nbufferlength,lpbuffer,lpfilepart);
end;

{==============================================================================}

function GetFullPathNameW(const lpfilename: LPCWSTR; nbufferlength: uint32_t; lpbuffer: LPWSTR; var lpfilepart: LPWSTR): uint32_t; stdcall;
{Note: lpFilePart is currently ignored by Ultibo}
begin
 {}
 Result:=Ultibo.GetFullPathNameW(lpfilename,nbufferlength,lpbuffer,lpfilepart);
end;

{==============================================================================}
{Directory Functions (Ultibo)}

{==============================================================================}
{Command Line Functions (Compatibility)}
function GetCommandLine: LPSTR; stdcall;
begin
 {}
 Result:=Ultibo.GetCommandLine;
end;

{==============================================================================}

function GetCommandLineA: LPSTR; stdcall;
{Note: The returned string must be freed with SysUtils.StrDispose}
begin
 {}
 Result:=Ultibo.GetCommandLineA;
end;

{==============================================================================}

function GetCommandLineW: LPWSTR; stdcall;
{Note: The returned string must be freed with SysUtils.StrDispose}
begin
 {}
 Result:=Ultibo.GetCommandLineW;
end;

{==============================================================================}
{Command Line Functions (Ultibo)}
function IsParamPresent(const param: PCHAR): BOOL; stdcall;
{Check if the specified parameter is present in the command line}
begin
 {}
 Result:=Ultibo.IsParamPresent(String(param));
end;

{==============================================================================}

function GetParamIndex(const param: PCHAR): int; stdcall;
{Get the index of the specified parameter in the command line}
begin
 {}
 Result:=Ultibo.GetParamIndex(String(param));
end;

{==============================================================================}

function GetParamValue(const param: PCHAR; value: PCHAR; len: uint32_t): uint32_t; stdcall;
{Get the value of the specified parameter from the command line}
begin
 {}
 Result:=APIStringToPCharBuffer(Ultibo.GetParamValue(String(param)),value,len);
end;

{==============================================================================}
{Environment Functions (Compatibility)}
function GetEnvironmentStrings: LPSTR; stdcall;
begin
 {}
 Result:=Ultibo.GetEnvironmentStrings;
end;

{==============================================================================}

function GetEnvironmentStringsA: LPSTR; stdcall;
begin
 {}
 Result:=Ultibo.GetEnvironmentStringsA;
end;

{==============================================================================}

function GetEnvironmentStringsW: LPWSTR; stdcall;
begin
 {}
 Result:=Ultibo.GetEnvironmentStringsW;
end;

{==============================================================================}

function FreeEnvironmentStrings(pstr: LPSTR): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.FreeEnvironmentStrings(pstr);
end;

{==============================================================================}

function FreeEnvironmentStringsA(pstr: LPSTR): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.FreeEnvironmentStringsA(pstr);
end;

{==============================================================================}

function FreeEnvironmentStringsW(pstr: LPWSTR): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.FreeEnvironmentStringsW(pstr);
end;

{==============================================================================}

function GetEnvironmentVariable(const lpname: LPCSTR; lpbuffer: LPSTR; nsize: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.GetEnvironmentVariable(lpname,lpbuffer,nsize);
end;

{==============================================================================}

function GetEnvironmentVariableA(const lpname: LPCSTR; lpbuffer: LPSTR; nsize: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.GetEnvironmentVariableA(lpname,lpbuffer,nsize);
end;

{==============================================================================}

function GetEnvironmentVariableW(const lpname: LPCWSTR; lpbuffer: LPWSTR; nsize: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.GetEnvironmentVariableW(lpname,lpbuffer,nsize);
end;

{==============================================================================}

function SetEnvironmentVariable(const lpname, lpvalue: LPCSTR): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.SetEnvironmentVariable(lpname,lpvalue);
end;

{==============================================================================}

function SetEnvironmentVariableA(const lpname, lpvalue: LPCSTR): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.SetEnvironmentVariableA(lpname,lpvalue);
end;

{==============================================================================}

function SetEnvironmentVariableW(const lpname, lpvalue: LPCWSTR): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.SetEnvironmentVariableW(lpname,lpvalue);
end;

{==============================================================================}

function ExpandEnvironmentStrings(const lpsrc: LPCSTR; lpdst: LPSTR; nsize: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.ExpandEnvironmentStrings(lpsrc,lpdst,nsize);
end;

{==============================================================================}

function ExpandEnvironmentStringsA(const lpsrc: LPCSTR; lpdst: LPSTR; nsize: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.ExpandEnvironmentStringsA(lpsrc,lpdst,nsize);
end;

{==============================================================================}

function ExpandEnvironmentStringsW(const lpsrc: LPCWSTR; lpdst: LPWSTR; nsize: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.ExpandEnvironmentStringsW(lpsrc,lpdst,nsize);
end;

{==============================================================================}
{Error Functions (Compatibility)}
function GetLastError: uint32_t; stdcall;
{Get the last error value for the calling thread}
begin
 {}
 Result:=Ultibo.GetLastError;
end;

{==============================================================================}

procedure SetLastError(dwerrcode: uint32_t); stdcall;
{Set the last error value for the calling thread}
begin
 {}
 Ultibo.SetLastError(dwerrcode);
end;

{==============================================================================}
{String Functions (Ultibo)}

{==============================================================================}
{GUID Functions (Ultibo)}
function CreateGUID: TGUID; stdcall;
{GUID has the following format DWORD-WORD-WORD-WORD-WORDDWORD }
{                                             | Not Swapped  |}
begin
 {}
 Result:=Ultibo.CreateGUID;
end;

{==============================================================================}

function GUIDToString(const value: TGUID; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(Ultibo.GUIDToString(value),_string,len);
end;

{==============================================================================}

function StringToGUID(const value: PCHAR): TGUID; stdcall;
begin
 {}
 Result:=Ultibo.StringToGUID(String(value));
end;

{==============================================================================}

function NullGUID(const guid: TGUID): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.NullGUID(guid);
end;

{==============================================================================}

function CompareGUID(const guid1, guid2: TGUID): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.CompareGUID(guid1,guid2);
end;

{==============================================================================}
{SID Functions (Ultibo)}
function SIDToString(sid: PSID; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=APIStringToPCharBuffer(Ultibo.SIDToString(sid),_string,len);
end;

{==============================================================================}

function StringToSID(value: PCHAR): PSID; stdcall;
begin
 {}
 Result:=Ultibo.StringToSID(String(value));
end;

{==============================================================================}
{Date Functions (Ultibo)}

{==============================================================================}
{Numeric Functions (Ultibo)}
function Min(a, b: int): int; stdcall;
begin
 {}
 Result:=Ultibo.Min(a,b);
end;

{==============================================================================}

function Max(a, b: int): int; stdcall;
begin
 {}
 Result:=Ultibo.Max(a,b);
end;

{==============================================================================}

function MinEx(a, b: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.MinEx(a,b);
end;

{==============================================================================}

function MaxEx(a, b: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.MaxEx(a,b);
end;

{==============================================================================}

function Min64(const a, b: int64_t): int64_t; stdcall;
begin
 {}
 Result:=Ultibo.Min64(a,b);
end;

{==============================================================================}

function Max64(const a, b: int64_t): int64_t; stdcall;
begin
 {}
 Result:=Ultibo.Max64(a,b);
end;

{==============================================================================}

function Or64(const value1, value2: int64_t): int64_t; stdcall;
begin
 {}
 Result:=Ultibo.Or64(value1,value2);
end;

{==============================================================================}

function And64(const value1, value2: int64_t): int64_t; stdcall;
begin
 {}
 Result:=Ultibo.And64(value1,value2);
end;

{==============================================================================}

function Xor64(const value1, value2: int64_t): int64_t; stdcall;
begin
 {}
 Result:=Ultibo.Xor64(value1,value2);
end;

{==============================================================================}

function Not64(const value: int64_t): int64_t; stdcall;
begin
 {}
 Result:=Ultibo.Not64(value);
end;

{==============================================================================}

function Rol32(value: uint32_t; count: uint8_t): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.Rol32(value,count);
end;

{==============================================================================}

function Ror32(value: uint32_t; count: uint8_t): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.Ror32(value,count);
end;

{==============================================================================}

function WordSwap(value: uint16_t): uint16_t; stdcall;
begin
 {}
 Result:=Ultibo.WordSwap(value);
end;

{==============================================================================}

function LongSwap(value: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.LongSwap(value);
end;

{==============================================================================}

function Int64Swap(const value: int64_t): int64_t; stdcall;
begin
 {}
 Result:=Ultibo.Int64Swap(value);
end;

{==============================================================================}

function BufferSwap(buffer: PVOID; size: uint32_t): BOOL; stdcall;
{Swap each word in the buffer supplied up to size}
{Note: Size is the number of Bytes in the buffer to swap}
begin
 {}
 Result:=Ultibo.BufferSwap(buffer,size);
end;

{==============================================================================}
{Hash Functions (Ultibo)}
function GenerateNameHash(const name: PCHAR; size: int): uint32_t; stdcall;
{Sum of (byte value + 1) * (position + 257) for all bytes in uppercase string}
{Note: Case Insensitive Hash}
begin
 {}
 Result:=Ultibo.GenerateNameHash(String(name),size);
end;

{==============================================================================}

function GenerateStringHash(const value: PCHAR; casesensitive: BOOL): uint32_t; stdcall;
{Sum of (byte value + 1) * (position + 257) for all bytes in string}
begin
 {}
 Result:=Ultibo.GenerateStringHash(String(value),casesensitive);
end;

{==============================================================================}
{Locale Functions (Compatibility)}
function GetThreadLocale: LCID; stdcall;
begin
 {}
 Result:=Ultibo.GetThreadLocale;
end;

{==============================================================================}

function SetThreadLocale(localeid: LCID): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.SetThreadLocale(localeid);
end;

{==============================================================================}
{Locale Functions (Ultibo)}
function WideCharToString(const buffer: PWCHAR; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{A replacement for WideCharToString in System unit to allow cross platform compatibility}
{Note: The WideStringManager installed by the Unicode unit should make the System version equivalent}
begin
 {}
 Result:=APIStringToPCharBuffer(Ultibo.WideCharToString(buffer),_string,len);
end;

{==============================================================================}

function WideCharLenToString(const buffer: PWCHAR; _length: int; _string: PCHAR; len: uint32_t): uint32_t; stdcall;
{A replacement for WideCharLenToString in System unit to allow cross platform compatibility}
{Note: Length is the size of the Buffer in WideChars (not Bytes)}
{Note: The WideStringManager installed by the Unicode unit should make the System version equivalent}
begin
 {}
 Result:=APIStringToPCharBuffer(Ultibo.WideCharLenToString(buffer,_length),_string,len);
end;

{==============================================================================}

function StringToWideChar(const _string: PCHAR; buffer: PWCHAR; size: int): BOOL; stdcall;
{A replacement for StringToWideChar in System unit to allow cross platform compatibility}
{Note: Size is the size of the Buffer in Bytes (not WideChars)}
{Note: The WideStringManager installed by the Unicode unit should make the System version equivalent}
begin
 {}
 Result:=Ultibo.StringToWideChar(String(_string),buffer,size);
end;

{==============================================================================}
{Code Page Functions (Compatibility)}

{==============================================================================}
{Code Page Functions (Ultibo)}

{==============================================================================}
{Translation Functions (Compatibility)}

{==============================================================================}
{Handle Functions (Compatibility)}
function CloseHandle(hobject: HANDLE): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.CloseHandle(hobject);
end;

{==============================================================================}

function DuplicateHandle(hsourceprocesshandle: HANDLE; hsourcehandle: HANDLE; htargetprocesshandle: HANDLE; lptargethandle: LPHANDLE; dwdesiredaccess: uint32_t; binherithandle: BOOL; dwoptions: uint32_t): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.DuplicateHandle(hsourceprocesshandle,hsourcehandle,htargetprocesshandle,lptargethandle,dwdesiredaccess,binherithandle,dwoptions);
end;

{==============================================================================}

function GetHandleInformation(hobject: HANDLE; var lpdwflags: uint32_t): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.GetHandleInformation(hobject,lpdwflags);
end;

{==============================================================================}

function SetHandleInformation(hobject: HANDLE; dwmask: uint32_t; dwflags: uint32_t): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.SetHandleInformation(hobject,dwmask,dwflags);
end;

{==============================================================================}
{Memory Functions (Compatibility)}
procedure MoveMemory(destination, source: PVOID; length: SIZE_T); stdcall;
begin
 {}
 Ultibo.MoveMemory(destination,source,length);
end;

{==============================================================================}

procedure CopyMemory(destination, source: PVOID; length: SIZE_T); stdcall;
begin
 {}
 Ultibo.CopyMemory(destination,source,length);
end;

{==============================================================================}

procedure FillMemory(destination: PVOID; length: SIZE_T; fill: uint8_t); stdcall;
begin
 {}
 Ultibo.FillMemory(destination,length,fill);
end;

{==============================================================================}

procedure ZeroMemory(destination: PVOID; length: SIZE_T); stdcall;
begin
 {}
 Ultibo.ZeroMemory(destination,length);
end;

{==============================================================================}

function GlobalAlloc(uflags: UINT; dwbytes: SIZE_T): HGLOBAL; stdcall;
{Note: All flags except GMEM_ZEROINIT are ignored by Ultibo}
begin
 {}
 Result:=Ultibo.GlobalAlloc(uflags,dwbytes);
end;

{==============================================================================}

function GlobalReAlloc(hmem: HGLOBAL; dwbytes: SIZE_T; uflags: UINT): HGLOBAL; stdcall;
begin
 {}
 Result:=Ultibo.GlobalReAlloc(hmem,dwbytes,uflags);
end;

{==============================================================================}

function GlobalFree(hmem: HGLOBAL): HGLOBAL; stdcall;
begin
 {}
 Result:=Ultibo.GlobalFree(hmem);
end;

{==============================================================================}

function GlobalSize(hmem: HGLOBAL): SIZE_T; stdcall;
begin
 {}
 Result:=Ultibo.GlobalSize(hmem);
end;

{==============================================================================}

function GlobalFlags(hmem: HGLOBAL): UINT; stdcall;
begin
 {}
 Result:=Ultibo.GlobalFlags(hmem);
end;

{==============================================================================}

function GlobalLock(hmem: HGLOBAL): LPVOID; stdcall;
begin
 {}
 Result:=Ultibo.GlobalLock(hmem);
end;

{==============================================================================}

function GlobalUnlock(hmem: HGLOBAL): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.GlobalUnlock(hmem);
end;

{==============================================================================}

function GlobalHandle(pmem: LPCVOID): HGLOBAL; stdcall;
begin
 {}
 Result:=Ultibo.GlobalHandle(pmem);
end;

{==============================================================================}

procedure GlobalMemoryStatus(var lpbuffer: MEMORYSTATUS); stdcall;
begin
 {}
 Ultibo.GlobalMemoryStatus(lpbuffer);
end;

{==============================================================================}

function GlobalMemoryStatusEx(var lpbuffer: MEMORYSTATUSEX): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.GlobalMemoryStatusEx(lpbuffer);
end;

{==============================================================================}

function LocalAlloc(uflags: UINT; ubytes: SIZE_T): HLOCAL; stdcall;
{Note: All flags except LMEM_ZEROINIT are ignored by Ultibo}
begin
 {}
 Result:=Ultibo.LocalAlloc(uflags,ubytes);
end;

{==============================================================================}

function LocalReAlloc(hmem: HLOCAL; ubytes: SIZE_T; uflags: UINT): HLOCAL; stdcall;
begin
 {}
 Result:=Ultibo.LocalReAlloc(hmem,ubytes,uflags);
end;

{==============================================================================}

function LocalFree(hmem: HLOCAL): HLOCAL; stdcall;
begin
 {}
 Result:=Ultibo.LocalFree(hmem);
end;

{==============================================================================}

function LocalSize(hmem: HLOCAL): SIZE_T; stdcall;
begin
 {}
 Result:=Ultibo.LocalSize(hmem);
end;

{==============================================================================}

function LocalFlags(hmem: HLOCAL): UINT; stdcall;
begin
 {}
 Result:=Ultibo.LocalFlags(hmem);
end;

{==============================================================================}

function LocalLock(hmem: HLOCAL): LPVOID; stdcall;
begin
 {}
 Result:=Ultibo.LocalLock(hmem);
end;

{==============================================================================}

function LocalUnlock(hmem: HLOCAL): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.LocalUnlock(hmem);
end;

{==============================================================================}

function LocalHandle(pmem: LPCVOID): HLOCAL; stdcall;
begin
 {}
 Result:=Ultibo.LocalHandle(pmem);
end;

{==============================================================================}

function VirtualAlloc(lpaddress: LPVOID; dwsize: SIZE_T; flallocationtype: uint32_t; flprotect: uint32_t): LPVOID; stdcall;
{Note: The value of lpAddress on entry is currently ignored by Ultibo}
{Note: The value of flProtect is currently ignored by Ultibo}
{Note: As per Win32, the value of dwSize is rounded to the next page multiple}
begin
 {}
 Result:=Ultibo.VirtualAlloc(lpaddress,dwsize,flallocationtype,flprotect);
end;

{==============================================================================}

function VirtualFree(lpaddress: LPVOID; dwsize: SIZE_T; dwfreetype: uint32_t): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.VirtualFree(lpaddress,dwsize,dwfreetype);
end;

{==============================================================================}

function VirtualQuery(lpaddress: LPCVOID; var lpbuffer: MEMORY_BASIC_INFORMATION; dwlength: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.VirtualQuery(lpaddress,lpbuffer,dwlength);
end;

{==============================================================================}

function VirtualLock(lpaddress: LPVOID; dwsize: SIZE_T): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.VirtualLock(lpaddress,dwsize);
end;

{==============================================================================}

function VirtualUnlock(lpaddress: LPVOID; dwsize: SIZE_T): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.VirtualUnlock(lpaddress,dwsize);
end;

{==============================================================================}

function FlushInstructionCache(hprocess: HANDLE; lpbaseaddress: LPCVOID; dwsize: uint32_t): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.FlushInstructionCache(hprocess,lpbaseaddress,dwsize);
end;

{==============================================================================}

function GetNumaHighestNodeNumber(var highestnodenumber: ULONG): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.GetNumaHighestNodeNumber(highestnodenumber);
end;

{==============================================================================}

function GetNumaProcessorNode(const processor: uint8_t; var nodenumber: uint8_t): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.GetNumaProcessorNode(processor,nodenumber);
end;

{==============================================================================}
{Tls Functions (Compatibility)}
function TlsAlloc: uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.TlsAlloc;
end;

{==============================================================================}

function TlsAllocEx(bfree: BOOL): uint32_t; stdcall;
{bFree: If true then TlsValue will be freed on TlsFree or thread terminate}
begin
 {}
 Result:=Ultibo.TlsAllocEx(bfree);
end;

{==============================================================================}

function TlsGetValue(dwtlsindex: uint32_t): LPVOID; stdcall;
begin
 {}
 Result:=Ultibo.TlsGetValue(dwtlsindex);
end;

{==============================================================================}

function TlsSetValue(dwtlsindex: uint32_t; lptlsvalue: LPVOID): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.TlsSetValue(dwtlsindex,lptlsvalue);
end;

{==============================================================================}

function TlsFree(dwtlsindex: uint32_t): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.TlsFree(dwtlsindex);
end;

{==============================================================================}
{Thread Functions (Compatibility)}
function SwitchToThread: BOOL; stdcall;
begin
 {}
 Result:=Ultibo.SwitchToThread;
end;

{==============================================================================}

procedure Sleep(dwmilliseconds: uint32_t); stdcall;
begin
 {}
 Ultibo.Sleep(dwmilliseconds);
end;

{==============================================================================}

function SleepEx(dwmilliseconds: uint32_t; balertable: BOOL): uint32_t; stdcall;
{Note: The bAlertable parameter is not currently used but is intended for I/O completion callback from ReadFileEx/WriteFileEx}
begin
 {}
 Result:=Ultibo.SleepEx(dwmilliseconds,balertable);
end;

{==============================================================================}

function GetCurrentThread: HANDLE; stdcall;
begin
 {}
 Result:=Ultibo.GetCurrentThread;
end;

{==============================================================================}

function GetCurrentThreadId: uint32_t; stdcall;
{Note: Thread Id and Thread Handle are currently equivalent}
begin
 {}
 Result:=Ultibo.GetCurrentThreadId;
end;

{==============================================================================}

function GetThreadPriority(hthread: HANDLE): int; stdcall;
begin
 {}
 Result:=Ultibo.GetThreadPriority(hthread);
end;

{==============================================================================}

function SetThreadPriority(hthread: HANDLE; npriority: int): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.SetThreadPriority(hthread,npriority);
end;

{==============================================================================}

function GetExitCodeThread(hthread: HANDLE; var lpexitcode: uint32_t): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.GetExitCodeThread(hthread,lpexitcode);
end;

{==============================================================================}

function GetThreadAffinityMask(hthread: HANDLE): DWORD_PTR; stdcall;
begin
 {}
 Result:=Ultibo.GetThreadAffinityMask(hthread);
end;

{==============================================================================}

function SetThreadAffinityMask(hthread: HANDLE; dwthreadaffinitymask: DWORD_PTR): DWORD_PTR; stdcall;
begin
 {}
 Result:=Ultibo.SetThreadAffinityMask(hthread,dwthreadaffinitymask);
end;

{==============================================================================}

function GetThreadTimes(hthread: HANDLE; var lpcreationtime, lpexittime, lpkerneltime, lpusertime: FILETIME): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.GetThreadTimes(hthread,lpcreationtime,lpexittime,lpkerneltime,lpusertime);
end;

{==============================================================================}

function CreateThread(lpthreadattributes: LPSECURITY_ATTRIBUTES; dwstacksize: uint32_t; lpstartaddress: LPTHREAD_START_ROUTINE; lpparameter: LPVOID; dwcreationflags: uint32_t; lpthreadid: LPDWORD): HANDLE; stdcall;
begin
 {}
 Result:=Ultibo.CreateThread(lpthreadattributes,dwstacksize,lpstartaddress,lpparameter,dwcreationflags,lpthreadid);
end;

{==============================================================================}

function OpenThread(dwdesiredaccess: uint32_t; binherithandle: BOOL; dwthreadid: uint32_t): HANDLE; stdcall;
begin
 {}
 Result:=Ultibo.OpenThread(dwdesiredaccess,binherithandle,dwthreadid);
end;

{==============================================================================}

function SuspendThread(hthread: HANDLE): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.SuspendThread(hthread);
end;

{==============================================================================}

function ResumeThread(hthread: HANDLE): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.ResumeThread(hthread);
end;

{==============================================================================}

function TerminateThread(hthread: HANDLE; dwexitcode: uint32_t): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.TerminateThread(hthread,dwexitcode);
end;

{==============================================================================}

procedure ExitThread(dwexitcode: uint32_t); stdcall;
begin
 {}
 Ultibo.ExitThread(dwexitcode);
end;

{==============================================================================}

function WaitForSingleObject(hhandle: HANDLE; dwmilliseconds: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.WaitForSingleObject(hhandle,dwmilliseconds);
end;

{==============================================================================}

function WaitForMultipleObjects(ncount: uint32_t; lphandles: PHANDLE; bwaitall: BOOL; dwmilliseconds: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.WaitForMultipleObjects(ncount,lphandles,bwaitall,dwmilliseconds);
end;

{==============================================================================}

function WaitForSingleObjectEx(hhandle: HANDLE; dwmilliseconds: uint32_t; balertable: BOOL): uint32_t; stdcall;
{Note: The bAlertable parameter is not currently used but is intended for I/O completion callback from ReadFileEx/WriteFileEx}
begin
 {}
 Result:=Ultibo.WaitForSingleObjectEx(hhandle,dwmilliseconds,balertable);
end;

{==============================================================================}

function WaitForMultipleObjectsEx(ncount: uint32_t; lphandles: PHANDLE; bwaitall: BOOL; dwmilliseconds: uint32_t; balertable: BOOL): uint32_t; stdcall;
{Note: The bAlertable parameter is not currently used but is intended for I/O completion callback from ReadFileEx/WriteFileEx}
begin
 {}
 Result:=Ultibo.WaitForMultipleObjectsEx(ncount,lphandles,bwaitall,dwmilliseconds,balertable);
end;

{==============================================================================}
{Thread Functions (Ultibo)}
function BeginThreadEx(threadfunction: thread_func; parameter: PVOID; var threadid: TTHREAD_ID; const stacksize: SIZE_T; priority, affinity, cpu: uint32_t; const name: PCHAR): TTHREAD_ID; stdcall;
begin
 {}
 Result:=Ultibo.BeginThreadEx(threadfunction,parameter,threadid,stacksize,priority,affinity,cpu,name);
end;

{==============================================================================}
{Message Functions (Compatibility)}
function WaitMessage: BOOL; stdcall;
begin
 {}
 Result:=Ultibo.WaitMessage;
end;

{==============================================================================}

function GetMessage(lpmsg: LPMSG; hthread: HANDLE; wmsgfiltermin, wmsgfiltermax: UINT): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.GetMessage(lpmsg,hthread,wmsgfiltermin,wmsgfiltermax);
end;

{==============================================================================}

function PeekMessage(var lpmsg: MSG; hthread: HANDLE; wmsgfiltermin, wmsgfiltermax, wremovemsg: UINT): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.PeekMessage(lpmsg,hthread,wmsgfiltermin,wmsgfiltermax,wremovemsg);
end;

{==============================================================================}

function PostMessage(hthread: HANDLE; msg: UINT; wparam: WPARAM; lparam: LPARAM): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.PostMessage(hthread,msg,wparam,lparam);
end;

{==============================================================================}

function SendMessage(hthread: HANDLE; msg: UINT; wparam: WPARAM; lparam: LPARAM): LRESULT; stdcall;
begin
 {}
 Result:=Ultibo.SendMessage(hthread,msg,wparam,lparam);
end;

{==============================================================================}

function SendMessageTimeout(hthread: HANDLE; msg: UINT; wparam: WPARAM; lparam: LPARAM; fuflags, utimeout: UINT; var lpdwresult: DWORD_PTR): LRESULT; stdcall;
begin
 {}
 Result:=Ultibo.SendMessageTimeout(hthread,msg,wparam,lparam,fuflags,utimeout,lpdwresult);
end;

{==============================================================================}
{Notification Functions (Compatibility)}

{==============================================================================}
{Interlocked Functions (Compatibility)}
function InterlockedIncrement(var lpaddend: LONG): LONG; stdcall;
begin
 {}
 Result:=Ultibo.InterlockedIncrement(lpaddend);
end;

{==============================================================================}

function InterlockedDecrement(var lpaddend: LONG): LONG; stdcall;
begin
 {}
 Result:=Ultibo.InterlockedDecrement(lpaddend);
end;

{==============================================================================}

function InterlockedExchange(var target: LONG; value: LONG): LONG; stdcall;
begin
 {}
 Result:=Ultibo.InterlockedExchange(target,value);
end;

{==============================================================================}

function InterlockedExchangePointer(var target: PVOID; value: PVOID): PVOID; stdcall;
begin
 {}
 Result:=Ultibo.InterlockedExchangePointer(target,value);
end;

{==============================================================================}

function InterlockedExchangeAdd(var addend: LONG; value: LONG): LONG; stdcall;
begin
 {}
 Result:=Ultibo.InterlockedExchangeAdd(addend,value);
end;

{==============================================================================}

function InterlockedCompareExchange(var destination: LONG; exchange: LONG; comperand: LONG): LONG; stdcall;
begin
 {}
 Result:=Ultibo.InterlockedCompareExchange(destination,exchange,comperand);
end;

{==============================================================================}

function InterlockedCompareExchangePointer(var destination: PVOID; exchange, comperand: PVOID): PVOID; stdcall;
begin
 {}
 Result:=Ultibo.InterlockedCompareExchangePointer(destination,exchange,comperand);
end;

{==============================================================================}
{Mutex Functions (Compatibility)}
function CreateMutex(lpmutexattributes: LPSECURITY_ATTRIBUTES; binitialowner: BOOL; const lpname: LPCSTR): HANDLE; stdcall;
begin
 {}
 Result:=Ultibo.CreateMutex(lpmutexattributes,binitialowner,lpname);
end;

{==============================================================================}

function CreateMutexA(lpmutexattributes: LPSECURITY_ATTRIBUTES; binitialowner: BOOL; const lpname: LPCSTR): HANDLE; stdcall;
begin
 {}
 Result:=Ultibo.CreateMutexA(lpmutexattributes,binitialowner,lpname);
end;

{==============================================================================}

function CreateMutexW(lpmutexattributes: LPSECURITY_ATTRIBUTES; binitialowner: BOOL; const lpname: LPCWSTR): HANDLE; stdcall;
begin
 {}
 Result:=Ultibo.CreateMutexW(lpmutexattributes,binitialowner,lpname);
end;

{==============================================================================}

function OpenMutex(dwdesiredaccess: uint32_t; binherithandle: BOOL; const lpname: LPCSTR): HANDLE; stdcall;
begin
 {}
 Result:=Ultibo.OpenMutex(dwdesiredaccess,binherithandle,lpname);
end;

{==============================================================================}

function OpenMutexA(dwdesiredaccess: uint32_t; binherithandle: BOOL; const lpname: LPCSTR): HANDLE; stdcall;
begin
 {}
 Result:=Ultibo.OpenMutexA(dwdesiredaccess,binherithandle,lpname);
end;

{==============================================================================}

function OpenMutexW(dwdesiredaccess: uint32_t; binherithandle: BOOL; const lpname: LPCWSTR): HANDLE; stdcall;
begin
 {}
 Result:=Ultibo.OpenMutexW(dwdesiredaccess,binherithandle,lpname);
end;

{==============================================================================}

function ReleaseMutex(hmutex: HANDLE): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.ReleaseMutex(hmutex);
end;

{==============================================================================}
{Semaphore Functions (Compatibility)}
function CreateSemaphore(lpsemaphoreattributes: LPSECURITY_ATTRIBUTES; linitialcount, lmaximumcount: LONG; const lpname: LPCSTR): HANDLE; stdcall;
begin
 {}
 Result:=Ultibo.CreateSemaphore(lpsemaphoreattributes,linitialcount,lmaximumcount,lpname);
end;

{==============================================================================}

function CreateSemaphoreA(lpsemaphoreattributes: LPSECURITY_ATTRIBUTES; linitialcount, lmaximumcount: LONG; const lpname: LPCSTR): HANDLE; stdcall;
begin
 {}
 Result:=Ultibo.CreateSemaphoreA(lpsemaphoreattributes,linitialcount,lmaximumcount,lpname);
end;

{==============================================================================}

function CreateSemaphoreW(lpsemaphoreattributes: LPSECURITY_ATTRIBUTES; linitialcount, lmaximumcount: LONG; const lpname: LPCWSTR): HANDLE; stdcall;
begin
 {}
 Result:=Ultibo.CreateSemaphoreW(lpsemaphoreattributes,linitialcount,lmaximumcount,lpname);
end;

{==============================================================================}

function OpenSemaphore(dwdesiredaccess: uint32_t; binherithandle: BOOL; const lpname: LPCSTR): HANDLE; stdcall;
begin
 {}
 Result:=Ultibo.OpenSemaphore(dwdesiredaccess,binherithandle,lpname);
end;

{==============================================================================}

function OpenSemaphoreA(dwdesiredaccess: uint32_t; binherithandle: BOOL; const lpname: LPCSTR): HANDLE; stdcall;
begin
 {}
 Result:=Ultibo.OpenSemaphoreA(dwdesiredaccess,binherithandle,lpname);
end;

{==============================================================================}

function OpenSemaphoreW(dwdesiredaccess: uint32_t; binherithandle: BOOL; const lpname: LPCWSTR): HANDLE; stdcall;
begin
 {}
 Result:=Ultibo.OpenSemaphoreW(dwdesiredaccess,binherithandle,lpname);
end;

{==============================================================================}

function ReleaseSemaphore(hsemaphore: HANDLE; lreleasecount: LONG; lppreviouscount: LPLONG): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.ReleaseSemaphore(hsemaphore,lreleasecount,lppreviouscount);
end;

{==============================================================================}
{Critical Section Functions (Compatibility)}
procedure InitializeCriticalSection(var lpcriticalsection: CRITICAL_SECTION); stdcall;
begin
 {}
 Ultibo.InitializeCriticalSection(lpcriticalsection);
end;

{==============================================================================}

procedure EnterCriticalSection(var lpcriticalsection: CRITICAL_SECTION); stdcall;
begin
 {}
 Ultibo.EnterCriticalSection(lpcriticalsection);
end;

{==============================================================================}

procedure LeaveCriticalSection(var lpcriticalsection: CRITICAL_SECTION); stdcall;
begin
 {}
 Ultibo.LeaveCriticalSection(lpcriticalsection);
end;

{==============================================================================}

function TryEnterCriticalSection(var lpcriticalsection: CRITICAL_SECTION): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.TryEnterCriticalSection(lpcriticalsection);
end;

{==============================================================================}

function InitializeCriticalSectionAndSpinCount(var lpcriticalsection: CRITICAL_SECTION; dwspincount: uint32_t): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.InitializeCriticalSectionAndSpinCount(lpcriticalsection,dwspincount);
end;

{==============================================================================}

function SetCriticalSectionSpinCount(var lpcriticalsection: CRITICAL_SECTION; dwspincount: uint32_t): uint32_t; stdcall;
begin
 {}
 Result:=Ultibo.SetCriticalSectionSpinCount(lpcriticalsection,dwspincount);
end;

{==============================================================================}

procedure DeleteCriticalSection(var lpcriticalsection: CRITICAL_SECTION); stdcall;
begin
 {}
 Ultibo.DeleteCriticalSection(lpcriticalsection);
end;

{==============================================================================}
{Condition Variable Functions (Compatibility)}
procedure InitializeConditionVariable(var conditionvariable: CONDITION_VARIABLE); stdcall;
{Initializes a condition variable}
{ConditionVariable: The condition variable to initialize}
begin
 {}
 Ultibo.InitializeConditionVariable(conditionvariable);
end;

{==============================================================================}

procedure WakeConditionVariable(var conditionvariable: CONDITION_VARIABLE); stdcall;
{Wake a single thread waiting on the specified condition variable}
{ConditionVariable: The condition variable to wake}
begin
 {}
 Ultibo.WakeConditionVariable(conditionvariable);
end;

{==============================================================================}

procedure WakeAllConditionVariable(var conditionvariable: CONDITION_VARIABLE); stdcall;
{Wake all threads waiting on the specified condition variable}
{ConditionVariable: The condition variable to wake}
begin
 {}
 Ultibo.WakeAllConditionVariable(conditionvariable);
end;

{==============================================================================}

function SleepConditionVariableCS(var conditionvariable: CONDITION_VARIABLE; var criticalsection: CRITICAL_SECTION; dwmilliseconds: uint32_t): BOOL; stdcall;
{Sleeps on the specified condition variable and releases the specified critical section as an atomic operation}
{ConditionVariable: The condition variable to sleep on}
{CriticalSection: The critical section object to release (This critical section must be entered exactly once by the caller at the time SleepConditionVariableCS is called)}
{dwMilliseconds: The time-out interval, in milliseconds. (If the time-out interval elapses, the function re-acquires the critical section and returns false)}
begin
 {}
 Result:=Ultibo.SleepConditionVariableCS(conditionvariable,criticalsection,dwmilliseconds);
end;

{==============================================================================}

procedure DeleteConditionVariable(var conditionvariable: CONDITION_VARIABLE); stdcall;
{Destroy a condition variable}
{ConditionVariable: The condition variable to destroy}
{Note: This function is Ultibo specific and is not part of the normal Windows API}
begin
 {}
 Ultibo.DeleteConditionVariable(conditionvariable);
end;

{==============================================================================}
{Event Functions (Compatibility)}
function CreateEvent(lpeventattributes: LPSECURITY_ATTRIBUTES; bmanualreset, binitialstate: BOOL; const lpname: LPCSTR): HANDLE; stdcall;
begin
 {}
 Result:=Ultibo.CreateEvent(lpeventattributes,bmanualreset,binitialstate,lpname);
end;

{==============================================================================}

function CreateEventA(lpeventattributes: LPSECURITY_ATTRIBUTES; bmanualreset, binitialstate: BOOL; const lpname: LPCSTR): HANDLE; stdcall;
begin
 {}
 Result:=Ultibo.CreateEventA(lpeventattributes,bmanualreset,binitialstate,lpname);
end;

{==============================================================================}

function CreateEventW(lpeventattributes: LPSECURITY_ATTRIBUTES; bmanualreset, binitialstate: BOOL; const lpname: LPCWSTR): HANDLE; stdcall;
begin
 {}
 Result:=Ultibo.CreateEventW(lpeventattributes,bmanualreset,binitialstate,lpname);
end;

{==============================================================================}

function OpenEvent(dwdesiredaccess: uint32_t; binherithandle: BOOL; const lpname: LPCSTR): HANDLE; stdcall;
begin
 {}
 Result:=Ultibo.OpenEvent(dwdesiredaccess,binherithandle,lpname);
end;

{==============================================================================}

function OpenEventA(dwdesiredaccess: uint32_t; binherithandle: BOOL; const lpname: LPCSTR): HANDLE; stdcall;
begin
 {}
 Result:=Ultibo.OpenEventA(dwdesiredaccess,binherithandle,lpname);
end;

{==============================================================================}

function OpenEventW(dwdesiredaccess: uint32_t; binherithandle: BOOL; const lpname: LPCWSTR): HANDLE; stdcall;
begin
 {}
 Result:=Ultibo.OpenEventW(dwdesiredaccess,binherithandle,lpname);
end;

{==============================================================================}

function SetEvent(hevent: HANDLE): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.SetEvent(hevent);
end;

{==============================================================================}

function ResetEvent(hevent: HANDLE): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.ResetEvent(hevent);
end;

{==============================================================================}

function PulseEvent(hevent: HANDLE): BOOL; stdcall;
begin
 {}
 Result:=Ultibo.PulseEvent(hevent);
end;

{==============================================================================}
{Process Functions (Compatibility)}
function GetProcessAffinityMask(hprocess: HANDLE; var lpprocessaffinitymask, lpsystemaffinitymask: DWORD_PTR): BOOL; stdcall;
{Note: Ultibo has no concept of a Process so this function is mapped to Threads instead}
begin
 {}
 Result:=Ultibo.GetProcessAffinityMask(hprocess,lpprocessaffinitymask,lpsystemaffinitymask);
end;

{==============================================================================}

function SetProcessAffinityMask(hprocess: HANDLE; dwprocessaffinitymask: DWORD_PTR): BOOL; stdcall;
{Note: Ultibo has no concept of a Process so this function is mapped to Threads instead}
begin
 {}
 Result:=Ultibo.SetProcessAffinityMask(hprocess,dwprocessaffinitymask);
end;

{==============================================================================}

function GetProcessTimes(hprocess: HANDLE; var lpcreationtime, lpexittime, lpkerneltime, lpusertime: FILETIME): BOOL; stdcall;
{Note: Ultibo has no concept of a Process so this function is mapped to Threads instead}
begin
 {}
 Result:=Ultibo.GetProcessTimes(hprocess,lpcreationtime,lpexittime,lpkerneltime,lpusertime);
end;

{==============================================================================}

function GetProcessIoCounters(hprocess: HANDLE; var lpiocounters: IO_COUNTERS): BOOL; stdcall;
{Note: Ultibo has no concept of a Process so this function is mapped to Threads instead}
begin
 {}
 Result:=Ultibo.GetProcessIoCounters(hprocess,lpiocounters);
end;

{==============================================================================}

function GetCurrentProcess: HANDLE; stdcall;
{Note: Ultibo has no concept of a Process so this function is mapped to Threads instead}
begin
 {}
 Result:=Ultibo.GetCurrentProcess;
end;

{==============================================================================}

function GetCurrentProcessId: uint32_t; stdcall;
{Note: Ultibo has no concept of a Process so this function is mapped to Threads instead}
{Note: Thread Id and Thread Handle are currently equivalent}
begin
 {}
 Result:=Ultibo.GetCurrentProcessId;
end;

{==============================================================================}

procedure ExitProcess(uexitcode: UINT); stdcall;
{Note: Ultibo has no concept of a Process so this function is mapped to Threads instead}
begin
 {}
 Ultibo.ExitProcess(uexitcode);
end;

{==============================================================================}

procedure FatalExit(exitcode: int); stdcall;
{Note: Ultibo has no concept of a Process so this function is mapped to Threads instead}
begin
 {}
 Ultibo.FatalExit(exitcode);
end;

{==============================================================================}

function TerminateProcess(hprocess: HANDLE; uexitcode: UINT): BOOL; stdcall;
{Note: Ultibo has no concept of a Process so this function is mapped to Threads instead}
begin
 {}
 Result:=Ultibo.TerminateProcess(hprocess,uexitcode);
end;

{==============================================================================}
{Debug Functions (Compatibility)}
procedure OutputDebugString(const lpoutputstring: LPCSTR); stdcall;
begin
 {}
 Ultibo.OutputDebugString(lpoutputstring);
end;

{==============================================================================}

procedure OutputDebugStringA(const lpoutputstring: LPCSTR); stdcall;
begin
 {}
 Ultibo.OutputDebugStringA(lpoutputstring);
end;

{==============================================================================}

procedure OutputDebugStringW(const lpoutputstring: LPCWSTR); stdcall;
begin
 {}
 Ultibo.OutputDebugStringW(lpoutputstring);
end;

{==============================================================================}
{Library Functions (Compatibility)}
function lstrcmp(lpstring1, lpstring2: LPCSTR): int; stdcall;
begin
 {}
 Result:=Ultibo.lstrcmp(lpstring1,lpstring2);
end;

{==============================================================================}

function lstrcmpA(lpstring1, lpstring2: LPCSTR): int; stdcall;
begin
 {}
 Result:=Ultibo.lstrcmpA(lpstring1,lpstring2);
end;

{==============================================================================}

function lstrcmpW(lpstring1, lpstring2: LPCWSTR): int; stdcall;
begin
 {}
 Result:=Ultibo.lstrcmpW(lpstring1,lpstring2);
end;

{==============================================================================}

function lstrcmpi(lpstring1, lpstring2: LPCSTR): int; stdcall;
begin
 {}
 Result:=Ultibo.lstrcmpi(lpstring1,lpstring2);
end;

{==============================================================================}

function lstrcmpiA(lpstring1, lpstring2: LPCSTR): int; stdcall;
begin
 {}
 Result:=Ultibo.lstrcmpiA(lpstring1,lpstring2);
end;

{==============================================================================}

function lstrcmpiW(lpstring1, lpstring2: LPCWSTR): int; stdcall;
begin
 {}
 Result:=Ultibo.lstrcmpiW(lpstring1,lpstring2);
end;

{==============================================================================}

function lstrcpy(lpstring1: LPSTR; lpstring2: LPCSTR): LPSTR; stdcall;
begin
 {}
 Result:=Ultibo.lstrcpy(lpstring1,lpstring2);
end;

{==============================================================================}

function lstrcpyA(lpstring1: LPSTR; lpstring2: LPCSTR): LPSTR; stdcall;
begin
 {}
 Result:=Ultibo.lstrcpyA(lpstring1,lpstring2);
end;

{==============================================================================}

function lstrcpyW(lpstring1: LPWSTR; lpstring2: LPCWSTR): LPWSTR; stdcall;
begin
 {}
 Result:=Ultibo.lstrcpyW(lpstring1,lpstring2);
end;

{==============================================================================}

function lstrcpyn(lpstring1: LPSTR; lpstring2: LPCSTR; imaxlength: int): LPSTR; stdcall;
begin
 {}
 Result:=Ultibo.lstrcpyn(lpstring1,lpstring2,imaxlength);
end;

{==============================================================================}

function lstrcpynA(lpstring1: LPSTR; lpstring2: LPCSTR; imaxlength: int): LPSTR; stdcall;
begin
 {}
 Result:=Ultibo.lstrcpynA(lpstring1,lpstring2,imaxlength);
end;

{==============================================================================}

function lstrcpynW(lpstring1: LPWSTR; lpstring2: LPCWSTR; imaxlength: int): LPWSTR; stdcall;
begin
 {}
 Result:=Ultibo.lstrcpynW(lpstring1,lpstring2,imaxlength);
end;

{==============================================================================}

function lstrcat(lpstring1: LPSTR; lpstring2: LPCSTR): LPSTR; stdcall;
begin
 {}
 Result:=Ultibo.lstrcat(lpstring1,lpstring2);
end;

{==============================================================================}

function lstrcatA(lpstring1: LPSTR; lpstring2: LPCSTR): LPSTR; stdcall;
begin
 {}
 Result:=Ultibo.lstrcatA(lpstring1,lpstring2);
end;

{==============================================================================}

function lstrcatW(lpstring1: LPWSTR; lpstring2: LPCWSTR): LPWSTR; stdcall;
begin
 {}
 Result:=Ultibo.lstrcatW(lpstring1,lpstring2);
end;

{==============================================================================}

function lstrlen(lpstring: LPCSTR): int; stdcall;
begin
 {}
 Result:=Ultibo.lstrlen(lpstring);
end;

{==============================================================================}

function lstrlenA(lpstring: LPCSTR): int; stdcall;
begin
 {}
 Result:=Ultibo.lstrlenA(lpstring);
end;

{==============================================================================}

function lstrlenW(lpstring: LPCWSTR): int; stdcall;
begin
 {}
 Result:=Ultibo.lstrlenW(lpstring);
end;
{$ENDIF}
{==============================================================================}
{==============================================================================}

initialization
 APIInit;

{==============================================================================}

finalization
 {Nothing}

{==============================================================================}
{==============================================================================}

{$NOTES ON}

end.
